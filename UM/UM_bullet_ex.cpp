#pragma clang diagnostic ignored "-Wc++20-extensions"
#pragma clang diagnostic ignored "-Wdeprecated-volatile"
#pragma clang diagnostic ignored "-Winvalid-source-encoding"

#if !CLANG_CL && __INTELLISENSE__
#define _HAS_CXX17 1
#define _HAS_CXX20 0
#endif

#include <stdlib.h>
#include <stdint.h>
#include <limits.h>
#include <stdint.h>
#include <direct.h>
#include <time.h>

#include <string.h>

#define _USE_MATH_DEFINES 1
#include <math.h>

#include <bit>

#include "../zero/FloatConstants.h"

#include "../zero/util.h"
//#include "../zero/custom_intrin.h"
#include "../zero/func_traits_basic.h"

//#define USE_FAST_REDUCE_ANGLE
#include "../reduce_angle_fast.h"

template <typename T>
using ZUNList = ZUNListBase<T, true>;
template <typename T>
using ZUNListHead = ZUNListHeadBase<T, true>;
template <typename T>
using ZUNListIter = ZUNListIterBase<T, true>;
template <typename T>
using ZUNListEnds = ZUNListEndsBase<T, true>;

#define FIX_REALLY_BAD_BUGS 1
#define PROTECT_ORIGINAL_FILES 1
#define IGNORE_HASH_CHECKS 1

#define USE_EXTERN_FOR_CODEGEN 0

#define GAME_VERSION UM_VER

#define ENGLISH_STRINGS

#ifndef ENGLISH_STRINGS
#define JpEnStr(jstring, estring) jstring
#else
#define JpEnStr(jstring, estring) estring
#endif

#define INCLUDE_PATCH_CODE 0

//#define USE_VOLATILES_AND_BARRIERS_FOR_ORIGINAL_CODEGEN 1

#if USE_VOLATILES_AND_BARRIERS_FOR_ORIGINAL_CODEGEN
#define codegen_volatile volatile
#define codegen_barrier() _ReadWriteBarrier()
#else
#define codegen_volatile
#define codegen_barrier() do {} while(false)
#endif

#if USE_EXTERN_FOR_CODEGEN
#define externcg extern
#define cgasm(...) asm(__VA_ARGS__)
#else
#define externcg
#define cgasm(...)
#endif

#define CHEAT_THE_LOADER 1

#if CHEAT_THE_LOADER
typedef struct StaticCtorsDtors StaticCtorsDtors;
extern StaticCtorsDtors fake_static_data;
#endif

#undef WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <process.h>
#include <WinUser.h>
#include <wbemidl.h>
#include <winnls32.h>
#include <d3d9.h>
#include <dinput.h>
#include <dsound.h>
#define UNICODE
#include <Core/DXUT.h>
#include <Optional/SDKsound.h>
#undef UNICODE

#include "../zero/zun.h"

#pragma comment (lib, "wbemuuid.lib")
#pragma comment (lib, "Xinput9_1_0.lib")

#ifndef SAFE_FREE
#define SAFE_FREE(p)       { if (p) { free ((void*)p);     (p)=NULL; } }
#endif

#ifndef SAFE_FREE_FAST
#define SAFE_FREE_FAST(p)       { if (auto ptr = (p)) { free ((void*)ptr);     (p)=NULL; } }
#endif

#if INCLUDE_PATCH_CODE
// just a stub to make the code look right
dllexport gnu_noinline const char* fastcall eval_expr(const char* expr, char end, int32_t* out, void* regs, uintptr_t rel_source, HMODULE hMod) {
    use_var(expr);
    use_var(end);
    use_var(regs);
    use_var(rel_source);
    use_var(hMod);
    *out = rand();
    return (const char*)rand();
}
#endif

/*
#ifdef cdecl
#undef cdecl
#endif
#define cdecl __cdecl
*/


dllexport gnu_noinline void* cdecl memset_force(void* dst, int val, size_t size) {
    gnu_attr(musttail) return memset(dst, val, size);
}

/*
inline void* cdecl memset_force(void* dst, int val, size_t size) {
    void* ret;
    clang_noinline ret = memset(dst, val, size);
    return ret;
}
*/

#define zero_pointer_contents(ptr) memset_force(ptr, 0, sizeof(*ptr))
#define zero_pointer_contents_inline(ptr) __builtin_memset(ptr, 0, sizeof(*ptr))
#define zero_array(arr) memset_force(arr, 0, sizeof(arr))
#define zero_array_inline(arr) __builtin_memset(arr, 0, sizeof(arr))
#define zero_this() memset_force(this, 0, sizeof(*this));
#define zero_this_inline() __builtin_memset(this, 0, sizeof(*this));

static inline consteval float DEGREES(float degrees) {
    return degrees * PI_f / 180.0f;
}

static inline uint8_t& BLUE(D3DCOLOR& color) {
    return ((uint8_t*)&color)[0];
}
static inline uint8_t& GREEN(D3DCOLOR& color) {
    return ((uint8_t*)&color)[1];
}
static inline uint8_t& RED(D3DCOLOR& color) {
    return ((uint8_t*)&color)[2];
}
static inline uint8_t& ALPHA(D3DCOLOR& color) {
    return ((uint8_t*)&color)[3];
}
// Just make these macro colored
// to indicate there's BS going on
#define BLUE(...) BLUE(__VA_ARGS__)
#define GREEN(...) GREEN(__VA_ARGS__)
#define RED(...) RED(__VA_ARGS__)
#define ALPHA(...) ALPHA(__VA_ARGS__)

// I don't even want to know how this is a thing
// 0x47D870
dllexport gnu_noinline D3DCOLOR& thiscall pack_rgb(D3DCOLOR& self, uint8_t r, uint8_t g, uint8_t b) asm_symbol_rel(0x47D870);
dllexport gnu_noinline D3DCOLOR& thiscall pack_rgb(D3DCOLOR& self, uint8_t r, uint8_t g, uint8_t b) {
    BLUE(self) = b;
    GREEN(self) = g;
    RED(self) = r;
    return self;
}

struct D3DMATRIXZ : D3DMATRIX {


    inline D3DXMATRIX& D3DX() {
        return *(D3DXMATRIX*)this;
    }

    // D3DXMatrixIdentity
    inline void set_identity() {
        this->m[0][0] = 1.0f;
        this->m[0][1] = 0.0f;
        this->m[0][2] = 0.0f;
        this->m[0][3] = 0.0f;
        this->m[1][0] = 0.0f;
        this->m[1][1] = 1.0f;
        this->m[1][2] = 0.0f;
        this->m[1][3] = 0.0f;
        this->m[2][0] = 0.0f;
        this->m[2][1] = 0.0f;
        this->m[2][2] = 1.0f;
        this->m[2][3] = 0.0f;
        this->m[3][0] = 0.0f;
        this->m[3][1] = 0.0f;
        this->m[3][2] = 0.0f;
        this->m[3][3] = 1.0f;
    }

    // D3DXMatrixScaling
    inline void set_scaled(float X, float Y, float Z = 1.0f) {
        this->m[0][0] = X;
        this->m[0][1] = 0.0f;
        this->m[0][2] = 0.0f;
        this->m[0][3] = 0.0f;
        this->m[1][0] = 0.0f;
        this->m[1][1] = Y;
        this->m[1][2] = 0.0f;
        this->m[1][3] = 0.0f;
        this->m[2][0] = 0.0f;
        this->m[2][1] = 0.0f;
        this->m[2][2] = Z;
        this->m[2][3] = 0.0f;
        this->m[3][0] = 0.0f;
        this->m[3][1] = 0.0f;
        this->m[3][2] = 0.0f;
        this->m[3][3] = 1.0f;
    }

    inline void rotate_x(float rotation) {
        if (rotation != 0.0f) {
            D3DXMATRIX temp;
            D3DXMatrixRotationX(&temp, rotation);
            D3DXMatrixMultiply(&this->D3DX(), &this->D3DX(), &temp);
        }
    }

    inline void rotate_y(float rotation) {
        if (rotation != 0.0f) {
            D3DXMATRIX temp;
            D3DXMatrixRotationY(&temp, rotation);
            D3DXMatrixMultiply(&this->D3DX(), &this->D3DX(), &temp);
        }
    }

    inline void rotate_z(float rotation) {
        if (rotation != 0.0f) {
            D3DXMATRIX temp;
            D3DXMatrixRotationZ(&temp, rotation);
            D3DXMatrixMultiply(&this->D3DX(), &this->D3DX(), &temp);
        }
    }
};
#pragma region // D3DMATRIXZ Validation
ValidateStructSize32(0x40, D3DMATRIXZ);
#pragma endregion

/*
// 0x4028F0
dllexport float vectorcall reduce_angle(float angle) asm_symbol_rel(0x4028F0);
dllexport float vectorcall reduce_angle(float angle) {
    int32_t counter = 0;
    while (angle > PI_f) {
        angle -= TWO_PI_f;
        if (counter++ > 32) break;
    }
    while (-PI_f > angle) {
        angle += TWO_PI_f;
        if (counter++ > 32) break;
    }
    return angle;
}

template <InlineState inline_state = DefaultInline>
static auto reduce_angle(float angle) {
    if constexpr (inline_state == ForceInline) {
        clang_forceinline return reduce_angle(angle);
    } else if constexpr (inline_state == NoInline) {
        clang_noinline return reduce_angle(angle);
    } else {
        return reduce_angle(angle);
    }
}

// 0x402890
// ZUN has always had this function... IDK why
dllexport float vectorcall reduce_angle_add(float angle, float value) asm_symbol_rel(0x402890);
dllexport float vectorcall reduce_angle_add(float angle, float value) {
    return reduce_angle(angle + value);
}
*/

/*
// 0x404BC0
dllexport float& vectorcall reduce_angle_add_write(float& angle_ref, float& out, float value) asm_symbol_rel(0x404BC0);
dllexport float& vectorcall reduce_angle_add_write(float& angle_ref, float& out, float value) {
    return out = reduce_angle_add(angle_ref, value);
}
*/
/*
// 0x404D10
dllexport float& vectorcall reduce_angle_add_assign_write(float& angle_ref, float value) asm_symbol_rel(0x404D10) {
    return angle_ref = reduce_angle_add_ref(angle_ref, value);
}
*/

inline float vectorcall __angle_diffB(float angle, float value, float temp) {
    if (temp > PI_f) {
        return angle - (value + TWO_PI_f);
    } else if (value - angle > PI_f) {
        return angle - (value - TWO_PI_f);
    } else {
        return temp;
    }
}

/*
// 0x439FE0
dllexport float vectorcall reduced_angle_diff(float angle, float value) asm_symbol_rel(0x439FE0);
dllexport float vectorcall reduced_angle_diff(float angle, float value) {
    float temp = angle - value;
    if (temp > PI_f) {
        return angle - (value + TWO_PI_f);
    }
    else if (value - angle > PI_f) {
        return angle - (value - TWO_PI_f);
    }
    else {
        return temp;
    }
}
*/

// 0x47D470
dllexport gnu_noinline void fastcall circle_pos(float* x, float* y, float angle, float magnitude) asm_symbol_rel(0x47D470);
dllexport gnu_noinline void fastcall circle_pos(float* x, float* y, float angle, float magnitude) {
#ifndef __x86_64__
    __asm {
        MOV EAX, x;
        FLD angle;
        FSINCOS;
        FMUL magnitude;
        FSTP DWORD PTR [EAX]
        FMUL magnitude;
        MOV EAX, y
        FSTP DWORD PTR [EAX]
    };
#else
    __asm {
        MOV RAX, x;
        FLD angle;
        FSINCOS;
        FMUL magnitude;
        FSTP DWORD PTR [RAX]
        FMUL magnitude;
        MOV RAX, y
        FSTP DWORD PTR [RAX]
    };
#endif
}

// 0x46F150
dllexport char* stdcall pbg_strdup(const char* str) asm_symbol_rel(0x46F150);
dllexport char* stdcall pbg_strdup(const char* str) {
    char* ret = (char*)malloc(byteloop_strlen(str));
    if (ret) {
        byteloop_strcpy(ret, str);
    }
    return ret;
}

/*
// 0x404C70
dllexport float& vectorcall reduce_angle_diff_write(float& angle_ref, float& out, float& value_ref) asm_symbol_rel(0x404C70) {
    return reduce_angle_write(out, reduced_angle_diff(angle_ref, value_ref));
}
*/

// size: 0x4
// Of course this exists...
struct ZUNAngle {
    float value; // 0x0

    inline ZUNAngle() {}

private:
    // 0x404C20
    dllexport gnu_noinline void vectorcall constructor(float, const float value) asm_symbol_rel(0x404C20) {
        this->value = reduce_angle(value);
    }
public:
    inline ZUNAngle(const float value) {
        this->constructor(UNUSED_FLOAT, value);
    }

private:
    // 0x404D70
    dllexport ZUNAngle& vectorcall set(float, const float value) asm_symbol_rel(0x404D70) {
        this->value = reduce_angle(value);
        return *this;
    }
public:
    // 0x404D70
    inline ZUNAngle& vectorcall operator=(const float value) {
        return this->set(UNUSED_FLOAT, value);
    }

    /*
    inline ZUNAngle& operator=(const ZUNAngle& value) {
        this->value = value.value;
        return *this;
    }
    */

    // 0x404DC0
    dllexport vectorcall operator float() const asm_symbol_rel(0x404DC0) {
        return this->value;
    }

private:
    // 0x404BC0
    dllexport ZUNAngle& vectorcall add(int, float, float, ZUNAngle& out, const float value) asm_symbol_rel(0x404BC0) {
        return out = this->value + value;
    }
public:
    inline ZUNAngle operator+(const float value) {
        ZUNAngle dummy;
        return this->add(UNUSED_DWORD, UNUSED_FLOAT, UNUSED_FLOAT, dummy, value);
    }

private:
    // 0x45E2A0
    dllexport ZUNAngle& thiscall add(ZUNAngle& out, const ZUNAngle& angle) asm_symbol_rel(0x45E2A0) {
        return out = this->value + angle.value;
    }
public:
    inline ZUNAngle operator+(const ZUNAngle& angle) {
        ZUNAngle dummy;
        return this->add(dummy, angle);
    }

private:
    // 0x404D10
    dllexport gnu_noinline ZUNAngle& vectorcall add_assign(float, const float value) asm_symbol_rel(0x404D10) {
        return *this = this->value + value;
    }
public:
    // 0x404D10
    inline ZUNAngle& vectorcall operator+=(const float value) {
        return this->add_assign(UNUSED_FLOAT, value);
    }

    // th14: 0x443D60
    inline ZUNAngle& thiscall operator+=(const ZUNAngle& angle) {
        return *this = this->value + angle.value;
    }

    /*
    inline ZUNAngle operator-(const float value) const {
        return this->value - value;
    }
    */

private:
    // 0x404C70
    dllexport ZUNAngle& thiscall sub(ZUNAngle& out, const ZUNAngle& angle) asm_symbol_rel(0x404C70) {
        return out = reduced_angle_diff(this->value, angle.value);
    }
public:
    inline ZUNAngle thiscall operator-(const ZUNAngle& angle) {
        ZUNAngle dummy;
        return this->sub(dummy, angle);
    }
    
    /*
    inline ZUNAngle& diff(float value) const {
        ZUNAngle temp;
        temp.value = value;
        return *this - temp;
    }
    */
    /*
    inline ZUNAngle& operator-=(const float value) {
        return *this = *this - value;
    }
    */

private:
    // 0x461540
    dllexport ZUNAngle& vectorcall mul(int, float, float, ZUNAngle& out, const float value) asm_symbol_rel(0x461540) {
        return out = this->value * value;
    }
public:
    inline ZUNAngle operator*(const float value) {
        ZUNAngle dummy;
        return this->mul(UNUSED_DWORD, UNUSED_FLOAT, UNUSED_FLOAT, dummy, value);
    }

private:
    // th14: 0x443D00
    inline ZUNAngle& vectorcall div(ZUNAngle& out, const float value) {
        return out = this->value / value;
    }
public:
    inline ZUNAngle vectorcall operator/(const float value) {
        ZUNAngle dummy;
        return this->div(dummy, value);
    }
};

enum CriticalSectionIndex {
    UpdateFuncRegistry_CS = 0,
    __unused_cs_1 = 1,
    FileIO_CS = 2,
    Logging_CS = 3,
    __unused_cs_2 = 4,
    Menu_CS = 5,
    __supervisor_thread_cs_1 = 6,
    __unused_cs_3 = 7,
    __unused_cs_4 = 8,
    AnmList_CS = 9,
    RNG_CS = 10,
    SoundManagerA_CS = 11,
    SoundManagerB_CS = 12,
    __unused_cs_5 = 13,
};

// size: 0x1D0
struct CriticalSectionManager {
    CRITICAL_SECTION sections[14]; // 0x0
    uint8_t section_depths[14]; // 0x1C0
    bool enable_sections; // 0x1CE

    // Pretty sure these aren't actually class methods, but whatever. Not the point.
    inline void initialize() {
        nounroll for (size_t i = 0; i < countof(this->sections); ++i) {
            InitializeCriticalSection(&this->sections[i]);
        }
        this->enable_sections = true;
    }

    inline void cleanup() {
        this->enable_sections = false;
        nounroll for (size_t i = 0; i < countof(this->sections); ++i) {
            DeleteCriticalSection(&this->sections[i]);
        }
    }

    // 0x404F60
    dllexport static inline void stdcall leave_section(CriticalSectionIndex index) asm_symbol_rel(0x404F60);
    
    // 0x404F90
    dllexport static inline void stdcall enter_section(CriticalSectionIndex index) asm_symbol_rel(0x404F90);

    static inline void leave_section_volatile(CriticalSectionIndex index);
    static inline void enter_section_volatile(CriticalSectionIndex index);
};
/*
#pragma region // CriticalSectionManager Validation
ValidateFieldOffset32(0x0, CriticalSectionManager, sections);
ValidateFieldOffset32(0x1C0, CriticalSectionManager, section_depths);
ValidateFieldOffset32(0x1CE, CriticalSectionManager, enable_sections);
ValidateStructSize32(0x1D0, CriticalSectionManager);
#pragma endregion
*/

extern "C" {
    // 0x521660
    externcg CriticalSectionManager CRITICAL_SECTION_MANAGER cgasm("_CRITICAL_SECTION_MANAGER");
}

// 0x404F60
dllexport inline void stdcall CriticalSectionManager::leave_section(CriticalSectionIndex index) {
    if (CRITICAL_SECTION_MANAGER.enable_sections) {
        LeaveCriticalSection(&CRITICAL_SECTION_MANAGER.sections[index]);
        --CRITICAL_SECTION_MANAGER.section_depths[index];
    }
}
// 0x404F90
dllexport inline void stdcall CriticalSectionManager::enter_section(CriticalSectionIndex index) {
    if (CRITICAL_SECTION_MANAGER.enable_sections) {
        EnterCriticalSection(&CRITICAL_SECTION_MANAGER.sections[index]);
        ++CRITICAL_SECTION_MANAGER.section_depths[index];
    }
}
inline void CriticalSectionManager::leave_section_volatile(CriticalSectionIndex index) {
    if (*(volatile uint8_t*)&CRITICAL_SECTION_MANAGER.enable_sections) {
        LeaveCriticalSection(&CRITICAL_SECTION_MANAGER.sections[index]);
        --*(volatile uint8_t*)&CRITICAL_SECTION_MANAGER.section_depths[index];
    }
}
inline void CriticalSectionManager::enter_section_volatile(CriticalSectionIndex index) {
    if (*(volatile uint8_t*)&CRITICAL_SECTION_MANAGER.enable_sections) {
        EnterCriticalSection(&CRITICAL_SECTION_MANAGER.sections[index]);
        ++*(volatile uint8_t*)&CRITICAL_SECTION_MANAGER.section_depths[index];
    }
}

template<CriticalSectionIndex index>
struct ScopedCriticalSection {
    inline ScopedCriticalSection() {
        CRITICAL_SECTION_MANAGER.enter_section(index);
    }
    inline ~ScopedCriticalSection() {
        CRITICAL_SECTION_MANAGER.leave_section(index);
    }
};

static constexpr auto wkrwjher = sizeof(ScopedCriticalSection<UpdateFuncRegistry_CS>);

#define UniqueCriticalSectionLock(index) auto unique_name(critical_section_scope_guard_) = ScopedCriticalSection<index>()
#define CriticalSectionBlock(index) switch (UniqueCriticalSectionLock(index); 0) default:

// size: 0x4
struct DebugLogger {
    int __dword_0; // 0x0

    // 0x404E80
    dllexport static gnu_noinline void cdecl __debug_log_stub_4(const char* format, ...) asm_symbol_rel(0x404E80) {}

    // 0x404F50
    dllexport gnu_noinline int32_t thiscall __debug_log_stub_12(int32_t value, int, const char*) asm_symbol_rel(0x404F50) {
        return value;
    }

    // 0x43A280
    dllexport static gnu_noinline void cdecl __debug_log_stub_3(const char* format, ...) asm_symbol_rel(0x43A280) {}

    // 0x442440
    dllexport static gnu_noinline void cdecl __debug_log_stub_8(const char* format, ...) asm_symbol_rel(0x442440) {}

    // 0x4562A0
    dllexport static gnu_noinline void cdecl __debug_log_stub_7(const char* format, ...) asm_symbol_rel(0x4562A0) {}

    // 0x46F1D0
    dllexport static gnu_noinline void cdecl __debug_log_stub_2(const char* format, ...) asm_symbol_rel(0x46F1D0) {}

    // 0x471110
    dllexport static gnu_noinline void cdecl __debug_log_stub_11(const char* format, ...) asm_symbol_rel(0x471110) {}

    // 0x476310
    dllexport static gnu_noinline void cdecl __debug_log_stub_1(const char* format, ...) asm_symbol_rel(0x476310) {}

    // 0x477AF0
    dllexport static gnu_noinline void cdecl __debug_log_stub_10(const char* format, ...) asm_symbol_rel(0x477AF0) {}

    // 0x489590
    [[gnu::no_caller_saved_registers]] dllexport static gnu_noinline void cdecl __debug_log_stub_6(const char* format, ...) asm_symbol_rel(0x489590) {}

    // 0x48B010
    dllexport static gnu_noinline void cdecl __debug_log_stub_9(const char* format, ...) asm_symbol_rel(0x48B010) {}

    // 0x48B020
    dllexport static gnu_noinline void cdecl __debug_log_stub_5(const char* format, ...) asm_symbol_rel(0x48B020) {}
};

extern "C" {
    // 0x4CF290
    externcg DebugLogger* DEBUG_LOG_PTR cgasm("_DEBUG_LOG_PTR");

    // 0x4CF2F0
    externcg char UNKNOWN_TEXT_BUFFER_A[MAX_PATH] cgasm("_UNKNOWN_TEXT_BUFFER_A");
}

namespace Pbg {

    // size: 0x4
    struct IFile {
        // Method 0
        virtual gnu_noinline bool thiscall open_file(LPCSTR path, const char* mode) = 0;
        // Method 4
        virtual gnu_noinline void thiscall close_file() = 0;
        // Method 8
        virtual gnu_noinline DWORD thiscall read_file_to_buffer(LPVOID buffer, DWORD size) = 0;
        // Method C
        virtual gnu_noinline bool thiscall write_buffer_to_file(LPVOID buffer, DWORD size) = 0;
        // Method 10
        virtual gnu_noinline DWORD thiscall get_file_pointer() = 0;
        // Method 14
        virtual gnu_noinline DWORD thiscall get_file_size() = 0;
        // Method 18
        virtual gnu_noinline bool thiscall set_file_pointer(LONG offset, DWORD origin) = 0;
        
        // 0x46F580
        virtual ~IFile() {}
    };

    // size: 0xC
    struct File : IFile {

        HANDLE handle; // 0x4
        ACCESS_MASK access_mask; // 0x8
        // 0xC

        inline File() : handle(INVALID_HANDLE_VALUE), access_mask(0) {}

        // 0x46F230
        // Method 0
        virtual gnu_noinline bool thiscall open_file(LPCSTR path_in, const char* mode_str) asm_symbol_rel(0x46F230) {
            BOOL is_append = false;
            DWORD create_type = 0;
            this->close_file();
            const char* read_mode = mode_str;
            for (
                char c;
                (c = *read_mode);
                ++read_mode
            ) {
                switch (c) {
                    case 'r':
                        this->access_mask = GENERIC_READ;
                        create_type = OPEN_EXISTING;
                        goto valid_mode;
                    case 'w':
                        this->access_mask = GENERIC_WRITE;
                        create_type = CREATE_ALWAYS;
                        goto valid_mode;
                    case 'a':
                        is_append = true;
                        this->access_mask = GENERIC_WRITE;
                        create_type = OPEN_ALWAYS;
                        goto valid_mode;
                }
            }
            return false;
        valid_mode:
            if (!*read_mode) {
                return false;
            }
            const char* path_no_drive = strchr(path_in, ':');
            char path_buffer[MAX_PATH];
            if (path_no_drive) {
                byteloop_strcpy(path_buffer, path_in);
            }
            else {
                GetModuleFileNameA(NULL, path_buffer, MAX_PATH);
                char* filename = strrchr(path_buffer, '\\');
                path_buffer[0] = filename ? path_buffer[0] : '\0';
                filename[1] = '\0';
                byteloop_strcat(path_buffer, path_in);
            }
            HANDLE file_handle = CreateFileA(
                path_buffer,
                this->access_mask,
                FILE_SHARE_READ,
                NULL,
                create_type,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
            );
            this->handle = file_handle;
            if (file_handle == INVALID_HANDLE_VALUE) {
                return false;
            }
            if (is_append) {
                SetFilePointer(file_handle, 0, NULL, FILE_END);
            }
            return true;
        }

        // 0x46F3E0
        // Method 4
        virtual gnu_noinline void thiscall close_file() asm_symbol_rel(0x46F3E0) {
            HANDLE file_handle = this->handle;
            if (file_handle != INVALID_HANDLE_VALUE) {
                CloseHandle(file_handle);
            }
            this->handle = INVALID_HANDLE_VALUE;
            this->access_mask = 0;
        }

        // 0x46F410
        // Method 8
        virtual gnu_noinline DWORD thiscall read_file_to_buffer(LPVOID buffer, DWORD size) asm_symbol_rel(0x46F410) {
            DWORD read_size = 0;
            if (this->access_mask != GENERIC_READ) {
                return 0;
            }
            ReadFile(this->handle, buffer, size, &read_size, NULL);
            return read_size;
        }

        // 0x46F450
        // Method C
        virtual gnu_noinline bool thiscall write_buffer_to_file(LPVOID buffer, DWORD size) asm_symbol_rel(0x46F450) {
            DWORD read_size = 0;
            if (this->access_mask != GENERIC_WRITE) {
                return false;
            }
            WriteFile(this->handle, buffer, size, &read_size, NULL);
            return size == read_size;
        }

        // 0x46F490
        // Method 10
        virtual gnu_noinline DWORD thiscall get_file_pointer() asm_symbol_rel(0x46F490) {
            HANDLE file_handle = this->handle;
            if (file_handle == INVALID_HANDLE_VALUE) {
                return 0;
            }
            return SetFilePointer(file_handle, 0, NULL, FILE_CURRENT);
        }

        // 0x46F4B0
        // Method 14
        virtual gnu_noinline DWORD thiscall get_file_size() asm_symbol_rel(0x46F4B0) {
            HANDLE file_handle = this->handle;
            if (file_handle == INVALID_HANDLE_VALUE) {
                return 0;
            }
            return GetFileSize(file_handle, NULL);
        }

        // 0x46F4D0
        // Method 18
        virtual gnu_noinline bool thiscall set_file_pointer(LONG offset, DWORD origin) asm_symbol_rel(0x46F4D0) {
            HANDLE file_handle = this->handle;
            if (file_handle == INVALID_HANDLE_VALUE) {
                return false;
            }
            SetFilePointer(file_handle, offset, NULL, origin);
            return true;
        }

        // 0x46F1E0
        // Method 1C
        virtual ~File() {
            HANDLE file_handle = this->handle;
            if (file_handle != INVALID_HANDLE_VALUE) {
                CloseHandle(file_handle);
                this->handle = INVALID_HANDLE_VALUE;
                this->access_mask = 0;
            }
        }

        // 0x46F500
        // Method 20
        virtual gnu_noinline LPVOID copy_file_to_new_buffer(LONG file_offset) asm_symbol_rel(0x46F500) {
            if (this->access_mask == GENERIC_READ) {
                DWORD file_size = this->get_file_size();
                if ((DWORD)file_offset <= file_size) {
                    if (LPVOID buffer = malloc(file_size)) {
                        file_offset = this->get_file_pointer();
                        if (this->set_file_pointer(file_offset, FILE_BEGIN)) {
                            if (!this->read_file_to_buffer(buffer, file_size)) {
                                // Yes, this free is misplaced and can leak memory
                                free(buffer);
                            } else {
                                this->set_file_pointer(file_offset, FILE_BEGIN);
                                return buffer;
                            }
                        }
                    }
                }
            }
            return NULL;
        }
    };

};

// size: 0x10
struct ArcFileInner {
    char* __string_0; // 0x0
    int __dword_4; // 0x4
    int32_t file_size; // 0x8
    int __dword_C; // 0xC
    // 0x10

    // 0x46F1C0
    ArcFileInner() : __string_0(NULL) {}

    // 0x46F1A0
    ~ArcFileInner() {
        SAFE_FREE(this->__string_0);
    }
};

// size: 0xC
struct UnknownP {
    uint8_t xor_mask; // 0x0
    uint8_t xor_accel; // 0x1
    uint8_t __ubyte_2; // 0x2
    probably_padding_bytes(0x1); // 0x3
    int32_t __int_4; // 0x4
    int32_t __int_8; // 0x8
    // 0xC
};

// 0x4C5360
static UnknownP UNKNOWN_P[] = {
    [0] = {
        .xor_mask = 0x1B,
        .xor_accel = 0x73,
        .__ubyte_2 = 0xAA,
        .__int_4 = 256,
        .__int_8 = 0x3800
    },
    [1] = {
        .xor_mask = 0x12,
        .xor_accel = 0x43,
        .__ubyte_2 = 0xFF,
        .__int_4 = 512,
        .__int_8 = 0x3E00
    },
    [2] = {
        .xor_mask = 0x35,
        .xor_accel = 0x79,
        .__ubyte_2 = 0x11,
        .__int_4 = 1024,
        .__int_8 = 0x3C00
    },
    [3] = {
        .xor_mask = 0x03,
        .xor_accel = 0x91,
        .__ubyte_2 = 0xDD,
        .__int_4 = 128,
        .__int_8 = 0x6400
    },
    [4] = {
        .xor_mask = 0xAB,
        .xor_accel = 0xDC,
        .__ubyte_2 = 0xEE,
        .__int_4 = 128,
        .__int_8 = 0x7000
    },
    [5] = {
        .xor_mask = 0x51,
        .xor_accel = 0x9E,
        .__ubyte_2 = 0xBB,
        .__int_4 = 256,
        .__int_8 = 0x4000
    },
    [6] = {
        .xor_mask = 0xC1,
        .xor_accel = 0x15,
        .__ubyte_2 = 0xCC,
        .__int_4 = 1024,
        .__int_8 = 0x2C00
    },
    [7] = {
        .xor_mask = 0x99,
        .xor_accel = 0x7D,
        .__ubyte_2 = 0x77,
        .__int_4 = 128,
        .__int_8 = 0x4400
    }
};

// 0x401F50
dllexport gnu_noinline void* fastcall __crypt_buffer(void* buffer, int32_t buffer_size, uint8_t xor_mask, uint8_t xor_accel, int32_t arg3, int32_t arg4) asm_symbol_rel(0x401F50);
dllexport gnu_noinline void* fastcall __crypt_buffer(void* buffer, int32_t buffer_size, uint8_t xor_mask, uint8_t xor_accel, int32_t arg3, int32_t arg4) {
    use_var(buffer);
    use_var(buffer_size);
    use_var(xor_mask);
    use_var(xor_accel);
    use_var(arg3);
    use_var(arg4);
    return (void*)rand();
}

// 0x401E40
dllexport gnu_noinline void* fastcall __decrypt_buffer(void* buffer, int32_t buffer_size, uint8_t xor_mask, uint8_t xor_accel, int32_t arg3, int32_t arg4) asm_symbol_rel(0x401E40);
dllexport gnu_noinline void* fastcall __decrypt_buffer(void* buffer, int32_t buffer_size, uint8_t xor_mask, uint8_t xor_accel, int32_t arg3, int32_t arg4) {
    int32_t intA = buffer_size % arg3; // EBX
    uint8_t* input_buffer = (uint8_t*)buffer; // ESI
    uint8_t* buffer_write_offset = input_buffer; // EBP-4
    int32_t intB = arg3 / 4; // EBP-C
    // Definitely not a min func since those use <
    int32_t temp_size = arg4 > buffer_size ? buffer_size : arg4; // EBP-10
    void* temp_buffer = malloc(temp_size);
    input_buffer = (uint8_t*)temp_buffer;
    if (temp_buffer) {
        buffer_size = (buffer_size & ~1) - (intA >= intB ? 0 : intA);
        memcpy(temp_buffer, buffer, temp_size);
        while (buffer_size > 0) {
            if (arg4 <= 0) {
                break;
            }
            arg3 = buffer_size >= arg3 ? arg3 : buffer_size;
            buffer_write_offset += arg3;
            uint8_t* buffer_write = buffer_write_offset - 1;
            for (
                int32_t i = (arg3 + 1) / 2;
                i > 0;

            ) {
                uint8_t val = *input_buffer;
                buffer_write -= 2;
                val ^= xor_mask;
                --i;
                xor_mask += xor_accel;
                buffer_write[2] = val;
                ++input_buffer;
            }
            buffer_write = buffer_write_offset - 2;
            for (
                int32_t i = arg3 / 2;
                i > 0;

            ) {
                uint8_t val = *input_buffer;
                buffer_write -= 2;
                val ^= xor_mask;
                --i;
                xor_mask += xor_accel;
                buffer_write[2] = val;
                ++input_buffer;
            }
            buffer_size -= arg3;
            arg4 -= arg3;
        }
        free(temp_buffer);
    }
    return buffer;
}

extern "C" {
    // 0x51F660
    externcg uint8_t DECOMPRESS_BUFFER[0x2000] cgasm("_DECOMPRESS_BUFFER");
}

// 0x46F5B0
dllexport gnu_noinline void* fastcall __compress_buffer(void* buffer_in, int32_t buffer_size, int32_t* out_buffer_size) asm_symbol_rel(0x46F5B0);
dllexport gnu_noinline void* fastcall __compress_buffer(void* buffer_in, int32_t buffer_size, int32_t* out_buffer_size) {
    use_var(buffer_in);
    use_var(buffer_size);
    *out_buffer_size = rand();
    return (void*)rand();
}

// 0x46F840
dllexport gnu_noinline void* fastcall __decompress_buffer(void* buffer_in, int32_t buffer_size, void* out_buffer, int32_t out_buffer_size) asm_symbol_rel(0x46F840);
dllexport gnu_noinline void* fastcall __decompress_buffer(void* buffer_in, int32_t buffer_size, void* out_buffer, int32_t out_buffer_size) {
    codegen_barrier();
    uint32_t uintA = 0; // EBP-8
    uint8_t* buffer = (uint8_t*)buffer_in;
    uint8_t byteA = 0x80;
    if (!out_buffer) {
        if (!(out_buffer = malloc(out_buffer_size))) {
            return NULL;
        }
        uintA = 0; // EBP-8
    }
    uint8_t* buffer_read = buffer; // EBP-1C
    uint8_t* out_buffer_write = (uint8_t*)out_buffer; // EBP-10
    uint32_t decompress_buffer_offset = 1; // EBP-14
    uint32_t uintC = 0x80; // EBP-20
    ptrdiff_t sizeA;

    auto common_loop = [&](uint32_t arg) {
        int32_t ret = 0;
        nounroll do {
            if (byteA == 0x80) {
                uintA = *buffer_read;
                if (sizeA >= buffer_size) {
                    uintA = 0;
                } else {
                    ++buffer_read;
                    ++sizeA;
                }
            }
            // The argument order gets flipped here without the cast
            if ((uint8_t)uintA & byteA) {
                codegen_barrier();
                ret |= arg;
            }
            if (!(byteA >>= 1)) {
                byteA = uintC;
            }
        } while (arg >>= 1);
        return ret;
    };

    for (;;) {
        uint8_t byteB = byteA >> 1; // EBP+F
        codegen_barrier();
        codegen_volatile uint8_t byteC = byteA; // EBP+1
        uint32_t uintB; // this was optimized out, see below
        if (byteA == 0x80) {
            uintA = *buffer_read;
            sizeA = buffer_read - buffer;
            byteA = byteB;
            if (sizeA >= buffer_size) {
                uintA = 0;
                uintB = 0;
                // the compiler figured out that the uintB != 0 branch
                // around loop A is impossible from here and skipped it
            }
            else {
                uintB = byteC;
                ++buffer_read;
                uintB &= uintA;
            }
        }
        else {
            uintB = byteA;
            byteA = byteB;
            uintB &= uintA;
            if (!byteA) {
                byteA = 0x80;
            }
        }
        sizeA = buffer_read - buffer;
        if (uintB) {
            // loop A
            uint32_t val = common_loop(0b10000000); // 0x80
            DECOMPRESS_BUFFER[decompress_buffer_offset++] = val;
            *out_buffer_write++ = val;
            decompress_buffer_offset %= countof(DECOMPRESS_BUFFER);
        }
        else {
            // loop B
            int32_t intD = common_loop(0b1000000000000); // 0x1000
            if (!intD) {
                return out_buffer;
            }
            sizeA = buffer_read - buffer;
            // loop C
            int32_t iters = common_loop(0b1000) + 2; // 0x8
            // loop D
            for (int32_t i = 0; i <= iters; ++i) {
                uint8_t val = DECOMPRESS_BUFFER[(intD + i) % countof(DECOMPRESS_BUFFER)];
                DECOMPRESS_BUFFER[decompress_buffer_offset++] = val;
                *out_buffer_write++ = val;
                decompress_buffer_offset %= countof(DECOMPRESS_BUFFER);
            }
        }
    }
}

// size: 0x10
struct ArcFile {
    ArcFileInner* __pointer_0; // 0x0
    int32_t __int_4; // 0x4
    char* __string_8; // 0x8
    Pbg::File* file; // 0xC
    // 0x10

    // 0x46EC50
    ~ArcFile() {
        if (char* str = this->__string_8) {
            DebugLogger::__debug_log_stub_2("info : %s close arcfile\r\n", str);
            free(this->__string_8);
        }
        this->__string_8 = NULL;
        SAFE_DELETE_ARRAY(this->__pointer_0);
        SAFE_DELETE(this->file);
        this->__int_4 = 0;
    }

    // 0x46EB80
    dllexport static gnu_noinline bool stdcall __sub_46EB80(int32_t = UNUSED_DWORD) asm_symbol_rel(0x46EB80);

    // 0x46EE90
    dllexport static gnu_noinline bool stdcall __sub_46EE90(int32_t = UNUSED_DWORD) asm_symbol_rel(0x46EE90);

    // 0x46ED10
    dllexport gnu_noinline void* thiscall __sub_46ED10(const char* filename, void* file_buffer) asm_symbol_rel(0x46ED10) {
        if (!this->file) {
            return NULL;
        }
        ArcFileInner* ptrA = this->__pointer_0;
        if (ptrA) {
            for (int32_t i = this->__int_4; i > 0; --i, ++ptrA) {
                if (!stricmp(filename, ptrA->__string_0)) {
                    goto found_in_cache;
                }
            }
        }
        DebugLogger::__debug_log_stub_2("info : %s error\r\n", this->__string_8);
        return NULL;
found_in_cache:
        int32_t new_file_size = ptrA[1].__dword_4 - ptrA->__dword_4;
        size_t cached_file_size = ptrA->file_size;
        void* cached_file_buffer;
        if (new_file_size == cached_file_size && file_buffer) {
            cached_file_buffer = file_buffer;
        } else {
            cached_file_buffer = malloc(new_file_size);
        }
        if (!cached_file_buffer) {
            goto error_free;
        }
        if (!this->file->set_file_pointer(ptrA->__dword_4, FILE_BEGIN)) {
            goto error_free;
        }
        if (!this->file->read_file_to_buffer(cached_file_buffer, new_file_size)) {
            goto error_free;
        }
        const char* strA = ptrA->__string_0;
        uint8_t string_sum = 0;
        for (
            size_t string_length = byteloop_strlen(strA);
            string_length;
            --string_length
        ) {
            string_sum += *strA++;
        }
        UnknownP& xor_data = UNKNOWN_P[string_sum % countof(UNKNOWN_P)];
        __decrypt_buffer(cached_file_buffer, new_file_size, xor_data.xor_mask, xor_data.xor_accel, xor_data.__int_4, xor_data.__int_8);
        void* ret;
        if (cached_file_size != new_file_size) {
            ret = __decompress_buffer(cached_file_buffer, new_file_size, file_buffer, cached_file_size);
        } else {
            ret = cached_file_buffer;
        }
        if (ret != file_buffer && file_buffer) {
            free(file_buffer);
        }
        return ret;
error_free:
        DebugLogger::__debug_log_stub_2("info : %s error\r\n", this->__string_8);
        if (cached_file_buffer) {
            free(cached_file_buffer);
        }
        return NULL;
    }
};
extern "C" {
    // 0x5217C0
    externcg ArcFile THDAT_ARCFILE cgasm("_THDAT_ARCFILE");
}

// size: 0x10
struct DatFileHeader {
    ZUNMagic magic; // 0x0
    uint32_t decompressed_size; // 0x4
    uint32_t compressed_size; // 0x8
    int __dword_C; // 0xC
    // 0x10
};
#pragma region // DatFileHeader Validation
ValidateFieldOffset32(0x0, DatFileHeader, magic);
ValidateFieldOffset32(0x4, DatFileHeader, decompressed_size);
ValidateFieldOffset32(0x8, DatFileHeader, compressed_size);
ValidateFieldOffset32(0xC, DatFileHeader, __dword_C);
ValidateStructSize32(0x10, DatFileHeader);
#pragma endregion

// 0x46EE90
dllexport gnu_noinline bool stdcall ArcFile::__sub_46EE90(int32_t) {
    if (Pbg::File* pbg_file = THDAT_ARCFILE.file) {
        if (pbg_file->open_file("th18.dat", "r")) {
            DatFileHeader dat_header;
            if (THDAT_ARCFILE.file->read_file_to_buffer(&dat_header, sizeof(DatFileHeader))) {
                __decrypt_buffer(&dat_header, sizeof(DatFileHeader), 0x1B, 0x37, 0x10, 0x10);
                if (dat_header.magic.as_uint == PackUInt('T', 'H', 'A', '1')) {
                    uint32_t uintA = dat_header.__dword_C + 0xF7E7F8AC; // IDK what this value is
                    dat_header.decompressed_size -= 123456789;
                    dat_header.compressed_size -= 987654321;
                    THDAT_ARCFILE.__int_4 = uintA;
                    int32_t data_offset = THDAT_ARCFILE.file->get_file_size() - dat_header.compressed_size;
                    THDAT_ARCFILE.file->set_file_pointer(data_offset, FILE_BEGIN);
                    size_t compressed_size = dat_header.compressed_size;
                    if (void* compressed_buffer = malloc(compressed_size)) {
                        void* buffer = NULL;
                        if (THDAT_ARCFILE.file->read_file_to_buffer(compressed_buffer, compressed_size)) {
                            __decrypt_buffer(compressed_buffer, compressed_size, 0x3E, 0x9B, 0x80, compressed_size);
                            buffer = __decompress_buffer(compressed_buffer, compressed_size, buffer, dat_header.decompressed_size);
                            if (buffer) {
                                int32_t intA = THDAT_ARCFILE.__int_4;
                                ArcFileInner* arcfile_inner_array = new ArcFileInner[intA + 1];
                                if (!arcfile_inner_array) {
                                    THDAT_ARCFILE.__pointer_0 = NULL;
                                    free(compressed_buffer);
                                    goto free_buffer;
                                }
                                char* buffer_read = (char*)buffer;
                                ArcFileInner* arcfile_inner_array_write = arcfile_inner_array;
                                for (int32_t i = intA; i > 0; --i) {
                                    arcfile_inner_array_write->__string_0 = pbg_strdup(buffer_read);
                                    int32_t length = byteloop_strlen(buffer_read) + 1;
                                    if (int32_t temp = length % 4) {
                                        length += 4 - temp;
                                    }
                                    buffer_read += length;
                                    arcfile_inner_array_write->__dword_4 = ((uint32_t*)buffer_read)[0];
                                    arcfile_inner_array_write->file_size = ((uint32_t*)buffer_read)[1];
                                    arcfile_inner_array_write->__dword_C = ((uint32_t*)buffer_read)[2];
                                    buffer_read += sizeof(uint32_t[3]);
                                    ++arcfile_inner_array_write;
                                }
                                arcfile_inner_array[intA].__dword_4 = data_offset;
                                arcfile_inner_array[intA].file_size = 0;
                                THDAT_ARCFILE.__pointer_0 = arcfile_inner_array;
                                free(compressed_buffer);
                                free(buffer);
                                return true;
                            }
                        }
                        free(compressed_buffer);
                        if (buffer) {
free_buffer:
                            free(buffer);
                        }
                    }
                }
            }
        }
        SAFE_DELETE(THDAT_ARCFILE.file);
    }
    return false;
}

// 0x46EB80
dllexport gnu_noinline bool stdcall ArcFile::__sub_46EB80(int32_t) {
    THDAT_ARCFILE.~ArcFile();
    char current_directory[512];
    GetCurrentDirectoryA(countof(current_directory), current_directory);
    DebugLogger::__debug_log_stub_2("info : CurrentDirectory %s \r\n", current_directory);
    Pbg::File* pbg_file = new Pbg::File();
    THDAT_ARCFILE.file = pbg_file;
    if (ArcFile::__sub_46EE90()) {
        char* str;
        clang_noinline str = pbg_strdup("th18.dat");
        THDAT_ARCFILE.__string_8 = str;
        if (str) {
            THDAT_ARCFILE.file->open_file(str, "r");
            return true;
        }
    }
    THDAT_ARCFILE.~ArcFile();
    return false;
}

// size: 0x10
struct ArcFileEx : ArcFile {
    // 0x46EB50
    dllexport gnu_noinline ArcFileEx() {
        this->__pointer_0 = NULL;
        this->__int_4 = 0;
        this->__string_8 = NULL;
        this->file = NULL;
    }

    // 0x46EB70
    dllexport gnu_noinline ~ArcFileEx() asm_symbol_rel(0x46EB70) {}
};

extern "C" {
    // 0x568AF0
    externcg ArcFileEx ARCFILE_ARRAY[20] cgasm("_ARCFILE_ARRAY");
}

// 0x402060
dllexport gnu_noinline void* fastcall read_file_to_buffer(const char* path, int32_t* file_size_out, bool is_not_in_dat) {
    CRITICAL_SECTION_MANAGER.enter_section(FileIO_CS);
    DWORD file_size;
    void* ret = NULL;
    if (!is_not_in_dat) {
        const char* filename = strrchr(path, '\\');
        filename = strrchr(filename ? ++filename : path, '/');
        filename = filename ? ++filename : path;
        if (ArcFileInner* ptrA = THDAT_ARCFILE.__pointer_0) {
            for (int32_t i = THDAT_ARCFILE.__int_4; i > 0; --i, ++ptrA) {
                if (!stricmp(filename, ptrA->__string_0)) {
                    file_size = ptrA->file_size;
                    goto decode_file;
                }
            }
        }
        file_size = 0;
decode_file:
        if (file_size_out) {
            *file_size_out = file_size;
        }
        if (file_size) {
            DebugLogger::__debug_log_stub_4("%s Decode ... \r\n", filename);
            if ((ret = malloc(file_size))) {
                THDAT_ARCFILE.__sub_46ED10(filename, ret);
            }
        }
    } else {
        DebugLogger::__debug_log_stub_4("%s Load ... \r\n", path);
        HANDLE file_handle = CreateFileA(
            path,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
            NULL
        );
        if (file_handle == INVALID_HANDLE_VALUE) {
            DebugLogger::__debug_log_stub_4("error : %s is not found.\r\n", path);
        }
        else {
            file_size = GetFileSize(file_handle, NULL);
            if (!(ret = malloc(file_size))) {
                DebugLogger::__debug_log_stub_4("error : %s allocation error.\r\n", path);
            }
            else {
                ReadFile(file_handle, ret, file_size, &file_size, NULL);
                if (file_size_out) {
                    *file_size_out = file_size;
                }
            }
            CloseHandle(file_handle);
        }
    }
    CRITICAL_SECTION_MANAGER.leave_section(FileIO_CS);
    return ret;
}

extern "C" {
    // 0x570EA0
    externcg char PATH_BUFFER[MAX_PATH] cgasm("_PATH_BUFFER");
}
inline void* read_file_from_dat(const char* path, int32_t* size_out) {
    PATH_BUFFER[0] = '\0';
    byteloop_strcat(PATH_BUFFER, path);
    return read_file_to_buffer(PATH_BUFFER, size_out, false);
}
inline void* read_file_from_dat(const char* path) {
    return read_file_from_dat(path, NULL);
}

// 0x402220
dllexport gnu_noinline BOOL fastcall zun_file_exists(const char* filename) asm_symbol_rel(0x402220);
dllexport gnu_noinline BOOL fastcall zun_file_exists(const char* filename) {
    CRITICAL_SECTION_MANAGER.enter_section(FileIO_CS);
    HANDLE file_handle = CreateFileA(
        filename, // lpFileName
        GENERIC_READ, // dwDesiredAccess
        FILE_SHARE_READ, // dwShareMode
        NULL, // lpSecurityFeatures
        OPEN_EXISTING, // dwCreationDisposition
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, // dwFlagsAndAttributes
        NULL // hTemplateFile
    );
    if (file_handle != INVALID_HANDLE_VALUE) {
        CloseHandle(file_handle);
        CRITICAL_SECTION_MANAGER.leave_section(FileIO_CS);
        return TRUE;
    }
    else {
        CRITICAL_SECTION_MANAGER.leave_section(FileIO_CS);
        return FALSE;
    }
}
// 0x4022A0
dllexport gnu_noinline ZUNResult fastcall __zun_create_new_file_from_buffer(const char* filename, void* buffer, size_t buffer_size) asm_symbol_rel(0x4022A0);
dllexport gnu_noinline ZUNResult fastcall __zun_create_new_file_from_buffer(const char* filename, void* buffer, size_t buffer_size) {
    CRITICAL_SECTION_MANAGER.enter_section(FileIO_CS);
    HANDLE file_handle = CreateFileA(
        filename, // lpFileName
        GENERIC_WRITE, // dwDesiredAccess
        FILE_SHARE_READ, // dwShareMode
        NULL, // lpSecurityFeatures
        CREATE_ALWAYS, // dwCreationDisposition
        FILE_ATTRIBUTE_NORMAL, // dwFlagsAndAttributes
        NULL // hTemplateFile
    );
    if (file_handle == INVALID_HANDLE_VALUE) {
        FormatMessageA(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM, // dwFlags
            NULL, // lpSource
            GetLastError(), // dwMessageId,
            LANG_USER_DEFAULT, // dwLanguageId,
            (LPSTR)&buffer_size, // lpBuffer
            0, // nSize
            NULL // Arguments
        );
        DebugLogger::__debug_log_stub_4("error : %s write error %s\r\n", filename, (char*)buffer_size);
        LocalFree((HLOCAL)buffer_size);
        CRITICAL_SECTION_MANAGER.leave_section(FileIO_CS);
        return ZUN_ERROR;
    }
    DWORD bytes_written;
    WriteFile(
        file_handle, // hFile
        buffer, // lpBuffer
        buffer_size, // nNumberOfBytesToWrite
        &bytes_written, // lpNumberOfBytesWritten
        NULL // lpOverlapped
    );
    if (buffer_size != bytes_written) {
        CloseHandle(file_handle);
        DebugLogger::__debug_log_stub_4("error : %s write error\r\n", filename);
        CRITICAL_SECTION_MANAGER.leave_section(FileIO_CS);
        return ZUN_ERROR2;
    }
    CloseHandle(file_handle);
    DebugLogger::__debug_log_stub_4("%s write ... \r\n", filename);
    CRITICAL_SECTION_MANAGER.leave_section(FileIO_CS);
    return ZUN_SUCCESS;
}

extern "C" {
    // 0x4CA96C
    externcg HANDLE STATIC_FILE_HANDLE cgasm("_STATIC_FILE_HANDLE");
}

inline ZUNResult __zun_open_file(const char* filename) {
    CRITICAL_SECTION_MANAGER.enter_section(FileIO_CS);
    HANDLE file_handle = CreateFileA(
        filename, // lpFileName
        GENERIC_READ, // dwDesiredAccess
        FILE_SHARE_READ, // dwShareMode
        NULL, // lpSecurityFeatures
        OPEN_EXISTING, // dwCreationDisposition
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, // dwFlagsAndAttributes
        NULL // hTemplateFile
    );
    STATIC_FILE_HANDLE = file_handle;
    if (file_handle == INVALID_HANDLE_VALUE) {
        char* message;
        FormatMessageA(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM, // dwFlags
            NULL, // lpSource
            GetLastError(), // dwMessageId,
            LANG_USER_DEFAULT, // dwLanguageId,
            (LPSTR)&message, // lpBuffer
            0, // nSize
            NULL // Arguments
        );
        DebugLogger::__debug_log_stub_4("error : %s write error %s\r\n", filename, message);
        LocalFree((HLOCAL)message);
        CRITICAL_SECTION_MANAGER.leave_section(FileIO_CS);
        return ZUN_ERROR;
    }
    DebugLogger::__debug_log_stub_4("%s open ...\r\n", filename);
    return ZUN_SUCCESS;
}

// 0x4023E0
dllexport gnu_noinline ZUNResult fastcall __zun_open_new_file(const char* filename) asm_symbol_rel(0x4023E0);
dllexport gnu_noinline ZUNResult fastcall __zun_open_new_file(const char* filename) {
    CRITICAL_SECTION_MANAGER.enter_section(FileIO_CS);
    HANDLE file_handle = CreateFileA(
        filename, // lpFileName
        GENERIC_WRITE, // dwDesiredAccess
        FILE_SHARE_READ, // dwShareMode
        NULL, // lpSecurityFeatures
        CREATE_ALWAYS, // dwCreationDisposition
        FILE_ATTRIBUTE_NORMAL, // dwFlagsAndAttributes
        NULL // hTemplateFile
    );
    STATIC_FILE_HANDLE = file_handle;
    if (file_handle == INVALID_HANDLE_VALUE) {
        char* message;
        FormatMessageA(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM, // dwFlags
            NULL, // lpSource
            GetLastError(), // dwMessageId,
            LANG_USER_DEFAULT, // dwLanguageId,
            (LPSTR)&message, // lpBuffer
            0, // nSize
            NULL // Arguments
        );
        DebugLogger::__debug_log_stub_4("error : %s write error %s\r\n", filename, message);
        LocalFree((HLOCAL)message);
        CRITICAL_SECTION_MANAGER.leave_section(FileIO_CS);
        return ZUN_ERROR;
    }
    DebugLogger::__debug_log_stub_4("%s open ...\r\n", filename);
    return ZUN_SUCCESS;
}

// 0x4024A0
dllexport gnu_noinline void* fastcall __zun_read_file(size_t bytes) asm_symbol_rel(0x4024A0);
dllexport gnu_noinline void* fastcall __zun_read_file(size_t bytes) {
    if (STATIC_FILE_HANDLE == INVALID_HANDLE_VALUE) {
        return NULL;
    }
    void* buffer = malloc(bytes);
    if (!buffer) {
        CloseHandle(STATIC_FILE_HANDLE);
        return NULL;
    }
    DWORD idgaf;
    ReadFile(
        STATIC_FILE_HANDLE, // hFile
        buffer, // lpBuffer
        bytes, // nNumberOfBytesToRead
        &idgaf, // lpNumberOfBytesRead
        NULL // lpOverlapped
    );
    return buffer;
}

inline ZUNResult fastcall __zun_write_file(void* buffer, size_t bytes) {
    if (STATIC_FILE_HANDLE == INVALID_HANDLE_VALUE) {
        return ZUN_ERROR;
    }
    DWORD written;
    WriteFile(
        STATIC_FILE_HANDLE, // hFile
        buffer, // lpBuffer
        bytes, // nNumberOfBytesToRead
        &written, // lpNumberOfBytesRead
        NULL // lpOverlapped
    );
    if (bytes != written) {
        CloseHandle(STATIC_FILE_HANDLE);
        CRITICAL_SECTION_MANAGER.leave_section(FileIO_CS);
        return ZUN_ERROR2;
    }
    return ZUN_SUCCESS;
}

// 0x402500
dllexport gnu_noinline ZUNResult fastcall __zun_close_file() asm_symbol_rel(0x402500);
dllexport gnu_noinline ZUNResult fastcall __zun_close_file() {
    HANDLE file_handle = STATIC_FILE_HANDLE;
    if (file_handle != INVALID_HANDLE_VALUE) {
        CloseHandle(file_handle);
        CRITICAL_SECTION_MANAGER.leave_section(FileIO_CS);
    }
    return ZUN_SUCCESS;
}

// size: 0x2008
template <size_t buffer_size>
struct LogBuffer {
    char buffer[buffer_size]; // 0x0
    char* buffer_write; // 0x2000
    bool is_error; // 0x2004

    LogBuffer() {
        this->buffer_write = this->buffer;
    }

    // 0x402530
    dllexport gnu_noinline const char* cdecl write(const char* format, ...) asm_symbol_rel(0x402530) {
        char stupid_stack_buffer[buffer_size];

        CRITICAL_SECTION_MANAGER.enter_section(Logging_CS);
        {
            va_list va;
            va_start(va, format);
            vsprintf(stupid_stack_buffer, format, va_use(va));
            size_t written_length = byteloop_strlen(stupid_stack_buffer);
            char* buffer_write = this->buffer_write;
            if (&buffer_write[written_length] < array_end_addr(this->buffer)) {
                byteloop_strcpy(buffer_write, stupid_stack_buffer);
                this->buffer_write += written_length;
                *this->buffer_write = '\0';
            }
        }
        CRITICAL_SECTION_MANAGER.leave_section(Logging_CS);
        return format;
    }

    // 0x402600
    dllexport gnu_noinline const char* cdecl write_error(const char* format, ...) asm_symbol_rel(0x402600) {
        char stupid_stack_buffer[0x200];

        CRITICAL_SECTION_MANAGER.enter_section(Logging_CS);
        {
            va_list va;
            va_start(va, format);
            vsprintf(stupid_stack_buffer, format, va_use(va));
            size_t written_length = byteloop_strlen(stupid_stack_buffer);
            char* buffer_write = this->buffer_write;
            if (&buffer_write[written_length] < array_end_addr(this->buffer)) {
                byteloop_strcpy(buffer_write, stupid_stack_buffer);
                this->buffer_write += written_length;
                *this->buffer_write = '\0';
            }
            this->is_error = true;
        }
        CRITICAL_SECTION_MANAGER.leave_section(Logging_CS);
        return format;
    }
};
extern "C" {
    // 0x4CABE8
    externcg LogBuffer<0x2000> LOG_BUFFER cgasm("_LOG_BUFFER");
}

enum UpdateFuncRet : int32_t {
    UpdateFuncDeleteCurrentThenNext = 0,
    UpdateFuncNext = 1,
    UpdateFuncRepeatCurrent = 2,
    UpdateFuncEnd1 = 3,
    UpdateFuncEnd0 = 4,
    UpdateFuncEndN1 = 5,
    UpdateFuncRestartTick = 6,
    UpdateFuncCleanupThenNext = 7,
    UpdateFuncEnd0Dupe = 8,
};

#define UpdateFuncCC fastcall

typedef UpdateFuncRet(UpdateFuncCC UpdateFunction)(void*);
typedef ZUNResult(UpdateFuncCC UpdateFuncInit)(void*);
typedef ZUNResult(UpdateFuncCC UpdateFuncCleanup)(void*);

// size: 0x28
struct UpdateFunc {
    int32_t priority; // 0x0
    union {
        uint32_t flags; // 0x4
        struct {
            uint32_t initialized : 1; // 1
            uint32_t run_on_update : 1; // 2
        };
    };
    UpdateFunction* on_update_func; // 0x8
    UpdateFuncInit* on_init_func; // 0xC
    UpdateFuncCleanup* on_cleanup_func; // 0x10
    ZUNList<UpdateFunc> list_node; // 0x14
    void* func_arg; // 0x24
    // 0x28

    // 0x401530
    UpdateFunc(UpdateFunction* tick_func) : initialized(false), on_update_func(NULL), on_init_func(NULL), on_cleanup_func(NULL) {
        this->priority = 0;
        this->list_node.initialize_with(this);
        this->initialized = true;
        this->on_update_func = tick_func;
        this->on_init_func = NULL;
        this->on_cleanup_func = NULL;
    }

    inline UpdateFunc(UpdateFunction* tick_func, bool run_on_update, void* arg) : initialized(false), on_update_func(NULL), on_init_func(NULL), on_cleanup_func(NULL) {
        this->priority = 0;
        this->list_node.initialize_with(this);
        this->initialized = true;
        this->run_on_update = run_on_update;
        this->on_update_func = tick_func;
        this->on_init_func = NULL;
        this->on_cleanup_func = NULL;
        this->func_arg = arg;
    }

    inline ZUNResult run_init() {
        if (auto* func = this->on_init_func) {
            return func(this->func_arg);
        }
        return ZUN_SUCCESS;
    }

    inline ZUNResult run_cleanup() {
        if (auto* func = this->on_cleanup_func) {
            return func(this->func_arg);
        }
        return ZUN_SUCCESS;
    }

    inline UpdateFuncRet run_update() {
        UpdateFuncRet ret;
        CRITICAL_SECTION_MANAGER.enter_section(UpdateFuncRegistry_CS);
        ret = this->on_update_func(this->func_arg);
        CRITICAL_SECTION_MANAGER.leave_section(UpdateFuncRegistry_CS);
        return ret;
    }
};
#pragma region // UpdateFunc Validation
ValidateFieldOffset32(0x0, UpdateFunc, priority);
ValidateFieldOffset32(0x4, UpdateFunc, flags);
ValidateFieldOffset32(0x8, UpdateFunc, on_update_func);
ValidateFieldOffset32(0xC, UpdateFunc, on_init_func);
ValidateFieldOffset32(0x10, UpdateFunc, on_cleanup_func);
ValidateFieldOffset32(0x14, UpdateFunc, list_node);
ValidateFieldOffset32(0x24, UpdateFunc, func_arg);
ValidateStructSize32(0x28, UpdateFunc);
#pragma endregion

typedef struct UpdateFuncRegistry UpdateFuncRegistry;
extern "C" {
    // 0x4CF294
    externcg UpdateFuncRegistry* UPDATE_FUNC_REGISTRY_PTR cgasm("_UPDATE_FUNC_REGISTRY_PTR");
}
// size: 0x58
struct UpdateFuncRegistry {
    UpdateFunc on_tick_funcs; // 0x0
    UpdateFunc on_draw_funcs; // 0x28
    ZUNList<UpdateFunc>* __next_node; // 0x50
    int __dword_54; // 0x54
    // 0x58

    inline UpdateFuncRegistry() : on_tick_funcs(NULL), on_draw_funcs(NULL) {
        this->__next_node = NULL;
        this->__dword_54 = 0;
    }

    inline ~UpdateFuncRegistry();

    // 0x401180
    dllexport static gnu_noinline ZUNResult stdcall register_on_tick(UpdateFunc* update_tick, int32_t new_func_priority) asm_symbol_rel(0x401180) {
        ZUNResult ret = update_tick->run_init();
        UpdateFuncRegistry* update_func_registry = UPDATE_FUNC_REGISTRY_PTR;
        CRITICAL_SECTION_MANAGER.enter_section(UpdateFuncRegistry_CS);
        {
            update_tick->priority = new_func_priority;
            auto* prev_priority_node = update_func_registry->on_tick_funcs.list_node.find_node_before([=](UpdateFunc* update_func) {
                return update_func->priority >= new_func_priority;
            });
            prev_priority_node->append(&update_tick->list_node);
        }
        CRITICAL_SECTION_MANAGER.leave_section(UpdateFuncRegistry_CS);
        return ret;
    }

    // 0x401230
    dllexport static gnu_noinline int32_t stdcall register_on_draw(UpdateFunc* update_draw, int32_t new_func_priority) asm_symbol_rel(0x401230) {
        int32_t ret = update_draw->run_init();
        UpdateFuncRegistry* update_func_registry = UPDATE_FUNC_REGISTRY_PTR;
        CRITICAL_SECTION_MANAGER.enter_section(UpdateFuncRegistry_CS);
        {
            update_draw->priority = new_func_priority;
            auto* prev_priority_node = update_func_registry->on_draw_funcs.list_node.find_node_before([=](UpdateFunc* update_func) {
                return update_func->priority >= new_func_priority;
            });
            prev_priority_node->append(&update_draw->list_node);
        }
        CRITICAL_SECTION_MANAGER.leave_section(UpdateFuncRegistry_CS);
        return ret;
    }

    // 0x4015A0
    dllexport gnu_noinline void thiscall delete_func(UpdateFunc* update_func) asm_symbol_rel(0x4015A0) {
        if (update_func) {
            auto data_match = [=](UpdateFunc* data) {
                return data == update_func;
            };
            ZUNList<UpdateFunc>* update_func_node;
            if (!(update_func_node = this->on_tick_funcs.list_node.find_node_if(data_match)) &&
                !(update_func_node = this->on_draw_funcs.list_node.find_node_if(data_match))
            ) {
                return;
            }
            update_func_node->unlink_from_head(this->__next_node);
            if (update_func_node->prev) { // Don't try to delete the list heads
                update_func_node->unlink();
                update_func->on_update_func = NULL;
                if (update_func->initialized) {
                    update_func->on_init_func = NULL;
                    update_func->on_cleanup_func = NULL;
                    delete update_func;
                }
            }
        }
    }

    // 0x401650
    inline void thiscall delete_func_locked(UpdateFunc* update_func) {
        if (update_func) {
            CRITICAL_SECTION_MANAGER.enter_section(UpdateFuncRegistry_CS);
            {
                this->delete_func(update_func);
            }
            CRITICAL_SECTION_MANAGER.leave_section(UpdateFuncRegistry_CS);
        }
    }

    // 0x4012E0
    dllexport gnu_noinline int32_t thiscall run_all_on_tick() asm_symbol_rel(0x4012E0) {
        int32_t ret;
        CRITICAL_SECTION_MANAGER.enter_section(UpdateFuncRegistry_CS);
        {
RestartOnTick:
            ret = 0;
            ZUNList<UpdateFunc>* node = this->on_tick_funcs.list_node.next;
            while (node) {
                ZUNList<UpdateFunc>* next_node = node->next;
                this->__next_node = next_node;
                UpdateFunc* update_tick = node->data;
                node = next_node;
                if (!update_tick->on_update_func) {
                    continue;
                }
                if (update_tick->run_on_update) {
                    do {
                        if (this->__dword_54) {
                            goto CleanupThenNext;
                        }
                        int32_t update_ret;
                        CRITICAL_SECTION_MANAGER.enter_section(UpdateFuncRegistry_CS);
                        {
                            update_ret = update_tick->on_update_func(update_tick->func_arg);
                        }
                        CRITICAL_SECTION_MANAGER.leave_section(UpdateFuncRegistry_CS);
                        switch (expect_chance(update_ret, UpdateFuncRepeatCurrent, 0.05)) {
                            case UpdateFuncDeleteCurrentThenNext:
                                goto DeleteCurrentThenNext;
                            case UpdateFuncNext: default:
                                goto NextFunc;
                            case UpdateFuncRepeatCurrent:
                                continue;
                            case UpdateFuncEnd0: case UpdateFuncEnd0Dupe:
                                ret = 0;
                                goto EndOnTick;
                            case UpdateFuncEnd1:
                                ret = 1;
                                goto EndOnTick;
                            case UpdateFuncEndN1:
                                ret = -1;
                                goto EndOnTick;
                            case UpdateFuncRestartTick:
                                goto RestartOnTick;
                            case UpdateFuncCleanupThenNext:
                                goto CleanupThenNext;
                        }
                    } while (update_tick->run_on_update);
                    jump_only_block{
DeleteCurrentThenNext:
                        this->delete_func(update_tick);
                    }
                    jump_only_block{
CleanupThenNext:
                        update_tick->run_cleanup();
                    }
                }
NextFunc:
                node = this->__next_node;
                ++ret;
            }
        }
EndOnTick:
        CRITICAL_SECTION_MANAGER.leave_section(UpdateFuncRegistry_CS);
        return ret;
    }

    // 0x401420
    dllexport static gnu_noinline int32_t run_all_on_draw() asm_symbol_rel(0x401420) {
        UpdateFuncRegistry* update_func_registry = UPDATE_FUNC_REGISTRY_PTR;
        int32_t ret;
        CRITICAL_SECTION_MANAGER.enter_section(UpdateFuncRegistry_CS);
        {
//RestartOnTick:
            ret = 0;
            ZUNList<UpdateFunc>* node = update_func_registry->on_draw_funcs.list_node.next;
            while (expect(node != NULL, true)) {
                ZUNList<UpdateFunc>* next_node = node->next;
                update_func_registry->__next_node = next_node;
                UpdateFunc* update_draw = node->data;
                node = next_node;
                if (!update_draw->on_update_func) {
                    continue;
                }
                if (update_draw->run_on_update) {
                    do {
                        /*if (update_func_registry->__dword_54) {
                            goto CleanupThenNext;
                        }*/
                        int32_t update_ret;
                        CRITICAL_SECTION_MANAGER.enter_section_volatile(UpdateFuncRegistry_CS);
                        {
                            update_ret = update_draw->on_update_func(update_draw->func_arg);
                        }
                        CRITICAL_SECTION_MANAGER.leave_section(UpdateFuncRegistry_CS);
                        switch (expect_chance(update_ret, UpdateFuncNext, 0.95)) {
                            case UpdateFuncDeleteCurrentThenNext:
                                goto DeleteCurrentThenNext;
                            case UpdateFuncNext: default:
                                goto NextFunc;
                            case UpdateFuncRepeatCurrent:
                                continue;
                            case UpdateFuncEnd0: //case UpdateFuncEnd0Dupe:
                                ret = 0;
                                goto EndOnDraw;
                            case UpdateFuncEnd1:
                                ret = 1;
                                goto EndOnDraw;
                            case UpdateFuncEndN1:
                                ret = -1;
                                goto EndOnDraw;
                            /*case UpdateFuncRestartTick:
                                goto RestartOnTick;
                            case UpdateFuncCleanupThenNext:
                                goto CleanupThenNext;*/
                        }
                    } while (update_draw->run_on_update);
                    jump_only_block{
DeleteCurrentThenNext:
                        update_func_registry->delete_func(update_draw);
                    }
                    /*jump_only_block{
CleanupThenNext:
                        update_tick->run_cleanup();
                    }*/
                }
            NextFunc:
                node = update_func_registry->__next_node;
                ++ret;
            }
        }
EndOnDraw:
        CRITICAL_SECTION_MANAGER.leave_section(UpdateFuncRegistry_CS);
        return ret;
    }
};
#pragma region // UpdateFuncRegistry Validation
ValidateFieldOffset32(0x0, UpdateFuncRegistry, on_tick_funcs);
ValidateFieldOffset32(0x28, UpdateFuncRegistry, on_draw_funcs);
ValidateFieldOffset32(0x50, UpdateFuncRegistry, __next_node);
ValidateFieldOffset32(0x54, UpdateFuncRegistry, __dword_54);
ValidateStructSize32(0x58, UpdateFuncRegistry);
#pragma endregion

// size: 0x8
struct Rng {
    uint16_t value; // 0x0
    uint32_t index; // 0x4
    // 0x8
    
    // 0x4026D0
    dllexport gnu_noinline uint16_t thiscall rand_ushort() asm_symbol_rel(0x4026D0) {
        CRITICAL_SECTION_MANAGER.enter_section(RNG_CS);
        {
            this->index++;
            uint16_t temp = (this->value ^ 0x9630) - 0x6553;
            this->value = ((temp & 0xC000) >> 14) + (temp << 2) & 0xFFFF;
        }
        CRITICAL_SECTION_MANAGER.leave_section(RNG_CS);
        return this->value;
    }
    
    // 0x402740
    dllexport gnu_noinline uint32_t thiscall rand_uint() asm_symbol_rel(0x402740) {
        uint16_t tempA, tempB;
        CRITICAL_SECTION_MANAGER.enter_section(RNG_CS);
        {
            this->index += 2;
            tempA = (this->value ^ 0x9630) - 0x6553;
            tempB = ((tempA & 0xC000) >> 14) + (tempA << 2) & 0xFFFF;
            tempB = (tempB ^ 0x9630) - 0x6553;
            this->value = ((tempB & 0xC000) >> 14) + (tempB << 2) & 0xFFFF;
        }
        CRITICAL_SECTION_MANAGER.leave_section(RNG_CS);
        return (tempA << 16) | tempB;
    }
    
    // 0x4027D0
    dllexport gnu_noinline float thiscall rand_float() asm_symbol_rel(0x4027D0) {
        __asm FINIT;
        float temp = this->rand_uint();
        return temp / (float)UINT32_MAX; // float jank rounds this to UINT32_MAX+1
    }
    // 0x402810
    dllexport gnu_noinline float thiscall rand_float_signed() asm_symbol_rel(0x402810) {
        __asm FINIT;
        float temp = this->rand_uint();
        return temp / (float)INT32_MAX - 1.0f; // float jank rounds this to INT32_MAX+1
    }
    // 0x405B90
    dllexport float vectorcall rand_angle() asm_symbol_rel(0x405B90) {
        return this->rand_float_signed() * PI_f;
    }
    // 0x402850
    dllexport gnu_noinline float thiscall rand_angle_2() asm_symbol_rel(0x402850) {
        __asm FINIT;
        float temp = this->rand_uint();
        return temp / TWO_PI_f - PI_f;
    }
    
private:
    // 0x406AB0
    dllexport gnu_noinline float vectorcall rand_float_range(float, float range) asm_symbol_rel(0x406AB0) {
        return this->rand_float() * range;
    }
public:
    inline float rand_float_range(float range) {
        return this->rand_float_range(UNUSED_FLOAT, range);
    }
    
    inline float rand_float_signed_range(float range) {
        return this->rand_float_signed() * range;
    }
    // 0x4615A0
    dllexport uint32_t thiscall rand_uint_range(uint32_t range) asm_symbol_rel(0x4615A0) {
        if (range != 0) {
            return this->rand_uint() % range;
        } else {
            return 0;
        }
    }
};
#pragma region // Rng Validation
ValidateFieldOffset32(0x0, Rng, value);
ValidateFieldOffset32(0x4, Rng, index);
ValidateStructSize32(0x8, Rng);
#pragma endregion

extern "C" {
    // 0x4CF280
    externcg Rng RNG cgasm("_RNG");
    // 0x4CF288
    externcg Rng REPLAY_RNG cgasm("_REPLAY_RNG");
}

enum Difficulty {
    EASY = 0,
    NORMAL = 1,
    HARD = 2,
    LUNATIC = 3,
    EXTRA = 4,
    OVERDRIVE = 5
};

typedef struct Float3 Float3;
typedef struct Enemy Enemy;

// 0x4237F0
dllexport gnu_noinline Enemy* get_boss_by_index(int32_t boss_id) asm_symbol_rel(0x4237F0);

// size: 0x8
struct GameSpeed {
    float value = 1.0f; // 0x0
    int __counter_4; // 0x4
    // 0x8

    // 0x43A200
    dllexport gnu_noinline void vectorcall set(float new_speed) asm_symbol_rel(0x43A200);

    inline operator float() const {
        return this->value;
    }
};
#pragma region // GameSpeed Validation
ValidateFieldOffset32(0x0, GameSpeed, value);
ValidateFieldOffset32(0x4, GameSpeed, __counter_4);
ValidateStructSize32(0x8, GameSpeed);
#pragma endregion

extern "C" {
    // 0x4CCBF0
    externcg GameSpeed GAME_SPEED cgasm("_GAME_SPEED");
}
// 0x43A200
dllexport gnu_noinline void vectorcall GameSpeed::set(float new_speed) {
    GAME_SPEED.value = new_speed;
}

static const float* TIME_SCALING_TABLE[] = {
    &GAME_SPEED.value
};

// size: 0x14
struct Timer {
    int32_t previous; // 0x0
    int32_t current; // 0x4
    float current_f; // 0x8
    uint32_t scale_table_index; // 0xC
    union {
        uint32_t flags; // 0x10
        struct {
            uint32_t initialized : 1;
        };
    };
    // 0x14

    inline operator int32_t() {
        return this->current;
    }
    inline operator float() {
        return this->current_f;
    }

    inline Timer() : initialized(false) {};

    inline void default_values() {
        this->current = 0;
        this->previous = -999999;
        this->current_f = 0.0f;
    }

private:
    inline void initialize_previous_force(int32_t value) volatile {
        this->previous = value;
    }
public:

    inline void initialize() {
        if (!this->initialized) {
            this->initialize_previous_force(-999999);
            this->scale_table_index = 0;
            this->initialized = true;
        }
    }

    inline void initialize_important() {
        if (!this->initialized) {
            this->scale_table_index = 0;
            this->initialized = true;
        }
    }
    inline void set_raw(int32_t time) {
        this->current = time;
        this->current_f = (float)time;
        this->previous = time - 1;
    }
    inline void set_raw(float time) {
        this->current_f = time;
        int32_t int_time = (int32_t)time;
        this->current = int_time;
        this->previous = int_time - 1;
    }
    // 0x405D10
    dllexport inline void thiscall set(int32_t time) asm_symbol_rel(0x405D10) {
        this->initialize_important();
        this->set_raw(time);
    }
    inline void set(float time) {
        this->initialize_important();
        this->set_raw(time);
    }
    inline void reset() {
        this->set(0);
    }

    inline void initialize_and_reset() {
        this->initialize();
        this->set_raw(0);
    }
    inline void initialize_and_set(int32_t time) {
        this->initialize();
        this->set_raw(time);
    }

    // 0x418C40
    // Yes, this really does copy a whole timer to the stack
    // Possibly an assignment operator...?
    dllexport gnu_noinline void set_from_timer(Timer timer) asm_symbol_rel(0x418C40) {
        this->set(timer.current);
    }

    // Just in case that is an assignment operator, check for warnings in current uses
    Timer& operator=(Timer timer) = delete;

    inline uint32_t get_scaling_index() {
        uint32_t time_scaling_index = this->scale_table_index;
        if (time_scaling_index >= countof(TIME_SCALING_TABLE)) {
            time_scaling_index = this->scale_table_index = 0;
        }
        return time_scaling_index;
    }

    inline float get_scale_unsafe() {
        return *TIME_SCALING_TABLE[this->scale_table_index];
    }

private:
    // 0x402A60
    dllexport gnu_noinline int32_t vectorcall add_raw(float, float value) asm_symbol_rel(0x402A60) {
        this->previous = this->current;
        return this->current = this->current_f += value;
    }
public:
    inline int32_t add_raw(float value) {
        return this->add_raw(UNUSED_FLOAT, value);
    }

    inline int32_t vectorcall add_float(float amount) {
        const float* time_scale_ptr = TIME_SCALING_TABLE[this->get_scaling_index()];
        this->previous = this->current;
        if (time_scale_ptr) {
            float time_scale = *time_scale_ptr;
            if (!(time_scale > 0.99f) || !(time_scale < 1.01f)) {
                return this->current = this->current_f += time_scale * amount;
            }
        }
        return this->current = this->current_f += amount;
    }

    inline int32_t vectorcall sub_float(float amount) {
        const float* time_scale_ptr = TIME_SCALING_TABLE[this->get_scaling_index()];
        this->previous = this->current;
        if (time_scale_ptr) {
            float time_scale = *time_scale_ptr;
            if (!(time_scale > 0.99f) || !(time_scale < 1.01f)) {
                return this->current = this->current_f -= time_scale * amount;
            }
        }
        return this->current = this->current_f -= amount;
    }

    inline int32_t add_int(int32_t amount) {
        return this->add_float(amount);
    }

    // 0x452BF0
    dllexport int32_t thiscall sub_int(int32_t amount) asm_symbol_rel(0x452BF0) {
        return this->add_float(-amount);
    }
    
    inline int32_t increment() {
        const float* time_scale_ptr = TIME_SCALING_TABLE[this->get_scaling_index()];
        int32_t current = this->current;
        this->previous = current;
        if (time_scale_ptr) {
            float time_scale = *time_scale_ptr;
            if (!(time_scale > 0.99f) || !(time_scale < 1.01f)) {
                return this->current = this->current_f += time_scale;
            }
        }
        this->current_f += 1.0f;
        return this->current = ++current;
    }

    inline int32_t decrement() {
        return this->sub_float(1.0f);
    }
    
    // 0x405990
    dllexport int32_t thiscall operator++(int) asm_symbol_rel(0x405990) {
        clang_forceinline return this->increment();
    }

    // 0x402A80
    dllexport int32_t thiscall operator++() asm_symbol_rel(0x402A80) {
        clang_forceinline return this->increment();
    }

    // 0x409750
    dllexport int32_t thiscall operator--(int) asm_symbol_rel(0x409750) {
        clang_forceinline return this->decrement();
    }

    dllexport int32_t thiscall operator--() {
        clang_forceinline return this->decrement();
    }

    inline int32_t operator+=(int32_t amount) {
        return this->add_int(amount);
    }

    inline int32_t operator+=(float amount) {
        return this->add_float(amount);
    }

    inline int32_t operator-=(int32_t amount) {
        return this->sub_int(amount);
    }

    inline int32_t operator-=(float amount) {
        return this->sub_float(amount);
    }

    inline int32_t operator+(int32_t amount) {
        return this->current + amount;
    }
    inline float operator+(float amount) {
        return this->current_f + amount;
    }
    inline int32_t operator-(int32_t amount) {
        return this->current - amount;
    }
    inline float operator-(float amount) {
        return this->current_f - amount;
    }
    inline int32_t operator*(int32_t amount) {
        return this->current * amount;
    }
    inline float operator*(float amount) {
        return this->current_f * amount;
    }
    inline int32_t operator/(int32_t amount) {
        return this->current / amount;
    }
    inline float operator/(float amount) {
        return this->current_f / amount;
    }

    inline int32_t operator%(int32_t amount) {
        return this->current % amount;
    }

    friend inline int32_t operator-(int32_t amount, const Timer& self) {
        return amount - self.current;
    }
    friend inline float operator-(float amount, const Timer& self) {
        return amount - self.current_f;
    }
    friend inline int32_t operator/(int32_t amount, const Timer& self) {
        return amount / self.current;
    }
    friend inline float operator/(float amount, const Timer& self) {
        return amount / self.current_f;
    }

    friend inline int32_t operator%(int32_t amount, const Timer& self) {
        return amount % self.current;
    }

    inline bool __is_paused() {
        int32_t current = this->current;
        return current == this->previous;
    }

    // 0x4210A0
    dllexport BOOL thiscall __is_multiple_of_not_paused(int32_t value) asm_symbol_rel(0x4210A0) {
        int32_t current = this->current;
        if (
            current != this->previous &&
            !(current % value)
        ) {
            return TRUE;
        }
        return FALSE;
    }

    inline bool is_multiple_of(int32_t value) {
        return !(this->current % value);
    }

    inline bool les(int32_t time) {
        return this->current < time;
    }
    inline bool les(float time) {
        return this->current_f < time;
    }
    inline bool leq(int32_t time) {
        return this->current <= time;
    }
    inline bool leq(float time) {
        return this->current_f <= time;
    }
    inline bool gre(int32_t time) {
        return this->current > time;
    }
    inline bool gre(float time) {
        return this->current_f > time;
    }
    inline bool geq(int32_t time) {
        return this->current >= time;
    }
    inline bool geq(float time) {
        return this->current_f >= time;
    }
    inline bool equ(int32_t time) {
        return this->current == time;
    }
    inline bool equ(float time) {
        return this->current_f == time;
    }
    inline bool neq(int32_t time) {
        return this->current != time;
    }
    inline bool neq(float time) {
        return this->current_f != time;
    }
    inline bool is_zero() {
        return this->equ(0);
    }
    inline bool is_not_zero() {
        return this->neq(0);
    }

    inline bool operator<(int32_t time) {
        return this->les(time);
    }
    inline bool operator<(float time) {
        return this->les(time);
    }
    inline friend bool operator<(int32_t time, Timer& self) {
        return time < self.current;
    }
    inline friend bool operator<(float time, Timer& self) {
        return time < self.current_f;
    }
    inline bool operator<=(int32_t time) {
        return this->leq(time);
    }
    inline bool operator<=(float time) {
        return this->leq(time);
    }
    inline friend bool operator<=(int32_t time, Timer& self) {
        return time <= self.current;
    }
    inline friend bool operator<=(float time, Timer& self) {
        return time <= self.current_f;
    }
    inline bool operator>(int32_t time) {
        return this->gre(time);
    }
    inline bool operator>(float time) {
        return this->gre(time);
    }
    inline friend bool operator>(int32_t time, Timer& self) {
        return time > self.current;
    }
    inline friend bool operator>(float time, Timer& self) {
        return time > self.current_f;
    }
    inline bool operator>=(int32_t time) {
        return this->geq(time);
    }
    inline bool operator>=(float time) {
        return this->geq(time);
    }
    inline friend bool operator>=(int32_t time, Timer& self) {
        return time >= self.current;
    }
    inline friend bool operator>=(float time, Timer& self) {
        return time >= self.current_f;
    }
    inline bool operator==(int32_t time) {
        return this->equ(time);
    }
    inline bool operator==(float time) {
        return this->equ(time);
    }
    inline bool operator!=(int32_t time) {
        return this->neq(time);
    }
    inline bool operator!=(float time) {
        return this->neq(time);
    }
    inline bool operator!() {
        return this->is_zero();
    }
    inline operator bool() {
        return this->is_not_zero();
    }
};
#pragma region // Timer Validation
ValidateFieldOffset32(0x0, Timer, previous);
ValidateFieldOffset32(0x4, Timer, current);
ValidateFieldOffset32(0x8, Timer, current_f);
ValidateFieldOffset32(0xC, Timer, scale_table_index);
ValidateFieldOffset32(0x10, Timer, flags);
ValidateStructSize32(0x14, Timer);
#pragma endregion

// size: 0x14
struct InputMapping {
    int16_t shoot; // 0x0
    int16_t bomb; // 0x2
    int16_t focus; // 0x4
    int16_t pause; // 0x6
    int16_t __button4; // 0x8
    int16_t __button5; // 0xA
    int16_t __button6; // 0xC
    int16_t __button7; // 0xE
    int16_t use_card; // 0x10
    int16_t switch_card; // 0x12
    // 0x14
};
#pragma region // InputMapping Validation
ValidateFieldOffset32(0x0, InputMapping, shoot);
ValidateFieldOffset32(0x2, InputMapping, bomb);
ValidateFieldOffset32(0x4, InputMapping, focus);
ValidateFieldOffset32(0x6, InputMapping, pause);
ValidateFieldOffset32(0x10, InputMapping, use_card);
ValidateFieldOffset32(0x12, InputMapping, switch_card);
ValidateStructSize32(0x14, InputMapping);
#pragma endregion

extern "C" {
    // 0x4CABA8
    externcg InputMapping DEFAULT_JOYPAD_MAPPINGS cgasm("_DEFAULT_JOYPAD_MAPPINGS");
    // 0x4CABBC
    externcg InputMapping DEFAULT_XINPUT_MAPPINGS cgasm("_DEFAULT_XINPUT_MAPPINGS");
    // 0x4CABD0
    externcg InputMapping DEFAULT_KEYBOARD_MAPPINGS cgasm("_DEFAULT_KEYBOARD_MAPPINGS");
}

static inline constexpr size_t BUTTON_COUNT = 32;

static inline constexpr uint32_t BUTTON_SHOOT       = 0x00000001; // 'Z'
static inline constexpr uint32_t BUTTON_BOMB        = 0x00000002; // 'X'

static inline constexpr uint32_t BUTTON_FOCUS       = 0x00000008; // VK_SHIFT
static inline constexpr uint32_t BUTTON_UP          = 0x00000010;
static inline constexpr uint32_t BUTTON_DOWN        = 0x00000020;
static inline constexpr uint32_t BUTTON_LEFT        = 0x00000040;
static inline constexpr uint32_t BUTTON_RIGHT       = 0x00000080;
static inline constexpr uint32_t BUTTON_PAUSE       = 0x00000100; // VK_ESCAPE
static inline constexpr uint32_t BUTTON_SKIP        = 0x00000200;
static inline constexpr uint32_t BUTTON_USE_CARD    = 0x00000400; // 'C'
static inline constexpr uint32_t BUTTON_SWITCH_CARD = 0x00000800; // 'D'

static inline constexpr uint32_t BUTTON_UNKNOWN_A   = 0x00010000;

static inline constexpr uint32_t BUTTON_SCREENSHOT  = 0x00040000; // 'P', VK_HOME
static inline constexpr uint32_t BUTTON_ENTER       = 0x00080000; // VK_RETURN

static inline constexpr uint32_t BUTTON_RESTART     = 0x00200000; // 'R', VK_END

static inline constexpr uint32_t BUTTON_SELECT      = BUTTON_SHOOT | BUTTON_ENTER; // 'Z', VK_RETURN
static inline constexpr uint32_t BUTTON_CANCEL      = BUTTON_BOMB; // 'X'

static inline constexpr uint32_t BUTTON_SHOOT_INDEX = 0;
static inline constexpr uint32_t BUTTON_BOMB_INDEX = 1;
static inline constexpr uint32_t BUTTON_FOCUS_INDEX = 3;
static inline constexpr uint32_t BUTTON_UP_INDEX = 4;
static inline constexpr uint32_t BUTTON_DOWN_INDEX = 5;
static inline constexpr uint32_t BUTTON_LEFT_INDEX = 6;
static inline constexpr uint32_t BUTTON_RIGHT_INDEX = 7;
static inline constexpr uint32_t BUTTON_PAUSE_INDEX = 8;
static inline constexpr uint32_t BUTTON_SKIP_INDEX = 9;
static inline constexpr uint32_t BUTTON_USE_CARD_INDEX = 10;
static inline constexpr uint32_t BUTTON_SWITCH_CARD_INDEX = 11;
static inline constexpr uint32_t BUTTON_SCREENSHOT_INDEX = 18;
static inline constexpr uint32_t BUTTON_ENTER_INDEX = 19;
static inline constexpr uint32_t BUTTON_RESTART_INDEX = 21;

#define XINPUT_GAMEPAD_LEFT_TRIGGER 0x10000
#define XINPUT_GAMEPAD_RIGHT_TRIGGER 0x20000

// 0x4B4320
// Is this actually an array of 20 with extra blanks?
static inline constexpr uint32_t XINPUT_PAD_MAPPINGS[] = {
    XINPUT_GAMEPAD_A,
    XINPUT_GAMEPAD_B,
    XINPUT_GAMEPAD_X,
    XINPUT_GAMEPAD_Y,
    XINPUT_GAMEPAD_LEFT_SHOULDER,
    XINPUT_GAMEPAD_RIGHT_SHOULDER,
    XINPUT_GAMEPAD_LEFT_TRIGGER,
    XINPUT_GAMEPAD_RIGHT_TRIGGER,
    XINPUT_GAMEPAD_LEFT_THUMB,
    XINPUT_GAMEPAD_RIGHT_THUMB,
    XINPUT_GAMEPAD_START,
    XINPUT_GAMEPAD_BACK
};

enum InputMode : int32_t {
    InputXInput = 0,
    InputJoypad = 1,
    InputKeyboard = 2,
};

// This matches UnknownV in the th19 repo
struct InputState {
    union {
        uint32_t hardware_inputs_current; // 0x0
        struct {

        };
    };
    union {
        uint32_t hardware_inputs_previous; // 0x4
        struct {

        };
    };
    union {
        uint32_t hardware_inputs_held_26_frames; // 0x8
        struct {

        };
    };
    union {
        uint32_t hardware_inputs_rising_edge; // 0xC
        struct {

        };
    };
    union {
        uint32_t hardware_inputs_falling_edge; // 0x10
        struct {

        };
    };
    uint32_t hardware_inputs_held_for_repeat[BUTTON_COUNT]; // 0x14
    uint32_t inputs_held_for_repeat[BUTTON_COUNT]; // 0x94
    uint32_t hardware_inputs_held[BUTTON_COUNT]; // 0x114
    uint32_t inputs_held[BUTTON_COUNT]; // 0x194
    int __dword_214; // 0x214
    union {
        uint32_t inputs_current; // 0x218
        struct {
            
        };
    };
    union {
        uint32_t inputs_previous; // 0x21C
        struct {
            
        };
    };
    union {
        uint32_t inputs_held_26_frames; // 0x220
        struct {
            
        };
    };
    union {
        uint32_t inputs_rising_edge; // 0x224
        struct {
            
        };
    };
    union {
        uint32_t inputs_falling_edge; // 0x228
        struct {
            
        };
    };
    union {
        uint32_t hardware_inputs_held_8_frames; // 0x22C
        struct {

        };
    };
    union {
        uint32_t inputs_held_8_frames; // 0x230
        struct {
            
        };
    };
    InputMode __device_type; // 0x234
    InputMapping joypad_mapping; // 0x238
    InputMapping xinput_mapping; // 0x24C
    InputMapping keyboard_mapping; // 0x260
    // 0x274

    // 0x418CE0
    dllexport gnu_noinline void thiscall __reset_inputs() asm_symbol_rel(0x418CE0) {
        zero_array(this->inputs_held_for_repeat);
        zero_array(this->inputs_held);
        this->__dword_214 = 0;
        this->inputs_current = 0;
        this->inputs_previous = 0;
        this->inputs_held_26_frames = 0;
        this->inputs_rising_edge = 0;
        this->inputs_falling_edge = 0;
        this->inputs_held_8_frames = 0;
    }

    // 0x404E90
    dllexport gnu_noinline void thiscall __update_hardware_input() asm_symbol_rel(0x404E90) {
        uint32_t current = this->hardware_inputs_current;
        uint32_t mask = 1;

        for (size_t i = 0; i < BUTTON_COUNT; ++i) {
            if (current & 1) {
                ++this->hardware_inputs_held_for_repeat[i];
                ++this->hardware_inputs_held[i];
                if (this->hardware_inputs_held_for_repeat[i] >= 8) {
                    this->hardware_inputs_held_8_frames |= mask;
                }
                if (this->hardware_inputs_held_for_repeat[i] >= 26) {
                    this->hardware_inputs_held_26_frames |= mask;
                    this->hardware_inputs_held_for_repeat[i] -= 8;
                }
            } else {
                this->hardware_inputs_held_for_repeat[i] = 0;
                this->hardware_inputs_held[i] = 0;
            }
            current >>= 1;
            mask <<= 1;
        }
        current = this->hardware_inputs_current;
        uint32_t changed = current ^ this->hardware_inputs_previous;
        this->hardware_inputs_rising_edge = current & changed;
        this->hardware_inputs_falling_edge = ~current & changed;
    }

    inline void __update_input() {
        uint32_t current = this->inputs_current;
        uint32_t mask = 1;

        for (size_t i = 0; i < BUTTON_COUNT; ++i) {
            if (current & 1) {
                ++this->inputs_held_for_repeat[i];
                ++this->inputs_held[i];
                if (this->inputs_held_for_repeat[i] >= 8) {
                    this->inputs_held_8_frames |= mask;
                }
                if (this->inputs_held_for_repeat[i] >= 26) {
                    this->inputs_held_26_frames |= mask;
                    this->inputs_held_for_repeat[i] -= 8;
                }
            } else {
                this->inputs_held_for_repeat[i] = 0;
                this->inputs_held[i] = 0;
            }
            current >>= 1;
            mask <<= 1;
        }
        current = this->inputs_current;
        uint32_t changed = current ^ this->inputs_previous;
        this->inputs_rising_edge = current & changed;
        this->inputs_falling_edge = ~current & changed;
    }

    inline BOOL check_inputs(uint32_t mask) {
        if (!(this->inputs_current & mask)) {
            return FALSE;
        }
        return TRUE;
    }

    inline BOOL check_inputs_no_repeat(uint32_t mask) {
        if (!(this->inputs_rising_edge & mask)) {
            return FALSE;
        }
        return TRUE;
    }

    inline BOOL check_inputs_repeating(uint32_t mask) {
        if (
            !(this->inputs_rising_edge & mask) &&
            !(this->inputs_held_26_frames & mask)
        ) {
            return FALSE;
        }
        return TRUE;
    }

    inline BOOL check_hardware_inputs(uint32_t mask) {
        if (!(this->hardware_inputs_current & mask)) {
            return FALSE;
        }
        return TRUE;
    }

    inline BOOL check_hardware_inputs_no_repeat(uint32_t mask) {
        if (!(this->hardware_inputs_rising_edge & mask)) {
            return FALSE;
        }
        return TRUE;
    }

    inline BOOL check_hardware_inputs_repeating(uint32_t mask) {
        if (
            !(this->hardware_inputs_rising_edge & mask) &&
            !(this->hardware_inputs_held_26_frames & mask)
        ) {
            return FALSE;
        }
        return TRUE;
    }

    inline uint32_t get_xinput(uint32_t buttons) {
        uint32_t prev_buttons = buttons;

        nounroll for (DWORD i = 0; i < 4; ++i) {
            XINPUT_STATE state = {};
            if (XInputGetState(i, &state) == ERROR_SUCCESS) {
                uint32_t pad_buttons = state.Gamepad.wButtons;
                if (state.Gamepad.bLeftTrigger >= XINPUT_GAMEPAD_TRIGGER_THRESHOLD) {
                    pad_buttons |= XINPUT_GAMEPAD_LEFT_TRIGGER;
                }
                if (state.Gamepad.bRightTrigger >= XINPUT_GAMEPAD_TRIGGER_THRESHOLD) {
                    pad_buttons |= XINPUT_GAMEPAD_RIGHT_TRIGGER;
                }
                if (state.Gamepad.sThumbLY >= XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE) {
                    pad_buttons |= XINPUT_GAMEPAD_DPAD_UP;
                }
                if (state.Gamepad.sThumbLY <= -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE) {
                    pad_buttons |= XINPUT_GAMEPAD_DPAD_DOWN;
                }
                if (state.Gamepad.sThumbLX >= XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE) {
                    pad_buttons |= XINPUT_GAMEPAD_DPAD_RIGHT;
                }
                if (state.Gamepad.sThumbLX <= -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE) {
                    pad_buttons |= XINPUT_GAMEPAD_DPAD_LEFT;
                }

                if (pad_buttons & XINPUT_GAMEPAD_DPAD_UP) {
                    buttons |= BUTTON_UP;
                }
                if (pad_buttons & XINPUT_GAMEPAD_DPAD_DOWN) {
                    buttons |= BUTTON_DOWN;
                }
                if (pad_buttons & XINPUT_GAMEPAD_DPAD_LEFT) {
                    buttons |= BUTTON_LEFT;
                }
                if (pad_buttons & XINPUT_GAMEPAD_DPAD_RIGHT) {
                    buttons |= BUTTON_RIGHT;
                }

                if (pad_buttons & XINPUT_PAD_MAPPINGS[this->xinput_mapping.shoot]) {
                    buttons |= BUTTON_SHOOT;
                }
                if (pad_buttons & XINPUT_PAD_MAPPINGS[this->xinput_mapping.bomb]) {
                    buttons |= BUTTON_BOMB;
                }
                if (pad_buttons & XINPUT_PAD_MAPPINGS[this->xinput_mapping.focus]) {
                    buttons |= BUTTON_FOCUS;
                }
                if (pad_buttons & XINPUT_PAD_MAPPINGS[this->xinput_mapping.use_card]) {
                    buttons |= BUTTON_USE_CARD;
                }
                if (pad_buttons & XINPUT_PAD_MAPPINGS[this->xinput_mapping.switch_card]) {
                    buttons |= BUTTON_SWITCH_CARD;
                }
                if (pad_buttons & XINPUT_PAD_MAPPINGS[this->xinput_mapping.pause]) {
                    buttons |= BUTTON_PAUSE;
                }
            }
        }

        if (buttons != prev_buttons) {
            this->__device_type = InputXInput;
        }
        return buttons;
    }

    inline uint32_t get_joypad(uint32_t buttons);

    inline uint32_t get_keyboard(uint32_t buttons) {
        uint32_t prev_buttons = buttons;

        BYTE keys[256];
        GetKeyboardState(keys);

        // Again, this original code is *bad*.
        // I'm not going to attempt to match it.

        int32_t bomb = this->keyboard_mapping.bomb;
        int32_t shoot = this->keyboard_mapping.shoot;

        uint32_t pressed = keys[shoot]; // becomes 0x1
        pressed >>= 1;

        pressed |= keys[bomb] & 0x80; // becomes 0x2
        pressed >>= 1;

        // mystery key
        pressed >>= 1;

        int32_t focus = this->keyboard_mapping.focus;
        pressed |= keys[focus] & 0x80; // becomes 0x8
        pressed >>= 1;

        pressed |= (keys[VK_UP] | keys[VK_NUMPAD8]) & 0x80; // becomes 0x10
        pressed >>= 1;
        pressed |= (keys[VK_DOWN] | keys[VK_NUMPAD2]) & 0x80; // becomes 0x20
        pressed >>= 1;
        pressed |= (keys[VK_LEFT] | keys[VK_NUMPAD4]) & 0x80; // becomes 0x40
        pressed >>= 1;

        uint32_t pressed2 = (keys[VK_END] | keys['R']) & 0x80; // becomes 0x200000
        pressed2 <<= 1;

        // mystery key
        pressed2 <<= 1;

        pressed2 |= keys[VK_RETURN] & 0x80; // becomes 0x80000
        pressed2 <<= 1;

        pressed2 |= (keys[VK_HOME] | keys['P']) & 0x80; // becomes 0x40000
        pressed2 <<= 7;

        int32_t switch_card = this->keyboard_mapping.switch_card;
        pressed2 |= keys[switch_card] & 0x80; // becomes 0x800
        pressed2 <<= 1;

        int32_t use_card = this->keyboard_mapping.use_card;
        pressed2 |= keys[use_card] & 0x80; // becomes 0x400
        pressed2 <<= 1;

        // mystery key
        pressed2 <<= 1;

        int32_t pause = this->keyboard_mapping.pause;
        pressed2 |= keys[pause] & 0x80; // becomes 0x100
        pressed2 <<= 1;

        pressed |= pressed2;

        pressed |= (keys[VK_RIGHT] | keys[VK_NUMPAD6]) & 0x80; // becomes 0x80

        pressed |= keys[VK_NUMPAD3] & 0x80 ? BUTTON_DOWN | BUTTON_RIGHT : 0;
        pressed |= keys[VK_NUMPAD9] & 0x80 ? BUTTON_UP | BUTTON_RIGHT : 0;
        pressed |= keys[VK_NUMPAD1] & 0x80 ? BUTTON_DOWN | BUTTON_LEFT : 0;
        pressed |= keys[VK_NUMPAD7] & 0x80 ? BUTTON_UP | BUTTON_LEFT : 0;

        buttons |= pressed;

        if (buttons != prev_buttons) {
            this->__device_type = InputKeyboard;
        }
        return buttons;
    }
};
#pragma region // InputState Validation
ValidateFieldOffset32(0x0, InputState, hardware_inputs_current);
ValidateFieldOffset32(0x4, InputState, hardware_inputs_previous);
ValidateFieldOffset32(0x8, InputState, hardware_inputs_held_26_frames);
ValidateFieldOffset32(0xC, InputState, hardware_inputs_rising_edge);
ValidateFieldOffset32(0x14, InputState, hardware_inputs_held_for_repeat);
ValidateFieldOffset32(0x94, InputState, inputs_held_for_repeat);
ValidateFieldOffset32(0x114, InputState, hardware_inputs_held);
ValidateFieldOffset32(0x194, InputState, inputs_held);
ValidateFieldOffset32(0x214, InputState, __dword_214);
ValidateFieldOffset32(0x218, InputState, inputs_current);
ValidateFieldOffset32(0x21C, InputState, inputs_previous);
ValidateFieldOffset32(0x220, InputState, inputs_held_26_frames);
ValidateFieldOffset32(0x224, InputState, inputs_rising_edge);
ValidateFieldOffset32(0x228, InputState, inputs_falling_edge);
ValidateFieldOffset32(0x22C, InputState, hardware_inputs_held_8_frames);
ValidateFieldOffset32(0x230, InputState, inputs_held_8_frames);
ValidateFieldOffset32(0x234, InputState, __device_type);
ValidateFieldOffset32(0x238, InputState, joypad_mapping);
ValidateFieldOffset32(0x24C, InputState, xinput_mapping);
ValidateFieldOffset32(0x260, InputState, keyboard_mapping);
ValidateStructSize32(0x274, InputState);
#pragma endregion


extern "C" {
    // 0x4CA210
    externcg InputState INPUT_STATES[3] cgasm("_INPUT_STATES");
}

// 0x42ABC0
dllexport gnu_noinline void __update_input0() asm_symbol_rel(0x42ABC0);
dllexport gnu_noinline void __update_input0() {
    INPUT_STATES[0].__update_input();
}

// 0x416B70
dllexport gnu_noinline BOOL stdcall __hardware_input0_pressed_or_held(uint32_t mask) asm_symbol_rel(0x416B70);
dllexport gnu_noinline BOOL stdcall __hardware_input0_pressed_or_held(uint32_t mask) {
    return INPUT_STATES[0].check_hardware_inputs_repeating(mask);
}

// size : 0x88
struct Config {
    int __dword_0; // 0x0
    InputMapping joypad_mapping; // 0x4
    InputMapping xinput_mapping; // 0x18
    InputMapping keyboard_mapping; // 0x2C
    int16_t deadzone_x; // 0x40
    int16_t deadzone_y; // 0x42
    uint8_t __ubyte_44; // 0x44
    uint8_t __ubyte_45; // 0x45
    uint8_t __ubyte_46; // 0x46
    uint8_t __ubyte_47; // 0x47
    uint8_t __ubyte_48; // 0x48
    uint8_t __ubyte_49; // 0x49
    int8_t __sbyte_4A; // 0x4A
    int8_t __sbyte_4B; // 0x4B
    char __byte_4C; // 0x4C
    char __byte_4D; // 0x4D
    uint8_t __ubyte_4E; // 0x4E
    unknown_fields(0x1); // 0x4F
    union {
        int32_t flags; // 0x50
        struct {
            int32_t __unknown_flag_B : 1; // 1
            int32_t reference_rasterizer : 1; // 2
            int32_t disable_fog : 1; // 3
            int32_t disable_direct_input : 1; // 4
            int32_t preload_bgm : 1; // 5
            int32_t disable_vsync : 1; // 6
            int32_t __disable_locale_detection : 1; // 7
            int32_t : 1; // 8
            int32_t __unknown_flag_A : 1; // 9
            int32_t __unknown_flag_C : 1; // 10
        };
    };
    int32_t window_x; // 0x54
    int32_t window_y; // 0x58
    unknown_fields(0x2C); // 0x5C
    
    inline void zero_contents() {
        zero_this();
    }
    
    // 0x444DD0
    dllexport gnu_noinline void initialize() asm_symbol_rel(0x444DD0) {
        this->zero_contents();
        this->__unknown_flag_A = true;
        this->__dword_0 = 0x180002;
        this->deadzone_x = 0x258;
        this->deadzone_y = 0x258;
        this->__ubyte_45 = 1;
        this->__ubyte_46 = 1;
        this->__ubyte_47 = 8;
        this->joypad_mapping = INPUT_STATES[0].joypad_mapping;
        this->xinput_mapping = INPUT_STATES[0].xinput_mapping;
        this->keyboard_mapping = INPUT_STATES[0].keyboard_mapping;
        this->__ubyte_49 = 2;
        this->__sbyte_4A = 0x64;
        this->__byte_4C = 0;
        this->__byte_4D = 2;
        this->__sbyte_4B = 50;
        this->window_x = INT32_MIN;
        this->window_y = INT32_MIN;
    }

    inline Config() {
        this->initialize();
    }
};
#pragma region // Config Validation
ValidateFieldOffset32(0x0, Config, __dword_0);
ValidateFieldOffset32(0x4, Config, joypad_mapping);
ValidateFieldOffset32(0x18, Config, xinput_mapping);
ValidateFieldOffset32(0x2C, Config, keyboard_mapping);
ValidateFieldOffset32(0x40, Config, deadzone_x);
ValidateFieldOffset32(0x42, Config, deadzone_y);
ValidateFieldOffset32(0x44, Config, __ubyte_44);
ValidateFieldOffset32(0x45, Config, __ubyte_45);
ValidateFieldOffset32(0x46, Config, __ubyte_46);
ValidateFieldOffset32(0x47, Config, __ubyte_47);
ValidateFieldOffset32(0x48, Config, __ubyte_48);
ValidateFieldOffset32(0x49, Config, __ubyte_49);
ValidateFieldOffset32(0x4A, Config, __sbyte_4A);
ValidateFieldOffset32(0x4B, Config, __sbyte_4B);
ValidateFieldOffset32(0x4C, Config, __byte_4C);
ValidateFieldOffset32(0x4D, Config, __byte_4D);
ValidateFieldOffset32(0x4E, Config, __ubyte_4E);
ValidateFieldOffset32(0x50, Config, flags);
ValidateFieldOffset32(0x54, Config, window_x);
ValidateFieldOffset32(0x58, Config, window_y);
ValidateStructSize32(0x88, Config);
#pragma endregion

// size: 0x10
struct ZUN_COLORVALUE {
    float b; // 0x0
    float g; // 0x4
    float r; // 0x8
    float a; // 0xC
    // 0x10
};

// size: 0x1C
struct StageSky {
    float begin_distance; // 0x0
    float end_distance; // 0x4
    ZUN_COLORVALUE color_components; // 0x8
    D3DCOLOR color; // 0x18
    // 0x1C

private:
    // 0x41F830
    dllexport gnu_noinline StageSky& add(StageSky& out, const StageSky& value) asm_symbol_rel(0x41F830) {
        out.begin_distance = this->begin_distance + value.begin_distance;
        out.begin_distance = this->begin_distance + value.end_distance;
        out.color_components.b = this->color_components.b + value.color_components.b;
        out.color_components.g = this->color_components.g + value.color_components.g;
        out.color_components.r = this->color_components.r + value.color_components.r;
        out.color_components.a = this->color_components.a + value.color_components.a;
        for (size_t i = 0; i < 4; ++i) {
            ((int8_t*)&out.color)[i] = ((float*)&out.color_components)[i];
        }
        return out;
    }
public:
    inline StageSky operator+(const StageSky& value) {
        StageSky dummy;
        return this->add(dummy, value);
    }

private:
    inline StageSky& sub(StageSky& out, const StageSky& value) {
        out.begin_distance = this->begin_distance - value.begin_distance;
        out.begin_distance = this->begin_distance - value.end_distance;
        out.color_components.b = this->color_components.b - value.color_components.b;
        out.color_components.g = this->color_components.g - value.color_components.g;
        out.color_components.r = this->color_components.r - value.color_components.r;
        out.color_components.a = this->color_components.a - value.color_components.a;
        for (size_t i = 0; i < 4; ++i) {
            ((int8_t*)&out.color)[i] = ((float*)&this->color_components)[i] - ((float*)&out.color_components)[i];
        }
        return out;
    }
public:
    inline StageSky operator-(const StageSky& value) {
        StageSky dummy;
        return this->sub(dummy, value);
    }

private:
    inline StageSky& mul(StageSky& out, const float value) {
        out.begin_distance = this->begin_distance * value;
        out.begin_distance = this->begin_distance * value;
        out.color_components.b = this->color_components.b * value;
        out.color_components.g = this->color_components.g * value;
        out.color_components.r = this->color_components.r * value;
        out.color_components.a = this->color_components.a * value;
        for (size_t i = 0; i < 4; ++i) {
            ((int8_t*)&out.color)[i] = ((float*)&this->color_components)[i] * value;
        }
        return out;
    }
public:
    inline StageSky operator*(const float value) {
        StageSky dummy;
        return this->mul(dummy, value);
    }
};
#pragma region // StageSky Validation
ValidateFieldOffset32(0x0, StageSky, begin_distance);
ValidateFieldOffset32(0x4, StageSky, end_distance);
ValidateFieldOffset32(0x8, StageSky, color_components);
ValidateFieldOffset32(0x18, StageSky, color);
ValidateStructSize32(0x1C, StageSky);
#pragma endregion

// size: 0x164
struct StageCamera {
    Float3 position; // 0x0
    Float3 facing; // 0xC
    Float3 rotation; // 0x18
    Float3 facing_normalized; // 0x24
    Float3 __float3_30; // 0x30
    Float3 __shaking_float3_A; // 0x3C
    Float3 __shaking_float3_B; // 0x48
    float fov; // 0x54
    Int2 window_resolution; // 0x58
    D3DMATRIXZ view_matrix; // 0x60
    D3DMATRIXZ projection_matrix; // 0xA0
    D3DVIEWPORT9 viewport; // 0xE0
    int32_t camera_index; // 0xF8
    Float2 __float2_FC; // 0xFC
    Int2 __int2_104; // 0x104
    D3DVIEWPORT9 __viewport_10C; // 0x10C
    D3DVIEWPORT9 __viewport_124; // 0x124
    Float3 __float3_13C; // 0x13C
    StageSky sky; // 0x148
    // 0x164

    inline void __copy_float2_FC_to_anm_manager();

    inline D3DRECT get_viewport_d3d_rect() {
        int32_t X = this->viewport.X;
        int32_t W = this->viewport.Width;
        int32_t Y = this->viewport.Y;
        int32_t H = this->viewport.Height;
        return {
            X, Y,
            X + W, Y + H
        };
    }

    inline Float2 get_viewport_position() {
        return {
            this->viewport.X,
            this->viewport.Y
        };
    }

    inline Float2 get_viewport_size() {
        return {
            this->viewport.Width,
            this->viewport.Height
        };
    }
};
#pragma region // StageCamera Validation
ValidateFieldOffset32(0x0, StageCamera, position);
ValidateFieldOffset32(0xC, StageCamera, facing);
ValidateFieldOffset32(0x18, StageCamera, rotation);
ValidateFieldOffset32(0x24, StageCamera, facing_normalized);
ValidateFieldOffset32(0x30, StageCamera, __float3_30);
ValidateFieldOffset32(0x3C, StageCamera, __shaking_float3_A);
ValidateFieldOffset32(0x48, StageCamera, __shaking_float3_B);
ValidateFieldOffset32(0x54, StageCamera, fov);
ValidateFieldOffset32(0x58, StageCamera, window_resolution);
ValidateFieldOffset32(0x60, StageCamera, view_matrix);
ValidateFieldOffset32(0xA0, StageCamera, projection_matrix);
ValidateFieldOffset32(0xE0, StageCamera, viewport);
ValidateFieldOffset32(0xF8, StageCamera, camera_index);
ValidateFieldOffset32(0xFC, StageCamera, __float2_FC);
ValidateFieldOffset32(0x104, StageCamera, __int2_104);
ValidateFieldOffset32(0x10C, StageCamera, __viewport_10C);
ValidateFieldOffset32(0x124, StageCamera, __viewport_124);
ValidateFieldOffset32(0x13C, StageCamera, __float3_13C);
ValidateFieldOffset32(0x148, StageCamera, sky);
ValidateStructSize32(0x164, StageCamera);
#pragma endregion

// size: 0x124
struct ScreenshotManager {
    BITMAPFILEHEADER bmp_header; // 0x0
    padding_bytes(0x2); // 0xE
    LPBITMAPINFOHEADER info_header; // 0x10
    unknown_fields(0x8); // 0x14
    int32_t __int_1C; // 0x1C
    char filename[MAX_PATH]; // 0x20
};
#pragma region // ScreenshotManager Validation
ValidateFieldOffset32(0x0, ScreenshotManager, bmp_header);
ValidateFieldOffset32(0x10, ScreenshotManager, info_header);
ValidateFieldOffset32(0x1C, ScreenshotManager, __int_1C);
ValidateFieldOffset32(0x20, ScreenshotManager, filename);
ValidateStructSize32(0x124, ScreenshotManager);
#pragma endregion

typedef struct AnmVM AnmVM;
typedef struct AnmLoaded AnmLoaded;

// size: 0x1C
struct ZUNThread {
    //void* vtable; // 0x0
    HANDLE thread; // 0x4
    uint32_t tid; // 0x8
    BOOL __bool_C; // 0xC
    BOOL __bool_10; // 0x10
    HMODULE* phModule; // 0x14
    _beginthreadex_proc_type start_func; // 0x18
    // 0x1C

    // 0x402B30
    // Might be destructor?
    dllexport gnu_noinline void stop_and_cleanup() asm_symbol_rel(0x402B30) {
        if (HANDLE thread_handle = this->thread) {
            this->__bool_C = true;
            this->__bool_10 = false;
            if (WaitForSingleObject(thread_handle, 200) == WAIT_TIMEOUT) {
                do {
                    this->__bool_C = true;
                    this->__bool_10 = false;
                    Sleep(1);
                } while (WaitForSingleObject(this->thread, 200) == WAIT_TIMEOUT);
            }
            CloseHandle(this->thread);
            this->thread = NULL;
            this->start_func = NULL;
        }
    }

    // 0x402BB0
    dllexport gnu_noinline void start(_beginthreadex_proc_type func, void* arg_list) asm_symbol_rel(0x402BB0) {
        this->stop_and_cleanup();
        this->start_func = func;
        this->__bool_10 = true;
        this->__bool_C = false;
        this->thread = (HANDLE)_beginthreadex(NULL, 0, func, arg_list, 0, &this->tid);
    }

    virtual ~ZUNThread() {
        this->stop_and_cleanup();
    }
};
#pragma region // ZUNThread Validation
//ValidateVirtualFieldOffset32(0x0, ZUNThread, vtable);
ValidateVirtualFieldOffset32(0x4, ZUNThread, thread);
ValidateVirtualFieldOffset32(0x8, ZUNThread, tid);
ValidateVirtualFieldOffset32(0xC, ZUNThread, __bool_C);
ValidateVirtualFieldOffset32(0x10, ZUNThread, __bool_10);
ValidateVirtualFieldOffset32(0x14, ZUNThread, phModule);
ValidateVirtualFieldOffset32(0x18, ZUNThread, start_func);
ValidateStructSize32(0x1C, ZUNThread);
#pragma endregion

// Couldn't figure out how to get the constructor right otherwise...
struct ZUNThreadB : ZUNThread {
    inline ZUNThreadB() {
        this->thread = NULL;
        this->tid = 0;
        this->__bool_C = FALSE;
        this->__bool_10 = FALSE;
    }
};

// size: 0x58
struct D3DThread : ZUNThread {
    unknown_fields(0x3C); // 0x1C
    // 0x58

    // 0x46FDD0
    virtual ~D3DThread() {

    }
};
#pragma region // D3DThread Validation
ValidateStructSize32(0x58, D3DThread);
#pragma endregion

extern "C" {
    // 0x4CD950
    externcg D3DThread D3D_THREAD_A cgasm("_D3D_THREAD_A");
    // 0x4CDAE0
    externcg ZUNThread UNKNOWN_THREAD_A cgasm("_UNKNOWN_THREAD_A");
}

// size: 0xC
struct ZUNTask {
    union {
        uint32_t task_flags; // 0x0
        struct {
            uint32_t : 1;
            uint32_t __unknown_task_flag_A : 1;
        };
    };
    UpdateFunc* on_tick_func; // 0x4
    UpdateFunc* on_draw_func; // 0x8
    // 0xC

    inline void enable_tick_unsafe() {
        this->on_tick_func->run_on_update = true;
    }

    inline void enable_draw_unsafe() {
        this->on_draw_func->run_on_update = true;
    }

    inline void enable_funcs_unsafe() {
        this->enable_tick_unsafe();
        this->enable_draw_unsafe();
    }

    inline void disable_tick() {
        if (UpdateFunc* on_tick = this->on_tick_func) {
            on_tick->run_on_update = false;
        }
    }

    inline void disable_draw() {
        if (UpdateFunc* on_draw = this->on_draw_func) {
            on_draw->run_on_update = false;
        }
    }

    inline void enable_tick() {
        if (UpdateFunc* on_tick = this->on_tick_func) {
            on_tick->run_on_update = true;
        }
    }

    inline void enable_draw() {
        if (UpdateFunc* on_draw = this->on_draw_func) {
            on_draw->run_on_update = true;
        }
    }

    // 0x42A9A0
    dllexport void enable_funcs() {
        this->enable_tick();
        this->enable_draw();
    }

    inline void disable_funcs() {
        this->disable_tick();
        this->disable_draw();
    }

    inline BOOL on_tick_enabled() {
        UpdateFunc* on_tick = this->on_tick_func;
        if (on_tick && on_tick->run_on_update) {
            return TRUE;
        }
        return FALSE;
    }

    inline BOOL on_draw_enabled() {
        UpdateFunc* on_draw = this->on_draw_func;
        if (on_draw && on_draw->run_on_update) {
            return TRUE;
        }
        return FALSE;
    }
};

extern "C" {
    // 0x57095C
    externcg size_t JOYPAD_INDEX cgasm("_JOYPAD_INDEX");
}

static constexpr LONG JOYPAD_MIN_RANGE = -1000;
static constexpr LONG JOYPAD_MAX_RANGE = 1000;

typedef struct FpsCounter FpsCounter;
typedef struct TickCounter TickCounter;

extern "C" {
    // 0x4CF2DC
    externcg FpsCounter* FPS_COUNTER_PTR cgasm("_FPS_COUNTER_PTR");
    // 0x507644
    externcg TickCounter* TICK_COUNTER_PTR cgasm("_TICK_COUNTER_PTR");
}

// size: 0x38
struct FpsCounter : ZUNTask {
    //ZUNTask base; // 0x0
    int __dword_C; // 0xC
    unknown_fields(0x10); // 0x10
    double __double_20; // 0x20
    double __double_28; // 0x28
    float __fps; // 0x30
    unknown_fields(0x4); // 0x34
    // 0x38

    inline void zero_contents() {
        zero_this();
    }

    inline FpsCounter() {
        this->zero_contents();
        this->__unknown_task_flag_A = true;
    }

    // 0x43A2D0
    dllexport gnu_noinline ~FpsCounter() {
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);
        FPS_COUNTER_PTR = NULL;
    }

    inline void reset() {
        this->__double_20 = 0.0;
        this->__double_28 = 0.0;
    }

    inline float calc_slowdown_rate() {
        return 100.0f - (float)(this->__double_20 / this->__double_28) * 100.0f;
    }

    // 0x43A340
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw(void* ptr) asm_symbol_rel(0x43A340);

    inline ZUNResult initialize() {
        UpdateFunc* update_func = new UpdateFunc(&on_draw, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 82);
        this->on_draw_func = update_func;

        return ZUN_SUCCESS;
    }

    static inline FpsCounter* allocate() {
        FpsCounter* fps_counter = new FpsCounter();
        FPS_COUNTER_PTR = fps_counter;
        if (ZUN_FAILED(fps_counter->initialize())) {
            delete fps_counter;
            return NULL;
        }
        return fps_counter;
    }
};

// size: 0x10
struct TickCounter : ZUNTask {
    // ZUNTask base; // 0x0
    size_t ticks; // 0xC
    // 0x10

    inline void zero_contents() {
        zero_this_inline();
    }

    inline TickCounter() {
        this->zero_contents();
        this->__unknown_task_flag_A = true;
    }

    // 0x475310
    dllexport gnu_noinline ~TickCounter() {
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
        TICK_COUNTER_PTR = NULL;
    }

    // 0x475440
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_tick(void* ptr) asm_symbol_rel(0x475440) {
        ((TickCounter*)ptr)->ticks++;
        return UpdateFuncNext;
    }

    inline ZUNResult initialize() {
        UpdateFunc* update_func = new UpdateFunc(&on_tick, true, this);
        UpdateFuncRegistry::register_on_tick(update_func, 2);
        this->on_tick_func = update_func;

        return ZUN_SUCCESS;
    }

    static inline TickCounter* allocate() {
        TickCounter* tick_counter = new TickCounter;
        TICK_COUNTER_PTR = tick_counter;
        if (ZUN_FAILED(tick_counter->initialize())) {
            delete tick_counter;
            return NULL;
        }
        return tick_counter;
    }
};
#pragma region // TickCounter Validation
ValidateFieldOffset32(0x0, TickCounter, task_flags);
ValidateFieldOffset32(0x4, TickCounter, on_tick_func);
ValidateFieldOffset32(0x8, TickCounter, on_draw_func);
ValidateFieldOffset32(0xC, TickCounter, ticks);
ValidateStructSize32(0x10, TickCounter);
#pragma endregion

static inline constexpr size_t msg_variant_count = 4;

// size: 0x28
struct StageDataInner {
    int32_t __spell_anm_indexA; // 0x0 (0x34)
    int32_t __spell_anm_scriptA; // 0x4 (0x38)
    int32_t __spell_flag_state; // 0x8 (0x3C)
    int32_t __spell_anm_indexB; // 0xC (0x40)
    int32_t __spell_anm_scriptB; // 0x10 (0x44)
    int32_t __intro_anm_index; // 0x14 (0x48)
    int32_t __intro_anm_script; // 0x18 (0x4C)
    int32_t __portrait_anm_file_index; // 0x1C (0x50)
    int32_t __portrait_anm_script; // 0x20 (0x54)
    int32_t __anm_script_24; // 0x24 (0x58)
    // 0x28
};

// size: 0xD4
struct StageData {
    int32_t stage_number; // 0x0
    const char* std_filename; // 0x4
    const char* ecl_filename; // 0x8
    const char* __string_array_C[2]; // 0xC
    const char* msg_filenames[msg_variant_count]; // 0x14
    const char* logo_anm_filename; // 0x24
    unknown_fields(0x4); // 0x28
    int32_t music_index; // 0x2C
    unknown_fields(0x4); // 0x30
    StageDataInner innner[1]; // 0x34 this may actually be shifted up by 1 dword

    int32_t __anm_file_index_78; // 0x78
    int32_t __anm_script_7C; // 0x7C
    int32_t __anm_script_80; // 0x80
    // 0x84
};


static inline constexpr int32_t STAGE_COUNT = 8;

extern "C" {
    // 0x4C9410
    externcg StageData STAGE_DATA[STAGE_COUNT] cgasm("_STAGE_DATA");
    // 0x4CF428
    externcg StageData* STAGE_DATA_PTR cgasm("_STAGE_DATA_PTR");
}

typedef struct AnmManager AnmManager;

#define ANM_FULL_ID_BITS (32)
#define ANM_FAST_ID_BITS (15)
#define ANM_SLOW_ID_BITS (ANM_FULL_ID_BITS - ANM_FAST_ID_BITS)
#define INVALID_FAST_ID uint_width_max(ANM_FAST_ID_BITS)

// size: 0x4
union AnmID {
    uint32_t full;
    struct {
        uint32_t fast_id : ANM_FAST_ID_BITS;
        uint32_t slow_id : ANM_SLOW_ID_BITS;
    };

    inline constexpr AnmID() : full(0) {}

    inline constexpr AnmID(const AnmID& id) : full(id.full) {}

    template<typename T> requires(std::is_integral_v<T>)
    inline constexpr AnmID(const T& raw) : full(raw) {}

    // 0x488E30
    dllexport AnmVM* get_vm_ptr() asm_symbol_rel(0x488E30);

    inline int32_t run_vm();

    // 0x488E50
    dllexport void interrupt_tree(int32_t interrupt_index) asm_symbol_rel(0x488E50);

    inline void interrupt_and_run_tree(int32_t interrupt_index);

    inline void interrupt_and_orphan_tree(int32_t interrupt_index) {
        this->interrupt_tree(interrupt_index);
        *this = 0;
    }

    // 0x488E70
    dllexport void __tree_set_visible2() asm_symbol_rel(0x488E70);

    inline void __tree_set_visible2(AnmManager* anm_manager);

    // 0x488EB0
    dllexport void __tree_clear_visible2() asm_symbol_rel(0x488EB0);

    // 0x488F50
    dllexport void mark_tree_for_delete() asm_symbol_rel(0x488F50);

    inline void mark_tree_for_delete(AnmManager* anm_manager);

    inline void set_position(Float3* position);

    // 0x488F70
    dllexport void thiscall set_controller_position(Float3* position) asm_symbol_rel(0x488F70);

    // 0x488FD0
    dllexport void thiscall __sub_488FD0(int32_t script) asm_symbol_rel(0x488FD0);

    // 0x4892F0
    dllexport void thiscall set_color1(D3DCOLOR color) asm_symbol_rel(0x4892F0);

    // 0x489230
    dllexport gnu_noinline AnmVM* thiscall __wtf_child_list_jank_A(int32_t script, uint32_t arg2) asm_symbol_rel(0x489230);

    inline constexpr operator uint32_t() const {
        return this->full;
    }
    template<typename T> requires(std::is_integral_v<T>)
    inline constexpr AnmID& operator=(const T& raw) {
        this->full = raw;
        return *this;
    }

    AnmID thiscall __sub_489140();
};
#pragma region // AnmID Validation
ValidateFieldOffset32(0x0, AnmID, full);
ValidateStructSize32(0x4, AnmID);
#pragma endregion

extern "C" {
    // 0x4C5F90
    externcg int32_t ACHIEVEMENT_MODE_STATE cgasm("_ACHIEVEMENT_MODE_STATE");
    // 0x4CF3FC
    externcg void (*UNKNOWN_FUNC_PTR_B)() cgasm("_UNKNOWN_FUNC_PTR_B");
    // 0x4CF400
    externcg void (*UNKNOWN_FUNC_PTR_A)() cgasm("_UNKNOWN_FUNC_PTR_A");

    // 0x5217D0
    externcg AnmID UNKNOWN_ANM_ID_A cgasm("_UNKNOWN_ANM_ID_A");
    // 0x5217D4
    externcg AnmID UNKNOWN_ANM_ID_B cgasm("_UNKNOWN_ANM_ID_B");
    // 0x5217D8
    externcg AnmID UNKNOWN_ANM_ID_C cgasm("_UNKNOWN_ANM_ID_C");
}

typedef struct LoadingThread LoadingThread;

// size: 0xB60
struct Supervisor {
    HINSTANCE current_instance; // 0x0
    LPDIRECT3D9 d3d; // 0x4
    LPDIRECT3DDEVICE9 d3d_device; // 0x8
    LPDIRECTINPUT8 dinput; // 0xC
    RECT window_rect; // 0x10
    LPDIRECTINPUTDEVICE8 keyboard_device; // 0x20;
    LPDIRECTINPUTDEVICE8 joypad_devices[1]; // 0x24;
    unknown_fields(0x4); // 0x28
    DIDEVCAPS __joypad_caps; // 0x2C
    HWND main_window_handle; // 0x58
    D3DMATRIXZ __view_matrix_5C; // 0x5C
    D3DMATRIXZ __projection_matrix_9C; // 0x9C
    D3DVIEWPORT9 __viewport_DC; // 0xDC
    D3DPRESENT_PARAMETERS present_parameters; // 0xF4
    unknown_fields(0x70); // 0x12C
    D3DDISPLAYMODE display_mode; // 0x19C
    LPDIRECT3DSURFACE9 __surface_1AC; // 0x1AC
    LPDIRECT3DSURFACE9 __surface_1B0; // 0x1B0
    LPDIRECT3DSURFACE9 back_buffer; // 0x1B4
    unknown_fields(0x4); // 0x1B8
    AnmVM* __arcade_vm_ptr_A; // 0x1BC
    AnmVM* __arcade_vm_ptr_B; // 0x1C0
    AnmVM* __arcade_vm_ptr_C; // 0x1C4
    AnmVM* __arcade_vm_ptr_D; // 0x1C8
    unknown_fields(0x4); // 0x1CC
    AnmID __vm_id_1D0; // 0x1D0
    Config config; // 0x1D4
    StageCamera cameras[4]; // 0x25C
    StageCamera* current_camera_ptr; // 0x7EC
    int32_t current_camera_index; // 0x7F0
    int32_t gamemode_current; // 0x7F4
    int32_t gamemode_switch; // 0x7F8
    int32_t gamemode_previous; // 0x7FC
    int __dword_800; // 0x800
    int32_t __int_804; // 0x804
    int __dword_808; // 0x808
    unknown_fields(0xC); // 0x80C
    int __int_818; // 0x818
    unknown_fields(0x4); // 0x81C
    BOOL disable_vsync; // 0x820
    int __dword_824; // 0x824
    int __dword_828; // 0x828
    AnmLoaded* text_anm; // 0x82C
    unknown_fields(0x4); // 0x830
    union {
        uint32_t flags; // 0x834
        struct {
            uint32_t __unknown_flag_D : 1; // 1
            uint32_t __unknown_flag_C : 1; // 2
            uint32_t __unknown_flag_E : 1; // 3
            uint32_t : 1; // 4
            uint32_t __unknown_flag_F : 1; // 5
            uint32_t : 1; // 6
            uint32_t __unknown_flag_A : 1; // 7
            uint32_t __unknown_bitfield_A : 2; // 8-9
            uint32_t : 2; // 10-11
            uint32_t __unknown_flag_G : 1; // 12
            uint32_t : 1; // 13
            uint32_t __unknown_flag_B : 1; // 14
        };
    };
    uint32_t initial_rng_seed; // 0x838
    unknown_fields(0x4); // 0x83C
    D3DCAPS9 d3dcaps; // 0x840
    ScreenshotManager screenshot_manager; // 0x970
    ZUNThread __thread_A94; // 0xA94
    ZUNThread __thread_AB0; // 0xAB0
    int __int_ACC; // 0xACC
    int32_t __int_AD0; // 0xAD0
    unknown_fields(0x54); // 0xAD4
    BOOL fog_enabled; // 0xB28
    BOOL zwrite_enabled; // 0xB2C
    int32_t game_exe_checksum; // 0xB30
    int32_t game_exe_file_size; // 0xB34
    int32_t ver_file_size; // 0xB38
    void* ver_file_buffer; // 0xB3C
    LoadingThread* __loading_thread_B40; // 0xB40
    unknown_fields(0xC); // 0xB44
    double __double_B50; // 0xB50
    D3DCOLOR background_color; // 0xB58
    probably_padding_bytes(0x4); // 0xB5C
    // 0xB60

    // 0x456180
    dllexport static gnu_noinline void __release_rendering_surfaces() asm_symbol_rel(0x456180);

    // 0x454950
    dllexport gnu_noinline int thiscall __sub_454950() asm_symbol_rel(0x454950);

    // 0x455040
    dllexport gnu_noinline UpdateFuncRet thiscall __sub_455040() asm_symbol_rel(0x455040);
    
    inline UpdateFuncRet thiscall on_tick();

    // 0x453460
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC on_tick(void* ptr) asm_symbol_rel(0x453460) {
        return ((Supervisor*)ptr)->on_tick();
    }

    // 0x4553B0
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC on_draw_A(void* ptr) asm_symbol_rel(0x4553B0);

    // 0x455610
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC on_draw_B(void* ptr) asm_symbol_rel(0x455610);

    // 0x455530
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC on_draw_arcade_vm_A(void* ptr) asm_symbol_rel(0x455530);

    // 0x455A70
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC on_draw_D(void* ptr) asm_symbol_rel(0x455A70);

    // 0x4559A0
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC on_draw_arcade_vm_B(void* ptr) asm_symbol_rel(0x4559A0);
    
    // 0x455BC0
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC on_draw_F(void* ptr) asm_symbol_rel(0x455BC0);

    // 0x455B10
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC on_draw_arcade_vm_C(void* ptr) asm_symbol_rel(0x455B10);

    // 0x455CF0
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC on_draw_H(void* ptr) asm_symbol_rel(0x455CF0);

    // 0x455C90
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC on_draw_arcade_vm_D(void* ptr) asm_symbol_rel(0x455C90);

    // 0x455D40
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC on_draw_J(void* ptr) asm_symbol_rel(0x455D40);

    // 0x453640
    dllexport static gnu_noinline ZUNResult UpdateFuncCC on_registration(void* self) asm_symbol_rel(0x453640);
    
    // 0x453DB0
    dllexport static gnu_noinline ZUNResult initialize() asm_symbol_rel(0x453DB0);

    // 0x4543A0
    dllexport gnu_noinline ZUNResult thiscall load_config_file(int) asm_symbol_rel(0x4543A0);

    // 0x454760
    dllexport HRESULT thiscall d3d_enable_fog() asm_symbol_rel(0x454760);

    // 0x4547A0
    dllexport HRESULT thiscall d3d_disable_fog() asm_symbol_rel(0x4547A0);

    // 0x4547E0
    dllexport HRESULT thiscall d3d_enable_zwrite() asm_symbol_rel(0x4547E0);

    // 0x454820
    dllexport HRESULT thiscall d3d_disable_zwrite() asm_symbol_rel(0x454820);

    inline HRESULT d3d_zfunc_always();

    inline HRESULT d3d_zfunc_lessequal();

private:
    // 0x454860
    dllexport static gnu_noinline int32_t stdcall __start_thread_A94(_beginthreadex_proc_type func, int) asm_symbol_rel(0x454860);
public:
    inline static int32_t __start_thread_A94(_beginthreadex_proc_type func) {
        return __start_thread_A94(func, UNUSED_DWORD);
    }

    // 0x455EC0
    dllexport gnu_noinline void thiscall __sub_455EC0() asm_symbol_rel(0x455EC0);

    // 0x453C70
    dllexport static gnu_noinline void thiscall __sub_453C70() asm_symbol_rel(0x453C70);

    // 0x453A70
    dllexport gnu_noinline void thiscall __sub_453A70() asm_symbol_rel(0x453A70);

    // 0x4548E0
    dllexport static gnu_noinline void stdcall __sub_4548E0(StageCamera* camera) asm_symbol_rel(0x4548E0);

    // 0x454950
    dllexport static gnu_noinline void stdcall __sub_454950(StageCamera* camera) asm_symbol_rel(0x454950) {
        uint32_t height = camera->viewport.Height;
        float x = (float)camera->viewport.X + (float)camera->viewport.Width * 0.5f;
        float viewport_height = (float)height;
        height /= 2;
        float y = (float)camera->viewport.Y + viewport_height * 0.5f;
        float eye_z = (float)height / ztanf(camera->fov * 0.5f);
        D3DXVECTOR3 eye;
        D3DXVECTOR3 at;
        D3DXVECTOR3 up;
        up.x = 0.0f;
        up.y = -1.0f;
        up.z = 0.0f;
        eye.z = eye_z;
        eye.x = x;
        eye.y = y;
        at.x = x;
        at.y = y;
        at.z = 0.0f;
        D3DXMatrixLookAtLH(&camera->view_matrix.D3DX(), &eye, &at, &up);
        float aspect = (float)camera->viewport.Width / (float)camera->viewport.Height;
        D3DXMatrixPerspectiveFovLH(&camera->projection_matrix.D3DX(), camera->fov, aspect, 1.0f, 10000.0f);
    }

    // 0x454B20
    dllexport gnu_noinline void thiscall __initialize_cameras() asm_symbol_rel(0x454B20);

    // 0x454F50
    dllexport static gnu_noinline void __camera2_sub_454F50() asm_symbol_rel(0x454F50);

    // 0x41B330
    dllexport void thiscall set_camera_by_index(uint32_t index) asm_symbol_rel(0x41B330);
    // 0x41B3B0
    dllexport static gnu_noinline void stdcall set_camera2_alt(uint32_t = UNUSED_DWORD) asm_symbol_rel(0x41B3B0);

    inline void thiscall set_camera_by_index_disable_fog(uint32_t index);
};
#pragma region // Supervisor Validation
ValidateFieldOffset32(0x0, Supervisor, current_instance);
ValidateFieldOffset32(0x4, Supervisor, d3d);
ValidateFieldOffset32(0x8, Supervisor, d3d_device);
ValidateFieldOffset32(0xC, Supervisor, dinput);
ValidateFieldOffset32(0x10, Supervisor, window_rect);
ValidateFieldOffset32(0x20, Supervisor, keyboard_device);
ValidateFieldOffset32(0x24, Supervisor, joypad_devices);
ValidateFieldOffset32(0x2C, Supervisor, __joypad_caps);
ValidateFieldOffset32(0x58, Supervisor, main_window_handle);
ValidateFieldOffset32(0x5C, Supervisor, __view_matrix_5C);
ValidateFieldOffset32(0x9C, Supervisor, __projection_matrix_9C);
ValidateFieldOffset32(0xDC, Supervisor, __viewport_DC);
ValidateFieldOffset32(0xF4, Supervisor, present_parameters);
ValidateFieldOffset32(0x19C, Supervisor, display_mode);
ValidateFieldOffset32(0x1AC, Supervisor, __surface_1AC);
ValidateFieldOffset32(0x1B0, Supervisor, __surface_1B0);
ValidateFieldOffset32(0x1B4, Supervisor, back_buffer);
ValidateFieldOffset32(0x1BC, Supervisor, __arcade_vm_ptr_A);
ValidateFieldOffset32(0x1C0, Supervisor, __arcade_vm_ptr_B);
ValidateFieldOffset32(0x1C4, Supervisor, __arcade_vm_ptr_C);
ValidateFieldOffset32(0x1C8, Supervisor, __arcade_vm_ptr_D);
ValidateFieldOffset32(0x1D0, Supervisor, __vm_id_1D0);
ValidateFieldOffset32(0x1D4, Supervisor, config);
ValidateFieldOffset32(0x25C, Supervisor, cameras);
ValidateFieldOffset32(0x7EC, Supervisor, current_camera_ptr);
ValidateFieldOffset32(0x7F0, Supervisor, current_camera_index);
ValidateFieldOffset32(0x7F4, Supervisor, gamemode_current);
ValidateFieldOffset32(0x7F8, Supervisor, gamemode_switch);
ValidateFieldOffset32(0x7FC, Supervisor, gamemode_previous);
ValidateFieldOffset32(0x800, Supervisor, __dword_800);
ValidateFieldOffset32(0x804, Supervisor, __int_804);
ValidateFieldOffset32(0x808, Supervisor, __dword_808);
ValidateFieldOffset32(0x818, Supervisor, __int_818);
ValidateFieldOffset32(0x820, Supervisor, disable_vsync);
ValidateFieldOffset32(0x824, Supervisor, __dword_824);
ValidateFieldOffset32(0x828, Supervisor, __dword_828);
ValidateFieldOffset32(0x82C, Supervisor, text_anm);
ValidateFieldOffset32(0x834, Supervisor, flags);
ValidateFieldOffset32(0x838, Supervisor, initial_rng_seed);
ValidateFieldOffset32(0x840, Supervisor, d3dcaps);
ValidateFieldOffset32(0x970, Supervisor, screenshot_manager);
ValidateFieldOffset32(0xA94, Supervisor, __thread_A94);
ValidateFieldOffset32(0xAB0, Supervisor, __thread_AB0);
ValidateFieldOffset32(0xACC, Supervisor, __int_ACC);
ValidateFieldOffset32(0xAD0, Supervisor, __int_AD0);
ValidateFieldOffset32(0xB28, Supervisor, fog_enabled);
ValidateFieldOffset32(0xB2C, Supervisor, zwrite_enabled);
ValidateFieldOffset32(0xB30, Supervisor, game_exe_checksum);
ValidateFieldOffset32(0xB34, Supervisor, game_exe_file_size);
ValidateFieldOffset32(0xB38, Supervisor, ver_file_size);
ValidateFieldOffset32(0xB3C, Supervisor, ver_file_buffer);
ValidateFieldOffset32(0xB40, Supervisor, __loading_thread_B40);
ValidateFieldOffset32(0xB50, Supervisor, __double_B50);
ValidateFieldOffset32(0xB58, Supervisor, background_color);
ValidateStructSize32(0xB60, Supervisor);
#pragma endregion

extern "C" {
    // 0x4CCDF0
    externcg Supervisor SUPERVISOR cgasm("_SUPERVISOR");
}

inline UpdateFuncRegistry::~UpdateFuncRegistry() {
    SUPERVISOR.__thread_A94.stop_and_cleanup();
    this->__dword_54 = 1;

    this->run_all_on_tick(); // this seems very bad

    this->on_tick_funcs.list_node.as_head().for_each_safeB([=](UpdateFunc* func) {
        this->delete_func_locked(func);
                                                           });
    this->on_draw_funcs.list_node.as_head().for_each_safeB([=](UpdateFunc* func) {
        this->delete_func_locked(func);
                                                           });
    this->on_draw_funcs.on_update_func = NULL;
    this->on_draw_funcs.on_init_func = NULL;
    this->on_draw_funcs.on_cleanup_func = NULL;
    this->on_tick_funcs.on_update_func = NULL;
    this->on_tick_funcs.on_init_func = NULL;
    this->on_tick_funcs.on_cleanup_func = NULL;
}

// 0x456180
dllexport gnu_noinline void Supervisor::__release_rendering_surfaces() {
    SAFE_RELEASE(SUPERVISOR.__surface_1AC);
    SAFE_RELEASE(SUPERVISOR.__surface_1B0);
    SAFE_RELEASE(SUPERVISOR.back_buffer);
    SUPERVISOR.__surface_1AC = NULL; // why tho
}

// 0x453DB0
dllexport gnu_noinline ZUNResult Supervisor::initialize() {
    SUPERVISOR.gamemode_current = -2;
    SUPERVISOR.gamemode_switch = 0;
    SUPERVISOR.__dword_800 = 0;
    UpdateFunc* update_func = new UpdateFunc(&Supervisor::on_tick, true, &SUPERVISOR);
    update_func->on_init_func = &Supervisor::on_registration;
    ZUNResult ret = UpdateFuncRegistry::register_on_tick(update_func, 1);
    if (ZUN_SUCCEEDED(ret)) {
        update_func = new UpdateFunc(&Supervisor::on_draw_A, true, &SUPERVISOR);
        UpdateFuncRegistry::register_on_draw(update_func, 1);
        update_func = new UpdateFunc(&Supervisor::on_draw_B, true, &SUPERVISOR);
        UpdateFuncRegistry::register_on_draw(update_func, 14);
        update_func = new UpdateFunc(&Supervisor::on_draw_arcade_vm_A, true, &SUPERVISOR);
        UpdateFuncRegistry::register_on_draw(update_func, 15);
        update_func = new UpdateFunc(&Supervisor::on_draw_D, true, &SUPERVISOR);
        UpdateFuncRegistry::register_on_draw(update_func, 25);
        update_func = new UpdateFunc(&Supervisor::on_draw_arcade_vm_B, true, &SUPERVISOR);
        UpdateFuncRegistry::register_on_draw(update_func, 26);
        update_func = new UpdateFunc(&Supervisor::on_draw_F, true, &SUPERVISOR);
        UpdateFuncRegistry::register_on_draw(update_func, 44);
        update_func = new UpdateFunc(&Supervisor::on_draw_arcade_vm_C, true, &SUPERVISOR);
        UpdateFuncRegistry::register_on_draw(update_func, 45);
        update_func = new UpdateFunc(&Supervisor::on_draw_H, true, &SUPERVISOR);
        UpdateFuncRegistry::register_on_draw(update_func, 58);
        update_func = new UpdateFunc(&Supervisor::on_draw_arcade_vm_D, true, &SUPERVISOR);
        UpdateFuncRegistry::register_on_draw(update_func, 59);
        update_func = new UpdateFunc(&Supervisor::on_draw_J, true, &SUPERVISOR);
        UpdateFuncRegistry::register_on_draw(update_func, 92);
        SUPERVISOR.d3d_device->GetBackBuffer(0, 0, D3DBACKBUFFER_TYPE_MONO, &SUPERVISOR.back_buffer);
        ret = ZUN_SUCCESS;
    }
    return ret;
}

// 0x454860
dllexport gnu_noinline int32_t Supervisor::__start_thread_A94(_beginthreadex_proc_type func, int) {
    CRITICAL_SECTION_MANAGER.enter_section(__supervisor_thread_cs_1);
    {
        clang_forceinline SUPERVISOR.__thread_A94.start(func, NULL);
    }
    CRITICAL_SECTION_MANAGER.leave_section(__supervisor_thread_cs_1);
    return 0;
}

#define SOUND_EFFECT_COUNT 84

// 0x4B47A0
static inline constexpr const char *const SOUND_EFFECT_FILENAMES[] = {
    "se_plst00.wav",
    "se_enep00.wav",
    "se_pldead00.wav",
    "se_power0.wav",
    "se_power1.wav",
    "se_tan00.wav",
    "se_tan01.wav",
    "se_tan02.wav",
    "se_ok00.wav",
    "se_cancel00.wav",
    "se_select00.wav",
    "se_gun00.wav",
    "se_cat00.wav",
    "se_lazer00.wav",
    "se_lazer01.wav",
    "se_enep01.wav",
    "se_damage00.wav",
    "se_item00.wav",
    "se_kira00.wav",
    "se_kira01.wav",
    "se_kira02.wav",
    "se_timeout.wav",
    "se_graze.wav",
    "se_powerup.wav",
    "se_pause.wav",
    "se_cardget.wav",
    "se_damage01.wav",
    "se_timeout2.wav",
    "se_invalid.wav",
    "se_slash.wav",
    "se_ch00.wav",
    "se_ch01.wav",
    "se_extend.wav",
    "se_cardget.wav", // Yes, this is a duplicate
    "se_nep00.wav",
    "se_bonus.wav",
    "se_bonus2.wav",
    "se_enep02.wav",
    "se_lazer02.wav",
    "se_nodamage.wav",
    "se_boon00.wav",
    "se_don00.wav",
    "se_boon01.wav",
    "se_ch02.wav",
    "se_ch03.wav",
    "se_extend2.wav",
    "se_pin00.wav",
    "se_pin01.wav",
    "se_lgods1.wav",
    "se_lgods2.wav",
    "se_lgods3.wav",
    "se_lgods4.wav",
    "se_lgodsget.wav",
    "se_msl.wav",
    "se_msl2.wav",
    "se_pldead01.wav",
    "se_heal.wav",
    "se_msl3.wav",
    "se_fault.wav",
    "se_noise.wav",
    "se_etbreak.wav",
    "se_tan03.wav",
    "se_wold.wav",
    "se_bonus4.wav",
    "se_big.wav",
    "se_item01.wav",
    "se_release.wav",
    "se_changeitem.wav",
    "se_trophy.wav",
    "se_warpl.wav",
    "se_warpr.wav",
    "se_notice.wav"
};

// size: 0x14
struct SoundData {
    int32_t id; // 0x0
    int32_t filename_index; // 0x4
    unknown_fields(0x2); // 0x8
    int16_t __short_A; // 0xA
    unknown_fields(0x8); // 0xC
};
#pragma region // SoundData Validation
ValidateFieldOffset32(0x0, SoundData, id);
ValidateFieldOffset32(0x4, SoundData, filename_index);
ValidateFieldOffset32(0xA, SoundData, __short_A);
ValidateStructSize32(0x14, SoundData);
#pragma endregion

// size: 0x34
struct ThBgmFormat {
    char filename[0x10]; // 0x0
    unknown_fields(0x4); // 0x10
    int __dword_14; // 0x14
    unknown_fields(0x1C); // 0x18
    // 0x34
};
#pragma region // ThBgmFormat Validation
ValidateFieldOffset32(0x0, ThBgmFormat, filename);
ValidateFieldOffset32(0x14, ThBgmFormat, __dword_14);
ValidateStructSize32(0x34, ThBgmFormat);
#pragma endregion

struct WavFileHeader {
    char riff_text[4]; // 0x0
    uint32_t remaining_file_size; // 0x4
    char wave_text[4]; // 0x8
};
struct WavFileChunk {
    char id[4]; // 0x0
    uint32_t size; // 0x4
    unsigned char data[]; // 0x8
};

// 0x476830
dllexport gnu_noinline unsigned char* vectorcall get_wav_chunk_data(WavFileChunk* chunk, const char* chunk_id, int32_t* remaining_size_ptr, int32_t remaining_size) asm_symbol_rel(0x476830);
dllexport gnu_noinline unsigned char* vectorcall get_wav_chunk_data(WavFileChunk* chunk, const char* chunk_id, int32_t* remaining_size_ptr, int32_t remaining_size) {
    while (remaining_size) {
        *remaining_size_ptr = chunk->size;
        if (strncmp(chunk->id, chunk_id, sizeof(chunk->id)) == 0) {
            return chunk->data;
        }
        int32_t chunk_size = *remaining_size_ptr;
        chunk = pointer_raw_offset(chunk, sizeof(WavFileChunk) + chunk_size);
        remaining_size -= sizeof(WavFileChunk) + chunk_size;
    }
    return NULL;
}

struct WavFile {
    WavFileHeader header; // 0x0
    WavFileChunk chunks[]; // 0xC
};

/*
struct MMCKINFO {
    FOURCC ckid; // 0x0
    DWORD cksize; // 0x4
    FOURCC fccType; // 0x8
    DWORD dwDataOffset; // 0xC
    DWORD dwFlags; // 0x10
    // 0x14
};

class CWaveFile {
    WAVEFORMATEX* m_pwfx; // 0x0
    HMMIO m_hmmio; // 0x4
    MMCKINFO m_ck; // 0x8
    MMCKINFO m_ckRiff; // 0x1C
    DWORD m_dwSize; // 0x30
    MMIOINFO m_mmioinfoOut; // 0x34
    DWORD m_dwFlags; // 0x48
    BOOL m_bIsReadingFromMemory; // 0x4C
    BYTE* m_pbData; // 0x50
    BYTE* m_pbDataCur; // 0x54
    ULONG m_ulDataSize; // 0x58
    CHAR* m_pResourceBuffer; // 0x5C
};
*/

struct SoundManagerUnknownA {

};

// size: 0x18
struct SoundManagerUnknownB {
    LPDIRECTSOUNDBUFFER sound_buffer; // 0x0
    int32_t __int_4; // 0x4
    SoundData* data; // 0x8
    int32_t __int_C; // 0xC
    int32_t __int_10; // 0x10
    int __dword_14; // 0x14
    // 0x18

    // 0x4776F0
    dllexport gnu_noinline ZUNResult thiscall __sub_4776F0(const char* filename) asm_symbol_rel(0x4776F0);
};
#pragma region // SoundManagerUnknownB Validation
ValidateFieldOffset32(0x0, SoundManagerUnknownB, sound_buffer);
ValidateFieldOffset32(0x4, SoundManagerUnknownB, __int_4);
ValidateFieldOffset32(0x8, SoundManagerUnknownB, data);
ValidateFieldOffset32(0xC, SoundManagerUnknownB, __int_C);
ValidateFieldOffset32(0x10, SoundManagerUnknownB, __int_10);
ValidateFieldOffset32(0x14, SoundManagerUnknownB, __dword_14);
ValidateStructSize32(0x18, SoundManagerUnknownB);
#pragma endregion

// size: 0x10C
struct SoundManagerUnknownD {
    int __dword_0; // 0x0
    unknown_fields(0x108); // 0x4
    // 0x10C
};
#pragma region // SoundManagerUnknownD Validation
ValidateFieldOffset32(0x0, SoundManagerUnknownD, __dword_0);
ValidateStructSize32(0x10C, SoundManagerUnknownD);
#pragma endregion

struct SoundManagerUnknownG {
    unknown_fields(0x78); // 0x0
    int __dword_78; // 0x78
    unknown_fields(0x10); // 0x7C
    HANDLE __handle_8C; // 0x8C
    // 0x90
};
#pragma region // SoundManagerUnknownG Validation
ValidateFieldOffset32(0x78, SoundManagerUnknownG, __dword_78);
ValidateFieldOffset32(0x8C, SoundManagerUnknownG, __handle_8C);
#pragma endregion

// This seems to be another part of CSound that isn't in my version of it...
struct SoundManagerUnknownE {

    // vtable ptr
    unknown_fields(0x4); // 0x4
    LPDIRECTSOUNDBUFFER* sound_buffer_array; // 0x8
    unknown_fields(0x4); // 0xC
    SoundManagerUnknownG* __smg_ptr_10; // 0x10
    uint32_t sound_buffer_count; // 0x14
    unknown_fields(0x8); // 0x18
    int __dword_20; // 0x20
    unknown_fields(0x34); // 0x24
    int __dword_58; // 0x58
    int __dword_5C; // 0x5C
    // 0x60

    // 0x48A620
    dllexport gnu_noinline HRESULT thiscall __sub_48A620(BOOL Arg1) asm_symbol_rel(0x48A620) {
        if (!this->sound_buffer_array) {
            return CO_E_NOTINITIALIZED;
        }
        this->__dword_58 = 0;
        this->__dword_5C = 0;
        HRESULT ret = 0;
        for (size_t i = 0; i < this->sound_buffer_count; ++i) {
            ret |= this->sound_buffer_array[i]->Stop();
            ret |= this->sound_buffer_array[i]->SetCurrentPosition(0);
        }
        this->__dword_20 = 0;
        if (Arg1) {
            SoundManagerUnknownG* smg_ptr = this->__smg_ptr_10;
            if (smg_ptr->__dword_78 == 1) {
                CloseHandle(smg_ptr->__handle_8C);
                smg_ptr->__handle_8C = INVALID_HANDLE_VALUE;
            }
        }
        return ret;
    }

    // 0x48AF10
    dllexport gnu_noinline void vectorcall __sub_48AF10(double arg1) asm_symbol_rel(0x48AF10) {
        use_var(arg1);
    }

    // This is giga jank
    virtual ~SoundManagerUnknownE() {}
};
#pragma region // SoundManagerUnknownE Validation
ValidateVirtualFieldOffset32(0x8, SoundManagerUnknownE, sound_buffer_array);
ValidateVirtualFieldOffset32(0x10, SoundManagerUnknownE, __smg_ptr_10);
ValidateVirtualFieldOffset32(0x14, SoundManagerUnknownE, sound_buffer_count);
ValidateVirtualFieldOffset32(0x20, SoundManagerUnknownE, __dword_20);
ValidateVirtualFieldOffset32(0x58, SoundManagerUnknownE, __dword_58);
ValidateVirtualFieldOffset32(0x5C, SoundManagerUnknownE, __dword_5C);
#pragma endregion

// size: 0x200
struct SoundManagerUnknownF {
    int32_t __int_array_0[60]; // 0x0
    unknown_fields(0x110); // 0xF0
};
#pragma region // SoundManagerUnknownF Validation
ValidateFieldOffset32(0x0, SoundManagerUnknownF, __int_array_0);
ValidateStructSize32(0x200, SoundManagerUnknownF);
#pragma endregion

extern "C" {
    // 0x4C9B80
    externcg SoundData SOUND_DATA[SOUND_EFFECT_COUNT] cgasm("_SOUND_DATA");
}

typedef struct SoundManager SoundManager;

static inline constexpr size_t MAX_ACTIVE_SOUNDS = 12;

// size: 0x573C
struct SoundManager {
    LPDIRECTSOUND8 dsound; // 0x0
    LPDIRECTSOUNDBUFFER sound_buffer_ptr; // 0x4
    HWND timer_hwnd; // 0x8
    CSoundManager* csound_manager_ptr; // 0xC
    DWORD sound_thread_id; // 0x10
    HANDLE __handle_14; // 0x14
    unknown_fields(0x4); // 0x18
    int32_t active_sound_ids[MAX_ACTIVE_SOUNDS]; // 0x1C
    int32_t active_sound_id_counts[MAX_ACTIVE_SOUNDS]; // 0x4C
    SoundManagerUnknownF __unknown_smf_array_7C[MAX_ACTIVE_SOUNDS]; // 0x7C
    void* bgm_format_offsets[16]; // 0x187C
    SoundManagerUnknownA* __unknown_sma_ptr_array_18BC[16]; // 0x18BC
    SoundManagerUnknownA* __unknown_sma_ptr_array_18FC[16]; // 0x18FC
    int __bgm_format_14_array_193C[16]; // 0x193C
    int __dword_197C; // 0x197C
    union {
        void* bgm_format_file; // 0x1980
        ThBgmFormat* bgm_formats;
    };
    char __text_buffer_1984[0x100]; // 0x1984
    SoundManagerUnknownB __unknown_smb_array_1A84[SOUND_EFFECT_COUNT]; // 0x1A84
    void* sound_effect_files[countof(SOUND_EFFECT_FILENAMES)]; // 0x2264
    char __text_buffer_2384[0x100]; // 0x2384
    SoundManagerUnknownD __unknown_smd_array_2484[32]; // 0x2484 (only 31 are used properly)
    char __text_buffer_array_4604[16][0x100]; // 0x4604
    char thbgm_filename[0x100]; // 0x5604
    SoundManagerUnknownE* __unknown_sme_ptr_5704; // 0x5704
    unknown_fields(0x4); // 0x5708
    HANDLE __handle_570C; // 0x570C
    unknown_fields(0x4); // 0x5710
    int32_t file_pointer_offset; // 0x5714
    HANDLE __thread_5718; // 0x5718
    HANDLE __handle_571C; // 0x571C
    DWORD __thread_id_5720; // 0x5720
    int __dword_5724; // 0x5724
    HWND main_window_hwnd; // 0x5728
    int __dword_572C; // 0x572C
    int32_t __int_5730; // 0x5730
    int32_t __int_5734; // 0x5734
    int __dword_5738; // 0x5738
    // 0x573C

    inline void zero_contents() {
        zero_this();
    }

    inline void copy_sound_data() {
        SoundManagerUnknownB* unknown_b_ptr = this->__unknown_smb_array_1A84;
        for (size_t i = 0; i < countof(this->__unknown_smb_array_1A84); ++unknown_b_ptr, ++i) {
            unknown_b_ptr->__int_4 = -1;
            SoundData* sound_data = SOUND_DATA;
            while (sound_data->id != i) ++sound_data;
            unknown_b_ptr->__int_C = i;
            unknown_b_ptr->data = sound_data;
        }
    }

    inline void free_bgm_format_file() {
        SAFE_FREE_FAST(this->bgm_format_file);
    }

    inline void release_smb_array() {
        SoundManagerUnknownB* smb_ptr = this->__unknown_smb_array_1A84;
        for (size_t i = 0; i < countof(this->__unknown_smb_array_1A84); ++smb_ptr, ++i) {
            SAFE_RELEASE(smb_ptr->sound_buffer);
        }
    }

    inline void free_all_sound_effect_files() {
        void** sound_file_pointer = this->sound_effect_files;
        for (size_t i = 0; i < countof(this->sound_effect_files); ++sound_file_pointer, ++i) {
            SAFE_FREE_FAST(*sound_file_pointer);
        }
    }

    inline void free_first_sma_array() {
        SoundManagerUnknownA** sma_ptr = this->__unknown_sma_ptr_array_18BC;
        for (size_t i = 0; i < countof(this->__unknown_sma_ptr_array_18BC); ++sma_ptr, ++i) {
            SAFE_FREE_FAST(*sma_ptr);
        }
    }

    SoundManager() {
        this->copy_sound_data();
    }

    // 0x476320
    dllexport static gnu_noinline int32_t __wait_and_close_handles() asm_symbol_rel(0x476320);

    // 0x4763D0
    dllexport static gnu_noinline DWORD WINAPI sound_thread_func(void* self) asm_symbol_rel(0x4763D0);

    // 0x476410
    dllexport gnu_noinline ZUNResult thiscall __sub_476410(HWND window_hwnd_arg) asm_symbol_rel(0x476410);

    // 0x4767B0
    dllexport static gnu_noinline DWORD WINAPI load_sound_effects(void* self) asm_symbol_rel(0x4767B0);
    
    // 0x476890
    dllexport gnu_noinline int32_t thiscall __sub_476890(const char* filename) asm_symbol_rel(0x476890) {
        char buffer[128];
        const char* path;
        if (!(path = strrchr(filename, '/')) && !(path = strrchr(filename, '\\'))) {
            byteloop_strcpy(buffer, filename);
        } else {
            byteloop_strcpy(buffer, path + 1);
        }
        ThBgmFormat* bgm_formats = this->bgm_formats;
        size_t i = 0;
        while (bgm_formats[i].filename[0] != '\0') {
            if (strcmp_asm(bgm_formats[i].filename, buffer)) {
                break;
            }
            ++i;
        }
        return bgm_formats[i].filename[0] ? i : 0;
    }
    
    // 0x476B40
    dllexport gnu_noinline void thiscall __sub_476B40() asm_symbol_rel(0x476B40);

    // 0x476BE0
    dllexport static gnu_noinline void stdcall play_sound_centered(int32_t sound_id, float) asm_symbol_rel(0x476BE0);

    // 0x476C70
    dllexport static gnu_noinline void vectorcall play_sound_positioned(int32_t sound_id, float position) asm_symbol_rel(0x476C70);

    static inline void stop_sound(int32_t sound_id);

    // 0x444D80
    dllexport static gnu_noinline void __stop_all() asm_symbol_rel(0x444D80);

    static inline void play_sound(int32_t sound_id) {
        SoundManager::play_sound_centered(sound_id, UNUSED_FLOAT);
    }

    static inline void play_sound_validate(int32_t sound_id) {
        if (sound_id >= 0) SoundManager::play_sound(sound_id);
    }

    static inline void play_sound_positioned_validate(int32_t sound_id, const float& position) {
        if (sound_id >= 0) SoundManager::play_sound_positioned(sound_id, position);
    }

    inline void cleanup() { // Might be destructor?
        this->__wait_and_close_handles();
        this->free_bgm_format_file();
        this->release_smb_array();
        this->free_all_sound_effect_files();
        if (this->csound_manager_ptr) {
            KillTimer(this->timer_hwnd, 1);
            this->__sub_476B40();
            this->dsound = NULL; // Isn't this supposed to be released though?
            this->sound_buffer_ptr->Stop();
            SAFE_RELEASE(this->sound_buffer_ptr);
            SAFE_DELETE(this->__unknown_sme_ptr_5704);
            SAFE_DELETE(this->csound_manager_ptr); // This destructor got inlined
            this->free_first_sma_array();
        }
    }
};
#pragma region // SoundManager Validation
ValidateFieldOffset32(0x0, SoundManager, dsound);
ValidateFieldOffset32(0x4, SoundManager, sound_buffer_ptr);
ValidateFieldOffset32(0x8, SoundManager, timer_hwnd);
ValidateFieldOffset32(0xC, SoundManager, csound_manager_ptr);
ValidateFieldOffset32(0x10, SoundManager, sound_thread_id);
ValidateFieldOffset32(0x14, SoundManager, __handle_14);
ValidateFieldOffset32(0x1C, SoundManager, active_sound_ids);
ValidateFieldOffset32(0x4C, SoundManager, active_sound_id_counts);
ValidateFieldOffset32(0x7C, SoundManager, __unknown_smf_array_7C);
ValidateFieldOffset32(0x187C, SoundManager, bgm_format_offsets);
ValidateFieldOffset32(0x18BC, SoundManager, __unknown_sma_ptr_array_18BC);
ValidateFieldOffset32(0x18FC, SoundManager, __unknown_sma_ptr_array_18FC);
ValidateFieldOffset32(0x193C, SoundManager, __bgm_format_14_array_193C);
ValidateFieldOffset32(0x197C, SoundManager, __dword_197C);
ValidateFieldOffset32(0x1980, SoundManager, bgm_format_file);
ValidateFieldOffset32(0x1A84, SoundManager, __unknown_smb_array_1A84);
ValidateFieldOffset32(0x2264, SoundManager, sound_effect_files);
ValidateFieldOffset32(0x2384, SoundManager, __text_buffer_2384);
ValidateFieldOffset32(0x2484, SoundManager, __unknown_smd_array_2484);
ValidateFieldOffset32(0x5604, SoundManager, thbgm_filename);
ValidateFieldOffset32(0x5704, SoundManager, __unknown_sme_ptr_5704);
ValidateFieldOffset32(0x570C, SoundManager, __handle_570C);
ValidateFieldOffset32(0x5714, SoundManager, file_pointer_offset);
ValidateFieldOffset32(0x5718, SoundManager, __thread_5718);
ValidateFieldOffset32(0x571C, SoundManager, __handle_571C);
ValidateFieldOffset32(0x5720, SoundManager, __thread_id_5720);
ValidateFieldOffset32(0x5724, SoundManager, __dword_5724);
ValidateFieldOffset32(0x5728, SoundManager, main_window_hwnd);
ValidateFieldOffset32(0x572C, SoundManager, __dword_572C);
ValidateFieldOffset32(0x5730, SoundManager, __int_5730);
ValidateFieldOffset32(0x5734, SoundManager, __int_5734);
ValidateFieldOffset32(0x5738, SoundManager, __dword_5738);
ValidateStructSize32(0x573C, SoundManager);
#pragma endregion

extern "C" {
    // 0x56AD80
    externcg SoundManager SOUND_MANAGER cgasm("_SOUND_MANAGER");
}

// 0x401C50
dllexport gnu_noinline uint32_t get_hardware_inputs() asm_symbol_rel(0x401C50);

inline uint32_t InputState::get_joypad(uint32_t buttons) {
    uint32_t prev_buttons = buttons;
    if (SUPERVISOR.joypad_devices[0]) {
        if (FAILED(SUPERVISOR.joypad_devices[0]->Poll())) {
            for (size_t i = 0; i < 400; ++i) {
                // This isn't even listed as a valid return value in the docs?
                if (SUPERVISOR.joypad_devices[0]->Acquire() != DIERR_INPUTLOST) {
                    break;
                }
            }
        }
        else {
            DIJOYSTATE2 state = {};
            if (SUCCEEDED(SUPERVISOR.joypad_devices[0]->GetDeviceState(sizeof(state), &state))) {
                // This code is mangled AF to the point that no sane compiler will ever
                // output it, so I'm not even going to attempt to match the codegen.

                int32_t mapping;

                mapping = this->joypad_mapping.shoot;
                if (mapping >= 0 && (int8_t)state.rgbButtons[mapping] < 0) {
                    buttons |= BUTTON_SHOOT;
                }

                mapping = this->joypad_mapping.bomb;
                if (mapping >= 0 && (int8_t)state.rgbButtons[mapping] < 0) {
                    buttons |= BUTTON_BOMB;
                }

                mapping = this->joypad_mapping.pause;
                if (mapping >= 0 && (int8_t)state.rgbButtons[mapping] < 0) {
                    buttons |= BUTTON_PAUSE;
                }

                mapping = this->joypad_mapping.focus;
                if (mapping >= 0 && (int8_t)state.rgbButtons[mapping] < 0) {
                    buttons |= BUTTON_FOCUS;
                }

                mapping = this->joypad_mapping.use_card;
                if (mapping >= 0 && (int8_t)state.rgbButtons[mapping] < 0) {
                    buttons |= BUTTON_USE_CARD;
                }

                mapping = this->joypad_mapping.switch_card;
                if (mapping >= 0 && (int8_t)state.rgbButtons[mapping] < 0) {
                    buttons |= BUTTON_SWITCH_CARD;
                }

                uint32_t axes = 0;

                int32_t deadzone_x = SUPERVISOR.config.deadzone_x;
                int32_t deadzone_y = SUPERVISOR.config.deadzone_y;

                if (state.lX < -deadzone_x) {
                    axes |= BUTTON_LEFT;
                }
                if (state.lY < -deadzone_y) {
                    axes |= BUTTON_UP;
                }
                if (state.lX > deadzone_x) {
                    axes |= BUTTON_RIGHT;
                }
                if (state.lY > SUPERVISOR.config.deadzone_y) {
                    axes |= BUTTON_DOWN;
                }

                buttons |= axes;

                if (buttons != prev_buttons) {
                    this->__device_type = InputJoypad;
                }
            }
        }
    }
    return buttons;
}

static inline constexpr size_t CHARACTER_COUNT = 4;
static inline constexpr size_t SHOTTYPES_PER_CHARACTER = 1;
static inline constexpr size_t SHOTTYPE_COUNT = CHARACTER_COUNT * SHOTTYPES_PER_CHARACTER;
static inline constexpr size_t DIFFICULTY_COUNT = 6;

enum CharacterID : int32_t {
    Reimu = 0,
    Marisa = 1,
    Sakuya = 2,
    Sanae = 3,
};

static inline constexpr int32_t RANK_BOUND = 1024;
static inline constexpr int32_t MAX_RANK = +RANK_BOUND; // 1024
static inline constexpr int32_t MIN_RANK = -RANK_BOUND; // -1024
static inline constexpr int32_t RANK_RANGE = RANK_BOUND * 2; // 2048

// This is used as an index into the scorefile section B array
static inline constexpr size_t SCOREFILE_TOTALS = SHOTTYPE_COUNT;

static inline void __update_life_ui();
static inline void __update_bomb_ui();

// 0x4B3FF4
static inline constexpr int32_t LIFE_FRAGMENT_COST_TABLE_EXTRA[10] = {
    3, 3, 3,
    3, 3, 3,
    3, 3, 3,
    99999999
};

// 0x4B40C8
static inline constexpr int32_t LIFE_FRAGMENT_COST_TABLE[31] = {
    3, 3, 3,
    3, 3, 3,
    3, 3, 3,
    3, 3, 3,
    3, 3, 3,
    3, 3, 3,
    3, 3, 3,
    3, 3, 3,
    3, 3, 3,
    3, 3, 3,
    99999999
};

static inline constexpr int32_t BOMB_FRAGMENT_COST = 3;
static inline constexpr int32_t MAX_CONTINUES = 9; // increasing this will break score rendering, so DO NOT
static inline constexpr int32_t DEFAULT_POWER_PER_LEVEL = 100;
static inline constexpr int32_t DEFAULT_MAX_POWER_LEVEL = 4;
static inline constexpr int32_t MAX_ALLOWED_POWER_LEVEL = 8;

// size: 0xFC
struct Globals {
    int32_t current_stage; // 0x0
    int32_t __stage_number_related_4; // 0x4
    int32_t chapter; // 0x8
    int32_t __counter_C; // 0xC (Sound related?)
    int32_t __counter_10; // 0x10 (Sound related?)
    int32_t __counter_14; // 0x14 (Sound related?)
    int32_t character; // 0x18
    int32_t shottype; // 0x1C
    int32_t score; // 0x20
    int32_t difficulty; // 0x24
    int32_t continues; // 0x28
    int32_t rank; // 0x2C
    int32_t graze_in_stage; // 0x30
    int32_t graze; // 0x34
    int32_t __ecl_var_9907; // 0x38
    int32_t miss_count_in_game; // 0x3C
    int __dword_40; // 0x40 (Maybe point_items_collected_in_stage?)
    int32_t point_items_collected_in_game; // 0x44
    int32_t point_item_value; // 0x48
    int32_t min_point_item_value; // 0x4C
    int32_t max_point_item_value; // 0x50
    int32_t money_collected_in_game; // 0x54
    int32_t current_money; // 0x58
    int32_t current_power; // 0x5C
    int32_t max_power; // 0x60
    int32_t power_per_level; // 0x64
    int __dword_68; // 0x68
    int32_t life_stocks; // 0x6C
    int32_t life_fragments; // 0x70
    int32_t lives_added; // 0x74
    int32_t life_stock_max; // 0x78
    int32_t bomb_stocks; // 0x7C
    int32_t bomb_fragments; // 0x80
    int32_t bomb_stocks_for_new_life; // 0x84
    int32_t bomb_stock_max; // 0x88
    int32_t __int_8C; // 0x8C
    int32_t __int_90; // 0x90
    int __dword_94; // 0x94
    int __dword_98; // 0x98
    int __dword_9C; // 0x9C
    int __dword_A0; // 0xA0
    int __dword_A4; // 0xA4
    int __dword_A8; // 0xA8
    int __dword_AC; // 0xAC
    int __dword_B0; // 0xB0
    int __dword_B4; // 0xB4
    int __dword_B8; // 0xB8
    int __dword_BC; // 0xBC
    int __dword_C0; // 0xC0
    Timer __timer_C4; // 0xC4
    Timer __timer_D8; // 0xD8
    int __dword_EC; // 0xEC
    int __dword_F0; // 0xF0
    int __dword_F4; // 0xF4
    union {
        uint32_t flags; // 0xF8
        struct {
            uint32_t : 4; // 1-4
            uint32_t __unknown_field_A : 2; // 5-6
            uint32_t : 5; // 7-11
            uint32_t __unknown_flag_A : 1; // 12
        };
    };
    // 0xFC

    inline int32_t shottype_index() const {
        return this->character + this->shottype * SHOTTYPES_PER_CHARACTER;
    }

    // 0x417A60
    dllexport gnu_noinline Globals& thiscall operator=(const Globals& rhs) {
        this->current_stage = rhs.current_stage;
        this->__stage_number_related_4 = rhs.__stage_number_related_4;
        this->chapter = rhs.chapter;
        this->__counter_C = rhs.__counter_C;
        this->__counter_10 = rhs.__counter_10;
        this->__counter_14 = rhs.__counter_14;
        this->character = rhs.character;
        this->shottype = rhs.shottype;
        this->score = rhs.score;
        this->difficulty = rhs.difficulty;
        this->continues = rhs.continues;
        this->rank = rhs.rank;
        this->graze_in_stage = rhs.graze_in_stage;
        this->graze = rhs.graze;
        this->__ecl_var_9907 = rhs.__ecl_var_9907;
        this->miss_count_in_game = rhs.miss_count_in_game;
        this->__dword_40 = rhs.__dword_40;
        this->point_items_collected_in_game = rhs.point_items_collected_in_game;
        this->point_item_value = rhs.point_item_value;
        this->min_point_item_value = rhs.min_point_item_value;
        this->max_point_item_value = rhs.max_point_item_value;
        this->money_collected_in_game = rhs.money_collected_in_game;
        this->current_money = rhs.current_money;
        this->current_power = rhs.current_power;
        this->max_power = rhs.max_power;
        this->power_per_level = rhs.power_per_level;
        this->__dword_68 = rhs.__dword_68;
        this->life_stocks = rhs.life_stocks;
        this->life_fragments = rhs.life_fragments;
        this->lives_added = rhs.lives_added;
        this->life_stock_max = rhs.life_stock_max;
        this->bomb_stocks = rhs.bomb_stocks;
        this->bomb_fragments = rhs.bomb_fragments;
        this->bomb_stocks_for_new_life = rhs.bomb_stocks_for_new_life;
        this->bomb_stock_max = rhs.bomb_stock_max;
        this->__int_8C = rhs.__int_8C;
        this->__int_90 = rhs.__int_90;
        this->__dword_94 = rhs.__dword_94;
        this->__dword_98 = rhs.__dword_98;
        this->__dword_9C = rhs.__dword_9C;
        this->__dword_A0 = rhs.__dword_A0;
        this->__dword_A4 = rhs.__dword_A4;
        this->__dword_A8 = rhs.__dword_A8;
        this->__dword_AC = rhs.__dword_AC;
        this->__dword_B0 = rhs.__dword_B0;
        this->__dword_B4 = rhs.__dword_B4;
        this->__dword_B8 = rhs.__dword_B8;
        this->__dword_BC = rhs.__dword_BC;
        this->__dword_C0 = rhs.__dword_C0;
        this->__timer_C4.set_from_timer(rhs.__timer_C4);
        this->__timer_D8.set_from_timer(rhs.__timer_D8);
        this->__dword_EC = rhs.__dword_EC;
        this->__dword_F0 = rhs.__dword_F0;
        this->__dword_F4 = rhs.__dword_F4;
        this->flags = rhs.flags;
        return *this;
    }

    inline void add_continue() {
        int32_t continues = this->continues + 1;
        this->continues = __min(continues, MAX_CONTINUES);
    }

    inline void add_death() {
        int32_t deaths = this->miss_count_in_game;
        if (deaths < 999999) {
            this->miss_count_in_game = deaths + 1;
        }
    }

    // 0x412FA0
    dllexport gnu_noinline void thiscall set_power(int32_t value) asm_symbol_rel(0x412FA0) {
        this->current_power = value;
        int32_t power = this->max_power;
        if (value <= power) {
            power = __max(power, this->power_per_level); // Effectively clamps to level 1 power
        }
        this->current_power = power;
    }

    // 0x42A970
    dllexport gnu_noinline void thiscall __set_unknown_flag_A(int32_t value) asm_symbol_rel(0x42A970) {
        this->__unknown_flag_A = value;
    }

    // 0x439EA0
    dllexport gnu_noinline int32_t thiscall get_rank() asm_symbol_rel(0x439EA0) {
        return this->rank;
    }

    template <typename T>
    inline T rank_lerp(const T& min_val, const T& max_val) {
        int32_t rank = this->get_rank();
        return min_val + ((rank + (T)RANK_BOUND) * (max_val - min_val)) / (T)RANK_RANGE;
    }

    // 0x439EB0
    dllexport gnu_noinline void thiscall __add_to_int_90(int32_t value) asm_symbol_rel(0x439EB0) {
        this->__int_90 += value;
    }

    // 0x439EC0
    dllexport gnu_noinline void thiscall __add_to_int_8C(int32_t value) asm_symbol_rel(0x439EC0) {
        this->__int_8C += value;
    }

    inline int32_t power_level() {
        return this->current_power / this->power_per_level;
    }

    inline int32_t power_percent_to_next_level() {
        return (this->current_power % this->power_per_level) * 100 / this->power_per_level;
    }

    inline int32_t power_level_max() {
        return this->max_power / this->power_per_level;
    }

    // 0x4573F0
    dllexport gnu_noinline BOOL thiscall add_power(int32_t amount) asm_symbol_rel(0x4573F0);

    // 0x457480
    dllexport gnu_noinline BOOL thiscall subtract_power(int32_t amount) asm_symbol_rel(0x457480);

    // 0x4574D0
    dllexport gnu_noinline void thiscall subtract_bomb() asm_symbol_rel(0x4574D0) {
        if (--this->bomb_stocks < 0) {
            this->bomb_stocks = 0;
        }
        int32_t max_bombs = this->bomb_stock_max;
        if (this->bomb_stocks > max_bombs) {
            this->bomb_stocks = max_bombs;
        }
        __update_bomb_ui();
    }

    // 0x457520
    dllexport gnu_noinline void thiscall set_bombs(int32_t bombs) asm_symbol_rel(0x457520) {
        this->bomb_stocks = bombs;
        if (bombs < 0) {
            this->bomb_stocks = 0;
            bombs = 0;
        }

        int32_t max_bombs = this->bomb_stock_max;
        this->bomb_stocks = bombs <= max_bombs ? this->bomb_stocks : max_bombs;

        __update_bomb_ui();
    }

private:
    // 0x457570
    dllexport gnu_noinline void thiscall add_life_fragments(int32_t) asm_symbol_rel(0x457570);
public:
    inline void add_life_fragment() {
        return this->add_life_fragments(UNUSED_DWORD);
    }

    // 0x4575F0
    dllexport gnu_noinline void thiscall add_life() asm_symbol_rel(0x4575F0);

private:
    // 0x457690
    dllexport gnu_noinline void thiscall add_bombs(int32_t) asm_symbol_rel(0x457690) {
        this->bomb_stocks += 1;
        int32_t max_bombs = this->bomb_stock_max;
        if (this->bomb_stocks >= max_bombs) {
            this->bomb_fragments = 0;
            if (this->bomb_stocks > max_bombs) {
                this->bomb_stocks = max_bombs;
            }
        }
        else {
            SOUND_MANAGER.play_sound(46);
        }
        __update_bomb_ui();
    }
public:
    inline void add_bomb() {
        return this->add_bombs(UNUSED_DWORD);
    }

private:
    // 0x4576E0
    dllexport gnu_noinline void thiscall add_bomb_fragments(int32_t) asm_symbol_rel(0x4576E0) {
        if (this->bomb_stocks >= this->bomb_stock_max) {
            this->bomb_fragments = 0;
            return;
        }
        this->bomb_fragments += 1;
        if (this->bomb_fragments >= BOMB_FRAGMENT_COST) {
            this->bomb_fragments = 0;
            this->add_bomb();
        }
        __update_bomb_ui();
    }
public:
    inline void add_bomb_fragment() {
        return this->add_bomb_fragments(UNUSED_DWORD);
    }

    inline void add_graze() {
        int32_t stage_graze = this->graze_in_stage;
        int32_t total_graze = this->graze;
        ++stage_graze;
        ++total_graze;
        this->graze_in_stage = __min(stage_graze, 99999999);
        this->graze = __min(total_graze, 99999999);
    }
};

// 0x130
struct GameManager {
    int32_t __high_score; // 0x0
    int32_t __high_score_continues; // 0x4
    union {
        uint32_t flags; // 0x8
        struct {
            uint32_t __unknown_flag_A : 1; // 1
            uint32_t __unknown_flag_B : 1; // 2
            uint32_t __unknown_flag_C : 1; // 3
            uint32_t __unknown_flag_D : 1; // 4
            uint32_t __unknown_field_A : 2; // 5-6
            uint32_t __unknown_flag_E : 1; // 7
        };
    };
    int32_t __int_C; // 0xC
    int32_t continue_credits; // 0x10
    int32_t __int_14; // 0x14
    int32_t __int_18; // 0x18
    Globals globals; // 0x1C
    int32_t __int_118; // 0x118
    probably_padding_bytes(0x4); // 0x11C
    double game_time_double; // 0x120
    int __dword_128; // 0x128
    probably_padding_bytes(0x4); // 0x12C
    // 0x130

    // 0x406AA0
    dllexport gnu_noinline int32_t thiscall get_chapter() asm_symbol_rel(0x406AA0) {
        return this->globals.chapter;
    }

    // 0x418D60
    dllexport gnu_noinline int32_t thiscall get_current_stage() asm_symbol_rel(0x418D60) {
        return this->globals.current_stage;
    }

    // 0x42A990
    dllexport bool thiscall __unknown_field_A_is_2() asm_symbol_rel(0x42A990) {
        return this->__unknown_field_A == 2;
    }

    // 0x42AA20
    dllexport gnu_noinline int32_t thiscall get_difficulty() asm_symbol_rel(0x42AA20) {
        return this->globals.difficulty;
    }

    // 0x4630B0
    dllexport gnu_noinline void __set_unknown_field_A(int32_t value) asm_symbol_rel(0x4630B0) {
        if (this->__unknown_field_A != 2) {
            this->globals.__ecl_var_9907 = -1;
        }
        this->__unknown_field_A = value;
    }

    inline void add_to_score(uint32_t value) {
        uint32_t new_score = this->globals.score + value / 10;
        if (new_score > 1000000000) {
            new_score = 999999999;
        }
        this->globals.score = new_score;
    }
};

extern "C" {
    // 0x4CCCC0
    externcg GameManager GAME_MANAGER cgasm("_GAME_MANAGER");
}

static inline constexpr float SCREEN_LEFT_EDGE = -192.0f;
static inline constexpr float SCREEN_RIGHT_EDGE = 192.0f;
static inline constexpr float SCREEN_BOTTOM_EDGE = 0.0f;
static inline constexpr float SCREEN_TOP_EDGE = 448.0f;
static inline constexpr float SCREEN_WIDTH = 384.0f;
static inline constexpr float SCREEN_HEIGHT = 448.0f;

static inline constexpr float LOGICAL_WINDOW_WIDTH = 640.0f;
static inline constexpr float LOGICAL_WINDOW_HEIGHT = 480.0f;

// 0x478540
dllexport gnu_noinline void fastcall __convert_position_to_window_uv(Float2* out, Float2* position) asm_symbol_rel(0x478540);
dllexport gnu_noinline void fastcall __convert_position_to_window_uv(Float2* out, Float2* position) {
    float x = position->x / LOGICAL_WINDOW_WIDTH;
    out->x = x;
    float y = position->y / LOGICAL_WINDOW_HEIGHT;
    out->y = y;
    if (x < 0.0f) {
        out->x = 0.0f;
    }
    if (y < 0.0f) {
        out->y = 0.0f;
    }
}

// size: 0x2108
struct WindowData {
    HWND window; // 0x0
    HWND resolution_dialogue; // 0x4
    int __dword_8; // 0x8
    HINSTANCE current_instance; // 0xC
    BOOL window_active; // 0x10
    int __dword_14; // 0x14
    int __dword_18; // 0x18
    int8_t __sbyte_1C; // 0x1C
    probably_padding_bytes(0x3); // 0x1D
    LARGE_INTEGER performance_counter_frequency; // 0x20
    LARGE_INTEGER startup_qpc_value; // 0x28
    bool __bool_30; // 0x30
    char appdata_path[0x1000]; // 0x31
    char exe_path[0x1000]; // 0x1031
    probably_padding_bytes(0x3); // 0x2031
    BOOL screen_saver_active; // 0x2034
    BOOL screen_saver_low_power_active; // 0x2038
    BOOL screen_saver_power_off_active; // 0x203C
    union {
        uint32_t flags; // 0x2040
        struct {
            uint32_t __unknown_flag_A : 1; // 1
            uint32_t __unknown_flag_B : 1; // 2
            uint32_t __unknown_bitfield_A : 5; // 3-7
            uint32_t __unknown_flag_C : 1; // 8
            uint32_t __unknown_bitfield_B : 2; // 9-10
        };
    };
    uint32_t __counter_2044; // 0x2044
    unknown_fields(0x8); // 0x2048
    int32_t __scaled_width; // 0x2050
    int32_t __scaled_height; // 0x2054
    int32_t window_width; // 0x2058
    int32_t window_height; // 0x205C
    int32_t __display_width; // 0x2060
    int32_t __display_height; // 0x2064
    int32_t __backbuffer_width; // 0x2068
    int32_t __backbuffer_height; // 0x206C
    float __game_scale; // 0x2070
    int32_t __int_2074; // 0x2074
    int32_t __int_2078; // 0x2078
    int32_t __int_207C; // 0x207C
    int32_t __int_2080; // 0x2080
    int32_t __int_2084; // 0x2084
    int32_t __int_2088; // 0x2088
    int32_t __int_208C; // 0x208C
    int32_t __int_2090; // 0x2090
    probably_padding_bytes(0x4); // 0x2094
    double __double_2098; // 0x2098
    double __double_20A0; // 0x20A0
    double __double_20A8; // 0x20A8
    double __double_20B0; // 0x20B0
    double __double_20B8; // 0x20B8
    double __double_20C0; // 0x20C0
    unknown_fields(0x4); // 0x20C8
    int __dword_20CC; // 0x20CC
    int __int_20D0; // 0x20D0
    int __dword_array_20D4[12]; // 0x20D4 (This might be an array of 4 Int3...?)
    probably_padding_bytes(0x4); // 0x2104
    // 0x2108

    // 0x4726A0
    dllexport gnu_noinline ZUNResult __save_properties_and_configure_paths() asm_symbol_rel(0x4726A0);

    inline void __restore_properties();

    template <typename L>
    inline int32_t update_window_common(const L& lambda);
    
    // 0x472DD0
    dllexport gnu_noinline int32_t thiscall update_window__normal_version() asm_symbol_rel(0x472DD0);

    // 0x472FD0
    dllexport gnu_noinline int32_t thiscall update_window__alt_version() asm_symbol_rel(0x472FD0);

    inline int32_t thiscall update_window__alt_version2();
    
    // 0x4734E0
    dllexport gnu_noinline void __sub_4734E0(int arg1) asm_symbol_rel(0x4734E0);
    
    // 0x473890
    dllexport gnu_noinline BOOL __create_window(HINSTANCE instance) asm_symbol_rel(0x473890);

    // 0x472B50
    dllexport gnu_noinline void thiscall __sub_472B50() asm_symbol_rel(0x472B50);

    // 0x4731B0
    dllexport gnu_noinline void thiscall __sub_4731B0() asm_symbol_rel(0x4731B0);
};
#pragma region // WindowData Verification
ValidateFieldOffset32(0x0, WindowData, window);
ValidateFieldOffset32(0x4, WindowData, resolution_dialogue);
ValidateFieldOffset32(0x8, WindowData, __dword_8);
ValidateFieldOffset32(0xC, WindowData, current_instance);
ValidateFieldOffset32(0x10, WindowData, window_active);
ValidateFieldOffset32(0x14, WindowData, __dword_14);
ValidateFieldOffset32(0x18, WindowData, __dword_18);
ValidateFieldOffset32(0x1C, WindowData, __sbyte_1C);
ValidateFieldOffset32(0x20, WindowData, performance_counter_frequency);
ValidateFieldOffset32(0x28, WindowData, startup_qpc_value);
ValidateFieldOffset32(0x30, WindowData, __bool_30);
ValidateFieldOffset32(0x31, WindowData, appdata_path);
ValidateFieldOffset32(0x1031, WindowData, exe_path);
ValidateFieldOffset32(0x2034, WindowData, screen_saver_active);
ValidateFieldOffset32(0x2038, WindowData, screen_saver_low_power_active);
ValidateFieldOffset32(0x203C, WindowData, screen_saver_power_off_active);
ValidateFieldOffset32(0x2040, WindowData, flags);
ValidateFieldOffset32(0x2044, WindowData, __counter_2044);

ValidateFieldOffset32(0x2050, WindowData, __scaled_width);
ValidateFieldOffset32(0x2054, WindowData, __scaled_height);
ValidateFieldOffset32(0x2058, WindowData, window_width);
ValidateFieldOffset32(0x205C, WindowData, window_height);
ValidateFieldOffset32(0x2060, WindowData, __display_width);
ValidateFieldOffset32(0x2064, WindowData, __display_height);
ValidateFieldOffset32(0x2068, WindowData, __backbuffer_width);
ValidateFieldOffset32(0x206C, WindowData, __backbuffer_height);
ValidateFieldOffset32(0x2070, WindowData, __game_scale);
ValidateFieldOffset32(0x2074, WindowData, __int_2074);
ValidateFieldOffset32(0x2078, WindowData, __int_2078);
ValidateFieldOffset32(0x207C, WindowData, __int_207C);
ValidateFieldOffset32(0x2080, WindowData, __int_2080);
ValidateFieldOffset32(0x2084, WindowData, __int_2084);
ValidateFieldOffset32(0x2088, WindowData, __int_2088);
ValidateFieldOffset32(0x208C, WindowData, __int_208C);
ValidateFieldOffset32(0x2090, WindowData, __int_2090);
ValidateFieldOffset32(0x2098, WindowData, __double_2098);
ValidateFieldOffset32(0x20A0, WindowData, __double_20A0);
ValidateFieldOffset32(0x20A8, WindowData, __double_20A8);
ValidateFieldOffset32(0x20B0, WindowData, __double_20B0);
ValidateFieldOffset32(0x20B8, WindowData, __double_20B8);
ValidateFieldOffset32(0x20C0, WindowData, __double_20C0);

ValidateFieldOffset32(0x20CC, WindowData, __dword_20CC);
ValidateFieldOffset32(0x20D0, WindowData, __int_20D0);
ValidateFieldOffset32(0x20D4, WindowData, __dword_array_20D4);
#pragma endregion

extern "C" {
    // 0x568C30
    externcg WindowData WINDOW_DATA cgasm("_WINDOW_DATA");
}

// Yes, I know I don't need explicit enum values. But it makes a quick lookup table visually.
enum CardId : int32_t {
    BLANK_CARD = 0,
    EXTEND_CARD = 1,
    BOMB_CARD = 2,
    EXTEND2_CARD = 3,
    BOMB2_CARD = 4,
    PENDULUM_CARD = 5,
    DANGO_CARD = 6,
    MOKOU_CARD = 7,
    REIMU_OP_CARD = 8,
    REIMU_OP2_CARD = 9,
    MARISA_OP_CARD = 10,
    MARISA_OP2_CARD = 11,
    SAKUYA_OP_CARD = 12,
    SAKUYA_OP2_CARD = 13,
    SANAE_OP_CARD = 14,
    SANAE_OP2_CARD = 15,
    YOUMU_OP_CARD = 16,
    ALICE_OP_CARD = 17,
    CIRNO_OP_CARD = 18,
    OKINA_OP_CARD = 19,
    NUE_OP_CARD = 20,
    ITEM_CATCH_CARD = 21,
    ITEM_LINE_CARD = 22,
    AUTOBOMB_CARD = 23,
    DBOMBEXTEND_CARD = 24,
    MAINSHOT_PU_CARD = 25,
    MAGICSCROLL_CARD = 26,
    KOISHI_CARD = 27,
    MAINSHOT_SP_CARD = 28,
    SPEEDQUEEN_CARD = 29,
    OPTION_BR_CARD = 30,
    DEAD_SPELL_CARD = 31,
    POWERMAX_CARD = 32,
    YUYUKO_CARD = 33,
    MONEY_CARD = 34,
    ROKUMON_CARD = 35,
    NARUMI_CARD = 36,
    PACHE_CARD = 37,
    MANEKI_CARD = 38,
    YAMAWARO_CARD = 39,
    KISERU_CARD = 40,
    WARP_CARD = 41,
    KOZUCHI_CARD = 42,
    KANAME_CARD = 43,
    MOON_CARD = 44,
    MIKOFLASH_CARD = 45,
    VAMPIRE_CARD = 46,
    SUN_CARD = 47,
    LILY_CARD = 48,
    BASSDRUM_CARD = 49,
    PSYCHO_CARD = 50,
    MAGATAMA_CARD = 51,
    CYLINDER_CARD = 52,
    RICEBALL_CARD = 53,
    MUKADE_CARD = 54,
    MAGATAMA2_CARD = 55,
    NULL_CARD = 56,
    BACK_CARD = 57,

    ENUM_VALUE_COUNT_DECLARE(CardId)
};

static inline constexpr size_t INTERNAL_CARD_COUNT = ENUM_VALUE_COUNT(CardId);
static inline constexpr size_t CARD_COUNT = INTERNAL_CARD_COUNT - 1;

// size: 0x34
struct CardData {
    const char* name; // 0x0
    CardId id; // 0x4
    unknown_fields(0x8); // 0x8
    int __type; // 0x10
    int __weight; // 0x14
    int __availability; // 0x18
    BOOL __allow_duplicates; // 0x1C
    uint8_t __byte_20; // 0x20
    unknown_fields(0x7); // 0x21
    BOOL __render_passive_in_hud; // 0x28
    int32_t sprite_large; // 0x2C
    int32_t sprite_small; // 0x30
    // 0x34

    // 0x416E10
    dllexport gnu_noinline int thiscall __check_availability() const asm_symbol_rel(0x416E10);
};
#pragma region // CardData Validation
ValidateFieldOffset32(0x0, CardData, name);
ValidateFieldOffset32(0x4, CardData, id);
ValidateFieldOffset32(0x10, CardData, __type);
ValidateFieldOffset32(0x14, CardData, __weight);
ValidateFieldOffset32(0x18, CardData, __availability);
ValidateFieldOffset32(0x1C, CardData, __allow_duplicates);
ValidateFieldOffset32(0x20, CardData, __byte_20);
ValidateFieldOffset32(0x28, CardData, __render_passive_in_hud);
ValidateFieldOffset32(0x2C, CardData, sprite_large);
ValidateFieldOffset32(0x30, CardData, sprite_small);
ValidateStructSize32(0x34, CardData);
#pragma endregion

extern "C" {
    // 0x4C53C0
    externcg CardData CARD_DATA_TABLE[INTERNAL_CARD_COUNT] cgasm("_CARD_DATA_TABLE");
}

template <typename L>
static inline constexpr const CardData& find_in_card_data(const L& lambda) {
    for (int32_t i = 0; i < countof(CARD_DATA_TABLE); ++i) {
        if (lambda(CARD_DATA_TABLE[i])) {
            return CARD_DATA_TABLE[i];
        }
    }
    return CARD_DATA_TABLE[NULL_CARD];
}

// 0x407D70
dllexport const CardData& find_id_in_card_data(int32_t id) {
    return find_in_card_data([=](const CardData& card) {
        return card.id == id;
    });
}

static inline constexpr uint32_t SCOREFILE_MAGIC = PackUInt32('T', 'H', '8', '1'); // Yup, it's backwards
static inline constexpr uint16_t SCOREFILE_VERSION_NUMBER = 6;

static inline constexpr int32_t SPELL_COUNT = 97;

// 0x4B3F30
static const int8_t SPELL_DIFFICULTY_TABLE[SPELL_COUNT] = {
    EASY, NORMAL, HARD, LUNATIC,
    EASY, NORMAL, HARD, LUNATIC,
    EASY, NORMAL, HARD, LUNATIC,
    EASY, NORMAL, HARD, LUNATIC,
    EASY, NORMAL, HARD, LUNATIC,
    EASY, NORMAL, HARD, LUNATIC,
    EASY, NORMAL, HARD, LUNATIC,
    EASY, NORMAL, HARD, LUNATIC,
    EASY, NORMAL, HARD, LUNATIC,
    EASY, NORMAL, HARD, LUNATIC,
    EASY, NORMAL, HARD, LUNATIC,
    EASY, NORMAL, HARD, LUNATIC,
    EASY, NORMAL, HARD, LUNATIC,
    EASY, NORMAL, HARD, LUNATIC,
    EASY, NORMAL, HARD, LUNATIC,
    EASY, NORMAL, HARD, LUNATIC,
    EASY, NORMAL, HARD, LUNATIC,
    EASY, NORMAL, HARD, LUNATIC,
    EASY, NORMAL, HARD, LUNATIC,
    EASY, NORMAL, HARD, LUNATIC,
    EASY, NORMAL, HARD, LUNATIC,
    EXTRA,
    EXTRA,
    EXTRA,
    EXTRA,
    EXTRA,
    EXTRA,
    EXTRA,
    EXTRA,
    EXTRA,
    EXTRA,
    EXTRA,
    EXTRA,
    EXTRA
};

// size: 0x18
struct ScorefileHeader {
    ZUNMagic magic; // 0x0
    uint32_t file_size; // 0x4
    uint16_t version_number; // 0x8
    short __short_A; // 0xA
    int __int_C; // 0xC
    int32_t compressed_size; // 0x10
    int32_t decompressed_size; // 0x14
    // 0x18

    inline void zero_contents() {
        zero_this_inline();
    }
};
#pragma region // ScorefileHeader Validation
ValidateFieldOffset32(0x0, ScorefileHeader, magic);
ValidateFieldOffset32(0x4, ScorefileHeader, file_size);
ValidateFieldOffset32(0x8, ScorefileHeader, version_number);
ValidateFieldOffset32(0xC, ScorefileHeader, __int_C);
ValidateFieldOffset32(0x10, ScorefileHeader, compressed_size);
ValidateFieldOffset32(0x14, ScorefileHeader, decompressed_size);
ValidateStructSize32(0x18, ScorefileHeader);
#pragma endregion

// size: 0x20
struct ScorefileRecord {
    uint32_t score; // 0x0
    uint8_t __byte_4; // 0x4
    int8_t continues; // 0x5
    char name[10]; // 0x6
    time_t time; // 0x10
    float slowdown_rate; // 0x18
    unknown_fields(0x4); // 0x1C
    // 0x20
};
#pragma region // ScorefileRecord Validation
ValidateFieldOffset32(0x0, ScorefileRecord, score);
ValidateFieldOffset32(0x4, ScorefileRecord, __byte_4);
ValidateFieldOffset32(0x5, ScorefileRecord, continues);
ValidateFieldOffset32(0x6, ScorefileRecord, name);
ValidateFieldOffset32(0x10, ScorefileRecord, time);
ValidateFieldOffset32(0x18, ScorefileRecord, slowdown_rate);
ValidateStructSize32(0x20, ScorefileRecord);
#pragma endregion

// size: 0xDC
struct ScorefileSpellcard {
    char name[0]; // 0x0, 0x8D0, 0x8D8
    unknown_fields(0xC0); // 0x0
    int32_t captures[2]; // 0xC0, 0x990, 0x998 0 = Spell record menu, Spell practice menu GAME MODE line, 1 = Spell practice menu
    int32_t attempts[2]; // 0xC8, 0x998, 0x9A0 0 = Spell record menu, Spell practice menu GAME MODE line, 1 = Spell practice menu
    int32_t id; // 0xD0, 0x9A0, 0x9A8
    int32_t difficulty; // 0xD0, 0x9A0, 0x9A8
    int32_t spell_practice_score; // 0xD0, 0x9A8, 0x9B0
    // 0xDC

    //inline void 
};
#pragma region // ScorefileSpellcard
ValidateFieldOffset32(0x0, ScorefileSpellcard, name);
ValidateStructSize32(0xDC, ScorefileSpellcard);
#pragma endregion

// size: 0x8
struct ScorefileStagePractice {
    uint32_t score; // 0x0, 0x12EF0, 0x12EF8
    bool __bool_4; // 0x4, 0x12EF4, 0x12EFC
    bool unlocked; // 0x5, 0x12EF5, 0x12EFD
    unknown_fields(0x2); // 0x6, 0x12EF6, 0x12EFE
    // 0x8, 0x12EF8, 0x12F00
};
#pragma region // ScorefileStagePractice Validation
ValidateFieldOffset32(0x0, ScorefileStagePractice, score);
ValidateFieldOffset32(0x4, ScorefileStagePractice, __bool_4);
ValidateFieldOffset32(0x5, ScorefileStagePractice, unlocked);
ValidateStructSize32(0x8, ScorefileStagePractice);
#pragma endregion

// size: 0xC
struct ScorefileSectionHeader {
    ZUNMagic16 magic; // 0x0
    uint16_t __version_number; // 0x2
    uint32_t checksum; // 0x4
    uint32_t size; // 0x8
    // 0xC
};
#pragma region // ScorefileSectionHeader Validation
ValidateFieldOffset32(0x0, ScorefileSectionHeader, magic);
ValidateFieldOffset32(0x2, ScorefileSectionHeader, __version_number);
ValidateFieldOffset32(0x4, ScorefileSectionHeader, checksum);
ValidateFieldOffset32(0x8, ScorefileSectionHeader, size);
ValidateStructSize32(0xC, ScorefileSectionHeader);
#pragma endregion


struct ScorefileSection : ScorefileSectionHeader {
    uint8_t data[]; // 0xC

    // 0x463250
    dllexport gnu_noinline uint32_t thiscall calculate_checksum(int32_t data_size) asm_symbol_rel(0x463250) {
        const uint8_t* read = this->data - 4;
        data_size -= sizeof(ScorefileSectionHeader) - 4;
        
        // This really just looks like MSVC trying to optimize a normal loop
        uint32_t sum = 0;
        for (int32_t i = 0; i < data_size; ++i) {
            sum += read[i];
        }
        return sum;
    }
};

static inline constexpr uint16_t SCOREFILE_SECTION_B_MAGIC = PackUInt16('C', 'R');
static inline constexpr uint16_t SCOREFILE_SECTION_B_VERSION_NUMBER = 3;
static inline constexpr int32_t RECORDS_PER_DIFFICULTY = 10;

/*
uint32_t score; //
bool __idk; // 0x12EF4, 0x12EFC
bool __seen; // 0x12EF5, 0x12EFD
// 0x12EFE
// 0x12F00
bool __idkB; // 0x12F05
// 0x12F06
*/

static inline constexpr size_t wekjbkrb = sizeof(ScorefileStagePractice[DIFFICULTY_COUNT][STAGE_COUNT + 1]);

// size: 0x130F0
struct ScorefileSectionB : ScorefileSectionHeader {
    // ScorefileSectionHeader base; // 0x0, 0x8
    int32_t index; // 0xC, 0x14
    ScorefileRecord records[DIFFICULTY_COUNT][RECORDS_PER_DIFFICULTY]; // 0x10, 0x18
    unknown_fields(0x140); // 0x790, 0x798
    ScorefileSpellcard spells[SPELL_COUNT]; // 0x8D0, 0x8D8
    unknown_fields(0x898); // 0x5C2C, 0x5C34
    int32_t __int_64C4; // 0x64C4, 0x64CC
    uint64_t __ulonglong_64C8; // 0x64C8, 0x64D0
    int32_t __total_clears[DIFFICULTY_COUNT]; // 0x64D0, 0x64D8
    unknown_fields(0x4); // 0x64E8, 0x64F0
    int32_t __1cc_clears[DIFFICULTY_COUNT]; // 0x64EC, 0x64F4
    unknown_fields(0xC9EC); // 0x6504, 0x650C
    ScorefileStagePractice practice[DIFFICULTY_COUNT][STAGE_COUNT + 1]; // 0x12EF0, 0x12EF8
    unknown_fields(0x50); // 0x130A0, 0x130A8
    // 0x130F0, 0x130F8

    inline void zero_contents() {
        zero_this();
    }

    inline ScorefileSectionHeader* next_section() {
        return this + 1;
    }

    inline uint32_t calculate_checksum() {
        return ((ScorefileSection*)this)->calculate_checksum(sizeof(ScorefileSectionB));
    }

    inline void __add_play_count() {
        int32_t count = this->__int_64C4;
        if (count < 9999999) {
            this->__int_64C4 = count + 1;
        }
    }

    // 0x463350
    dllexport gnu_noinline void thiscall initialize() asm_symbol_rel(0x463350) {
        this->zero_contents();
        this->magic.as_uint = SCOREFILE_SECTION_B_MAGIC;
        this->__version_number = SCOREFILE_SECTION_B_VERSION_NUMBER;
        this->size = sizeof(ScorefileSectionB);

        for (size_t i = 0; i < DIFFICULTY_COUNT; ++i) {
            for (size_t j = 0; j < RECORDS_PER_DIFFICULTY; ++j) {
                this->records[i][j].score = 100000 - j * 10000;
                this->records[i][j].__byte_4 = 1;
                memcpy(this->records[i][j].name, "--------", sizeof("--------"));
                this->records[i][j].time = 0;
                this->records[i][j].continues = 0;
                this->records[i][j].slowdown_rate = 0.0f;
            }
        }

        for (int32_t i = 0; i < SPELL_COUNT; ++i) {
            int32_t difficulty = SPELL_DIFFICULTY_TABLE[i];
            this->spells[i].id = i;
            this->spells[i].difficulty = difficulty;
        }
    }

    // 0x457870
    dllexport gnu_noinline int32_t thiscall __sub_457870() asm_symbol_rel(0x457870) {
        ScorefileRecord* cur_record = &this->records[GAME_MANAGER.globals.difficulty][0];
        int32_t cur_score = GAME_MANAGER.globals.score;

        int32_t found_index;
        for (found_index = 0; found_index < RECORDS_PER_DIFFICULTY; ++found_index) {
            if (cur_score >= cur_record->score) {
                goto found_record;
            }
            ++cur_record;
        }
        return -1;
    found_record:
        for (size_t i = RECORDS_PER_DIFFICULTY - 1; found_index < i; --i) {
            this->records[GAME_MANAGER.globals.difficulty][i] = this->records[GAME_MANAGER.globals.difficulty][i - 1];
        }

        cur_record->score = GAME_MANAGER.globals.score;
        cur_record->continues = GAME_MANAGER.globals.continues;
        cur_record->__byte_4 = GAME_MANAGER.globals.current_stage;
        time(&cur_record->time);
        cur_record->slowdown_rate = FPS_COUNTER_PTR->calc_slowdown_rate();

        return found_index;
    }
};
#pragma region // ScorefileSectionB Validation
ValidateFieldOffset32(0x0, ScorefileSectionB, magic);
ValidateFieldOffset32(0x2, ScorefileSectionB, __version_number);
ValidateFieldOffset32(0x4, ScorefileSectionB, checksum);
ValidateFieldOffset32(0x8, ScorefileSectionB, size);
ValidateFieldOffset32(0xC, ScorefileSectionB, index);
ValidateFieldOffset32(0x10, ScorefileSectionB, records);
ValidateFieldOffset32(0x8D0, ScorefileSectionB, spells);
ValidateFieldOffset32(0x64C4, ScorefileSectionB, __int_64C4);
ValidateFieldOffset32(0x64C8, ScorefileSectionB, __ulonglong_64C8);
ValidateFieldOffset32(0x64D0, ScorefileSectionB, __total_clears);
ValidateFieldOffset32(0x64EC, ScorefileSectionB, __1cc_clears);
ValidateFieldOffset32(0x12EF0, ScorefileSectionB, practice);
ValidateStructSize32(0x130F0, ScorefileSectionB);
#pragma endregion

static inline constexpr uint16_t SCOREFILE_SECTION_A_MAGIC = PackUInt16('S', 'T');
static inline constexpr uint16_t SCOREFILE_SECTION_A_VERSION_NUMBER = 6;

// size: 0x3D0
struct ScorefileSectionA : ScorefileSectionHeader {
    // ScorefileSectionHeader base; // 0x0, 0x5F4B8
    char __text_buffer_C[10]; // 0xC, 0x5F4C4
    unknown_fields(0x32); // 0x16, 0x5F4CE
    uint64_t __ulonglong_48; // 0x48, 0x5F500
    bool trophies[30]; // 0x50, 0x5F508
    unknown_fields(0x62); // 0x6E, 0x5F526
    uint8_t __byte_array_D0[CARD_COUNT]; // 0xD0, 0x5F588
    unknown_fields(0x47); // 0x109, 0x5F5C1
    uint8_t __card_ids_150[SHOTTYPE_COUNT][16]; // 0x150, 0x5F608
    unknown_fields(0x30); // 0x190, 0x5F648
    int32_t __int_array_1C0[4]; // 0x1C0, 0x5F678
    short __short_array_1D0[0x100]; // 0x1D0, 0x5F688
    // 0x3D0, 0x5F888

    inline void zero_contents() {
        zero_this();
    }

    inline ScorefileSectionHeader* next_section() {
        return this + 1;
    }

    inline uint32_t calculate_checksum() {
        return ((ScorefileSection*)this)->calculate_checksum(sizeof(ScorefileSectionA));
    }

    // 0x463670
    dllexport gnu_noinline void thiscall initialize() asm_symbol_rel(0x463670) {
        this->zero_contents();
        this->magic.as_uint = SCOREFILE_SECTION_A_MAGIC;
        this->__version_number = SCOREFILE_SECTION_A_VERSION_NUMBER;
        this->size = sizeof(ScorefileSectionA);

        memcpy(this->__text_buffer_C, "        ", sizeof("        "));
        for (int32_t i = 0; i < CARD_COUNT; ++i) {
            this->__byte_array_D0[i] = find_id_in_card_data(i).__byte_20;
        }
        memset(this->__card_ids_150, NULL_CARD, sizeof(__card_ids_150));
        this->__card_ids_150[0][0] = KOZUCHI_CARD;
        this->__int_array_1C0[0] = 1;
        this->__int_array_1C0[1] = 3;
        this->__card_ids_150[1][0] = KOZUCHI_CARD;
        this->__card_ids_150[1][1] = YOUMU_OP_CARD;
        this->__card_ids_150[1][2] = DBOMBEXTEND_CARD;
        this->__int_array_1C0[2] = 5;
        this->__card_ids_150[2][0] = KOZUCHI_CARD;
        this->__int_array_1C0[3] = 0;
        for (size_t i = 0; i < countof(this->__short_array_1D0); ++i) {
            this->__short_array_1D0[i] = REPLAY_RNG.rand_ushort();
        }
    }
};
#pragma region // ScorefileInnerA Validation
ValidateFieldOffset32(0x0, ScorefileSectionA, magic);
ValidateFieldOffset32(0x2, ScorefileSectionA, __version_number);
ValidateFieldOffset32(0x4, ScorefileSectionA, checksum);
ValidateFieldOffset32(0x8, ScorefileSectionA, size);
ValidateFieldOffset32(0xC, ScorefileSectionA, __text_buffer_C);
ValidateFieldOffset32(0x48, ScorefileSectionA, __ulonglong_48);
ValidateFieldOffset32(0x50, ScorefileSectionA, trophies);
ValidateFieldOffset32(0xD0, ScorefileSectionA, __byte_array_D0);
ValidateFieldOffset32(0x150, ScorefileSectionA, __card_ids_150);
ValidateFieldOffset32(0x1C0, ScorefileSectionA, __int_array_1C0);
ValidateFieldOffset32(0x1D0, ScorefileSectionA, __short_array_1D0);
ValidateStructSize32(0x3D0, ScorefileSectionA);
#pragma endregion

struct ScorefileBuffer {
    ScorefileHeader header; // 0x0
    uint8_t file_body[]; // 0x18
};

// size: 0x5F888
struct Scorefile {
    ScorefileBuffer* buffer; // 0x0
    void* decompressed_buffer; // 0x4
    ScorefileSectionB shottypes[SHOTTYPE_COUNT + 1]; // 0x8, 0x130F8, 0x251E8, 0x392D8, 0x4C3C8
    ScorefileSectionA __sectionA; // 0x5F4B8
    // 0x5F888

    inline ~Scorefile() {
        SAFE_FREE(this->buffer);
        SAFE_FREE(this->decompressed_buffer);
    }

private:
    // 0x463B30
    dllexport gnu_noinline ZUNResult stdcall save_to_file(const char* filename, Scorefile* scorefile) {
        if (!scorefile->buffer) {
            return ZUN_ERROR;
        }

        // bad ZUN, don't do BS like this!
        uint8_t* big_buffer = (uint8_t*)malloc(0x200000);
        uint32_t written_size = 0;

        *(ScorefileHeader*)big_buffer = scorefile->buffer->header;
        written_size += sizeof(ScorefileHeader);
        
        ScorefileSectionB* sectionB = scorefile->shottypes;
        for (size_t i = 0; i < countof(scorefile->shottypes); ++i) {
            if (sectionB->magic.as_uint == SCOREFILE_SECTION_B_MAGIC) {
                sectionB->index = i;
                clang_forceinline sectionB->checksum = sectionB->calculate_checksum();
                *(ScorefileSectionB*)&big_buffer[written_size] = *sectionB;
                written_size += sizeof(ScorefileSectionB);
            }
            ++sectionB;
        }

        ScorefileSectionA* sectionA = &scorefile->__sectionA;
        sectionA->checksum = sectionA->calculate_checksum();
        *(ScorefileSectionA*)&big_buffer[written_size] = *sectionA;
        written_size += sizeof(ScorefileSectionA) - sizeof(ScorefileHeader); // WTF ZUN

        scorefile->buffer->header.decompressed_size = written_size;
        void* compressed_buffer = __compress_buffer(&big_buffer[sizeof(ScorefileHeader)], scorefile->buffer->header.decompressed_size, &scorefile->buffer->header.compressed_size);
        scorefile->buffer->header.file_size = scorefile->buffer->header.compressed_size + sizeof(ScorefileHeader);
        __crypt_buffer(compressed_buffer, scorefile->buffer->header.compressed_size, 0xAC, 0x35, 0x10, scorefile->buffer->header.compressed_size);
        
        chdir(WINDOW_DATA.appdata_path);

        if (ZUN_FAILED(__zun_open_new_file(filename))) {
            LOG_BUFFER.write_error(JpEnStr("", "error : cannot write score file\n"));
            SAFE_FREE(compressed_buffer);
            free(big_buffer);
            chdir(WINDOW_DATA.exe_path);
            return ZUN_ERROR;
        }

        __zun_write_file(&scorefile->buffer->header, sizeof(ScorefileHeader));
        __zun_write_file(compressed_buffer, scorefile->buffer->header.compressed_size);
        __zun_close_file();

        SAFE_FREE(compressed_buffer);
        chdir(WINDOW_DATA.exe_path);
        free(big_buffer);
        return ZUN_SUCCESS;
    }

    // 0x4639B0
    dllexport gnu_noinline ZUNResult stdcall load_from_buffer(Scorefile* scorefile) {
        if (scorefile->buffer) {
            if (
                scorefile->buffer->header.magic.as_uint == SCOREFILE_MAGIC &&
                scorefile->buffer->header.version_number == SCOREFILE_VERSION_NUMBER
            ) {
                __decrypt_buffer(scorefile->buffer->file_body, scorefile->buffer->header.compressed_size, 0xAC, 0x35, 0x10, scorefile->buffer->header.compressed_size);
                scorefile->decompressed_buffer = malloc(scorefile->buffer->header.decompressed_size * 4);
                __decompress_buffer(scorefile->buffer->file_body, scorefile->buffer->header.compressed_size, scorefile->decompressed_buffer, scorefile->buffer->header.decompressed_size);

                ScorefileSectionHeader* section = (ScorefileSectionHeader*)scorefile->decompressed_buffer;
                int32_t remaining_size = scorefile->buffer->header.decompressed_size;
                while (remaining_size > 0) {
                    switch (section->magic.as_uint) {
                        case SCOREFILE_SECTION_B_MAGIC: {
                            ScorefileSectionB* sectionB = (ScorefileSectionB*)section;
                            if (
                                sectionB->__version_number == SCOREFILE_SECTION_B_VERSION_NUMBER &&
                                sectionB->checksum == sectionB->calculate_checksum() &&
                                sectionB->size == sizeof(ScorefileSectionB)
                            ) {
                                scorefile->shottypes[sectionB->index] = *sectionB;
                                remaining_size -= sectionB->size;
                                if (remaining_size < 0) break;
                                section = sectionB->next_section();
                            }
                            break;
                        }
                        case SCOREFILE_SECTION_A_MAGIC: {
                            ScorefileSectionA* sectionA = (ScorefileSectionA*)section;
                            if (
                                sectionA->__version_number == SCOREFILE_SECTION_A_VERSION_NUMBER &&
                                sectionA->checksum == sectionA->calculate_checksum() &&
                                sectionA->size == sizeof(ScorefileSectionA)
                            ) {
                                scorefile->__sectionA = *sectionA;
                                remaining_size -= sectionA->size;
                                if (remaining_size < 0) break;
                                section = sectionA->next_section();
                            }
                            break;
                        }
                    }
                }
                return ZUN_SUCCESS;
            }
            SAFE_FREE(scorefile->buffer);
        }
        scorefile->buffer = (ScorefileBuffer*)malloc(sizeof(ScorefileBuffer));
        scorefile->buffer->header.zero_contents();
        scorefile->buffer->header.magic.as_uint = SCOREFILE_MAGIC;
        scorefile->buffer->header.version_number = SCOREFILE_VERSION_NUMBER;
        scorefile->buffer->header.__int_C = 256;
        return ZUN_SUCCESS;
    }

public:
    inline ZUNResult save_to_file(const char* filename) {
        return Scorefile::save_to_file(filename, this);
    }

    inline ZUNResult load_from_buffer() {
        return Scorefile::load_from_buffer(this);
    }

    inline void initialize(const char* filename) {
        chdir(WINDOW_DATA.appdata_path);
        int32_t bak_file_size;
        this->buffer = (ScorefileBuffer*)read_file_to_buffer(filename, &bak_file_size, true);
        chdir(WINDOW_DATA.exe_path);
        this->__sectionA.initialize();

        for (
            ScorefileSectionB* sectionB = this->shottypes;
            (int32_t)(sectionB - this->shottypes) < SHOTTYPE_COUNT + 1;
            ++sectionB
        ) {
            sectionB->initialize();
        }
    }
};
#pragma region // Scorefile Validation
ValidateFieldOffset32(0x0, Scorefile, buffer);
ValidateFieldOffset32(0x4, Scorefile, decompressed_buffer);
ValidateFieldOffset32(0x8, Scorefile, shottypes);
ValidateFieldOffset32(0x5F4B8, Scorefile, __sectionA);
ValidateStructSize32(0x5F888, Scorefile);
#pragma endregion

typedef struct ScorefileManager ScorefileManager;

extern "C" {
    // 0x4CF41C
    externcg ScorefileManager* SCOREFILE_MANAGER_PTR cgasm("_SCOREFILE_MANAGER_PTR");
}

// size: 0xBF158
struct ScorefileManager {
    Scorefile primary_file; // 0x0
    Scorefile backup_file; // 0x5F888
    unknown_fields(0x48); // 0xBF110
    // 0xBF158

    inline void zero_contents() {
        zero_this();
    }

    inline ScorefileManager() {
        this->zero_contents();
        this->initialize();
    }

    inline void copy_backup_to_primary() {
        memcpy(this->primary_file.shottypes, this->backup_file.shottypes, sizeof(this->backup_file.shottypes));
        this->primary_file.__sectionA = this->backup_file.__sectionA;
    }

    inline void copy_primary_to_backup() {
        memcpy(this->backup_file.shottypes, this->primary_file.shottypes, sizeof(this->primary_file.shottypes));
        this->backup_file.__sectionA = this->primary_file.__sectionA;
    }

    inline void initialize() {
        this->backup_file.initialize("scoreth18bak.dat");
        this->backup_file.load_from_buffer();
        this->primary_file.initialize("scoreth18.dat");

        this->copy_backup_to_primary();

        this->primary_file.load_from_buffer();

        this->copy_primary_to_backup();
    }

    // 0x4637D0
    dllexport gnu_noinline static ScorefileManager* allocate() {
        ScorefileManager* scorefile_manager = new ScorefileManager();
        SCOREFILE_MANAGER_PTR = scorefile_manager;
        return scorefile_manager;
    }

    // 0x413510
    dllexport gnu_noinline static ZUNResult save_files() {
#if !PROTECT_ORIGINAL_FILES
        ScorefileManager* scorefile_manager = SCOREFILE_MANAGER_PTR;
        int32_t ret = scorefile_manager->backup_file.save_to_file("scoreth18bak.dat");
        ret |= scorefile_manager->primary_file.save_to_file("scoreth18.dat");
        scorefile_manager->copy_primary_to_backup();
        return (ZUNResult)ret;
#else
        SCOREFILE_MANAGER_PTR->copy_primary_to_backup();
        return ZUN_SUCCESS;
#endif
    }
};
#pragma region // ScorefileManager Validation
ValidateFieldOffset32(0x0, ScorefileManager, primary_file);
ValidateFieldOffset32(0x5F888, ScorefileManager, backup_file);
ValidateStructSize32(0xBF158, ScorefileManager);
#pragma endregion

// 0x416E10
dllexport gnu_noinline int thiscall CardData::__check_availability() const {
    switch (this->__availability) {
        case 0:
            return 1;
        case 1:
            if (GAME_MANAGER.globals.current_stage == 1) {
                return 2;
            }
            break;
        case 2:
            if (GAME_MANAGER.globals.current_stage == 2) {
                return 2;
            }
            break;
        case 3:
            if (GAME_MANAGER.globals.current_stage == 3) {
                return 2;
            }
            break;
        case 4:
            if (GAME_MANAGER.globals.current_stage == 4) {
                return 2;
            }
            break;
        case 5:
            if (GAME_MANAGER.globals.current_stage == 5) {
                return 2;
            }
            break;
        case 6:
            switch (GAME_MANAGER.globals.current_stage) {
                case 1: case 2:
                    return 1;
                default:
                    return !(RNG.rand_uint() % 5);
            }
        case 7:
            switch (GAME_MANAGER.globals.current_stage) {
                case 1: case 2: case 3:
                    return 1;
                default:
                    return !(RNG.rand_uint() % 5);
            }
        case 8:
            switch (GAME_MANAGER.globals.current_stage) {
                case 2: case 3: case 4:
                    return 1;
                default:
                    return !(RNG.rand_uint() % 5);
            }
        case 9:
            switch (GAME_MANAGER.globals.current_stage) {
                case 3: case 4: case 5:
                    return 1;
                default:
                    return !(RNG.rand_uint() % 5);
            }
        case 10:
            switch (GAME_MANAGER.globals.current_stage) {
                case 4: case 5:
                    return 1;
                default:
                    return !(RNG.rand_uint() % 5);
            }
        case 11:
            switch (GAME_MANAGER.globals.current_stage) {
                default:
                    return 0;
                case 1: case 2: case 3: case 4: case 5:
                    break;
            }
        case 12:
            break;
    }
    return SCOREFILE_MANAGER_PTR->primary_file.__sectionA.__byte_array_D0[this->id] != 0;
}

enum MotionMode : int32_t {
    AxisVelocityMovement = 0,
    NoMovement = 1,
    OrbitMovement = 2,
    EllipseMovement = 3,
    UnknownMovement = 4
};

// size: 0x44
struct MotionData {
    Float3 position; // 0x0
    Float3 position2; // 0xC
    float speed; // 0x18
    ZUNAngle angle; // 0x1C
    float radius; // 0x20
    union {
        float radius_delta; // 0x24
        float __angle_30_delta; // 0x24
    };
    ZUNAngle ellipse_angle; // 0x28
    float ellipse_ratio; // 0x2C
    float __angle_30; // 0x30
    union {
        Float3 misc_float3; // 0x34
        Float3 axis_velocity; // 0x34
        Float3 orbit_origin; // 0x34
    };
    union {
        uint32_t flags; // 0x40
        struct {
            uint32_t mode : 4; // 1-4
        };
    };

    inline void zero_contents() {
        zero_this();
    }
    
    // 0x402CC0
    dllexport gnu_noinline void update() asm_symbol_rel(0x402CC0) {
        switch (this->mode) {
            case AxisVelocityMovement:
                this->position += this->axis_velocity;
                break;
            case OrbitMovement: {
                Float3 offset;
                offset.make_from_vector(this->angle, this->radius);
                this->position = this->orbit_origin + offset.as2();
                break;
            }
            case EllipseMovement: {
                float angle = this->angle - this->ellipse_angle;
                Float3 offset;
                offset.make_from_vector(reduce_angle<NoInline>(angle), this->radius);
                offset.x *= this->ellipse_ratio;
                offset.rotate_around_origin(this->ellipse_angle);
                this->position = this->orbit_origin + offset.as2();
                break;
            }
            case UnknownMovement: {
                Float2 prev_position = this->position;
                this->position2 += this->axis_velocity;
                float angle = this->ellipse_angle + HALF_PI_f;
                Float3 offset;
                offset.make_from_vector(reduce_angle<NoInline>(angle), this->radius * zsinf(this->__angle_30) * GAME_SPEED);
                this->position = this->position2 + offset;
                float angle_to_prev = this->position.angle_to(&prev_position);
                clang_noinline this->angle = angle_to_prev;
                break;
            }
        }
        this->position.x = zfloorf(this->position.x * 100.0f) / 100.0f;
        this->position.y = zfloorf(this->position.y * 100.0f) / 100.0f;
    }

    // 0x402F90
    dllexport gnu_noinline void update2() asm_symbol_rel(0x402F90) {
        if (this->mode == UnknownMovement) {
            this->position2 = this->position;
        }
        this->update();
    }

    // 0x402BF0
    dllexport gnu_noinline void update3() asm_symbol_rel(0x402BF0) {
        switch (this->mode) {
            case AxisVelocityMovement:
                this->axis_velocity.make_from_vector(this->angle, this->speed * GAME_SPEED);
                break;
            case OrbitMovement: case EllipseMovement:
                this->radius += this->radius_delta * GAME_SPEED;
                this->angle += this->speed * GAME_SPEED;
                break;
            case UnknownMovement:
                this->__angle_30 += this->__angle_30_delta * GAME_SPEED;
                this->axis_velocity.make_from_vector3(this->ellipse_angle, this->speed * GAME_SPEED);
                break;
        }
    }
    
    // 0x412F60
    dllexport gnu_noinline void set_position(Float3* coord) asm_symbol_rel(0x412F60) {
        this->position = *coord;
    }
    // 0x43A290
    dllexport gnu_noinline void set_positionB(Float3* coord) asm_symbol_rel(0x43A290) {
        this->position = *coord;
    }
    
    // 0x412FD0
    dllexport gnu_noinline void vectorcall set_speed(float value) asm_symbol_rel(0x412FD0) {
        this->speed = value;
    }
    
    // 0x413280
    dllexport gnu_noinline Float3& thiscall get_position() asm_symbol_rel(0x413280) {
        return this->position;
    }
    
    // 0x422530
    dllexport gnu_noinline void vectorcall set_orbit_radius_delta(float value) asm_symbol_rel(0x422530) {
        this->radius_delta = value;
    }
    
    // 0x422540
    dllexport gnu_noinline void vectorcall set_orbit_radius(float value) asm_symbol_rel(0x422540) {
        this->radius = value;
    }
    
    // 0x422550
    dllexport gnu_noinline void set_orbit_mode() asm_symbol_rel(0x422550) {
        this->mode = OrbitMovement;
    }
    
    // 0x422560
    dllexport gnu_noinline void set_misc_float3(const Float3& value) asm_symbol_rel(0x422560) {
        this->misc_float3 = value;
    }

    forceinline void set_axis_velocity(const Float3& value) {
        this->set_misc_float3(value);
    }

    forceinline void set_orbit_origin(const Float3& value) {
        this->set_misc_float3(value);
    }

    // 0x422580
    dllexport gnu_noinline float vectorcall get_speed() asm_symbol_rel(0x422580) {
        return this->speed;
    }
    
    // 0x422590
    dllexport gnu_noinline ZUNAngle& get_angle() asm_symbol_rel(0x422590) {
        return this->angle;
    }
    
    // 0x4225A0
    dllexport gnu_noinline void vectorcall set_angle(float angle) asm_symbol_rel(0x4225A0) {
        this->angle = angle;
    }
    
    // 0x4225F0
    dllexport gnu_noinline void set_axis_velocity_mode() asm_symbol_rel(0x4225F0) {
        this->mode = AxisVelocityMovement;
    }
    
    // 0x43A210
    dllexport gnu_noinline void vectorcall set_position_y(float value) asm_symbol_rel(0x43A210) {
        this->position.y = value;
    }
    
    // 0x43A220
    dllexport gnu_noinline void vectorcall set_position_x(float value) asm_symbol_rel(0x43A220) {
        this->position.x = value;
    }
    
    // 0x43A230
    dllexport gnu_noinline float vectorcall get_position_y() asm_symbol_rel(0x43A230) {
        return this->position.y;
    }
    
    // 0x43A240
    dllexport gnu_noinline float vectorcall get_position_x() asm_symbol_rel(0x43A240) {
        return this->position.x;
    }

    // 0x439ED0
    dllexport gnu_noinline float vectorcall get_ellipse_angle() asm_symbol_rel(0x439ED0) {
        return this->ellipse_angle;
    }

    // 0x439EE0
    dllexport gnu_noinline float vectorcall get_ellipse_ratio() asm_symbol_rel(0x439EE0) {
        return this->ellipse_ratio;
    }
    
    // 0x439EF0
    dllexport gnu_noinline void set_ellipse_mode() asm_symbol_rel(0x439EF0) {
        this->mode = EllipseMovement;
    }
    
    // 0x439F00
    dllexport gnu_noinline void vectorcall set_ellipse_ratio(float ratio) asm_symbol_rel(0x439F00) {
        this->ellipse_ratio = ratio;
    }
    
    // 0x439F10
    dllexport gnu_noinline void vectorcall set_ellipse_angle(float angle) asm_symbol_rel(0x439F10) {
        this->ellipse_angle = angle;
    }

    // 0x439FA0
    dllexport gnu_noinline void vectorcall set_misc_float3_y(float value) asm_symbol_rel(0x439FA0) {
        this->misc_float3.y = value;
    }

    forceinline void vectorcall set_axis_velocity_y(float value) {
        this->set_misc_float3_y(value);
    }

    forceinline void vectorcall set_orbit_origin_y(float value) {
        this->set_misc_float3_y(value);
    }

    // 0x439FB0
    dllexport gnu_noinline void vectorcall set_misc_float3_x(float value) asm_symbol_rel(0x439FB0) {
        this->misc_float3.x = value;
    }

    forceinline void vectorcall set_axis_velocity_x(float value) {
        this->set_misc_float3_x(value);
    }

    forceinline void vectorcall set_orbit_origin_x(float value) {
        this->set_misc_float3_x(value);
    }
    
    // 0x439FC0
    dllexport gnu_noinline float vectorcall get_orbit_radius() asm_symbol_rel(0x439FC0) {
        return this->radius;
    }
    
    // 0x439FD0
    dllexport gnu_noinline float vectorcall get_orbit_radius_delta() asm_symbol_rel(0x439FD0) {
        return this->radius_delta;
    }
    
    // 0x43A270
    dllexport gnu_noinline bool mode_is_orbit() asm_symbol_rel(0x43A270) {
        return this->mode == OrbitMovement;
    }

    inline MotionData() {};
};
#pragma region // MotionData Validation
ValidateFieldOffset32(0x0, MotionData, position);
ValidateFieldOffset32(0xC, MotionData, position2);
ValidateFieldOffset32(0x18, MotionData, speed);
ValidateFieldOffset32(0x1C, MotionData, angle);
ValidateFieldOffset32(0x20, MotionData, radius);
ValidateFieldOffset32(0x24, MotionData, radius_delta);
ValidateFieldOffset32(0x28, MotionData, ellipse_angle);
ValidateFieldOffset32(0x2C, MotionData, ellipse_ratio);
ValidateFieldOffset32(0x30, MotionData, __angle_30);
ValidateFieldOffset32(0x34, MotionData, misc_float3);
ValidateFieldOffset32(0x40, MotionData, flags);
ValidateStructSize32(0x44, MotionData);
#pragma endregion

template <typename T>
struct ZUNAbsRel {
    T absolute;
    T relative;
};
/*
enum InterpMode {
    Linear = 0,
    AccelerateSlow = 1,
    Accelerate = 2,
    AccelerateFast = 3,
    DecelerateSlow = 4,
    Decelerate = 5,
    DecelerateFast = 6,
    ConstantVelocity = 7,
    Bezier = 8,
    AccelDecelSlow = 9,
    AccelDecel = 10,
    AccelDecelFast = 11,
    DecelAccelSlow = 12,
    DecelAccel = 13,
    DecelAccelFast = 14,
};
*/

// 0x402FB0
dllexport gnu_noinline float vectorcall __interp_inner_thing(int32_t mode, float current_time, float end_time) asm_symbol_rel(0x402FB0);
dllexport gnu_noinline float vectorcall __interp_inner_thing(int32_t mode, float current_time, float end_time) {
    float value = current_time;
    if (end_time == 0.0f) {
        goto interp_final;
    }
    value /= end_time;
    switch (mode) {
        case AccelerateSlow: // 1
            value = value * value;
        default: // linear
            return value;
        case DecelerateSlow: // 4
            value = 1.0f - value;
            value = value * value;
            value = 1.0f - value;
            return value;
        case Accelerate: // 2
            value = value * value * value;
            return value;
        case Decelerate: // 5
            value = 1.0f - value;
            value = value * value * value;
            value = 1.0f - value;
            return value;
        case AccelerateFast: // 3
            value = value * value * value * value;
            return value;
        case DecelerateFast: // 6
            value = 1.0f - value;
            value = value * value * value * value;
            value = 1.0f - value;
            return value;
        case AccelDecelSlow: // 9
            value += value;
            if (value < 1.0f) {
                value = value * value;
                return value * 0.5f;
            } else {
                value = 2.0f - value;
                value = value * value;
                value = 2.0f - value;
                return value * 0.5f;
            }
        case DecelAccelSlow: // 12
            value += value;
            if (value < 1.0f) {
                value = 1.0f - value;
                value = value * value;
                return 0.5f - value * 0.5f;
            } else {
                value = value - 1.0f;
                value = value * value;
                return 0.5f + value * 0.5f;
            }
        case AccelDecel: // 10
            value += value;
            if (value < 1.0f) {
                value = value * value * value;
                return value * 0.5f;
            } else {
                value = 2.0f - value;
                value = value * value * value;
                value = 2.0f - value;
                return value * 0.5f;
            }
        case DecelAccel: // 13
            value += value;
            if (value < 1.0f) {
                value = 1.0f - value;
                value = value * value * value;
                return 0.5f - value * 0.5f;
            } else {
                value = value - 1.0f;
                value = value * value * value;
                return 0.5f + value * 0.5f;
            }
        case AccelDecelFast: // 11
            value += value;
            if (value < 1.0f) {
                value = value * value * value * value;
                return value * 0.5f;
            } else {
                value = 2.0f - value;
                value = value * value * value * value;
                value = 2.0f - value;
                return value * 0.5f;
            }
        case DecelAccelFast: // 14
            value += value;
            if (value < 1.0f) {
                value = 1.0f - value;
                value = value * value * value * value;
                return 0.5f - value * 0.5f;
            } else {
                value = value - 1.0f;
                value = value * value * value * value;
                return 0.5f + value * 0.5f;
            }
        case DecelerateSine: // 18
            return zsinf(value * PI_f * 0.5f);
        case AccelerateSine: // 19
            return 1.0f - zsinf(value * PI_f * 0.5f + HALF_PI_f);
        case DecelAccelSine: // 20
            value += value;
            if (1.0f > value) {
                return zsinf(value * PI_f * 0.5f) * 0.5f;
            } else {
                return (1.0f - zsinf(value * PI_f * 0.5f)) * 0.5f + 0.5f;
            }
        case AccelDecelSine: // 21
            value += value;
            if (1.0f > value) {
                return (1.0f - zsinf(value * PI_f * 0.5f + HALF_PI_f)) * 0.5f;
            } else {
                value = value - 1.0f;
                return zsinf(value * PI_f * 0.5f) * 0.5f + 0.5f;
            }
        case AccelParabolaA: // 22
            value = value - 0.25f;
            value = (value * value / (9.0f / 16.0f) - 1.0f / 9.0f) / (8.0f / 9.0f);
            return value;
        case AccelParabolaB: // 23
            value = value - 0.3f;
            value = (value * value / 0.49f - 9.0f / 49.0f) / (40.0f / 49.0f);
            return value;
        case AccelParabolaC: // 24
            value = value - 0.35f;
            value = (value * value / 0.4225f - 49.0f / 169.0f) / (120.0f / 169.0f);
            return value;
        case AccelParabolaD: // 25
            value = value - 0.38f;
            value = (value * value / 0.3844f - 361.0f / 961.0f) / (600.0f / 961.0f);
            return value;
        case AccelParabolaE: // 26
            value = value - 0.4f;
            value = (value * value / 0.36f - 4.0f / 9.0f) / (5.0f / 9.0f);
            return value;
        case DecelParabolaA: // 27
            value = 1.0f - value;
            value = value - 0.25f;
            value = (value * value / (9.0f / 16.0f) - 1.0f / 9.0f) / (8.0f / 9.0f);
            value = 1.0f - value;
            return value;
        case DecelParabolaB: // 28
            value = 1.0f - value;
            value = value - 0.3f;
            value = (value * value / 0.49f - 9.0f / 49.0f) / (40.0f / 49.0f);
            value = 1.0f - value;
            return value;
        case DecelParabolaC: // 29
            value = 1.0f - value;
            value = value - 0.35f;
            value = (value * value / 0.4225f - 49.0f / 169.0f) / (120.0f / 169.0f);
            value = 1.0f - value;
            return value;
        case DecelParabolaD: // 30
            value = 1.0f - value;
            value = value - 0.38f;
            value = (value * value / 0.3844f - 361.0f / 961.0f) / (600.0f / 961.0f);
            value = 1.0f - value;
            return value;
        case DecelParabolaE: // 31
            value = 1.0f - value;
            value = value - 0.4f;
            value = (value * value / 0.36f - 4.0f / 9.0f) / (5.0f / 9.0f);
            value = 1.0f - value;
            return value;
        case ForceFinal: interp_final: // 16
            return 1.0f;
        case ForceInitial: // 15
            return 0.0f;
    }
}

template <typename T>
struct ZUNInterp { //       0x58    0x44    0x30
    //                      T3      T2      T1
    T initial_value; //     0x0     0x0     0x0
    T final_value; //       0xC     0x8     0x4
    T bezier1; //           0x18    0x10    0x8
    T bezier2; //           0x24    0x18    0xC
    T current; //           0x30    0x20    0x10
    Timer time; //          0x3C    0x28    0x14
    int32_t end_time; //    0x50    0x3C    0x28
    int32_t mode; //        0x54    0x40    0x2C

    inline ZUNInterp<T>() : end_time(0) {}

    // float: 0x41F600
    // Float2: 0x439600
    // Float3: 0x405A00
    // ZUNAngle: 0x47CBF0
    dllexport gnu_noinline void set_end_time(int32_t time) {
        this->end_time = time;
    }
    
    // float: 0x41B790
    // Float2: 0x4395C0
    dllexport gnu_noinline void reset_end_time() {
        this->end_time = 0;
    }

    // float: 0x41F630
    // Float2: 0x439690
    // Float3: 0x405A10
    // ZUNAngle: 0x47CC40
    dllexport gnu_noinline void set_mode(int32_t mode) {
        this->mode = mode;
    }

    // float: 0x41F620
    // Float2: 0x439670
    // Float3: 0x405A20
    // ZUNAngle: 0x47CC30
    dllexport gnu_noinline void set_initial_value(const T& value) {
        this->initial_value = value;
    }

    // float: 0x41F610
    // Float2: 0x439650
    // Float3: 0x405A40
    // ZUNAngle: 0x47CC20
    dllexport gnu_noinline void set_final_value(const T& value) {
        this->final_value = value;
    }

    // float: 0x429A70
    // Float3: 0x405A60
    // ZUNAngle: 0x47CC10
    dllexport gnu_noinline void set_bezier1(const T& value) {
        this->bezier1 = value;
    }

    // float: 0x429A60
    // Float3: 0x405A80
    // ZUNAngle: 0x47CC00
    dllexport gnu_noinline void set_bezier2(const T& value) {
        this->bezier2 = value;
    }

    // float: 0x41F5D0
    // Float2: 0x4395D0
    // ZUNAngle: 0x47CBC0
    dllexport gnu_noinline void reset_timer() {
        this->time.reset();
    }
    
    // int: 0x47CF40
    // float: 0x41F640
    // Float2: 0x4396A0
    // ZUNAngle: 0x47CC50
    // StageSky: 0x41EFA0
    dllexport T vectorcall step() {
        int32_t end_time = this->end_time;
        if (end_time > 0) {
            this->time.increment();
            end_time = this->end_time;
            if (this->time >= end_time) {
                this->time.set(end_time);
                goto TimeEnd;
            }
        } else if (end_time == 0) {
TimeEnd:
            int32_t mode = this->mode;
            if (mode != ConstantVelocity && mode != ConstantAccel) {
                return this->final_value;
            } else {
                return this->initial_value;
            }
        }
        int32_t mode = this->mode;
        if (mode == ConstantVelocity) { // 7
            // Final value is per-tick velocity
            return this->current = this->initial_value = this->initial_value + this->final_value;
        }
        if (mode == ConstantAccel) { // 17
            // Bezier2 is per-tick velocity
            // Final value is per-tick acceleration
            T temp = this->bezier2;
            this->bezier2 = temp + this->final_value;
            return this->current = this->initial_value = this->initial_value + temp;
        }
        float current_time = this->time.current_f;
        float end_time_f = end_time;
        if (mode == Bezier) { // 8
            float t = current_time / end_time_f;

            float t_plus_one = t + 1.0f;
            float two_t = t + t;
            float t_minus_one = t - 1.0f;
            float one_minus_t = 1.0f - t;
            float two_t_plus_one = two_t + 1.0f;

            float initial_factor = t_minus_one * t_minus_one * two_t_plus_one;
            float final_factor = (3.0f - two_t) * t * t;
            float bezier1_factor = one_minus_t * one_minus_t * t;
            float bezier2_factor = t_minus_one * t * t;

            T value = this->initial_value * initial_factor;
            value = value + this->final_value * final_factor;
            value = value + this->bezier1 * bezier1_factor;
            value = value + this->bezier2 * bezier2_factor;
            return this->current = value;
        }
        else {
            float interp_value = __interp_inner_thing(mode, current_time, end_time_f);
            return this->current = lerp(this->initial_value, this->final_value, interp_value);
        }
    }

    forceinline void __initialize_but_ignores_bezier(int32_t end_time, int32_t mode, const T& initial_value, const T& final_value) {
        clang_forceinline this->set_end_time(end_time);
        clang_forceinline this->set_mode(mode);
        clang_forceinline this->set_initial_value(initial_value);
        clang_forceinline this->set_final_value(final_value);
        clang_forceinline this->reset_timer();
    }

    forceinline void initialize(int32_t end_time, int32_t mode, const T& initial_value, const T& final_value) {
        const T zero = {};
        this->set_end_time(end_time);
        this->set_mode(mode);
        this->set_bezier1(zero);
        this->set_bezier2(zero);
        this->set_initial_value(initial_value);
        this->set_final_value(final_value);
        this->reset_timer();
    }

    forceinline void initialize_bezier(int32_t end_time, int32_t mode, const T& initial_value, const T& final_value, const T& bezier1_value, const T& bezier2_value) {
        this->set_end_time(end_time);
        this->set_mode(mode);
        this->set_bezier1(bezier1_value);
        this->set_bezier2(bezier2_value);
        this->set_initial_value(initial_value);
        this->set_final_value(final_value);
        this->reset_timer();
    }
};
#pragma region // ZUNInterp Validation
ValidateFieldOffset32(0x0, ZUNInterp<float>, initial_value);
ValidateFieldOffset32(0x4, ZUNInterp<float>, final_value);
ValidateFieldOffset32(0x8, ZUNInterp<float>, bezier1);
ValidateFieldOffset32(0xC, ZUNInterp<float>, bezier2);
ValidateFieldOffset32(0x10, ZUNInterp<float>, current);
ValidateFieldOffset32(0x14, ZUNInterp<float>, time);
ValidateFieldOffset32(0x28, ZUNInterp<float>, end_time);
ValidateFieldOffset32(0x2C, ZUNInterp<float>, mode);
ValidateStructSize32(0x30, ZUNInterp<float>);
ValidateFieldOffset32(0x0, ZUNInterp<Float2>, initial_value);
ValidateFieldOffset32(0x8, ZUNInterp<Float2>, final_value);
ValidateFieldOffset32(0x10, ZUNInterp<Float2>, bezier1);
ValidateFieldOffset32(0x18, ZUNInterp<Float2>, bezier2);
ValidateFieldOffset32(0x20, ZUNInterp<Float2>, current);
ValidateFieldOffset32(0x28, ZUNInterp<Float2>, time);
ValidateFieldOffset32(0x3C, ZUNInterp<Float2>, end_time);
ValidateFieldOffset32(0x40, ZUNInterp<Float2>, mode);
ValidateStructSize32(0x44, ZUNInterp<Float2>);
ValidateFieldOffset32(0x0, ZUNInterp<Float3>, initial_value);
ValidateFieldOffset32(0xC, ZUNInterp<Float3>, final_value);
ValidateFieldOffset32(0x18, ZUNInterp<Float3>, bezier1);
ValidateFieldOffset32(0x24, ZUNInterp<Float3>, bezier2);
ValidateFieldOffset32(0x30, ZUNInterp<Float3>, current);
ValidateFieldOffset32(0x3C, ZUNInterp<Float3>, time);
ValidateFieldOffset32(0x50, ZUNInterp<Float3>, end_time);
ValidateFieldOffset32(0x54, ZUNInterp<Float3>, mode);
ValidateStructSize32(0x58, ZUNInterp<Float3>);
#pragma endregion

template <typename T, typename E>
struct ZUNInterpExImpl { //                 0x68    0x50
    static inline constexpr size_t AXIS_COUNT = sizeof(T) / sizeof(E);
    T current; //                       0x0     0x0
    T initial_value; //                 0xC     0x8
    T final_value; //                   0x18    0x10
    T bezier1; //                       0x24    0x18
    T bezier2; //                       0x30    0x20
    Timer time; //                      0x3C    0x28
    int32_t end_time; //                0x50    0x3C
    int32_t axis_modes[AXIS_COUNT]; //  0x54    0x40
    int32_t combined_mode; //           0x60    0x48
    union {
        uint32_t flags; //              0x64    0x4C
        struct {
            uint32_t interp_per_axis : 1; // 1
        };
    };

    inline ZUNInterpExImpl<T, E>() : end_time(0) {}

    // Float3: 0x439940
    dllexport gnu_noinline void set_end_time(int32_t time) {
        this->end_time = time;
    }

    // Float3: 0x439900
    dllexport gnu_noinline void reset_end_time() {
        this->end_time = 0;
    }

    // Float3: 0x4399B0
    dllexport gnu_noinline void set_initial_value(const T& value) {
        this->initial_value = value;
    }

    // Float3: 0x439990
    dllexport gnu_noinline void set_final_value(const T& value) {
        this->final_value = value;
    }

    // Float3: 0x439970
    dllexport gnu_noinline void set_bezier1(const T& value) {
        this->bezier1 = value;
    }

    // Float3: 0x439950
    dllexport gnu_noinline void set_bezier2(const T& value) {
        this->bezier2 = value;
    }

    // Float3: 0x439910
    dllexport gnu_noinline void reset_timer() {
        this->time.reset();
    }
    
    // Float3: 0x4399D0
    dllexport gnu_noinline void set_axis_mode(int32_t axis, int32_t mode) {
        this->interp_per_axis = true;
        this->axis_modes[axis] = mode;
    }
    
    // Float3: 0x4399F0
    dllexport gnu_noinline void set_combined_mode(int32_t mode) {
        this->interp_per_axis = false;
        this->combined_mode = mode;
    }

    // Float3: 0x439A10
    dllexport T vectorcall step() {
        int32_t end_time = this->end_time;
        if (end_time > 0) {
            this->time.increment();
            end_time = this->end_time;
            if (this->time >= end_time) {
                this->time.set(end_time);
                goto TimeEnd;
            }
        } else if (end_time == 0) {
TimeEnd:
            int32_t mode = this->combined_mode;
            if (mode != ConstantVelocity && mode != ConstantAccel) {
                return this->final_value;
            } else {
                return this->initial_value;
            }
        }
        if (!this->interp_per_axis) {
            int32_t mode = this->combined_mode;
            if (mode == ConstantVelocity) { // 7
                // Final value is per-tick velocity
                return this->current = this->initial_value = this->initial_value + this->final_value;
            }
            if (mode == ConstantAccel) { // 17
                // Bezier2 is per-tick velocity
                // Final value is per-tick acceleration
                T temp = this->bezier2;
                this->bezier2 = temp + this->final_value;
                return this->current = this->initial_value = this->initial_value + temp;
            }
            float current_time = this->time.current_f;
            float end_time_f = end_time;
            if (mode == Bezier) { // 8
                float t = current_time / end_time_f;

                float t_plus_one = t + 1.0f;
                float two_t = t + t;
                float t_minus_one = t - 1.0f;
                float one_minus_t = 1.0f - t;
                float two_t_plus_one = two_t + 1.0f;

                float initial_factor = t_minus_one * t_minus_one * two_t_plus_one;
                float final_factor = (3.0f - two_t) * t * t;
                float bezier1_factor = one_minus_t * one_minus_t * t;
                float bezier2_factor = t_minus_one * t * t;

                T value = this->initial_value * initial_factor;
                value = value + this->final_value * final_factor;
                value = value + this->bezier1 * bezier1_factor;
                value = value + this->bezier2 * bezier2_factor;
                return this->current = value;
            }
            else {
                float interp_value = __interp_inner_thing(mode, current_time, end_time_f);
                return this->current = lerp(this->initial_value, this->final_value, interp_value);
            }
        }
        else {
            for (size_t i = 0; i < AXIS_COUNT; ++i) {
                E& current = ((E*)&this->current)[i];
                E& initial_value = ((E*)&this->initial_value)[i];
                E& final_value = ((E*)&this->final_value)[i];
                E& bezier1 = ((E*)&this->bezier1)[i];
                E& bezier2 = ((E*)&this->bezier2)[i];

                int32_t mode = this->axis_modes[i];
                if (mode == ConstantVelocity) { // 7
                    // Final value is per-tick velocity
                    current = initial_value = initial_value + final_value;
                }
                else if (mode == ConstantAccel) { // 17
                    // Bezier2 is per-tick velocity
                    // Final value is per-tick acceleration
                    E temp = bezier2;
                    bezier2 = temp + final_value;
                    current = initial_value = initial_value + temp;
                }
                else {
                    float end_time_f = end_time;
                    E final_val = final_value;
                    float current_time = this->time.current_f;
                    if (mode == Bezier) { // 8
                        float t = current_time / end_time_f;

                        float t_plus_one = t + 1.0f;
                        float two_t = t + t;
                        float t_minus_one = t - 1.0f;
                        float one_minus_t = 1.0f - t;
                        float two_t_plus_one = two_t + 1.0f;

                        float initial_factor = t_minus_one * t_minus_one * two_t_plus_one;
                        float final_factor = (3.0f - two_t) * t * t;
                        float bezier1_factor = one_minus_t * one_minus_t * t;
                        float bezier2_factor = t_minus_one * t * t;

                        E value = initial_value * initial_factor;
                        value = value + final_val * final_factor;
                        value = value + bezier1 * bezier1_factor;
                        value = value + bezier2 * bezier2_factor;
                        current = value;
                    }
                    else {
                        float interp_value = __interp_inner_thing(mode, current_time, end_time_f);
                        current = lerp(initial_value, final_val, interp_value);
                    }
                }
            }
            return this->current;
        }
    }
};
template <typename T> struct ZUNInterpEx;
template <> struct ZUNInterpEx<Float2> : ZUNInterpExImpl<Float2, float> {};
template <> struct ZUNInterpEx<Float3> : ZUNInterpExImpl<Float3, float> {};
template <> struct ZUNInterpEx<Int2> : ZUNInterpExImpl<Int2, int32_t> {};
template <> struct ZUNInterpEx<Int3> : ZUNInterpExImpl<Int3, int32_t> {};
#pragma region // ZUNInterpEx Validation
ValidateFieldOffset32(0x0, ZUNInterpEx<Float2>, current);
ValidateFieldOffset32(0x8, ZUNInterpEx<Float2>, initial_value);
ValidateFieldOffset32(0x10, ZUNInterpEx<Float2>, final_value);
ValidateFieldOffset32(0x18, ZUNInterpEx<Float2>, bezier1);
ValidateFieldOffset32(0x20, ZUNInterpEx<Float2>, bezier2);
ValidateFieldOffset32(0x28, ZUNInterpEx<Float2>, time);
ValidateFieldOffset32(0x3C, ZUNInterpEx<Float2>, end_time);
ValidateFieldOffset32(0x40, ZUNInterpEx<Float2>, axis_modes);
ValidateFieldOffset32(0x48, ZUNInterpEx<Float2>, combined_mode);
ValidateFieldOffset32(0x4C, ZUNInterpEx<Float2>, flags);
ValidateStructSize32(0x50, ZUNInterpEx<Float2>);
ValidateFieldOffset32(0x0, ZUNInterpEx<Float3>, current);
ValidateFieldOffset32(0xC, ZUNInterpEx<Float3>, initial_value);
ValidateFieldOffset32(0x18, ZUNInterpEx<Float3>, final_value);
ValidateFieldOffset32(0x24, ZUNInterpEx<Float3>, bezier1);
ValidateFieldOffset32(0x30, ZUNInterpEx<Float3>, bezier2);
ValidateFieldOffset32(0x3C, ZUNInterpEx<Float3>, time);
ValidateFieldOffset32(0x50, ZUNInterpEx<Float3>, end_time);
ValidateFieldOffset32(0x54, ZUNInterpEx<Float3>, axis_modes);
ValidateFieldOffset32(0x60, ZUNInterpEx<Float3>, combined_mode);
ValidateFieldOffset32(0x64, ZUNInterpEx<Float3>, flags);
ValidateStructSize32(0x68, ZUNInterpEx<Float3>);
#pragma endregion

#define SetInstr(value) \
current_instruction = (decltype(current_instruction))(value)

#define IndexInstr(offset) \
SetInstr((intptr_t)current_instruction + (offset))

#define ByteArg(number) \
(((uint8_t*)current_instruction->args)[(number)])

#define OneBitArg(number) \
(ByteArg(number) & 0b1)

#define ShortArg(number) \
(((int16_t*)current_instruction->args)[(number)])

#define UShortArg(number) \
(((uint16_t*)current_instruction->args)[(number)])

#define RawArg(number) \
(((EclArg*)current_instruction->args)[(number)])

#define IntArg(number) \
(((int32_t*)current_instruction->args)[(number)])

#define UIntArg(number) \
(((uint32_t*)current_instruction->args)[(number)])

#define FloatArg(number) \
(((float*)current_instruction->args)[(number)])

#define Float2Arg(number) \
(((Float2*)current_instruction->args)[(number)])

#define Float3Arg(number) \
(((Float3*)current_instruction->args)[(number)])

#define StringArg(offset) \
((const char*)(current_instruction->args + (offset)))

#define TypeArg(type, number) \
(((type*)current_instruction->args)[(number)])

typedef struct EclVM EclVM;

// size: 0x54
struct EnemyInitData {
    Float3 position; // 0x0
    int32_t score; // 0xC
    int32_t item_drop; // 0x10
    int32_t life; // 0x14
    int32_t mirrored; // 0x18
    int32_t __basic_anm_update; // 0x1C
    int32_t int_vars[4]; // 0x20
    float float_vars[8]; // 0x30
    int32_t parent_id; // 0x50
    // 0x54
};
#pragma region // EnemyInitData Validation
ValidateFieldOffset32(0x0, EnemyInitData, position);
ValidateFieldOffset32(0xC, EnemyInitData, score);
ValidateFieldOffset32(0x10, EnemyInitData, item_drop);
ValidateFieldOffset32(0x14, EnemyInitData, life);
ValidateFieldOffset32(0x18, EnemyInitData, mirrored);
ValidateFieldOffset32(0x1C, EnemyInitData, __basic_anm_update);
ValidateFieldOffset32(0x20, EnemyInitData, int_vars);
ValidateFieldOffset32(0x30, EnemyInitData, float_vars);
ValidateFieldOffset32(0x50, EnemyInitData, parent_id);
ValidateStructSize32(0x54, EnemyInitData);
#pragma endregion

// size: 0x10
struct EclInstruction {
    int32_t time; // 0x0
    int16_t opcode; // 0x4
    uint16_t offset_to_next; // 0x6
    uint16_t param_mask; // 0x8
    uint8_t difficulty_mask; // 0xA
    uint8_t param_count; // 0xB
    uint8_t stack_adjust; // 0xC
    padding_bytes(0x3); // 0xD
    unsigned char args[]; // 0x10
};
#pragma region // EclInstruction Validation
ValidateFieldOffset32(0x0, EclInstruction, time);
ValidateFieldOffset32(0x4, EclInstruction, opcode);
ValidateFieldOffset32(0x6, EclInstruction, offset_to_next);
ValidateFieldOffset32(0x8, EclInstruction, param_mask);
ValidateFieldOffset32(0xA, EclInstruction, difficulty_mask);
ValidateFieldOffset32(0xB, EclInstruction, param_count);
ValidateFieldOffset32(0xC, EclInstruction, stack_adjust);
ValidateFieldOffset32(0x10, EclInstruction, args);
ValidateStructSize32(0x10, EclInstruction);
#pragma endregion

#define EclStackCount 0x400
#define EclStackSize sizeof(EclStackItem[EclStackCount])

// size: 0x8
struct EclLocation {
    int32_t sub_index; // 0x0
    int32_t instruction_offset; // 0x4

    inline void reset() {
        this->instruction_offset = -1;
        this->sub_index = -1;
    }
};
#pragma region // EclLocation Validation
ValidateFieldOffset32(0x0, EclLocation, sub_index);
ValidateFieldOffset32(0x4, EclLocation, instruction_offset);
ValidateStructSize32(0x8, EclLocation);
#pragma endregion

typedef char EclSubName[64];

union EclRawValue {
    int32_t integer;
    float real;
    struct {
        char type;
        char type2;
    };
};

struct EclValue {
    char type;
    char type2;
    EclRawValue value;

    template<typename T>
    static forceinline T cast_to(const int32_t& value, const char& type) {
        if constexpr (std::is_same_v<T, int32_t> || std::is_same_v<T, uint32_t>) {
            if (type == 'f') {
                return bitcast<T>((float)value);
            } else {
                return value;
            }
        } else if constexpr (std::is_same_v<T, float>) {
            if (type != 'f' && type == 'i') {
                return (float)value;
            } else {
                return bitcast<float>(value);
            }
        }
    }

    template<typename T>
    forceinline T read() {
        return this->cast_to<T>(this->value.integer, this->type);
    }

    template<typename T>
    forceinline T read() const {
        return this->cast_to<T>(this->value.integer, this->type);
    }
};

using EclStackItem = EclRawValue;

// size: 0x1008
struct EclStack {

    union { // 0x0
        EclStackItem data[EclStackCount];
        uint8_t raw[EclStackSize];
    };
    int32_t pointer; // 0x1000
    int32_t base; // 0x1004

    template<typename T>
    forceinline T read_offset(int32_t offset) {
        return *based_pointer<T>(this->raw, offset);
    }
    template<typename T>
    forceinline T read_typed_offset(int32_t offset) {
        return based_pointer<EclValue>(this->raw, offset)->read<T>();
    }
    template<typename T>
    forceinline T read_typed_offset(int32_t offset) const {
        return based_pointer<EclValue>(this->raw, offset)->read<T>();
    }
    template<typename T>
    forceinline T read_local(int32_t offset, int32_t base_offset) {
        return this->read_offset<T>(base_offset + offset);
    }
    template<typename T>
    forceinline T read_local(T offset) {
        return this->read_local<T>((int32_t)offset, this->base);
    }
    /*
    template<typename T>
    forceinline T read_temp(int32_t offset, int32_t top_offset) {
        return this->read_offset<T>(top_offset - offset);
    }
    template<typename T>
    forceinline T read_temp(int32_t offset) {
        return this->read_temp<T>(offset, this->pointer);
    }
    */
    template<typename T>
    forceinline T read_temp(T index, int32_t top_offset);
    template<>
    forceinline int32_t read_temp<int32_t>(int32_t index, int32_t top_offset) {
        return this->read_typed_offset<int32_t>(top_offset + index * sizeof(EclValue));
    }
    template<>
    forceinline float read_temp<float>(float index, int32_t top_offset) {
        index *= -(float)sizeof(EclValue);
        return this->read_typed_offset<float>(top_offset - (int32_t)index);
    }

    template<typename T>
    forceinline T read_temp(T index) {
        return this->read_temp<T>(index, this->pointer);
    }

    template<typename T>
    forceinline T read_temp_index(int32_t index) const {
        return this->read_typed_offset<T>(this->pointer + index * sizeof(EclValue));
    }

    template<typename T>
    forceinline void write_offset(int32_t offset, const T& value) {
        *based_pointer<T>(this->raw, offset) = value;
    }
    template<typename T>
    forceinline void write_local(int32_t offset, const T& value, int32_t base_offset) {
        this->write_offset<T>(base_offset + offset, value);
    }
    template<typename T>
    forceinline void write_local(T offset, const T& value) {
        this->write_local<T>((int32_t)offset, value, this->base);
    }
    
    template<typename T>
    forceinline void write_temp(int32_t index, const T& value, int32_t top_offset) {
        this->write_offset<T>(top_offset - index * sizeof(int32_t), value);
    }
    template<typename T>
    forceinline void write_temp(int32_t index, const T& value) {
        this->write_temp<T>(index, value, this->pointer);
    }

    template<typename T>
    forceinline void write_typed_temp(int32_t index, const T& value, int32_t top_offset) {
        this->write_temp<T>(index * 2, value, top_offset);
        if constexpr (std::is_same_v<T, int32_t> || std::is_same_v<T, uint32_t>) {
            this->write_temp(index * 2 + 1, 'i', top_offset);
        } else if constexpr (std::is_same_v<T, float>) {
            this->write_temp(index * 2 + 1, 'f', top_offset);
        }
    }
    template<typename T>
    forceinline void write_typed_temp(int32_t index, const T& value) {
        this->write_typed_temp<T>(index, value, this->pointer);
    }
    
    template<typename T>
    forceinline T& ref_offset(int32_t offset) {
        return *based_pointer<T>(this->raw, offset);
    }
    template<typename T>
    forceinline T& ref_local(int32_t offset, int32_t base_offset) {
        return this->ref_offset<T>(base_offset + offset);
    }
    template<typename T>
    forceinline T& ref_local(T offset) {
        return this->ref_local<T>((int32_t)offset, this->base);
    }
    
    template<typename T>
    forceinline T& ref_temp(int32_t index, int32_t top_offset) {
        return this->ref_offset<T>(top_offset - index * sizeof(int32_t));
    }
    template<typename T>
    forceinline T& ref_temp(int32_t index) {
        return this->ref_temp<T>(index, this->pointer);
    }
    

    template<typename T>
    forceinline void push(int32_t& starting_offset, const T& value) {
        this->write_offset(starting_offset, value);
        starting_offset += sizeof(int32_t);
    }

    template<typename T>
    forceinline void push(const T& value) {
        this->push(this->pointer, value);
    }

    template<typename T>
    forceinline void push_cast(const T& value) {
        if constexpr (std::is_same_v<T, int32_t> || std::is_same_v<T, uint32_t>) {
            this->push('i');
        } else if constexpr (std::is_same_v<T, float>) {
            this->push('f');
        }
        this->push(value);
    }

    template<typename T>
    forceinline T pop(int32_t& starting_offset) {
        starting_offset -= sizeof(int32_t);
        return this->read_offset<T>(starting_offset);
    }
    template<typename T>
    forceinline T pop() {
        return this->pop<T>(this->pointer);
    }

    template<typename T>
    forceinline T pop_cast(int32_t& starting_offset) {
        return EclValue::cast_to<T>(this->pop<int32_t>(), this->pop<char>());
    }
    template<typename T>
    forceinline T pop_cast() {
        return this->pop_cast<T>(this->pointer);
    }
    
    template<typename L> requires(FunctionTraitsType<L>::arg_count == 1)
    void unary_op(const L& func) {
        using T = typename FunctionTraitsType<L>::template nth_arg_type<0>;
        using P = typename FunctionTraitsType<L>::ret_type;
        this->push_cast<P>(func(this->pop_cast<T>()));
    }

    template<typename L> requires(FunctionTraitsType<L>::arg_count == 2 && std::is_same_v<typename FunctionTraitsType<L>::template nth_arg_type<0>, typename FunctionTraitsType<L>::template nth_arg_type<1>>)
    void binary_op(const L& func) {
        using T1 = typename FunctionTraitsType<L>::template nth_arg_type<0>;
        using T2 = typename FunctionTraitsType<L>::template nth_arg_type<1>;
        using P = typename FunctionTraitsType<L>::ret_type;
        T1 right = this->pop_cast<T1>();
        T2 left = this->pop_cast<T2>();
        this->push_cast<P>(func(left, right));
    }

#if INCLUDE_PATCH_CODE
    template<typename L> requires(FunctionTraitsType<L>::arg_count == 1)
    void unary_op_fast(const L& func) {
        using T = typename FunctionTraitsType<L>::template nth_arg_type<0>;
        using P = typename FunctionTraitsType<L>::ret_type;

        this->read_typed_offset<int32_t>(top_offset + index * sizeof(EclValue));

        this->write_typed_temp<P>(0, func(this->read_temp_index<T>(0)));
    }

    template<typename L> requires(FunctionTraitsType<L>::arg_count == 2 && std::is_same_v<typename FunctionTraitsType<L>::template nth_arg_type<0>, typename FunctionTraitsType<L>::template nth_arg_type<1>>)
    void binary_op_fast(const L& func) {
        using T1 = typename FunctionTraitsType<L>::template nth_arg_type<0>;
        using T2 = typename FunctionTraitsType<L>::template nth_arg_type<1>;
        using P = typename FunctionTraitsType<L>::ret_type;
        T1 right = this->read_temp_index<T1>(0);
        T2 left = this->read_temp_index<T2>(-1);
        this->write_typed_temp<P>(1, func(left, right));
        this->pointer -= sizeof(EclValue);
    }
#endif

    inline ZUNResult enter_frame(int32_t size) {
        int32_t prev_pointer = this->pointer;
        size += prev_pointer;
        if (size >= EclStackSize) {
            return ZUN_ERROR;
        } else {
            this->pointer = size;
            this->push(this->base);
            this->base = prev_pointer;
            return ZUN_SUCCESS;
        }
    }

    ZUNResult leave_frame(void) {
        int32_t new_base = this->pop<int32_t>();
        int32_t new_pointer = this->base;
        this->base = new_base;
        this->pointer = new_pointer;
        if (new_pointer) {
            return ZUN_SUCCESS;
        }
        else {
            return ZUN_ERROR;
        }
    }

    inline void zero_contents() {
        zero_this();
    }

    inline EclStack() {
        this->zero_contents();
    }
};
#pragma region // EclStack Validation
ValidateFieldOffset32(0x0, EclStack, data);
ValidateFieldOffset32(0x1000, EclStack, pointer);
ValidateFieldOffset32(0x1004, EclStack, base);
ValidateStructSize32(0x1008, EclStack);
#pragma endregion

// size: 0x1208
struct EclContext {
    float time; // 0x0
    EclLocation location; // 0x4
    EclStack stack; // 0xC
    int32_t async_id; // 0x1014
    EclVM* vm; // 0x1018
    int32_t __int_101C; // 0x101C
    uint8_t difficulty_mask; // 0x1020
    padding_bytes(3);
    ZUNInterp<float> float_interps[8]; // 0x1024
    int32_t float_interp_stack_offsets[8]; // 0x11A4
    EclLocation float_interp_locations[8]; // 0x11C4
    union {
        uint32_t flags; // 0x1204
        struct {
            uint32_t __unknown_flag_A : 1;
        };
    };
    // 0x1208

    inline void set_float_interp_times(int32_t value) {
        this->float_interps[0].end_time = value;
        this->float_interps[1].end_time = value;
        this->float_interps[2].end_time = value;
        this->float_interps[3].end_time = value;
        this->float_interps[4].end_time = value;
        this->float_interps[5].end_time = value;
        this->float_interps[6].end_time = value;
        this->float_interps[7].end_time = value;
    }

    inline EclInstruction* get_instruction(int32_t sub_index, int32_t instruction_offset);

    inline EclInstruction* get_instruction(const EclLocation& location) {
        return this->get_instruction(location.sub_index, location.instruction_offset);
    }

    // 0x48DBE0
    dllexport EclInstruction* thiscall EclContext::get_current_instruction() asm_symbol_rel(0x48DBE0) {
        int32_t instr_offset = this->location.instruction_offset;
        if (instr_offset != -1) {
            int32_t sub_index = this->location.sub_index;
            if (sub_index != -1) {
                return this->get_instruction(sub_index, instr_offset);
            }
        }
        return NULL;
    }

    inline void step_float_interps();

    forceinline int32_t thiscall get_int_arg(int32_t index, EclInstruction* current_instruction);

    // 0x48D4F0
    dllexport gnu_noinline int32_t thiscall get_int_arg(int32_t index) asm_symbol_rel(0x48D4F0);

    forceinline float vectorcall get_float_arg(int32_t index, EclInstruction* current_instruction);

private:
    // 0x48D5A0
    dllexport gnu_noinline float vectorcall get_float_arg(int, int32_t index) asm_symbol_rel(0x48D5A0);
public:
    forceinline float get_float_arg(int32_t index) {
        return this->get_float_arg(UNUSED_DWORD, index);
    }

    forceinline int32_t thiscall get_int_arg_pop(int32_t index, EclInstruction* current_instruction);

    forceinline int32_t thiscall get_int_arg_pop(int32_t index);

    forceinline float vectorcall get_float_arg_pop(int32_t index, EclInstruction* current_instruction);

    forceinline float vectorcall get_float_arg_pop(int32_t index);

    forceinline int32_t thiscall parse_int_as_arg_pop(int32_t index, int32_t value, EclInstruction* current_instruction);

    // 0x48D690
    dllexport gnu_noinline int32_t thiscall parse_int_as_arg_pop(int32_t index, int32_t value) asm_symbol_rel(0x48D690);

    forceinline float vectorcall parse_float_as_arg_pop(int32_t index, float value, EclInstruction* current_instruction);

    inline float vectorcall parse_float_as_arg_pop(int32_t index, float value);

    forceinline int32_t* thiscall get_int_ptr_arg(int32_t index, EclInstruction* current_instruction);

    // 0x48D750
    dllexport gnu_noinline int32_t* thiscall get_int_ptr_arg(int32_t index = UNUSED_DWORD) asm_symbol_rel(0x48D750);

    forceinline float* thiscall get_float_ptr_arg(int32_t index, EclInstruction* current_instruction);

    // 0x48D7C0
    dllexport gnu_noinline float* thiscall get_float_ptr_arg(int32_t index) asm_symbol_rel(0x48D7C0);

    forceinline int32_t thiscall parse_int_as_arg(int32_t index, int32_t value, EclInstruction* current_instruction);

    forceinline int32_t thiscall parse_int_as_arg(int32_t index, int32_t value);

    forceinline float parse_float_as_arg(int32_t index, float value, EclInstruction* current_instruction);

    forceinline float parse_float_as_arg(int32_t index, float value);

    // 0x42CCC0
    dllexport gnu_noinline EclContext() noexcept(true) {}

    // 0x48B030
    dllexport gnu_noinline ZUNResult thiscall call(EclContext* new_context, int32_t va_index, int32_t = UNUSED_DWORD) asm_symbol_rel(0x48B030);

private:
    // 0x48B3A0
    dllexport gnu_noinline ZUNResult vectorcall low_ecl_run(float, float current_gamespeed) asm_symbol_rel(0x48B3A0);

public:
    forceinline ZUNResult low_ecl_run(float current_gamespeed) {
        return this->low_ecl_run(UNUSED_FLOAT, current_gamespeed);
    }

#if INCLUDE_PATCH_CODE
    inline void basic_call(EclContext* new_context, const char* sub_name);
#endif
};
#pragma region // EclContext Validation
ValidateFieldOffset32(0x0, EclContext, time);
ValidateFieldOffset32(0x4, EclContext, location);
ValidateFieldOffset32(0xC, EclContext, stack);
ValidateFieldOffset32(0x1014, EclContext, async_id);
ValidateFieldOffset32(0x1018, EclContext, vm);
ValidateFieldOffset32(0x101C, EclContext, __int_101C);
ValidateFieldOffset32(0x1024, EclContext, float_interps);
ValidateFieldOffset32(0x11A4, EclContext, float_interp_stack_offsets);
ValidateFieldOffset32(0x11C4, EclContext, float_interp_locations);
ValidateFieldOffset32(0x1204, EclContext, flags);
ValidateStructSize32(0x1208, EclContext);
#pragma endregion

using BulletEffectType = enum BulletEffectType : uint32_t;

// size: 0x2C
struct BulletEffectArgs {
    float float_values[4]; // 0x0
    int32_t int_values[4]; // 0x10
    BulletEffectType type; // 0x20
    int32_t async; // 0x24
    const char* string; // 0x28
    // 0x2C
};
#pragma region // BulletEffectArgs Validation
ValidateFieldOffset32(0x0, BulletEffectArgs, float_values);
ValidateFieldOffset32(0x10, BulletEffectArgs, int_values);
ValidateFieldOffset32(0x20, BulletEffectArgs, type);
ValidateFieldOffset32(0x24, BulletEffectArgs, async);
ValidateFieldOffset32(0x28, BulletEffectArgs, string);
ValidateStructSize32(0x2C, BulletEffectArgs);
#pragma endregion

static inline constexpr int32_t BULLET_EFFECT_MAX = 24;

// size: 0x488
struct ShooterData {
    int32_t type; // 0x0
    int32_t color; // 0x4
    Float3 position; // 0x8
    float angle1; // 0x14
    float angle2; // 0x18
    float speed1; // 0x1C
    float speed2; // 0x20
    float distance; // 0x24
    BulletEffectArgs effects[BULLET_EFFECT_MAX]; // 0x28
    float width; // 0x448
    unknown_fields(0xC); // 0x44C
    int32_t start_time; // 0x458
    int32_t __transform_A; // 0x45C
    int32_t duration; // 0x460
    int32_t __transform_B; // 0x464
    int32_t __laser_flags; // 0x468
    int16_t count1; // 0x46C
    int16_t count2; // 0x46E
    uint16_t aim_mode; // 0x470
    unknown_fields(0x2); // 0x472
    union {
        uint32_t flags; // 0x474
        struct {
            uint32_t : 5;
            uint32_t play_sound_on_spawn : 1;
        };
    };
    int32_t shoot_sound; // 0x478
    int32_t transform_sound; // 0x47C
    int32_t start_transform; // 0x480
    int __dword_484; // 0x484
    // 0x488

    inline void zero_contents() {
        zero_this();
    }

    inline ShooterData() {
        this->zero_contents();
        this->transform_sound = -1;
    }

    inline ShooterData(int) {}
};
#pragma region // ShooterData Validation
ValidateFieldOffset32(0x0, ShooterData, type);
ValidateFieldOffset32(0x4, ShooterData, color);
ValidateFieldOffset32(0x8, ShooterData, position);
ValidateFieldOffset32(0x14, ShooterData, angle1);
ValidateFieldOffset32(0x18, ShooterData, angle2);
ValidateFieldOffset32(0x1C, ShooterData, speed1);
ValidateFieldOffset32(0x20, ShooterData, speed2);
ValidateFieldOffset32(0x24, ShooterData, distance);
ValidateFieldOffset32(0x28, ShooterData, effects);
ValidateFieldOffset32(0x448, ShooterData, width);
ValidateFieldOffset32(0x458, ShooterData, start_time);
ValidateFieldOffset32(0x45C, ShooterData, __transform_A);
ValidateFieldOffset32(0x460, ShooterData, duration);
ValidateFieldOffset32(0x464, ShooterData, __transform_B);
ValidateFieldOffset32(0x468, ShooterData, __laser_flags);
ValidateFieldOffset32(0x46C, ShooterData, count1);
ValidateFieldOffset32(0x46E, ShooterData, count2);
ValidateFieldOffset32(0x470, ShooterData, aim_mode);
ValidateFieldOffset32(0x474, ShooterData, flags);
ValidateFieldOffset32(0x478, ShooterData, shoot_sound);
ValidateFieldOffset32(0x47C, ShooterData, transform_sound);
ValidateFieldOffset32(0x480, ShooterData, start_transform);
ValidateFieldOffset32(0x484, ShooterData, __dword_484);
ValidateStructSize32(0x488, ShooterData);
#pragma endregion

union EnemyID {
    uint32_t raw;

    inline constexpr operator uint32_t() const {
        return this->raw;
    }
    template<typename T> requires(std::is_integral_v<T>)
        inline constexpr EnemyID& operator=(const T& raw) {
        this->raw = raw;
        return *this;
    }

    // 0x42E0C0
    dllexport gnu_noinline Enemy* thiscall get_enemy_ptr() asm_symbol_rel(0x42E0C0);
};

static inline constexpr uint32_t MAX_CALLBACKS = 8;
static inline constexpr uint32_t LAST_CALLBACK_INDEX = MAX_CALLBACKS - 1;

// size: 0x88
struct EnemyCallback {
    int32_t life; // 0x0
    int32_t time; // 0x4
    EclSubName life_sub; // 0x8
    EclSubName time_sub; // 0x48
    // 0x88

    inline void initialize() {
        this->life = -1;
        this->time = -1;
        this->life_sub[0] = '\0';
    }

    inline void set(int32_t life, int32_t time, const char* sub_name) {
        this->life = life;
        if (life >= 0) {
            this->time = time;
            if (sub_name) {
                byteloop_strcpy(this->life_sub, sub_name);
                byteloop_strcpy(this->time_sub, sub_name);
            } else {
                this->life_sub[0] = '\0';
                this->time_sub[0] = '\0';
            }
        }
    }

    inline void set_life_sub(const char* sub_name) {
        if (sub_name) {
            byteloop_strcpy(this->life_sub, sub_name);
        } else {
            this->life_sub[0] = '\0';
        }
    }

    inline void set_time_sub(const char* sub_name) {
        if (sub_name) {
            byteloop_strcpy(this->time_sub, sub_name);
        } else {
            this->time_sub[0] = '\0';
        }
    }

#if INCLUDE_PATCH_CODE
    inline void set_interrupt(uint32_t slot, const char* sub_name) {
        this->life = -1;
        this->time = -1;
        byteloop_strcpy((&this->life_sub)[slot], sub_name);
    }

    inline const char* get_interrupt(uint32_t slot) {
        return (&this->life_sub)[slot];
    }
#endif
};

typedef struct AbilityShop AbilityShop;
extern "C" {
    // 0x4CF2A4
    externcg AbilityShop* ABILITY_SHOP_PTR cgasm("_ABILITY_SHOP_PTR");
}

typedef struct BombBase BombBase;
extern "C" {
    // 0x4CF2B8
    externcg BombBase* BOMB_PTR cgasm("_BOMB_PTR");
}

// size: 0xA8
struct BombBase : ZUNTask {
    // void* vftable; // 0x0
    // ZUNTask base; // 0x4
    unknown_fields(0x4); // 0x10
    Float3 __float3_14; // 0x14
    unknown_fields(0x4); // 0x20
    Float3 __float3_24; // 0x24 (only 0x2C is know so far, but it's Z rotation)
    BOOL active; // 0x30
    Timer __timer_34; // 0x34
    unknown_fields(0x14); // 0x48
    AnmID __vm_id_5C; // 0x5C
    AnmID __vm_id_60; // 0x60
    AnmID __vm_id_64; // 0x64
    int __int_68; // 0x68
    unknown_fields(0x4); // 0x6C
    void* __ptr_70; // 0x70
    float __float_74; // 0x74
    float __float_78; // 0x78
    Timer __timer_7C; // 0x7C
    int __int_90; // 0x90
    Float3 __float3_94; // 0x94
    int __dword_A0; // 0xA0
    int __int_A4; // 0xA4
    // 0xA8

    inline void zero_contents() {
        zero_this();
    }

    inline BombBase() {
        this->zero_contents();
        this->__unknown_task_flag_A = true;
    }

    inline bool is_active() {
        return this->active == TRUE;
    }

    // 0x420360
    dllexport gnu_noinline static ZUNResult start_bomb() asm_symbol_rel(0x420360);

    // 0x420420
    dllexport gnu_noinline static BOOL bomb_allowed() asm_symbol_rel(0x420420);


    // These probably weren't inline functions,
    // especially since it's just slightly different
    // statement ordering. But this makes the code
    // easier to read anyway.
    inline static bool check_for_bomb() {
        if (
            BOMB_PTR &&
            BOMB_PTR->bomb_allowed() &&
            INPUT_STATES[0].check_inputs_no_repeat(BUTTON_BOMB)
        ) {
            BOMB_PTR->start_bomb();
            return true;
        }
        return false;
    }
    inline static bool check_for_deathbomb() {
        if (
            BOMB_PTR &&
            INPUT_STATES[0].check_inputs_no_repeat(BUTTON_BOMB) &&
            BOMB_PTR->bomb_allowed()
        ) {
            BOMB_PTR->start_bomb();
            return true;
        }
        return false;
    }

    // Method 0
    // 0x41FC10
    dllexport gnu_noinline virtual ~BombBase() {
        this->__vm_id_5C.mark_tree_for_delete();
        this->__vm_id_60.mark_tree_for_delete();
        this->__vm_id_64.mark_tree_for_delete();
        
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);

        SAFE_FREE(this->__ptr_70);
    }

    // Method 4
    // 0x41FB80
    dllexport gnu_noinline virtual int thiscall activate() {
        return 0;
    }
    // Method 8
    // 0x41FB90
    dllexport gnu_noinline virtual int thiscall on_tick_impl() {
        return 0;
    }
    // Method C
    // 0x41FBA0
    dllexport gnu_noinline virtual int thiscall on_draw_impl() {
        return 0;
    }
    // Method 10
    // 0x41FBB0
    dllexport gnu_noinline virtual int32_t thiscall __method_10(Float3* position, Float2* size) {
        return 0;
    }
    // Method 14
    // 0x41FBC0
    dllexport gnu_noinline virtual int thiscall __method_14() {
        return 0;
    }
    // Method 18
    // 0x41FBD0
    dllexport gnu_noinline virtual void thiscall __method_18() {
    }

    // 0x41FD40
    dllexport gnu_noinline static BombBase* allocate() asm_symbol_rel(0x41FD40);

    // 0x420040
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_tick(void* ptr) {
        BombBase* self = (BombBase*)ptr;
        if (!ABILITY_SHOP_PTR) {
            if (self->__timer_34 < 0) {
                ++self->__timer_34;
            }
            if (self->active) {
                if (!self->on_tick_impl()) {
                    self->active = FALSE;
                    return UpdateFuncNext;
                }
                ++self->__timer_34;
            }
        }
        return UpdateFuncNext;
    }

    // 0x420160
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw(void* ptr) {
        BombBase* self = (BombBase*)ptr;
        self->on_draw_impl();
        if (self->__timer_7C <= 0) {
            self->__float_78 = -1.0f;
            return UpdateFuncNext;
        }
        if (self->__timer_7C <= 60) {
            // TODO
            --self->__timer_7C;
        }
        return UpdateFuncNext;
    }
};
#pragma region // BombBase Validation
ValidateVirtualFieldOffset32(0x4, BombBase, task_flags);
ValidateVirtualFieldOffset32(0x8, BombBase, on_tick_func);
ValidateVirtualFieldOffset32(0xC, BombBase, on_draw_func);
ValidateVirtualFieldOffset32(0x14, BombBase, __float3_14);
ValidateVirtualFieldOffset32(0x24, BombBase, __float3_24);
ValidateVirtualFieldOffset32(0x30, BombBase, active);
ValidateVirtualFieldOffset32(0x34, BombBase, __timer_34);
ValidateVirtualFieldOffset32(0x5C, BombBase, __vm_id_5C);
ValidateVirtualFieldOffset32(0x60, BombBase, __vm_id_60);
ValidateVirtualFieldOffset32(0x64, BombBase, __vm_id_64);
ValidateVirtualFieldOffset32(0x68, BombBase, __int_68);
ValidateVirtualFieldOffset32(0x70, BombBase, __ptr_70);
ValidateVirtualFieldOffset32(0x74, BombBase, __float_74);
ValidateVirtualFieldOffset32(0x78, BombBase, __float_78);
ValidateVirtualFieldOffset32(0x7C, BombBase, __timer_7C);
ValidateVirtualFieldOffset32(0x90, BombBase, __int_90);
ValidateVirtualFieldOffset32(0x94, BombBase, __float3_94);
ValidateVirtualFieldOffset32(0xA0, BombBase, __dword_A0);
ValidateVirtualFieldOffset32(0xA4, BombBase, __int_A4);
ValidateStructSize32(0xA8, BombBase);
#pragma endregion

// size: 0xDC
struct BombReimuAInner {
    AnmID __vm_id_0; // 0x0
    MotionData current_motion; // 0x4
    // 0x48

    Timer __timer_A4; // 0xA4
    Float3 __float3_B8; // 0xB8
    EnemyID __enemy_id_C4; // 0xC4
    Enemy* __enemy_C8; // 0xC8
    int __object_index; // 0xCC
    int32_t __damage_source_index_D0; // 0xD0
    // 0xD4
    float __float_D8; // 0xD8
    // 0xDC
};

// size: 0x14A0
struct BombReimuAData {
    BombReimuAInner inners[24]; // 0x0
    // 0x14A0

    inline void zero_contents() {
        zero_this();
    }

    // 0x4212A0
    dllexport gnu_noinline void thiscall __sub_4212A0() asm_symbol_rel(0x4212A0) {
        // TODO
    }
};

struct BombReimuA : BombBase {
    // Method 4
    // 0x421420
    dllexport gnu_noinline virtual int thiscall activate() {
        // TODO
        SOUND_MANAGER.play_sound(49);
        // TODO
        //++ENEMY_MANAGER_PTR->player_bomb_count;
        SAFE_FREE(this->__ptr_70);
        this->__ptr_70 = malloc(sizeof(BombReimuAData));
        memset(this->__ptr_70, 0, sizeof(BombReimuAData));
        // TODO
        return 0;
    }
    // Method 8
    // 0x421590
    dllexport gnu_noinline virtual int thiscall on_tick_impl() {
        // TODO
        if (this->__timer_34 >= 120) {
            // TODO
        }
        // TODO
        return 0;
    }
    // Method C
    // 0x422380
    dllexport gnu_noinline virtual int thiscall on_draw_impl() {
        return 1;
    }
    // Method 10
    // 0x422390
    dllexport gnu_noinline virtual int32_t thiscall __method_10(Float3* position, Float2* size) {
        return 0;
    }
    // Method 14
    // 0x4223A0
    dllexport gnu_noinline virtual int thiscall __method_14() {
        // TODO
        return 0;
    }
    // Method 18
    // 0x41FBD0
    dllexport gnu_noinline virtual void thiscall __method_18() {
        ((BombReimuAData*)this->__ptr_70)->__sub_4212A0();
        this->__vm_id_64.interrupt_tree(1);
        SAFE_FREE(this->__ptr_70);
        // TODO
        this->active = FALSE;
    }
};

struct BombMarisaA : BombBase {

};

struct BombSakuya : BombBase {

};

struct BombSanaeA : BombBase {

};

// 0x41FD40
dllexport gnu_noinline BombBase* BombBase::allocate() {
    BombBase* bomb_ptr;
    switch (GAME_MANAGER.globals.shottype_index()) {
        default:
            bomb_ptr = new BombReimuA();
            break;
        case 1:
            bomb_ptr = new BombMarisaA();
            break;
        case 2:
            bomb_ptr = new BombSakuya();
            break;
        case 3:
            bomb_ptr = new BombSanaeA();
            break;
    }
    UpdateFunc* update_func = new UpdateFunc(&on_tick, true, bomb_ptr);
    UpdateFuncRegistry::register_on_tick(update_func, 25);
    bomb_ptr->on_tick_func = update_func;
    update_func = new UpdateFunc(&on_draw, true, bomb_ptr);
    UpdateFuncRegistry::register_on_draw(update_func, 41);
    bomb_ptr->on_draw_func = update_func;
    bomb_ptr->__timer_34.reset();
    bomb_ptr->__timer_7C.reset();
    bomb_ptr->__float_78 = -1.0f;
    bomb_ptr->__float_74 = 0.0f;
    bomb_ptr->__dword_A0 = 0;
    bomb_ptr->__int_A4 = 0;
    BOMB_PTR = bomb_ptr;
    return bomb_ptr;
}

enum ItemID : int32_t {
    InvalidItem = 0,
    PowerItem = 1,
    PointItem = 2,
    BigPowerItem = 3,
    LifeFragmentItem = 4,
    LifeItem = 5,
    BombFragmentItem = 6,
    BombItem = 7,
    FItem = 8,
    Piv5Item = 9,
    Piv10Item = 10,
    Piv20Item = 11,
    Piv30Item = 12,
    Piv40Item = 13,
    Piv50Item = 14,
    Item15 = 15,
    Item16 = 16,
    Item17 = 17,
    Item18 = 18,
    Item19 = 19
};

typedef struct Item Item;
static inline Item* spawn_item(int32_t item_id, Float3* position, float angle, float speed, int32_t arg6);

// size: 0xC4
struct EnemyDrops {
    int32_t main_id; // 0x0
    int32_t extra_ids[20]; // 0x4
    int32_t limited_extra_ids[20]; // 0x54
    int32_t limited_end_time; // 0xA4
    Timer limited_timer; // 0xA8
    float width; // 0xBC
    float height; // 0xC0
    // 0xC4

    inline void zero_contents() {
        zero_this();
    }

    // 0x42D010
    dllexport gnu_noinline void set_extra_drop(int32_t index, int32_t id) asm_symbol_rel(0x42D010) {
        this->extra_ids[index - 1] = id;
    }

    // 0x42D020
    dllexport gnu_noinline void set_timed_extra_drop(int32_t index, int32_t id) asm_symbol_rel(0x42D020) {
        this->limited_extra_ids[index - 1] = id;
    }

    // 0x42D040
    dllexport gnu_noinline void set_timed_drop_time(int32_t time) asm_symbol_rel(0x42D040) {
        this->limited_end_time = time;
        this->limited_timer.reset();
    }

private:
    // 0x42D090
    dllexport gnu_noinline void vectorcall set_area(float, float width, float height) asm_symbol_rel(0x42D090) {
        this->width = width;
        this->height = height;
    }
public:
    inline void vectorcall set_area(float width, float height) {
        return this->set_area(UNUSED_FLOAT, width, height);
    }

    // 0x42D0B0
    dllexport gnu_noinline void set_main_drop(int32_t id) asm_symbol_rel(0x42D0B0) {
        this->main_id = id;
    }

    // 0x430510
    dllexport gnu_noinline void spawn_extra_items(Float3* position) asm_symbol_rel(0x430510) {

    }

    // 0x42D0C0
    dllexport void spawn_items(Float3* position) asm_symbol_rel(0x42D0C0) {
        if (int32_t main_drop = this->main_id) {
            spawn_item(main_drop, position, -HALF_PI_f, 2.2f, 0);
        }
        this->spawn_extra_items(position);
        this->main_id = 0;
    }

    // 0x42D110
    dllexport gnu_noinline void initialize() asm_symbol_rel(0x42D110) {
        this->zero_contents();
        this->height = 32.0f;
        this->width = 32.0f;
        this->limited_timer.reset();
    }

    inline void reset() {
        memset(this->extra_ids, 0, sizeof(EnemyDrops) - sizeof(this->main_id));
        this->height = 32.0f;
        this->width = 32.0f;
        this->main_id = 0;
        this->limited_timer.reset();
    }

    // 0x42D180
    dllexport gnu_noinline void reset_extra_drops() asm_symbol_rel(0x42D180) {
        memset(this->extra_ids, 0, sizeof(this->extra_ids) + sizeof(this->limited_extra_ids));
        this->limited_end_time = 0;
        this->limited_timer.reset();
    }
};

// size: 0x1C
struct EnemyLife {
    int32_t current; // 0x0, 0x4FF4, 0x6220
    int32_t maximum; // 0x4, 0x4FF8, 0x6224
    int32_t remaining_current_attack; // 0x8, 0x4FFC, 0x6228
    int32_t current_scaled_by_seven; // 0xC, 0x5000, 0x622C
    int32_t starting_value_for_next_attack; // 0x10, 0x5004, 0x6230
    int32_t total_damage_including_ignored; // 0x14, 0x5008, 0x6234
    union {
        uint32_t flags; // 0x18, 0x500C, 0x6238
        struct {
            uint32_t is_spell : 1; // 1
            uint32_t __unknown_flag_A : 1; // 2
        };
    };
    // 0x1C

    inline void initialize() {
        this->__unknown_flag_A = false;
        this->current = 0;
        this->maximum = 0;
        this->remaining_current_attack = 0;
        this->total_damage_including_ignored = 0;
    }

    // 0x42CF80
    dllexport gnu_noinline int32_t get_current() asm_symbol_rel(0x42CF80) {
        return this->current;
    }

    // 0x42CF90
    dllexport gnu_noinline void set_current_scaled(int32_t value) asm_symbol_rel(0x42CF90) {
        this->current_scaled_by_seven = value * 7;
    }

    // 0x42CFB0
    dllexport gnu_noinline void set_spell(int32_t value) asm_symbol_rel(0x42CFB0) {
        this->is_spell = value;
    }

    // 0x42CFD0
    dllexport gnu_noinline int32_t get_maximum() asm_symbol_rel(0x42CFD0) {
        return this->maximum;
    }

    // 0x42CFE0
    dllexport gnu_noinline void set_maximum(int32_t value) asm_symbol_rel(0x42CFE0) {
        this->maximum = value;
    }

    // 0x42CFF0
    dllexport gnu_noinline void set_current_remaining(int32_t value) asm_symbol_rel(0x42CFF0) {
        this->remaining_current_attack = value;
    }

    // 0x42D000
    dllexport gnu_noinline void set_current(int32_t value) asm_symbol_rel(0x42D000) {
        this->current = value;
    }

    inline void take_damage(int32_t damage, bool invulnerable) {
        if (!invulnerable) {
            this->total_damage_including_ignored += damage;
            if (this->is_spell) {
                this->current_scaled_by_seven -= damage;
                int32_t next_base = this->starting_value_for_next_attack;
                this->current = next_base + (this->current_scaled_by_seven - next_base * 7) / 7;
            } else {
                this->current -= damage;
            }
        } else {
            this->total_damage_including_ignored += damage;
        }
    }
};

// size: 0x1C
struct EnemyFogImpl {
    int32_t __int_0; // 0x0
    unknown_fields(0x4); // 0x4
    AnmID __anm_id_8; // 0x8
    AnmID* __anm_id_array_C; // 0xC
    void* __ptr_10; // 0x10
    void* __ptr_14; // 0x14
    void* __ptr_18; // 0x18
    // 0x1C

    // 0x41BE50
    dllexport gnu_noinline ~EnemyFogImpl() {
        this->__anm_id_8.mark_tree_for_delete();
        SAFE_FREE(this->__ptr_14);
        SAFE_FREE(this->__ptr_18);

        for (int32_t i = 0; i < this->__int_0 - 1; ++i) {
            this->__anm_id_array_C[i].mark_tree_for_delete();
        }

        SAFE_FREE(this->__anm_id_array_C);
        SAFE_FREE(this->__ptr_10);
    }
};
#pragma region // EnemyFogImpl Field Validation
ValidateFieldOffset32(0x0, EnemyFogImpl, __int_0);
ValidateFieldOffset32(0x8, EnemyFogImpl, __anm_id_8);
ValidateFieldOffset32(0xC, EnemyFogImpl, __anm_id_array_C);
ValidateFieldOffset32(0x10, EnemyFogImpl, __ptr_10);
ValidateFieldOffset32(0x14, EnemyFogImpl, __ptr_14);
ValidateFieldOffset32(0x18, EnemyFogImpl, __ptr_18);
ValidateStructSize32(0x1C, EnemyFogImpl);
#pragma endregion

// size: 0x1C
struct EnemyFog {
    EnemyFogImpl* fog_ptr; // 0x0
    unknown_fields(0x4); // 0x4
    float radius; // 0x8
    float __float_C; // 0xC
    D3DCOLOR color; // 0x10
    float __angle_14; // 0x14
    float __angle_18; // 0x18
    // 0x1C
};

typedef struct EnemyData EnemyData;

typedef int32_t fastcall ExtraDamageFunc(EnemyData* enemy_data, int32_t prev_damage);
typedef int32_t fastcall ExtraHitboxFunc(EnemyData* enemy_data);
typedef ZUNResult fastcall FuncSetFunc(EnemyData* enemy_data);

static inline constexpr size_t ENEMY_ANM_SLOTS = 16;
static inline constexpr size_t ENEMY_SHOOTER_SLOTS = 16;

// size: 0x5600
struct EnemyData {
    MotionData previous_motion; // 0x0, 0x122C
    MotionData current_motion; // 0x44, 0x1270
    ZUNAbsRel<MotionData> motion; // 0x88, 0x12B4
    Float2 hitbox_size; // 0x110, 0x133C
    Float2 collision_size; // 0x118, 0x1344
    float hitbox_rotation; // 0x120, 0x134C
    AnmID anm_vms[ENEMY_ANM_SLOTS]; // 0x124, 0x1350
    Float3 anm_positions[ENEMY_ANM_SLOTS]; // 0x164, 0x1390
    int32_t anm_vm_indices[ENEMY_ANM_SLOTS]; // 0x224, 0x1450
    int32_t anm_source_index; // 0x264, 0x1490
    int32_t anm_slot_0_source_index; // 0x268, 0x1494
    int32_t anm_slot_0_script; // 0x26C, 0x1498
    int32_t current_anm_script; // 0x270, 0x149C
    int32_t current_anm_pose; // 0x274, 0x14A0
    int32_t kill_id; // 0x278, 0x14A4
    int32_t anm_base_layer; // 0x27C, 0x14A8
    Float3 position_of_last_damage_source_to_hit; // 0x280, 0x14AC
    int32_t int_vars[4]; // 0x28C, 0x14B8
    float float_vars[8]; // 0x29C, 0x14C8
    Timer ecl_time; // 0x2BC, 0x14E8
    Timer boss_timer; // 0x2D0, 0x14FC
    float slowdown; // 0x2E4, 0x1510
    ZUNList<Enemy> global_list_node; // 0x2E8, 0x1514
    ZUNAbsRel<ZUNInterpEx<Float3>> position_interp; // 0x2F8, 0x1524
    ZUNInterp<float> angle_interp_absolute; // 0x3C8, 0x15F4
    ZUNInterp<float> speed_interp_absolute; // 0x3F8, 0x1624
    ZUNInterp<float> angle_interp_relative; // 0x428, 0x1654
    ZUNInterp<float> speed_interp_relative; // 0x458, 0x1684
    ZUNAbsRel<ZUNInterp<Float2>> orbit_radius_interp; // 0x488, 0x16B4
    ZUNAbsRel<ZUNInterp<Float2>> ellipse_interp; // 0x510, 0x173C
    ShooterData shooters[ENEMY_SHOOTER_SLOTS]; // 0x598, 0x17C4
    int32_t bullet_effect_indices[ENEMY_SHOOTER_SLOTS]; // 0x4E18, 0x6044
    Float3 shooter_offsets[ENEMY_SHOOTER_SLOTS]; // 0x4E58, 0x6084
    Float3 shooter_origins[ENEMY_SHOOTER_SLOTS]; // 0x4F18, 0x6144
    Float2 final_sprite_size; // 0x4FD8, 0x6204
    Float2 move_bounds_center; // 0x4FE0, 0x620C
    Float2 move_bounds_size; // 0x4FE8, 0x6214
    int32_t score; // 0x4FF0, 0x621C
    EnemyLife life; // 0x4FF4, 0x6220
    EnemyDrops drops; // 0x5010, 0x623C
    int32_t __int_50D4; // 0x50D4, 0x6300
    int32_t death_sound; // 0x50D8, 0x6304
    int32_t death_anm_script; // 0x50DC, 0x6308
    int32_t death_anm_index; // 0x50E0, 0x630C
    int32_t __int_50E4; // 0x50E4, 0x6310
    int __dword_50E8; // 0x50E8, 0x6314
    int32_t hit_sound; // 0x50EC, 0x6318
    Timer invulnerable_timer; // 0x50F0, 0x631C
    Timer no_collision_timer; // 0x5104, 0x6330
    Timer __timer_5118; // 0x5118, 0x6344
    float bomb_damage_multiplier; // 0x512C, 0x6358
    union {
        uint32_t flags_low; // 0x5130, 0x635C
        struct {
            uint32_t disable_hitbox : 1; // 1
            uint32_t disable_collision : 1; // 2
            uint32_t offscreen_immune_horizontal : 1; // 3
            uint32_t offscreen_immune_vertical : 1; // 4
            uint32_t invincible : 1; // 5
            uint32_t intangible : 1; // 6
            uint32_t __is_midboss : 1; // 7
            uint32_t no_delete : 1; // 8
            uint32_t always_delete : 1; // 9
            uint32_t grazable : 1; // 10
            uint32_t only_dialogue_delete : 1; // 11
            uint32_t delete_as_bullet : 1; // 12
            uint32_t rectangular_hitbox : 1; // 13
            uint32_t slowdown_immune : 1; // 14
            uint32_t __unknown_flag_E : 1; // 15
            uint32_t __unknown_flag_F : 1; // 16
            uint32_t __unknown_flag_G : 1; // 17
            uint32_t move_bounds_enable : 1; // 18
            uint32_t __unknown_flag_A : 1; // 19
            uint32_t mirrored : 1; // 20
            uint32_t __unknown_flag_I : 1; // 21
            uint32_t __damaged_this_frame : 1; // 22
            uint32_t __delete_related : 1; // 23 like is_boss, but skips something in the GUI code
            uint32_t is_boss : 1; // 24
            uint32_t __unknown_flag_L : 1; // 25
            uint32_t __unknown_flag_B : 1; // 26
            uint32_t __basic_anm_update : 1; // 27
            uint32_t homing_disable : 1; // 28
            uint32_t bomb_shield : 1; // 29
            uint32_t bomb_shield_active : 1; // 30
            uint32_t __unknown_flag_O : 1; // 31
            uint32_t __anm_related_flag_A : 1; // 32
        };
    };
    union {
        uint32_t flags_high; // 0x5134, 0x6360
        struct {
            uint32_t __anm_slowdown_immune : 1; // 1
            uint32_t : 1; // 2
            uint32_t __unknown_flag_P : 1; // 3
#if INCLUDE_PATCH_CODE
            uint32_t : 13; // padding
            uint32_t active_interrupt_slots : 8;
            uint32_t run_interrupt : 8;
#endif
        };
    };
    int32_t bombshield_on_anm; // 0x5138, 0x6364
    int32_t bombshield_off_anm; // 0x513C, 0x6368
    int32_t boss_id; // 0x5140, 0x636C
    float player_protect_radius_squared; // 0x5144, 0x6370
    EnemyCallback callbacks[MAX_CALLBACKS]; // 0x5148, 0x6374
    EclVM* vm; // 0x5588, 0x67B4
    EnemyFog fog; // 0x558C, 0x67B8
    EclSubName death_callback_sub; // 0x55A8, 0x67D4
    FuncSetFunc* func_set_func; // 0x55E8, 0x6814
    uint32_t __is_func_set_2; // 0x55EC, 0x6818
    ExtraDamageFunc* extra_damage_func; // 0x55F0, 0x681C
    ExtraHitboxFunc* extra_hitbox_func; // 0x55F4, 0x6820
    int32_t chapter; // 0x55F8, 0x6824
    int32_t chapter_spawn_weight; // 0x55FC, 0x6828
    // 0x5600, 0x682C

    inline Enemy* enemy() {
        return (Enemy*)this->vm;
    }

    inline EnemyData() {
        zero_this();
    }

    inline void initialize_callbacks() {
        this->callbacks[0].initialize();
        this->callbacks[1].initialize();
        this->callbacks[2].initialize();
        this->callbacks[3].initialize();
        this->callbacks[4].initialize();
        this->callbacks[5].initialize();
        this->callbacks[6].initialize();
        this->callbacks[7].initialize();
    }

    inline void initialize_anm_vm_slots() {
        this->anm_vm_indices[0] = -1;
        this->anm_vm_indices[1] = -1;
        this->anm_vm_indices[2] = -1;
        this->anm_vm_indices[3] = -1;
        this->anm_vm_indices[4] = -1;
        this->anm_vm_indices[5] = -1;
        this->anm_vm_indices[6] = -1;
        this->anm_vm_indices[7] = -1;
        this->anm_vm_indices[8] = -1;
        this->anm_vm_indices[9] = -1;
        this->anm_vm_indices[10] = -1;
        this->anm_vm_indices[11] = -1;
        this->anm_vm_indices[12] = -1;
        this->anm_vm_indices[13] = -1;
        this->anm_vm_indices[14] = -1;
        this->anm_vm_indices[15] = -1;
    }

    inline void set_anm_vm_slowdowns(const float& slowdown_value);

    inline void initialize(Enemy* enemy);

    // 0x42D1E0
    dllexport gnu_noinline MotionData& get_current_motion() asm_symbol_rel(0x42D1E0) {
        return this->current_motion;
    }

    inline Float3& get_position() {
        return this->get_current_motion().position;
    }

    // 0x42D1F0
    dllexport gnu_noinline EnemyLife& get_life_data() asm_symbol_rel(0x42D1F0) {
        return this->life;
    }

    forceinline bool get_mirror_flag() {
        return this->mirrored;
    }

    inline bool flags_allow_kill() {
        return !(this->is_boss | this->__delete_related | this->intangible | this->no_delete | this->only_dialogue_delete) ||
                this->always_delete;
    }

    inline bool has_active_hitbox() {
        return !(this->disable_hitbox | this->intangible);
    }

    inline bool hide_lifebar() {
        return (this->disable_hitbox | this->invincible | this->intangible) || this->invulnerable_timer > 0;
    }

    inline bool has_active_collision() {
        return !(this->disable_collision | this->intangible) && this->no_collision_timer <= 0;
    }

    inline bool is_invulnerable() {
        return this->invincible || this->invulnerable_timer > 0;
    }

    inline void enforce_move_bounds() {
        if (this->move_bounds_enable) {
            float x_limit_size = this->move_bounds_size.x * 0.5f;
            float x_limit_pos = this->move_bounds_center.x;
            float x_pos = this->current_motion.position.x;
            {
                float temp = x_limit_pos - x_limit_size;
                if (temp > x_pos) {
                    this->current_motion.position.x = temp;
                } else {
                    temp = x_limit_pos + x_limit_size;
                    if (x_pos > temp) {
                        this->current_motion.position.x = temp;
                    }
                }
            }
            float y_limit_size = this->move_bounds_size.y * 0.5f;
            float y_limit_pos = this->move_bounds_center.y;
            float y_pos = this->current_motion.position.y;
            {
                float temp = y_limit_pos - y_limit_size;
                if (temp > y_pos) {
                    this->current_motion.position.y = temp;
                } else {
                    temp = y_limit_pos + y_limit_size;
                    if (y_pos > temp) {
                        this->current_motion.position.y = temp;
                    }
                }
            }
            this->motion.absolute.position = this->current_motion.position - this->motion.relative.position;
        }
    }

    // 0x42EC00
    dllexport gnu_noinline void update_current_motion() asm_symbol_rel(0x42EC00) {
        this->current_motion.axis_velocity = this->motion.relative.position + this->motion.absolute.position - this->current_motion.position;
        this->current_motion.update();
        this->enforce_move_bounds();
    }

    inline ZUNResult run_ecl();

    // 0x430D40
    dllexport gnu_noinline int32_t thiscall high_ecl_run() asm_symbol_rel(0x430D40);

    // 0x438AA0
    dllexport gnu_noinline int32_t thiscall get_int_arg(int32_t index) asm_symbol_rel(0x438AA0);

    // 0x438AC0
    dllexport gnu_noinline int32_t* thiscall get_int_ptr_arg(int32_t index = UNUSED_DWORD) asm_symbol_rel(0x438AC0);

private:
    // 0x438AD0
    dllexport gnu_noinline float vectorcall get_float_arg(int32_t, int32_t index) asm_symbol_rel(0x438AD0);

public:
    forceinline float get_float_arg(int32_t index) {
        return this->get_float_arg(UNUSED_DWORD, index);
    }

    // 0x438AF0
    dllexport gnu_noinline float* thiscall get_float_ptr_arg(int32_t index) asm_symbol_rel(0x438AF0);

    // 0x438B10
    dllexport gnu_noinline int32_t thiscall parse_int_as_arg(int32_t index, int32_t value) asm_symbol_rel(0x438B10);

private:
    // 0x438BC0
    dllexport gnu_noinline float vectorcall parse_float_as_arg(int32_t, int32_t index, float, float, float value) asm_symbol_rel(0x438BC0);

public:
    forceinline float parse_float_as_arg(int32_t index, float value) {
        return this->parse_float_as_arg(UNUSED_DWORD, index, UNUSED_FLOAT, UNUSED_FLOAT, value);
    }

    // 0x4369E0
    dllexport gnu_noinline int32_t thiscall ecl_enm_create() asm_symbol_rel(0x4369E0);

    // 0x42E5A0
    dllexport gnu_noinline ZUNResult thiscall __move() asm_symbol_rel(0x42E5A0) {
        clang_noinline this->previous_motion = this->current_motion;
        // TODO: Finish this function and all the giga-jank in it

        return ZUN_SUCCESS;
    }

    forceinline ZUNResult thiscall update();

    // 0x42ED40
    dllexport gnu_noinline ZUNResult thiscall __update_state() asm_symbol_rel(0x42ED40);

    // 0x42F890
    dllexport gnu_noinline void thiscall __update_fog() asm_symbol_rel(0x42F890) {

    }

    // 0x42FF80
    dllexport gnu_noinline ZUNResult thiscall on_tick() asm_symbol_rel(0x42FF80);
    
    // 0x439480
    dllexport gnu_noinline static int32_t fastcall extra_damage_func1(EnemyData* enemy_data, int32_t prev_damage) asm_symbol_rel(0x439480) {
        int32_t new_damage = enemy_data->int_vars[3];
        if (new_damage > 0) {
            new_damage += prev_damage;
            enemy_data->int_vars[3] = 0;
            return new_damage;
        } else {
            return prev_damage;
        }
    }
    
    // 0x4394A0
    dllexport gnu_noinline static int32_t fastcall extra_damage_func2(EnemyData* enemy_data, int32_t prev_damage) asm_symbol_rel(0x4394A0);

    // 0x436BB0
    dllexport gnu_noinline void thiscall anm_set_slot_impl() asm_symbol_rel(0x436BB0);

    inline void thiscall anm_set_slot_main_impl();
    
    // 0x436CF0
    dllexport gnu_noinline void thiscall ecl_set_anm_data() asm_symbol_rel(0x436CF0);

    inline void thiscall anm_play_main_impl();

    inline void thiscall anm_play_attack_impl();

    inline void thiscall anm_play_attack_ex_impl();

    template <bool sanity_check_script>
    inline float kill_effects();

    template <bool inline_calls = true>
    inline void add_spawn_weight_to_chapter_destroy() {
        if constexpr (inline_calls) {
            if (
                this->chapter_spawn_weight &&
                this->chapter == GAME_MANAGER.globals.chapter
            ) {
                GAME_MANAGER.globals.__int_90 += this->chapter_spawn_weight;
                this->chapter_spawn_weight = 0;
            }
        }
        else {
            if (
                this->chapter_spawn_weight &&
                this->chapter == GAME_MANAGER.get_chapter()
            ) {
                GAME_MANAGER.globals.__add_to_int_90(this->chapter_spawn_weight);
                this->chapter_spawn_weight = 0;
            }
        }
    }

    inline void reinitialize_vm_with_sub(const char* sub_name);

#if INCLUDE_PATCH_CODE
    inline void set_interrupt(uint32_t slot, const char* sub_name) {
        uint32_t inner_index = slot & 1;
        this->callbacks[LAST_CALLBACK_INDEX - (slot >> 1)].set_interrupt(inner_index, sub_name);
        
    }

    inline const char* get_interrupt(uint32_t slot) {
        uint32_t inner_index = slot & 1;
        this->callbacks[LAST_CALLBACK_INDEX - (slot >> 1)].get_interrupt(inner_index);
    }
#endif

    // 0x438D90
    dllexport gnu_noinline static ZUNResult fastcall __func_set_1_6bs(EnemyData* enemy_data) asm_symbol_rel(0x438D90);

    // 0x439020
    dllexport gnu_noinline static ZUNResult fastcall __func_call_2_ex(EnemyData* enemy_data) asm_symbol_rel(0x439020);

    // 0x4391A0
    dllexport gnu_noinline static ZUNResult fastcall __func_call_3_ex(EnemyData* enemy_data) asm_symbol_rel(0x4391A0);

    // 0x439320
    dllexport gnu_noinline static ZUNResult fastcall __func_set_4_ex(EnemyData* enemy_data) asm_symbol_rel(0x439320);
};
#pragma region // EnemyData Field Validation
ValidateFieldOffset32(0x0, EnemyData, previous_motion);
ValidateFieldOffset32(0x44, EnemyData, current_motion);
ValidateFieldOffset32(0x88, EnemyData, motion);
ValidateFieldOffset32(0x110, EnemyData, hitbox_size);
ValidateFieldOffset32(0x118, EnemyData, collision_size);
ValidateFieldOffset32(0x120, EnemyData, hitbox_rotation);
ValidateFieldOffset32(0x124, EnemyData, anm_vms);
ValidateFieldOffset32(0x164, EnemyData, anm_positions);
ValidateFieldOffset32(0x224, EnemyData, anm_vm_indices);
ValidateFieldOffset32(0x264, EnemyData, anm_source_index);
ValidateFieldOffset32(0x268, EnemyData, anm_slot_0_source_index);
ValidateFieldOffset32(0x26C, EnemyData, anm_slot_0_script);
ValidateFieldOffset32(0x270, EnemyData, current_anm_script);
ValidateFieldOffset32(0x274, EnemyData, current_anm_pose);
ValidateFieldOffset32(0x278, EnemyData, kill_id);
ValidateFieldOffset32(0x27C, EnemyData, anm_base_layer);
ValidateFieldOffset32(0x280, EnemyData, position_of_last_damage_source_to_hit);
ValidateFieldOffset32(0x28C, EnemyData, int_vars);
ValidateFieldOffset32(0x29C, EnemyData, float_vars);
ValidateFieldOffset32(0x2BC, EnemyData, ecl_time);
ValidateFieldOffset32(0x2D0, EnemyData, boss_timer);
ValidateFieldOffset32(0x2E4, EnemyData, slowdown);
ValidateFieldOffset32(0x2E8, EnemyData, global_list_node);
ValidateFieldOffset32(0x2F8, EnemyData, position_interp);
ValidateFieldOffset32(0x3C8, EnemyData, angle_interp_absolute);
ValidateFieldOffset32(0x3F8, EnemyData, speed_interp_absolute);
ValidateFieldOffset32(0x428, EnemyData, angle_interp_relative);
ValidateFieldOffset32(0x458, EnemyData, speed_interp_relative);
ValidateFieldOffset32(0x488, EnemyData, orbit_radius_interp);
ValidateFieldOffset32(0x510, EnemyData, ellipse_interp);
ValidateFieldOffset32(0x598, EnemyData, shooters);
ValidateFieldOffset32(0x4E18, EnemyData, bullet_effect_indices);
ValidateFieldOffset32(0x4E58, EnemyData, shooter_offsets);
ValidateFieldOffset32(0x4F18, EnemyData, shooter_origins);
ValidateFieldOffset32(0x4FD8, EnemyData, final_sprite_size);
ValidateFieldOffset32(0x4FE0, EnemyData, move_bounds_center);
ValidateFieldOffset32(0x4FE8, EnemyData, move_bounds_size);
ValidateFieldOffset32(0x4FF0, EnemyData, score);
ValidateFieldOffset32(0x4FF4, EnemyData, life);
ValidateFieldOffset32(0x5010, EnemyData, drops);
ValidateFieldOffset32(0x50D4, EnemyData, __int_50D4);
ValidateFieldOffset32(0x50E8, EnemyData, __dword_50E8);
ValidateFieldOffset32(0x50EC, EnemyData, hit_sound);
ValidateFieldOffset32(0x50F0, EnemyData, invulnerable_timer);
ValidateFieldOffset32(0x5104, EnemyData, no_collision_timer);
ValidateFieldOffset32(0x5118, EnemyData, __timer_5118);
ValidateFieldOffset32(0x512C, EnemyData, bomb_damage_multiplier);
ValidateFieldOffset32(0x5130, EnemyData, flags_low);
ValidateFieldOffset32(0x5134, EnemyData, flags_high);
ValidateFieldOffset32(0x5138, EnemyData, bombshield_on_anm);
ValidateFieldOffset32(0x513C, EnemyData, bombshield_off_anm);
ValidateFieldOffset32(0x5140, EnemyData, boss_id);
ValidateFieldOffset32(0x5144, EnemyData, player_protect_radius_squared);
ValidateFieldOffset32(0x5148, EnemyData, callbacks);
ValidateFieldOffset32(0x5588, EnemyData, vm);
ValidateFieldOffset32(0x558C, EnemyData, fog);
ValidateFieldOffset32(0x55A8, EnemyData, death_callback_sub);
ValidateFieldOffset32(0x55E8, EnemyData, func_set_func);
ValidateFieldOffset32(0x55EC, EnemyData, __is_func_set_2);
ValidateFieldOffset32(0x55F0, EnemyData, extra_damage_func);
ValidateFieldOffset32(0x55F4, EnemyData, extra_hitbox_func);
ValidateFieldOffset32(0x55F8, EnemyData, chapter);
ValidateFieldOffset32(0x55FC, EnemyData, chapter_spawn_weight);
ValidateStructSize32(0x5600, EnemyData);
#pragma endregion

// 0x4B3FE0
static constexpr FuncSetFunc *const ECL_FUNC_CALL_TABLE[5] = {
    NULL,
    &EnemyData::__func_set_1_6bs,
    &EnemyData::__func_call_2_ex,
    &EnemyData::__func_call_3_ex,
    &EnemyData::__func_set_4_ex
};

// 0x4B36E4
static constexpr ExtraDamageFunc *const EXTRA_DAMAGE_FUNC_TABLE[] = {
    NULL,
    &EnemyData::extra_damage_func1,
    &EnemyData::extra_damage_func2,
};

extern "C" {
    // Table is *not* const
    // 0x4CF2D8
    externcg ExtraHitboxFunc* EXTRA_HITBOX_FUNC_TABLE[1] cgasm("_EXTRA_HITBOX_FUNC_TABLE");
}

static inline constexpr uint32_t ECL_FILE_MAGIC = PackUInt('S', 'C', 'P', 'T');
static inline constexpr uint32_t ANM_INCLUDE_MAGIC = PackUInt('A', 'N', 'I', 'M');
static inline constexpr uint32_t ECL_INCLUDE_MAGIC = PackUInt('E', 'C', 'L', 'I');

// size: 0x10
struct EclSub {
    ZUNMagic magic; // 0x0
    uint32_t data_offset; // 0x4
    unknown_fields(0x8); // 0x8
    EclInstruction instructions[]; // 0x10
};

// size: 0x8
struct EclSubHeader {
    const char* name; // 0x0
    EclSub* data; // 0x4
    // 0x8
};
#pragma region // EclSubHeader Validation
ValidateFieldOffset32(0x0, EclSubHeader, name);
ValidateFieldOffset32(0x4, EclSubHeader, data);
ValidateStructSize32(0x8, EclSubHeader);
#pragma endregion

// size: 0x8
struct EclIncludes {
    ZUNMagic magic; // 0x0
    uint32_t count; // 0x4
    unsigned char data[]; // 0x8
};

// size: 0x24
struct EclFileHeader {
    ZUNMagic magic; // 0x0
    uint16_t version; // 0x4
    uint16_t include_length; // 0x6 include_offset + ANIM+ECLI length
    uint32_t include_offset; // 0x8
    int __dword_C; // 0xC
    uint16_t sub_count; // 0x10

    int __dword_14; // 0x14
    int __dword_18; // 0x18
    int __dword_1C; // 0x1C
    int __dword_20; // 0x20
    // 0x24
};

struct EclFile {
    EclFileHeader header; // 0x0
    unsigned char data[]; // 0x24
};

static inline constexpr size_t MAX_ECL_FILE_COUNT = 32;
static inline constexpr size_t MAX_ECL_ANM_FILES = 8;

struct SptResource {
    //void* vtable; // 0x0
    int32_t file_count; // 0x4
    int32_t sub_count; // 0x8
    EclFile* files[MAX_ECL_FILE_COUNT]; // 0xC
    EclSubHeader* subs; // 0x8C
    // 0x90

    inline ~SptResource() {
        SAFE_FREE(this->subs);
    }

    // 0x48D9D0
    // Method 0
    dllexport virtual gnu_noinline int32_t thiscall add_ecl_file(const char* file_buffer) asm_symbol_rel(0x48D9D0) {
        this->files[this->file_count] = (EclFile*)file_buffer;
        EclFile* ecl_file = this->files[this->file_count];
        if (
            ecl_file->header.magic.as_uint == ECL_FILE_MAGIC &&
            ecl_file->header.version == 1
        ) {
            const char* sub_data_start = based_pointer<char>(ecl_file->data, ecl_file->header.include_length);
            uint32_t sub_count_in_file = ecl_file->header.sub_count;
            this->sub_count += sub_count_in_file;
            EclSubHeader* old_sub_array = this->subs; // ESI
            const uint32_t* sub_offsets = (uint32_t*)sub_data_start; // EBP+8
            const char* sub_names = sub_data_start + sizeof(uint32_t[sub_count_in_file]); // EDI, EBP-8

            EclSubHeader* new_sub_array = (EclSubHeader*)malloc(sizeof(EclSubHeader[this->sub_count]));

            if (!old_sub_array) {
                this->subs = new_sub_array;
                for (int32_t i = 0; i < this->sub_count; ++i) {
                    EclSub* sub = based_pointer<EclSub>(this->files[this->file_count], *sub_offsets);
                    this->subs[i].data = sub;
                    this->subs[i].name = sub_names;
                    sub_names += byteloop_strlen(sub_names) + 1;
                    ++sub_offsets;
                }
            }
            else {
                this->subs = new_sub_array;
                uint32_t old_sub_count = this->sub_count - this->files[this->file_count]->header.sub_count; // EBP-4
                memcpy(new_sub_array, old_sub_array, sizeof(EclSubHeader[old_sub_count]));
                free(old_sub_array);

                int32_t checked_sub_count = old_sub_count;
                for (
                    int32_t i = 0; // EBP-C
                    i < this->files[this->file_count]->header.sub_count;
                    ++i
                ) {
                    int32_t j = 0; // EDI
                    if (checked_sub_count > 0) {
                        EclSubHeader* subs = this->subs;
                        do {
                            if (strcmp_asm(sub_names, subs[j].name) <= 0) {
                                break;
                            }
                        } while (++j < checked_sub_count);
                    }

                    int32_t k = this->sub_count; // ESI
                    while (--k > j) {
                        this->subs[k] = this->subs[k - 1];
                    }
                    
                    EclSub* sub = based_pointer<EclSub>(this->files[this->file_count], *sub_offsets);
                    this->subs[j].data = sub;
                    this->subs[j].name = sub_names;
                    sub_names += byteloop_strlen(sub_names) + 1;
                    ++checked_sub_count;
                    ++sub_offsets;
                }
            }
            
            int32_t file_index = this->file_count++;
            ecl_file = this->files[file_index];
            if (ecl_file->header.include_length) {
                this->load_imports((EclIncludes*)ecl_file->data);
            }
            return file_index;
        }
        this->files[this->file_count] = NULL;
        return ZUN_ERROR;
    }

    // 0x42CCB0
    // Method 4
    dllexport virtual gnu_noinline ZUNResult thiscall load_imports(EclIncludes* includes) asm_symbol_rel(0x42CCB0) {
        return ZUN_SUCCESS;
    }
};
#pragma region // SptResource Validation
ValidateVirtualFieldOffset32(0x4, SptResource, file_count);
ValidateVirtualFieldOffset32(0x8, SptResource, sub_count);
ValidateVirtualFieldOffset32(0xC, SptResource, files);
ValidateVirtualFieldOffset32(0x8C, SptResource, subs);
ValidateStructSize32(0x90, SptResource);
#pragma endregion

// size: 0x1098
struct EclManager : SptResource {
    // SptResource base; // 0x0
    EclStack __wtf_stack_maybe; // 0x90
    // 0x1098

    inline void zero_contents() {
        zero_this();
    }

    inline EclManager() {
        this->zero_contents();
    }

    inline ~EclManager() {
        nounroll for (size_t i = 0; i < MAX_ECL_FILE_COUNT; ++i) {
            if (void* file = this->files[i]) {
                free(file);
            }
        }
    }

    // 0x42D3E0
    // Method 0
    dllexport virtual gnu_noinline int32_t thiscall add_ecl_file(const char* file_name) asm_symbol_rel(0x42D3E0) {
        const char* ecl_file = (const char*)read_file_from_dat(file_name);
        int32_t index = __super::add_ecl_file(ecl_file);
        return index >= 0 ? ZUN_SUCCESS : ZUN_ERROR;
    }

    // 0x42DA90
    // Method 4
    dllexport virtual gnu_noinline ZUNResult thiscall load_imports(EclIncludes* includes) asm_symbol_rel(0x42DA90);
};
#pragma region // EclManager Validation
ValidateVirtualFieldOffset32(0x4, EclManager, file_count);
ValidateVirtualFieldOffset32(0x8, EclManager, sub_count);
ValidateVirtualFieldOffset32(0xC, EclManager, files);
ValidateVirtualFieldOffset32(0x8C, EclManager, subs);
//ValidateVirtualFieldOffset32(0x90, EclManager, __wtf_stack_maybe);
ValidateStructSize32(0x1098, EclManager);
#pragma endregion

// size: 0x122C
struct EclVM {
    //void* vtable; // 0x0
    EclContext* next_context; // 0x4
    EclContext* prev_context; // 0x8
    EclContext* current_context; // 0xC
    EclContext context; // 0x10
    EclManager* controller; // 0x1218
    ZUNList<EclContext> context_list; // 0x121C
    // 0x122C

private:
    // 0x42CDC0
    dllexport gnu_noinline void vectorcall subtract_time_float(float, float amount) asm_symbol_rel(0x42CDC0) {
        this->current_context->time -= amount;
    }
public:
    inline void subtract_time_float(float amount) {
        return this->subtract_time_float(UNUSED_FLOAT, amount);
    }

    // 0x42CE10
    dllexport gnu_noinline EclVM() {
        this->context.set_float_interp_times(0);
    }

    // 0x42CE80
    dllexport gnu_noinline void initialize_vm() asm_symbol_rel(0x42CE80) {
        this->context.__unknown_flag_A = false;
        this->context.time = 0.0f;
        this->context.location.reset();
        this->context.async_id = -1;
        this->context.vm = this;
        this->context.__int_101C = 0;
        this->context.set_float_interp_times(0);
        this->current_context = &this->context;
        this->context.stack.pointer = 0;
        this->context.stack.base = 0;
        this->context_list.initialize_with(&this->context);
    }

    // 0x42CD70
    dllexport gnu_noinline virtual int32_t high_ecl_run() asm_symbol_rel(0x42CD70) {
        return 0;
    }

    // 0x42CD80
    dllexport gnu_noinline virtual int32_t get_int_var(int32_t index) asm_symbol_rel(0x42CD80) {
        return 0;
    }

    // 0x42CD90
    dllexport gnu_noinline virtual int32_t* get_int_ptr(int32_t index) asm_symbol_rel(0x42CD90) {
        return NULL;
    }

    // 0x42CDA0
    dllexport gnu_noinline virtual float get_float_var(int32_t index) asm_symbol_rel(0x42CDA0) {
        return 0.0f;
    }

    // 0x42CDB0
    dllexport gnu_noinline virtual float* get_float_ptr(int32_t index) asm_symbol_rel(0x42CDB0) {
        return NULL;
    }

    // 0x42CDD0
    dllexport gnu_noinline void cleanup_vm() asm_symbol_rel(0x42CDD0) {
        this->context_list.as_head().delete_each();
    }

    // 0x42CF50
    dllexport inline virtual ~EclVM() asm_symbol_rel(0x42CF50) {
        clang_forceinline this->cleanup_vm();
    }

private:
    // 0x48D420
    dllexport gnu_noinline ZUNResult vectorcall run_ecl(float, float current_gamespeed) asm_symbol_rel(0x48D420) {
        BOOL is_primary_context = true;
        if (this->context_list.do_while_safe([=, &is_primary_context](EclContext* context, ZUNList<EclContext>* node) {
            this->current_context = context;
            if (is_primary_context) {
                if (ZUN_FAILED(context->low_ecl_run(current_gamespeed))) {
                    return false;
                }
                is_primary_context = false;
            } else {
                if (ZUN_FAILED(context->low_ecl_run(current_gamespeed))) {
                    delete context;
                    node->unlink();
                    delete node;
                }
            }
            return true;
        })) {
            this->current_context = &this->context;
            return ZUN_SUCCESS;
        } else {
            return ZUN_ERROR;
        }
    }

public:
    forceinline ZUNResult run_ecl(float time) {
        return this->run_ecl(UNUSED_FLOAT, time);
    }

    // 0x48D850
    dllexport gnu_noinline ZUNResult thiscall new_async(int32_t async_id, int32_t args_index) asm_symbol_rel(0x48D850) {
        EclContext* context = new EclContext();
        ZUNList<EclContext>* list_node = new ZUNList<EclContext>();
        context->async_id = async_id;
        context->vm = this;
        context->time = 0.0f;
        context->location.reset();
        context->difficulty_mask = this->current_context->difficulty_mask;
        list_node->initialize_with(context);
        this->context_list.append(list_node);
        return this->current_context->call(context, args_index);
    }

    // 0x48D920
    dllexport gnu_noinline void thiscall locate_sub(const char* sub_name) asm_symbol_rel(0x48D920) {
        EclManager* ecl_manager = this->controller;
        int32_t left_index = 0;
        assume(sub_name[0] != '\0');
        int32_t right_index = ecl_manager->sub_count - 1;
        if (expect(right_index >= 0, true)) {
            EclSubHeader* subs = ecl_manager->subs;
            do {
                int32_t index = right_index - left_index;
                const char* name = sub_name;
                index /= 2;
                index += left_index;
                int32_t cmp_value = strcmp_asm(name, subs[index].name);
                if (!cmp_value) {
                    this->current_context->location.sub_index = index;
                    return;
                } else if (cmp_value < 0) {
                    right_index = index - 1;
                } else {
                    left_index = index + 1;
                }
            } while (left_index <= right_index);
        }
        this->current_context->location.sub_index = -1;
    }

    // 0x48DC20
    dllexport gnu_noinline int32_t thiscall set_context_to_sub(const char* sub_name) asm_symbol_rel(0x48DC20) {
        this->locate_sub(sub_name);
        this->current_context->location.instruction_offset = 0;
        this->current_context->time = 0.0f;
        return 0;
    }

    inline void reinitialize_vm_with_sub(const char* sub_name) {
        this->cleanup_vm();
        this->initialize_vm();
        this->set_context_to_sub(sub_name);
    }
};
#pragma region // EclVM Validation
ValidateVirtualFieldOffset32(0x4, EclVM, next_context);
ValidateVirtualFieldOffset32(0x8, EclVM, prev_context);
ValidateVirtualFieldOffset32(0xC, EclVM, current_context);
ValidateVirtualFieldOffset32(0x10, EclVM, context);
ValidateVirtualFieldOffset32(0x1218, EclVM, controller);
ValidateVirtualFieldOffset32(0x121C, EclVM, context_list);
ValidateStructSize32(0x122C, EclVM);
#pragma endregion

inline ZUNResult EnemyData::run_ecl() {
    return this->vm->run_ecl(this->ecl_time.get_scale_unsafe());
}

inline void EnemyData::reinitialize_vm_with_sub(const char* sub_name) {
    this->vm->cleanup_vm();
    this->vm->initialize_vm();
    this->vm->set_context_to_sub(sub_name);
}

inline EclInstruction* EclContext::get_instruction(int32_t sub_index, int32_t instr_offset) {
    return based_pointer(this->vm->controller->subs[sub_index].data->instructions, instr_offset);
}

forceinline int32_t thiscall EclContext::get_int_arg(int32_t index, EclInstruction* current_instruction) {
    if (current_instruction->param_mask & (1 << index)) {
        int32_t value = IntArg(index);
        if (value >= 0) {
            return this->stack.read_local(value);
        } else if (value <= -1 && value >= -100) {
            return this->stack.read_temp(value);
        } else {
            return this->vm->get_int_var(value);
        }
    } else {
        return IntArg(index);
    }
}

// 0x48D4F0
dllexport gnu_noinline int32_t thiscall EclContext::get_int_arg(int32_t index) {
    return this->get_int_arg(index, this->get_current_instruction());
}

forceinline float vectorcall EclContext::get_float_arg(int32_t index, EclInstruction* current_instruction) {
    float value = FloatArg(index);
    if (current_instruction->param_mask & (1 << index)) {
        if (value >= 0.0f) {
            return this->stack.read_local(value);
        } else if (value <= -1.0f && value >= -100.0f) {
            return this->stack.read_temp(value);
        } else {
            return this->vm->get_float_var((int32_t)value);
        }
    } else {
        return value;
    }
}

// 0x48D5A0
dllexport gnu_noinline float vectorcall EclContext::get_float_arg(int32_t, int32_t index) {
    return this->get_float_arg(index, this->get_current_instruction());
}

forceinline int32_t thiscall EclContext::get_int_arg_pop(int32_t index, EclInstruction* current_instruction) {
    if (current_instruction->param_mask & (1 << index)) {
        int32_t value = IntArg(index);
        if (value >= 0) {
            return this->stack.read_local<int32_t>(value);
        } else if (value <= -1 && value >= -100) {
            return this->stack.pop_cast<int32_t>();
        } else {
            return this->vm->get_int_var(value);
        }
    } else {
        return IntArg(index);
    }
}

forceinline int32_t thiscall EclContext::get_int_arg_pop(int32_t index) {
    return this->get_int_arg_pop(index, this->get_current_instruction());
}

forceinline float vectorcall EclContext::get_float_arg_pop(int32_t index, EclInstruction* current_instruction) {
    float value = FloatArg(index);
    if (current_instruction->param_mask & (1 << index)) {
        if (value >= 0.0f) {
            return this->stack.read_local<float>(value);
        } else if (value <= -1.0f && value >= -100.0f) {
            return this->stack.pop_cast<float>();
        } else {
            return this->vm->get_float_var(value);
        }
    } else {
        return value;
    }
}

forceinline float vectorcall EclContext::get_float_arg_pop(int32_t index) {
    return this->get_float_arg_pop(index, this->get_current_instruction());
}

forceinline int32_t thiscall EclContext::parse_int_as_arg_pop(int32_t index, int32_t value, EclInstruction* current_instruction) {
    if (current_instruction->param_mask & (1 << index)) {
        if (value >= 0) {
            return this->stack.read_local(value);
        } else if (value <= -1 && value >= -100) {
            return this->stack.pop_cast<int32_t>();
        } else {
            return this->vm->get_int_var(value);
        }
    } else {
        return value;
    }
}

// 0x48D690
dllexport gnu_noinline int32_t thiscall EclContext::parse_int_as_arg_pop(int32_t index, int32_t value) {
    return this->parse_int_as_arg_pop(index, value, this->get_current_instruction());
}

forceinline float vectorcall EclContext::parse_float_as_arg_pop(int32_t index, float value, EclInstruction* current_instruction) {
    if (current_instruction->param_mask & (1 << index)) {
        if (value >= 0.0f) {
            return this->stack.read_local(value);
        } else if (value <= -1.0f && value >= -100.0f) {
            return this->stack.pop_cast<float>();
        } else {
            return this->vm->get_float_var(value);
        }
    } else {
        return value;
    }
}

inline float vectorcall EclContext::parse_float_as_arg_pop(int32_t index, float value) {
    return this->parse_float_as_arg_pop(index, value, this->get_current_instruction());
}

forceinline int32_t* thiscall EclContext::get_int_ptr_arg(int32_t index, EclInstruction* current_instruction) {
    if (current_instruction->param_mask & (1 << index)) {
        int32_t value = IntArg(index);
        if (value >= 0) {
            return &this->stack.ref_local(value);
        } else {
            return this->vm->get_int_ptr(value);
        }
    } else {
        return NULL;
    }
}

// 0x48D750
dllexport gnu_noinline int32_t* thiscall EclContext::get_int_ptr_arg(int32_t index) {
    return this->get_int_ptr_arg(index, this->get_current_instruction());
}

forceinline float* thiscall EclContext::get_float_ptr_arg(int32_t index, EclInstruction* current_instruction) {
    if (current_instruction->param_mask & (1 << index)) {
        float value = FloatArg(index);
        if (value >= 0.0f) {
            return &this->stack.ref_local(value);
        } else {
            return this->vm->get_float_ptr((int32_t)value);
        }
    } else {
        return NULL;
    }
}

// 0x48D7C0
dllexport gnu_noinline float* thiscall EclContext::get_float_ptr_arg(int32_t index) {
    return this->get_float_ptr_arg(index, this->get_current_instruction());
}

forceinline int32_t thiscall EclContext::parse_int_as_arg(int32_t index, int32_t value, EclInstruction* current_instruction) {
    if (current_instruction->param_mask & (1 << index)) {
        if (value >= 0) {
            return this->stack.read_local(value);
        } else if (value <= -1 && value >= -100) {
            return this->stack.read_temp(value);
        } else {
            return this->vm->get_int_var(value);
        }
    } else {
        return IntArg(index);
    }
}

forceinline int32_t thiscall EclContext::parse_int_as_arg(int32_t index, int32_t value) {
    return this->parse_int_as_arg(index, value, this->get_current_instruction());
}

forceinline float EclContext::parse_float_as_arg(int32_t index, float value, EclInstruction* current_instruction) {
    if (current_instruction->param_mask & (1 << index)) {
        if (value >= 0.0f) {
            return this->stack.read_local(value);
        } else if (value <= -1.0f && value >= -100.0f) {
            return this->stack.read_temp(value);
        } else {
            return this->vm->get_float_var((int32_t)value);
        }
    } else {
        return value;
    }
}

forceinline float EclContext::parse_float_as_arg(int32_t index, float value) {
    return this->parse_float_as_arg(index, value, this->get_current_instruction());
}

// 0x438AA0
dllexport gnu_noinline int32_t thiscall EnemyData::get_int_arg(int32_t index) {
    return this->vm->current_context->get_int_arg(index);
}

// 0x438AC0
dllexport gnu_noinline int32_t* thiscall EnemyData::get_int_ptr_arg(int32_t index) {
    return this->vm->current_context->get_int_ptr_arg(index);
}

// 0x438AD0
dllexport gnu_noinline float vectorcall EnemyData::get_float_arg(int32_t, int32_t index) {
    return this->vm->current_context->get_float_arg(index);
}

// 0x438AF0
dllexport gnu_noinline float* thiscall EnemyData::get_float_ptr_arg(int32_t index) {
    return this->vm->current_context->get_float_ptr_arg(index);
}

// 0x438B10
dllexport gnu_noinline int32_t thiscall EnemyData::parse_int_as_arg(int32_t index, int32_t value) {
    return this->vm->current_context->parse_int_as_arg(index, value);
}

// 0x438BC0
dllexport gnu_noinline float vectorcall EnemyData::parse_float_as_arg(int32_t, int32_t index, float, float, float value) {
    return this->vm->current_context->parse_float_as_arg(index, value);
}

namespace Ecl {
enum Var : int32_t {
    RAND_INT = -10000,
    RAND_FLOAT = -9999,
    RAND_ANGLE = -9998,
    SELF_X = -9997,
    SELF_Y = -9996,
    SELF_X_ABS = -9995,
    SELF_Y_ABS = -9994,
    SELF_X_REL = -9993,
    SELF_Y_REL = -9992,

    SELF_X2 = -9977,
    SELF_Y2 = -9976,
    SELF_X2_ABS = -9975,
    SELF_Y2_ABS = -9974,
    SELF_X2_REL = -9973,
    SELF_Y2_REL = -9972
};
enum Opcode : uint16_t {
    // Section A
    nop = 0, // 0
    enemy_delete, // 1
    ret = 10, // 10
    call, // 11
    jump, // 12
    jump_equ, // 13
    jump_neq, // 14
    async_call, // 15
    async_call_id, // 16
    async_stop_id, // 17
    __async_unknown_flag_set, // 18
    __async_unknown_flag_clear, // 19
    __async_unknown_value, // 20
    async_stop_all, // 21
    __debug_unknown_A, // 22
    ecl_time_sub, // 23
    ecl_time_sub_float, // 24
    debug_print = 30, // 30
    __debug_unknown_B, // 31
    frame_enter = 40, // 40
    frame_leave, // 41
    push_int, // 42
    pop_int, // 43
    push_float, // 44
    pop_float, // 45
    math_int_add = 50, // 50
    math_float_add, // 51
    math_int_sub, // 52
    math_float_sub, // 53
    math_int_mul, // 54
    math_float_mul, // 55
    math_int_div, // 56
    math_float_div, // 57
    math_int_mod, // 58
    cmp_int_equ, // 59
    cmp_float_equ, // 60
    cmp_int_neq, // 61
    cmp_float_neq, // 62
    cmp_int_les, // 63
    cmp_float_les, // 64
    cmp_int_leq, // 65
    cmp_float_leq, // 66
    cmp_int_gre, // 67
    cmp_float_gre, // 68
    cmp_int_geq, // 69
    cmp_float_geq, // 70
    cmp_int_not, // 71
    cmp_float_not, // 72
    cmp_or, // 73
    cmp_and, // 74
    math_bit_xor, // 75
    math_bit_or, // 76
    math_bit_and, // 77
    math_post_dec, // 78
    math_sin, // 79
    math_cos, // 80
    math_circle_pos, // 81
    math_reduce_angle, // 82
    math_int_neg, // 83
    math_float_neg, // 84
    math_hypot_squared, // 85
    math_hypot, // 86
    math_line_angle, // 87
    math_sqrt, // 88
    math_angle_diff, // 89
    math_point_rotate, // 90
    math_float_interp, // 91
    math_float_interp_bezier, // 92
    math_circle_pos_rand, // 93
    math_ellipse_pos, // 94
    __math_angle_95,
    __math_angle_96,
    __math_angle_97,

    // Section B
    enemy_create_rel = 300,
    enemy_create_abs,
    anm_source,
    anm_set_slot,
    enemy_create_rel_mirror,
    enemy_create_abs_mirror,
    anm_set_slot_main,
    anm_create_front,
    anm_create_zero_front,
    enemy_create_rel_stage,
    enemy_create_abs_stage,
    enemy_create_rel_stage_mirror,
    enemy_create_abs_stage_mirror,
    anm_play_attack,
    anm_create_back,
    anm_create_front_rotated,
    anm_play_attack_ex,
    anm_interrupt_slot,
    anm_play_main,
    anm_rotate_slot,
    anm_move_position_slot,
    __enemy_create_rel_2,
    __anm_set_slot_anchor_index,
    anm_death_effects,
    enemy_id_get_position,
    anm_color_slot,
    anm_color_slot_interp,
    anm_alpha_slot,
    anm_alpha_slot_interp,
    anm_scale_slot,
    anm_scale_slot_interp,
    anm_alpha2_slot,
    anm_alpha2_slot_interp,
    anm_move_position_slot_interp,
    __effect_create_special,
    anm_scale2_slot,
    __anm_layer_slot,
    anm_blend_mode_slot,
    anm_create_rel_front_rotated,
    __anm_create_zero_front_and_run,
    __enemy_id_set_flag_unknown_B,

    // Section C
    move_position_abs = 400,
    move_position_abs_interp,
    move_position_rel,
    move_position_rel_interp,
    move_velocity_abs,
    move_velocity_abs_interp,
    move_velocity_rel,
    move_velocity_rel_interp,
    move_orbit_abs,
    move_orbit_abs_interp,
    move_orbit_rel,
    move_orbit_rel_interp,
    move_rand_interp_abs,
    move_rand_interp_rel,
    move_to_boss0_abs,
    move_to_boss0_rel,
    move_position_add_abs,
    move_position_add_rel,
    move_origin_abs,
    move_origin_rel,
    move_ellipse_abs,
    move_ellipse_abs_interp,
    move_ellipse_rel,
    move_ellipse_rel_interp,
    enemy_flag_mirror,
    move_bezier_abs,
    move_bezier_rel,
    move_stop,
    move_velocity_no_mirror_abs,
    move_velocity_no_mirror_abs_interp,
    move_velocity_no_mirror_rel,
    move_velocity_no_mirror_rel_interp,
    move_to_enemy_id_abs,
    move_to_enemy_id_rel,
    move_axis_interp_abs,
    move_axis_interp_rel,
    __move_position_offset_abs_interp,
    __move_position_offset_rel_interp,
    __move_axis_offset_abs_interp,
    __move_axis_offset_rel_interp,
    move_angle_abs,
    move_angle_abs_interp,
    move_angle_rel,
    move_angle_rel_interp,
    move_speed_abs,
    move_speed_abs_interp,
    move_speed_rel,
    move_speed_rel_interp,

    // Section D
    enemy_set_hitbox = 500,
    enemy_set_collision,
    enemy_flags_set,
    enemy_flags_clear,
    move_bounds_set,
    move_bounds_disable,
    item_bonus_slots_reset,
    item_bonus_slot_set,
    item_drop_area,
    drop_item_rewards,
    item_reward_set,
    enemy_life_set,
    boss_set,
    boss_timer_clear,
    callback_ex,
    enemy_invincible_timer,
    effect_sound,
    effect_screen_shake,
    msg_read,
    msg_wait,
    boss_wait,
    timer_callback_sub,
    spellcard_start,
    spellcard_end,
    chapter_set,
    enemy_kill_all,
    player_protect_range,
    enemy_lifebar_color,
    spellcard_start_2,
    set_float_rank_3,
    set_float_rank_5,
    math_float_rank_lerp,
    set_int_rank_3,
    set_int_rank_5,
    math_int_rank_lerp,
    set_int_difficulty,
    set_float_difficulty,
    spellcard_start_difficulty,
    spellcard_start_difficulty_1,
    spellcard_start_difficulty_2,
    boss_set_life_count,
    enemy_no_collision_timer,
    spellcard_flag_timeout_set,
    __spellcard_flag_anm_unknown,
    enemy_flag_homing_disable,
    laser_clear_all,
    enemy_bomb_shield,
    game_speed_set,
    ecl_time_sub_difficulty,
    __enemy_flag_unknown_A,
    enemy_set_kill_id,
    enemy_kill_all_id,
    anm_layer_base,
    enemy_damage_sound,
    __stage_logo,
    enemy_id_exists,
    death_callback_sub,
    std_fog_interp,
    enemy_flag_mirror2,
    enemy_limit_set,
    bullet_bounce_bounds_set,
    __enemy_kill_effect_create,
    drop_item_rewards_force,
    enemy_flag_hitbox_shape,
    enemy_set_hitbox_rotation,
    enemy_bomb_shield_multiplier,
    enemy_kill,
    __spellcard_flag_unknown_A,
    __enemy_flag_armored,
    __enemy_set_chapter_spawn_weight,
    __enemy_add_spawn_weight_to_destroy,
    enemy_kill_all_no_callbacks,
    __enemy_life_set_current,
    item_timed_bonus_slot_set,
    item_timed_bonus_duration,

    // Section E
    shooter_reset = 600,
    shoot_now,
    bullet_sprite,
    shoot_offset,
    shoot_angle,
    bullet_speed,
    bullet_count,
    shoot_aim_mode,
    bullet_sound,
    bullet_effects,
    bullet_effects_ex,
    bullet_effects_add,
    bullet_effects_add_ex,
    bullet_cancel,
    shooter_copy,
    bullet_cancel_radius,
    bullet_clear_radius,
    bullet_speed_rank_3,
    bullet_speed_rank_5,
    bullet_speed_rank_lerp,
    bullet_count_rank_3,
    bullet_count_rank_5,
    bullet_count_rank_lerp,
    set_float_angle_to_player_from_point,
    bullet_speed_difficulty,
    bullet_count_difficulty,
    shoot_offset_circle,
    shoot_spawn_distance,
    __shoot_origin,
    enemy_fog_spawn,
    std_interrupt,
    __enemy_manager_flag_unknown_A,
    ex_ins_repeat,
    enemy_damage_ex,
    enemy_hitbox_ex,
    bullet_cancel_weak_radius,
    bullet_clear_weak_radius,
    ex_ins_call,
    score_add,
    __ex_ins_repeat2,
    bullet_effects_set_string,
    __bullet_effects_prev,

    // Section F
    laser_size_data = 700,
    laser_timing_data,
    laser_line_create,
    laser_infinite_create,
    laser_offset,
    laser_target,
    laser_speed,
    laser_width,
    laser_angle,
    laser_rotate,
    laser_clear,
    laser_curve_create,
    __bullet_cancel_weak_rectangle,
    laser_beam_create,
    __laser_beam_flag_unknown_A,

    // Section G
    enemy_id_change_sub = 800,
    enemy_id_get_position_crash,
    boss_callback,

    // Section H
    __debug_unknown_C = 901,
    __debug_unknown_D = 902,

    // Section I
    __globals_flag_unknown_A = 1001
};
}

using EnemyOnKillFunc = void fastcall (Enemy*);

// size: 0x683C
struct Enemy : EclVM {
    //EclVM vm; // 0x0
    EnemyData data; // 0x122C
    EnemyOnKillFunc* __on_kill_func; // 0x682C
    EnemyID id; // 0x6830
    EnemyID parent_id; // 0x6834
    int __dword_6838; // 0x6838
    // 0x683C

    // 0x42E100
    dllexport gnu_noinline Enemy(const char* sub_name);

    // 0x42D200
    dllexport gnu_noinline void __set_unknown_flag_B() asm_symbol_rel(0x42D200) {
        this->data.__unknown_flag_B = true;
    }

    // 0x42D210
    dllexport gnu_noinline EnemyData& get_data() asm_symbol_rel(0x42D210) {
        return this->data;
    }

    // 0x42D220
    dllexport gnu_noinline virtual ~Enemy() asm_symbol_rel(0x42D220);

    // 0x42FE80
    dllexport gnu_noinline ZUNResult thiscall on_tick() asm_symbol_rel(0x42FE80) {
        float enemy_slowdown = this->data.slowdown;
        if (enemy_slowdown <= 0.0f) {
            if (this->data.__anm_slowdown_immune) {
                this->data.set_anm_vm_slowdowns(0.0f);
            }
            return this->data.on_tick();
        } else {
            float previous_gamespeed = GAME_SPEED;
            GAME_SPEED.value = confine_to_range(0.0f, previous_gamespeed - enemy_slowdown * previous_gamespeed, 1.0f);
            this->data.set_anm_vm_slowdowns(this->data.slowdown);
            ZUNResult ret = this->data.on_tick();
            GAME_SPEED.value = previous_gamespeed;
            this->data.__anm_slowdown_immune = true; // Why?
            return ret;
        }
    }

    // 0x4389F0
    dllexport gnu_noinline void thiscall set_callback(int32_t index, int32_t life, int32_t time, const char* sub_name) asm_symbol_rel(0x4389F0) {
        EnemyCallback& callback = this->data.callbacks[index];
        callback.life = life;
        if (life >= 0) {
            callback.time = time;
            if (sub_name) {
                byteloop_strcpy(callback.life_sub, sub_name);
                byteloop_strcpy(callback.time_sub, sub_name);
            } else {
                callback.life_sub[0] = '\0';
                callback.time_sub[0] = '\0';
            }
        }
    }

    inline void set_callback_life_sub_name(int32_t index, const char* sub_name) {
        EnemyCallback& callback = this->data.callbacks[index];
        if (sub_name) {
            byteloop_strcpy(callback.life_sub, sub_name);
        } else {
            callback.life_sub[0] = '\0';
        }
    }

    // 0x438A60
    dllexport gnu_noinline void thiscall set_callback_time_sub_name(int32_t index, const char* sub_name) asm_symbol_rel(0x438A60) {
        EnemyCallback& callback = this->data.callbacks[index];
        if (sub_name) {
            byteloop_strcpy(callback.time_sub, sub_name);
        } else {
            callback.time_sub[0] = '\0';
        }
    }

    inline const char* check_timer_callbacks();

    inline const char* check_life_callbacks();

    // 0x409980
    dllexport gnu_noinline MotionData* thiscall get_current_motion() {
        return &this->data.current_motion;
    }

    // 0x430D30
    dllexport gnu_noinline virtual int32_t high_ecl_run() asm_symbol_rel(0x430D30) {
        return this->data.high_ecl_run();
    }

    // 0x437360
    dllexport gnu_noinline virtual int32_t get_int_var(int32_t index) asm_symbol_rel(0x437360) {
        switch (index) {

            default:
                return 0;
        }
    }

    // 0x437B20
    dllexport gnu_noinline virtual int32_t* get_int_ptr(int32_t index) asm_symbol_rel(0x437B20) {
        switch (index) {

            default:
                return NULL;
        }
    }

    // 0x437C90
    dllexport gnu_noinline virtual float get_float_var(int32_t index) asm_symbol_rel(0x437C90) {
        switch (index) {

            default:
                return 0.0f;
        }
    }

    // 0x4387E0
    dllexport gnu_noinline virtual float* get_float_ptr(int32_t index) asm_symbol_rel(0x4387E0) {
        switch (index) {

            default:
                return NULL;
        }
    }

    // 0x430240
    dllexport gnu_noinline int thiscall kill() asm_symbol_rel(0x430240);

protected:
    template <bool no_callbacks = false>
    forceinline void try_kill_success() {
        this->data.drops.reset();
        this->data.position_of_last_damage_source_to_hit.x = 0.0f;
        this->data.position_of_last_damage_source_to_hit.y = 192.0f;
        this->data.chapter_spawn_weight = 0;
        if constexpr (no_callbacks) {
            this->data.death_callback_sub[0] = '\0';
        }
        this->kill();
        nounroll for (size_t i = 0; i < ENEMY_ANM_SLOTS; ++i) {
            this->data.anm_vms[i].mark_tree_for_delete();
        }
        this->data.__unknown_flag_B = true;
    }

public:
    template <bool no_callbacks = false>
    forceinline void try_kill() {
        if (this->data.flags_allow_kill()) {
            this->try_kill_success<no_callbacks>();
        }
    }

    template <bool no_callbacks = false>
    forceinline void try_kill_by_kill_id(int32_t kill_id) {
        if (
            this->data.flags_allow_kill() &&
            this->data.kill_id == kill_id
        ) {
            this->try_kill_success<no_callbacks>();
        }
    }
};
#pragma region // Enemy Validation
//ValidateFieldOffset32(0x0, Enemy, vm);
ValidateFieldOffset32(0x122C, Enemy, data);
ValidateFieldOffset32(0x682C, Enemy, __on_kill_func);
ValidateFieldOffset32(0x6830, Enemy, id);
ValidateFieldOffset32(0x6834, Enemy, parent_id);
ValidateFieldOffset32(0x6838, Enemy, __dword_6838);
ValidateStructSize32(0x683C, Enemy);
#pragma endregion

// size: 0xC
struct RGB {
    int32_t r; // 0x0
    int32_t g; // 0x4
    int32_t b; // 0x8
    // 0xC

private:
    inline RGB& add(RGB& out, const RGB& value) const {
        out.r = this->r + value.r;
        out.g = this->g + value.g;
        out.b = this->b + value.b;
        return out;
    }
public:
    inline RGB operator+(const RGB& value) const {
        RGB dummy;
        return this->add(dummy, value);
    }

private:
    inline RGB& sub(RGB& out, const RGB& value) const {
        out.r = this->r - value.r;
        out.g = this->g - value.g;
        out.b = this->b - value.b;
        return out;
    }
public:
    inline RGB operator-(const RGB& value) const {
        RGB dummy;
        return this->sub(dummy, value);
    }

private:
    inline RGB& mul(RGB& out, const float value) const {
        out.r = this->r * value;
        out.g = this->g * value;
        out.b = this->b * value;
        return out;
    }
public:
    inline RGB operator*(const float value) const {
        RGB dummy;
        return this->mul(dummy, value);
    }
    friend inline RGB operator*(const float value, const RGB& rhs) {
        RGB dummy;
        return rhs.mul(dummy, value);
    }
};

typedef struct EnemyManager EnemyManager;
typedef struct Gui Gui;

extern "C" {
    // 0x4CF2E0
    externcg Gui* GUI_PTR cgasm("_GUI_PTR");
    // 0x570918
    externcg void* CACHED_MSG_FILE_PTR cgasm("_CACHED_MSG_FILE_PTR");
    // 0x57091C
    externcg BOOL FRONT_ANM_IS_LOADED cgasm("_FRONT_ANM_IS_LOADED");

    // 0x4CF2D0
    externcg EnemyManager* ENEMY_MANAGER_PTR cgasm("_ENEMY_MANAGER_PTR");
}



enum ReplayMode {
    __replay_recording = 0,
    __replay_playback = 1,
    __replay_mode_2 = 2
};

static inline bool is_replay();

typedef struct GameThread GameThread;
extern "C" {
    // 0x4CF2E4
    externcg GameThread* GAME_THREAD_PTR cgasm("_GAME_THREAD_PTR");
}

// size: 0xD8
struct GameThread : ZUNTask {
    //ZUNTask base; // 0x0
    Timer __timer_C; // 0xC
    int32_t stage_number; // 0x20
    int32_t chapter; // 0x24
    Config config; // 0x28
    union {
        uint32_t flags; // 0xB0
        struct {
            uint32_t __unknown_flag_A : 1; // 1
            uint32_t __unknown_flag_B : 1; // 2
            uint32_t skip_flag : 1; // 3
            uint32_t __unknown_flag_H : 1; // 4
            uint32_t __unknown_flag_I : 1; // 5
            uint32_t __unknown_flag_L : 1; // 6
            uint32_t __unknown_flag_M : 1; // 7
            uint32_t __unknown_flag_J : 1; // 8
            uint32_t __unknown_flag_D : 1; // 9
            uint32_t : 1; // 10
            uint32_t __unknown_flag_C : 1; // 11
            uint32_t __unknown_flag_K : 1; // 12
            uint32_t : 2; // 13-14
            uint32_t __unknown_flag_E : 1; // 15
            uint32_t : 1; // 16
            uint32_t __unknown_flag_F : 1; // 17
            uint32_t __unknown_flag_G : 1; // 18
        };
    };
    unknown_fields(0x4); // 0xB4
    int __int_B8; // 0xB8
    unknown_fields(0x14); // 0xBC
    ReplayMode replay_mode; // 0xD0
    int __int_D4; // 0xD4
    // 0xD8

    inline void zero_contents() {
        zero_this();
    }

    inline GameThread() {
        this->zero_contents();
    }

    // 0x4432C0
    dllexport gnu_noinline ~GameThread();

    // 0x443830
    dllexport static void cleanup() asm_symbol_rel(0x443830) {
        GameThread* game_thread = GAME_THREAD_PTR;
        WINDOW_DATA.__int_20D0 = 0;
        if (game_thread) {
            delete game_thread;
        }
    }

    // 0x439E80
    dllexport gnu_noinline void thiscall set_chapter(int32_t chapter) asm_symbol_rel(0x439E80) {
        GAME_MANAGER.globals.chapter = chapter;
        GAME_THREAD_PTR->chapter = chapter;
    }

    // 0x443860
    dllexport gnu_noinline UpdateFuncRet thiscall on_tick() asm_symbol_rel(0x443860);

    // 0x443D70
    dllexport gnu_noinline static UpdateFuncRet fastcall on_tick(void* ptr) asm_symbol_rel(0x443D70) {
        return ((GameThread*)ptr)->on_tick();
    }

    // 0x443D80
    dllexport gnu_noinline static UpdateFuncRet fastcall on_draw(void* ptr) asm_symbol_rel(0x443D80);

private:
    inline unsigned thread_start_impl();
public:
    // 0x4424E0
    dllexport gnu_noinline unsigned thiscall thread_start() {
        return GAME_THREAD_PTR->thread_start_impl();
    }

    // 0x4432B0
    dllexport static unsigned cdecl thread_start_stub(void*) {
        return GAME_THREAD_PTR->thread_start();
    }

    // 0x443E60
    dllexport gnu_noinline ZUNResult thiscall __sub_443E60() asm_symbol_rel(0x443E60) {

    }

    // 0x4443C0
    dllexport gnu_noinline ZUNResult thiscall __sub_4443C0() asm_symbol_rel(0x4443C0) {

    }

    // 0x4437B0
    dllexport gnu_noinline static GameThread* fastcall allocate(ReplayMode mode) asm_symbol_rel(0x4437B0) {
        GameThread* game_thread = new GameThread();
        WINDOW_DATA.__int_20D0 = 0;
        SUPERVISOR.d3d_device->EvictManagedResources();
        game_thread->skip_flag = true;
        GAME_THREAD_PTR = game_thread;
        game_thread->replay_mode = mode;
        SUPERVISOR.__start_thread_A94((_beginthreadex_proc_type)&thread_start_stub);
        return game_thread;
    }
};

static inline constexpr int32_t MENU_STACK_DEPTH = 16;

// size: 0xD8
struct MenuSelect {
    int32_t current_selection; // 0x0
    int32_t previous_selection; // 0x4
    int32_t menu_length; // 0x8
    int32_t selection_stack[MENU_STACK_DEPTH]; // 0xC
    int32_t menu_length_stack[MENU_STACK_DEPTH]; // 0x4C
    int32_t stack_index; // 0x8C
    int32_t disabled_selections[MENU_STACK_DEPTH]; // 0x90
    BOOL enable_wrap; // 0xD0
    int32_t disabled_selections_count; // 0xD4
    // 0xD8

    inline MenuSelect() {
        this->stack_index = 0;
        this->current_selection = 0;
        this->disabled_selections_count = 0;
        this->enable_wrap = TRUE;
        this->menu_length = 999;
    }

    // 0x402940
    dllexport gnu_noinline void thiscall push_state() asm_symbol_rel(0x402940) {
        this->selection_stack[this->stack_index] = this->current_selection;
        this->menu_length_stack[this->stack_index] = this->menu_length;
        ++this->stack_index;
        if (this->stack_index >= MENU_STACK_DEPTH) {
            this->stack_index = MENU_STACK_DEPTH - 1;
        }
        this->disabled_selections_count = 0;
    }

    // 0x402990
    dllexport gnu_noinline void thiscall pop_state() asm_symbol_rel(0x402990) {
        if (--this->stack_index < 0) {
            this->stack_index = 0;
            this->current_selection = 0;
            this->menu_length = 0;
            this->disabled_selections_count = 0;
        }
        else {
            this->current_selection = this->selection_stack[this->stack_index];
            this->menu_length = this->menu_length_stack[this->stack_index];
            this->disabled_selections_count = 0;
        }
    }

    // 0x4029E0
    dllexport gnu_noinline int32_t thiscall __move_selection(int32_t offset) asm_symbol_rel(0x4029E0) {
        int32_t selection = this->current_selection;
        int32_t menu_length = this->menu_length;

        if (menu_length > 0) {
            int32_t disabled_count = this->disabled_selections_count;

        retry_selection:
            selection += offset;
            this->current_selection = selection;
            if (selection >= menu_length) {
                BOOL wrap = this->enable_wrap;
                do {
                    if (wrap) {
                        selection -= menu_length;
                    } else {
                        --selection;
                    }
                    this->current_selection = selection;
                } while (selection >= menu_length);
            }
            if (selection < 0) {
                BOOL wrap = this->enable_wrap;
                do {
                    if (wrap) {
                        selection += menu_length;
                    } else {
                        selection = 0;
                    }
                    this->current_selection = selection;
                } while (selection < 0);
            }

            for (int32_t i = 0; i < disabled_count; ++i) {
                if (this->current_selection == this->disabled_selections[i]) {
                    goto retry_selection;
                }
            }
        }

        return selection;
    }
};
#pragma region // MenuSelect Verification
ValidateFieldOffset32(0x0, MenuSelect, current_selection);
ValidateFieldOffset32(0x4, MenuSelect, previous_selection);
ValidateFieldOffset32(0x8, MenuSelect, menu_length);
ValidateFieldOffset32(0xC, MenuSelect, selection_stack);
ValidateFieldOffset32(0x4C, MenuSelect, menu_length_stack);
ValidateFieldOffset32(0x8C, MenuSelect, stack_index);
ValidateFieldOffset32(0x90, MenuSelect, disabled_selections);
ValidateFieldOffset32(0xD0, MenuSelect, enable_wrap);
ValidateFieldOffset32(0xD4, MenuSelect, disabled_selections_count);
ValidateStructSize32(0xD8, MenuSelect);
#pragma endregion

// size: 0x4
struct MsgInstruction {
    uint16_t time; // 0x0
    uint8_t opcode; // 0x2
    uint8_t args_size; // 0x3
    unsigned char args[]; // 0x4
};

namespace Msg {
enum Opcode : uint8_t {
    msg_delete = 0,
    initialize_player = 1,
    initialize_boss = 2,
    initialize_textbox = 3,
    delete_player = 4,
    delete_boss = 5,
    delete_textbox = 6,
    focus_player = 7,
    focus_boss = 8,
    focus_none = 9,
    msg_flag_wait_skippable = 10,
    wait = 11,
    ecl_resume = 12,
    portrait_player = 13,
    portrait_boss = 14,
    text_top_line = 15,
    text_bottom_line = 16,
    text_dialogue = 17,
    text_clear = 18,
    music_boss = 19,
    text_intro = 20,
    stage_end = 21,
    music_fade_out = 22,
    player_shake = 23,
    boss_shake = 24,
    text_offset = 25,
    __unknown_flag_set_A = 26,
    music_fade_out_time = 27,
    text_position = 28,
    text_type = 29,
    
};
}

// 0x570DA0
static char MSG_DECRYPT_BUFFER[0x100];

// 0x4419F0
dllexport gnu_noinline const char* fastcall __decrypt_related(const char* str) {
    uint8_t xor_mask = 0x77;
    uint8_t xor_accel = 7;

    char* buffer_write = MSG_DECRYPT_BUFFER;
    uint8_t c;
    do {
        c = *str++;
        c ^= xor_mask;
        xor_mask += xor_accel;
        xor_accel += 16;
        *buffer_write++ = c;
    } while (c);

    char* buffer_read = MSG_DECRYPT_BUFFER;

    while ((c = *buffer_read)) {
        if (
            (c <= 0x80 || 0xA0 <= c) &&
            (c + ' ' > 0x1C)
        ) {
            if (c == '_') {
                *buffer_read = ' ';
            }
        } else {
            ++buffer_read;
        }
        ++buffer_read;
    }

    return MSG_DECRYPT_BUFFER;
}

static inline constexpr size_t MAX_PORTRAIT_COUNT = 4;
static inline constexpr size_t MAX_DIALOG_LINE_COUNT = 2;

// 0x4B6620
static int32_t PLAYER_PORTRAIT_SCRIPT_TABLE[] = {
    40, 46, 29, 28
};

// size: 0x1D8
struct MsgVM {
    unknown_fields(0x4); // 0x0
    Timer __timer_4; // 0x4
    Timer script_time; // 0x18
    Timer pause_timer; // 0x2C
    AnmID player_portraits[MAX_PORTRAIT_COUNT]; // 0x40
    AnmID enemy_portraits[MAX_PORTRAIT_COUNT]; // 0x50
    AnmID __anm_id_60; // 0x60
    AnmID dialogue_lines[MAX_DIALOG_LINE_COUNT]; // 0x64
    AnmID furigana_lines[MAX_DIALOG_LINE_COUNT]; // 0x6C
    AnmID intro; // 0x74
    AnmID __textbox_related; // 0x78
    AnmID __anm_id_7C; // 0x7C
    int32_t menu_time; // 0x80
    int32_t menu_state; // 0x84
    MenuSelect menu_controller; // 0x88
    int __dword_160; // 0x160
    MsgInstruction* current_instr; // 0x164
    Float3 __float3_168; // 0x168
    Float3 __float3_174; // 0x174
    Float3 __float3_180; // 0x180
    Float3 __float3_18C; // 0x18C
    int32_t __enemy_appear_counter; // 0x198
    union {
        uint32_t flags; // 0x19C
        struct {
            uint32_t __unknown_flag_B : 1; // 1
            uint32_t __unknown_flag_C : 1; // 2
            uint32_t : 3; // 3-5
            uint32_t __unknown_flag_A : 1; // 6
        };
    };
    int32_t next_text_line; // 0x1A0
    int __dword_1A4; // 0x1A4
    int32_t __int_1A8; // 0x1A8
    int32_t active_portait; // 0x1AC
    D3DCOLOR __color_array_1B0[1]; // 0x1B0
    int __dword_1B4; // 0x1B4
    int __dword_1B8; // 0x1B8
    int __dword_1BC; // 0x1BC
    Float3 callout_position; // 0x1C0
    float __float_1CC; // 0x1CC
    unknown_fields(0x4); // 0x1D0
    int32_t __int_1D4; // 0x1D4
    // 0x1D8

    // 0x43A3F0
    dllexport gnu_noinline ~MsgVM();
    
private:
    // 0x4416D0
    dllexport gnu_noinline void vectorcall __sub_4416D0(int, float, float arg1, float arg2, float arg3, int arg4) asm_symbol_rel(0x4416D0) {
        this->__textbox_related.mark_tree_for_delete();
        // TODO
    }
public:
    inline void __sub_4416D0(float arg1, float arg2, float arg3, int arg4) {
        return this->__sub_4416D0(UNUSED_DWORD, UNUSED_FLOAT, arg1, arg2, arg3, arg4);
    }

    // 0x43E550
    dllexport gnu_noinline ZUNResult thiscall run_msg() {
        using namespace Msg;

        if (this->__enemy_appear_counter > 0) {
            --this->__enemy_appear_counter;
        }
        if (this->__int_1A8 > 0) {
            --this->__int_1A8;
        } else {
            if (INPUT_STATES[0].check_inputs_no_repeat(BUTTON_SHOOT | BUTTON_SKIP)) {
                this->__unknown_flag_A = true;
            }
        }
        if (
            (this->__unknown_flag_A & this->__unknown_flag_B) &&
            (
                (INPUT_STATES[0].check_inputs(BUTTON_SKIP) && INPUT_STATES[0].inputs_held[BUTTON_SKIP_INDEX] >= 20) ||
                (INPUT_STATES[0].check_inputs(BUTTON_SHOOT) && INPUT_STATES[0].inputs_held[BUTTON_SHOOT_INDEX] >= 20)
            )
        ) {
            this->script_time.set(this->current_instr->time);
        }

        for (
            MsgInstruction* current_instruction = this->current_instr;
            this->script_time >= current_instruction->time;
            this->current_instr = IndexInstr(sizeof(MsgInstruction) + this->current_instr->args_size)
        ) {
            switch (current_instruction->opcode) {
                case __unknown_flag_set_A: // 36
                    this->__unknown_flag_C = true;
                    break;
                case text_top_line: { // 15
                    AnmVM* vm = this->dialogue_lines[0].get_vm_ptr();
                    const char* text = __decrypt_related(StringArg(0));
                    // ANM_MANAGER_PTR->draw_text_left(vm, this->__color_array_1B0[this->active_portait], 0, this->__unknown_flag_C + 4, 0, 0, text);
                    break;
                }
                case text_bottom_line: { // 16
                    AnmVM* vm = this->dialogue_lines[1].get_vm_ptr();
                    const char* text = __decrypt_related(StringArg(0));
                    // ANM_MANAGER_PTR->draw_text_left(vm, this->__color_array_1B0[this->active_portait], 0, this->__unknown_flag_C + 4, 0, 0, text);
                    break;
                }
                case text_position: // 28
                    this->callout_position.x = FloatArg(0) * 2;
                    this->callout_position.y = FloatArg(1) * 2;
                    break;
                case text_dialogue: { // 17
                    // TODO: A disgusting pile of inlined ANM code
                    break;
                }
                case text_clear: // 18
                    this->__textbox_related.mark_tree_for_delete();
                    this->dialogue_lines[0].interrupt_tree(3);
                    this->dialogue_lines[1].interrupt_tree(3);
                    this->furigana_lines[0].interrupt_tree(3);
                    this->furigana_lines[1].interrupt_tree(3);
                    break;
                case initialize_player: { // 1
                    int32_t who = IntArg(0);
                    if (who == 0) {

                    }
                    else {

                    }
                }
            }
        }
        this->script_time++;
        if (AnmVM* vm = this->__textbox_related.__wtf_child_list_jank_A(this->__int_1D4 + 170, 0)) {
            // TODO
        }
        return ZUN_SUCCESS;
    }

    inline ZUNResult on_tick() {
        if (ABILITY_SHOP_PTR) {
            this->__unknown_flag_A = false;
            this->__int_1A8 = 2;
        }
        else {
            if (ZUN_FAILED(this->run_msg())) {
                return ZUN_ERROR;
            }
            this->__timer_4++;
        }
        return ZUN_SUCCESS;
    }
};
#pragma region // MsgVM Validation
ValidateFieldOffset32(0x4, MsgVM, __timer_4);
ValidateFieldOffset32(0x18, MsgVM, script_time);
ValidateFieldOffset32(0x2C, MsgVM, pause_timer);
ValidateFieldOffset32(0x40, MsgVM, player_portraits);
ValidateFieldOffset32(0x50, MsgVM, enemy_portraits);
ValidateFieldOffset32(0x60, MsgVM, __anm_id_60);
ValidateFieldOffset32(0x64, MsgVM, dialogue_lines);
ValidateFieldOffset32(0x6C, MsgVM, furigana_lines);
ValidateFieldOffset32(0x74, MsgVM, intro);
ValidateFieldOffset32(0x78, MsgVM, __textbox_related);
ValidateFieldOffset32(0x7C, MsgVM, __anm_id_7C);
ValidateFieldOffset32(0x80, MsgVM, menu_time);
ValidateFieldOffset32(0x84, MsgVM, menu_state);
ValidateFieldOffset32(0x88, MsgVM, menu_controller);
ValidateFieldOffset32(0x160, MsgVM, __dword_160);
ValidateFieldOffset32(0x164, MsgVM, current_instr);
ValidateFieldOffset32(0x168, MsgVM, __float3_168);
ValidateFieldOffset32(0x174, MsgVM, __float3_174);
ValidateFieldOffset32(0x180, MsgVM, __float3_180);
ValidateFieldOffset32(0x18C, MsgVM, __float3_18C);
ValidateFieldOffset32(0x198, MsgVM, __enemy_appear_counter);
ValidateFieldOffset32(0x19C, MsgVM, flags);
ValidateFieldOffset32(0x1A0, MsgVM, next_text_line);
ValidateFieldOffset32(0x1A4, MsgVM, __dword_1A4);
ValidateFieldOffset32(0x1A8, MsgVM, __int_1A8);
ValidateFieldOffset32(0x1AC, MsgVM, active_portait);
ValidateFieldOffset32(0x1B0, MsgVM, __color_array_1B0);
ValidateFieldOffset32(0x1B4, MsgVM, __dword_1B4);
ValidateFieldOffset32(0x1B8, MsgVM, __dword_1B8);
ValidateFieldOffset32(0x1BC, MsgVM, __dword_1BC);
ValidateFieldOffset32(0x1C0, MsgVM, callout_position);
ValidateFieldOffset32(0x1CC, MsgVM, __float_1CC);
ValidateFieldOffset32(0x1D4, MsgVM, __int_1D4);
ValidateStructSize32(0x1D8, MsgVM);
#pragma endregion

#pragma region IMPORTED_FROM_VD_DATA_NEEDS_VALIDATION
// size: 0x8
struct LifebarMarker {
    float bar_position; // 0x0
    D3DCOLOR section_color; // 0x4
    // 0x8
};

static inline constexpr int32_t MAX_LIFEBAR_MARKERS = 4;

// size: 0x54
struct Lifebar {
    float bar_value; // 0x0, 0x1C4
    float life_percentage; // 0x4, 0x1C8
    int32_t current_life; // 0x8, 0x1CC
    unknown_fields(0x4); // 0xC, 0x1D0
    LifebarMarker markers[MAX_LIFEBAR_MARKERS]; // 0x10, 0x1D4
    AnmID main_vm; // 0x30, 0x1F4
    AnmID glowA_vm; // 0x34, 0x1F8
    AnmID glowB_vm; // 0x38, 0x1FC
    AnmID marker_vms[MAX_LIFEBAR_MARKERS]; // 0x3C, 0x200
    BOOL vms_initialized; // 0x4C, 0x210
    int __dword_50; // 0x50, 0x214
    // 0x54

    inline void zero_contents() {
        zero_this_inline();
    }

    inline Lifebar() {
        this->zero_contents();
    }

    inline void interrupt_vms(int32_t interrupt);

    inline void delete_vms();

    inline void clear() {
        this->bar_value = 0.0f;
        for (size_t i = 0; i < MAX_LIFEBAR_MARKERS; ++i) {
            this->markers[i].bar_position = 0.0f;
        }
        this->delete_vms();
    }
};
#pragma endregion

static inline constexpr int32_t MAX_LIFEBARS_IN_GUI = 3;
static inline constexpr uint32_t MAX_BOSS_LIFE_MARKERS = 10;

static inline constexpr int32_t LIFE_ICONS_IN_GUI = 7;
static inline constexpr int32_t BOMB_ICONS_IN_GUI = 7;

// size: 0x2CC
struct Gui : ZUNTask {
    // ZUNTask base; // 0x0
    AnmID __anm_id_C; // 0xC
    AnmID __anm_id_10; // 0x10
    AnmID __anm_id_14; // 0x14
    AnmID __anm_id_18; // 0x18
    AnmID __anm_id_1C; // 0x1C
    AnmID __anm_id_20; // 0x20
    AnmID __anm_id_24; // 0x24
    AnmID __anm_id_28; // 0x28
    AnmID __anm_id_2C; // 0x2C
    AnmID __anm_id_30; // 0x30
    AnmID __anm_id_34; // 0x34
    AnmID __anm_id_38; // 0x38
    AnmID __anm_id_3C; // 0x3C
    AnmID __anm_id_40; // 0x40
    AnmID __anm_id_44; // 0x44
    AnmID __anm_id_48; // 0x48
    AnmVM* player_life_icons[LIFE_ICONS_IN_GUI]; // 0x4C
    AnmVM* player_bomb_icons[BOMB_ICONS_IN_GUI]; // 0x68
    AnmVM* __anm_vm_84; // 0x84
    AnmVM* __anm_vm_88; // 0x88
    AnmID __anm_id_8C; // 0x8C
    AnmID __anm_id_array_90[10]; // 0x90
    AnmID __anm_id_B8; // 0xB8
    AnmID __anm_id_BC; // 0xBC
    AnmID __anm_id_C0; // 0xC0
    AnmID __anm_id_C4; // 0xC4
    AnmID __anm_id_C8; // 0xC8
    AnmID __boss_life_markers[MAX_BOSS_LIFE_MARKERS]; // 0xCC
    AnmID __anm_id_F4; // 0xF4
    AnmID __anm_id_F8; // 0xF8
    AnmID __anm_id_FC; // 0xFC
    AnmID __anm_id_100; // 0x100
    AnmID __anm_id_104; // 0x104
    AnmID __anm_id_108; // 0x108
    AnmID __anm_id_10C; // 0x10C
    AnmID __anm_id_110; // 0x110
    AnmID __anm_id_114; // 0x114
    unknown_fields(0x4); // 0x118
    float __float_11C; // 0x11C
    float __float_120; // 0x120
    int __int_124; // 0x124
    int __int_128; // 0x128
    int __int_12C; // 0x12C
    unknown_fields(0x4); // 0x130
    int __int_134; // 0x134
    AnmID __anm_id_138; // 0x138
    Timer __timer_13C; // 0x13C
    UpdateFunc* on_draw_func_B; // 0x150
    unknown_fields(0x4); // 0x154
    int32_t __score; // 0x158
    int32_t __int_15C; // 0x15C
    AnmLoaded* stage_logo_anm; // 0x160
    unknown_fields(0xC); // 0x164
    int32_t __boss_life_count; // 0x170
    unknown_fields(0x20); // 0x174
    union {
        uint32_t flags; // 0x194
        struct {
            uint32_t : 1; // 1
            uint32_t __unknown_field_C : 2; // 2-3
            uint32_t : 2; // 4-5
            uint32_t __unknown_field_D : 3; // 6-8
            uint32_t __unknown_flag_A : 1; // 9
            uint32_t __unknown_field_B : 2; // 10-11
            uint32_t __unknown_field_A : 2; // 12-13
        };
    };
    Timer __timer_198; // 0x198
    int32_t __int_1AC; // 0x1AC
    MsgVM* msg_vm; // 0x1B0
    void* msg_file; // 0x1B4
    int32_t spell_timer_seconds; // 0x1B8
    int32_t spell_timer_hundredths; // 0x1BC
    int32_t __int_1C0; // 0x1C0
    Lifebar lifebars[MAX_LIFEBARS_IN_GUI]; // 0x1C4
    AnmLoaded* __anm_loaded_2C0; // 0x2C0
    int32_t __int_2C4; // 0x2C4
    unknown_fields(0x4); // 0x2C8
    // 0x2CC

    inline void zero_contents() {
        zero_this();
    }

    inline Gui() {
        this->zero_contents();
        this->__unknown_task_flag_A = true;
    }

    // 0x43B350
    dllexport gnu_noinline void thiscall cleanup() asm_symbol_rel(0x43B350);

    // 0x43B560
    dllexport gnu_noinline ~Gui();

    inline void update_spell_timer(int32_t time) {
        // I'm only ~80% sure I got this math right
        int32_t seconds = time / 60;
        int32_t frames = time % 60;

        int32_t hundredths = frames * 100;
        hundredths += (hundredths / 60);

        this->spell_timer_seconds = seconds > 99 ? seconds : 99;
        this->spell_timer_hundredths = seconds > 99 ? hundredths : 99; // Is this a bug?
    }

    // 0x441F10
    dllexport gnu_noinline void thiscall __update_life_ui(int32_t life_count, int32_t life_fragments, int32_t life_max) asm_symbol_rel(0x441F10);

    // 0x4420E0
    dllexport gnu_noinline void thiscall __update_bomb_ui(int32_t bomb_count, int32_t bomb_fragments, int32_t bomb_max) asm_symbol_rel(0x4420E0);

    // 0x4422C0
    dllexport gnu_noinline void thiscall __sub_4422C0() asm_symbol_rel(0x4422C0);

    // 0x42D560
    dllexport gnu_noinline void __set_boss_life_count(int value) asm_symbol_rel(0x42D560) {
        this->__boss_life_count = value;
    }

    // 0x42D570
    dllexport gnu_noinline void vectorcall set_lifebar_marker(int32_t bar_index, int32_t marker_index, D3DCOLOR color, float position) asm_symbol_rel(0x42D570) {
        Gui* gui = GUI_PTR;
        gui->lifebars[bar_index].markers[marker_index].bar_position = position;
        gui->lifebars[bar_index].markers[marker_index].section_color = color;
    }

    // 0x42D5B0
    dllexport gnu_noinline int32_t __get_enemy_appear_counter() asm_symbol_rel(0x42D5B0) {
        return GUI_PTR->msg_vm->__enemy_appear_counter;
    }

    // 0x43A730
    dllexport gnu_noinline ZUNResult thiscall __initialize() asm_symbol_rel(0x43A730);

    // 0x407D60
    dllexport bool thiscall msg_vm_active() {
        return this->msg_vm;
    }

    static inline bool msg_is_active() {
        if (Gui* gui = GUI_PTR) {
            return gui->msg_vm_active();
        }
        return false;
    }

    static inline bool msg_is_inactive() {
        if (Gui* gui = GUI_PTR) {
            return !gui->msg_vm_active();
        }
        return false;
    }

    // 0x441ED0
    dllexport gnu_noinline void thiscall __display_stage_logo() asm_symbol_rel(0x441ED0);

    // 0x43A8B0
    dllexport gnu_noinline static void __sub_43A8B0() {

    }

    // 0x43BB70
    dllexport gnu_noinline UpdateFuncRet thiscall on_tick() asm_symbol_rel(0x43BB70);

    // 0x43CD00
    dllexport gnu_noinline UpdateFuncRet thiscall on_draw() asm_symbol_rel(0x43CD00);

    // 0x43D6F0
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_tick(void* ptr) asm_symbol_rel(0x43D6F0) {
        return ((Gui*)ptr)->on_tick();
    }

    // 0x43D700
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw(void* ptr) asm_symbol_rel(0x43D700) {
        return UpdateFuncNext;
    }

    // 0x43D710
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw_B(void* ptr) asm_symbol_rel(0x43D710) {
        return ((Gui*)ptr)->on_draw();
    }

    // 0x43B800
    dllexport gnu_noinline static Gui* allocate() asm_symbol_rel(0x43B800);
};
#pragma region // Gui Validation
ValidateFieldOffset32(0x0, Gui, task_flags);
ValidateFieldOffset32(0x4, Gui, on_tick_func);
ValidateFieldOffset32(0x8, Gui, on_draw_func);
ValidateFieldOffset32(0x4C, Gui, player_life_icons);
ValidateFieldOffset32(0x68, Gui, player_bomb_icons);
ValidateFieldOffset32(0x84, Gui, __anm_vm_84);
ValidateFieldOffset32(0x88, Gui, __anm_vm_88);
ValidateFieldOffset32(0x90, Gui, __anm_id_array_90);
ValidateFieldOffset32(0x8C, Gui, __anm_id_8C);
ValidateFieldOffset32(0xB8, Gui, __anm_id_B8);
ValidateFieldOffset32(0xBC, Gui, __anm_id_BC);
ValidateFieldOffset32(0x108, Gui, __anm_id_108);
ValidateFieldOffset32(0x10C, Gui, __anm_id_10C);
ValidateFieldOffset32(0x110, Gui, __anm_id_110);
ValidateFieldOffset32(0x134, Gui, __int_134);
ValidateFieldOffset32(0x138, Gui, __anm_id_138);
ValidateFieldOffset32(0x13C, Gui, __timer_13C);
ValidateFieldOffset32(0x150, Gui, on_draw_func_B);
ValidateFieldOffset32(0x158, Gui, __score);
ValidateFieldOffset32(0x15C, Gui, __int_15C);
ValidateFieldOffset32(0x170, Gui, __boss_life_count);
ValidateFieldOffset32(0x194, Gui, flags);
ValidateFieldOffset32(0x198, Gui, __timer_198);
ValidateFieldOffset32(0x1B0, Gui, msg_vm);
ValidateFieldOffset32(0x1B4, Gui, msg_file);
ValidateFieldOffset32(0x1B8, Gui, spell_timer_seconds);
ValidateFieldOffset32(0x1BC, Gui, spell_timer_hundredths);
ValidateFieldOffset32(0x1C0, Gui, __int_1C0);
ValidateFieldOffset32(0x1C4, Gui, lifebars);
ValidateFieldOffset32(0x2C0, Gui, __anm_loaded_2C0);
ValidateFieldOffset32(0x2C4, Gui, __int_2C4);
ValidateStructSize32(0x2CC, Gui);
#pragma endregion

static inline void __update_life_ui() {
    if (Gui* gui = GUI_PTR) {
        gui->__update_life_ui(GAME_MANAGER.globals.life_stocks, GAME_MANAGER.globals.life_fragments, GAME_MANAGER.globals.life_stock_max);
    }
}

static inline void __update_bomb_ui() {
    if (Gui* gui = GUI_PTR) {
        gui->__update_bomb_ui(GAME_MANAGER.globals.bomb_stocks, GAME_MANAGER.globals.bomb_fragments, GAME_MANAGER.globals.bomb_stock_max);
    }
}

// 0x4767B0
dllexport gnu_noinline DWORD WINAPI SoundManager::load_sound_effects(void* self) {
    int32_t i = 0;
    do {
        if (SOUND_MANAGER.__dword_5724 == 2) {
            return 1;
        }
        void* sound_effect_file = read_file_to_buffer(SOUND_EFFECT_FILENAMES[i], NULL, false);
        SOUND_MANAGER.sound_effect_files[i] = sound_effect_file;
        if (!sound_effect_file) {
            LOG_BUFFER.write(JpEnStr("", "error : Sound File cannot read Check data %s\r\n"), SOUND_EFFECT_FILENAMES[i]);
            return 1;
        }
    } while (++i < countof(SOUND_EFFECT_FILENAMES));
    while (SOUND_MANAGER.__dword_5724 == 0) {
        Sleep(1);
    }
    return 0;
}

// 0x4776F0
dllexport gnu_noinline ZUNResult thiscall SoundManagerUnknownB::__sub_4776F0(const char* filename) {
    if (SOUND_MANAGER.csound_manager_ptr) {
        SAFE_RELEASE(this->sound_buffer);
        SoundManagerUnknownB* unknown_b_ptr = SOUND_MANAGER.__unknown_smb_array_1A84;
        int32_t idk = this->__int_C;
        int32_t current_filename_index = this->data->filename_index;
        for (int32_t i = 0; i < idk; ++i, ++unknown_b_ptr) {
            if (unknown_b_ptr->data->filename_index == current_filename_index) {
                SOUND_MANAGER.dsound->DuplicateSoundBuffer(SOUND_MANAGER.__unknown_smb_array_1A84[i].sound_buffer, &this->sound_buffer);
                return ZUN_SUCCESS;
            }
        }
        while (!SOUND_MANAGER.sound_effect_files[this->data->filename_index]) {
            Sleep(10);
        }
        const char* error_text;
        if (WavFile* sound_file = (WavFile*)SOUND_MANAGER.sound_effect_files[this->data->filename_index]) {
            if (!strncmp(sound_file->header.riff_text, "RIFF", sizeof(sound_file->header.riff_text))) {
                error_text = JpEnStr("Wav t@C %s\r\n", "Not a Wav file %s\r\n");
                goto OtherError;
            }
            int32_t file_size = sound_file->header.remaining_file_size;
            if (!strncmp(sound_file->header.wave_text, "WAVE", sizeof(sound_file->header.wave_text))) {
                goto MalformedWaveError;
            }
            int32_t data_size = file_size - sizeof(WavFileHeader);
            WAVEFORMATEX* wav_format_ptr = (WAVEFORMATEX*)get_wav_chunk_data(sound_file->chunks, "fmt ", &file_size, data_size);
            if (!wav_format_ptr) {
                goto MalformedWaveError;
            }
            WAVEFORMATEX wav_format = *wav_format_ptr;
            unsigned char* sound_data_ptr = get_wav_chunk_data(sound_file->chunks, "data", &file_size, data_size);
            if (!sound_data_ptr) {
                goto MalformedWaveError;
            }
            DSBUFFERDESC wav_buffer_desc = {
                .dwSize = sizeof(DSBUFFERDESC),
                .dwFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | DSBCAPS_LOCSOFTWARE,
                .dwBufferBytes = (DWORD)file_size,
                .dwReserved = 0,
                .lpwfxFormat = &wav_format,
                .guid3DAlgorithm = DS3DALG_DEFAULT
            };
            if (SUCCEEDED(SOUND_MANAGER.dsound->CreateSoundBuffer(&wav_buffer_desc, &this->sound_buffer, NULL))) {
                LPVOID buffer_contents_ptr_A, buffer_contents_ptr_B;
                DWORD buffer_contents_size_A, buffer_contents_size_B;
                if (SUCCEEDED(this->sound_buffer->Lock(0, file_size, &buffer_contents_ptr_A, &buffer_contents_size_A, &buffer_contents_ptr_B, &buffer_contents_size_B, 0))) {
                    memcpy(buffer_contents_ptr_A, sound_data_ptr, buffer_contents_size_A);
                    if (buffer_contents_size_B) {
                        memcpy(buffer_contents_ptr_B, sound_data_ptr + buffer_contents_size_A, buffer_contents_size_B);
                    }
                    this->sound_buffer->Unlock(buffer_contents_ptr_A, buffer_contents_size_A, buffer_contents_ptr_B, buffer_contents_size_B);
                    SAFE_FREE(SOUND_MANAGER.sound_effect_files[this->data->filename_index]);
                    DebugLogger::__debug_log_stub_10("Create Sound Buffer %s\n", filename);
                }
            }
        }
        else {
MalformedWaveError:
            error_text = JpEnStr("Wav t@C? %s\r\n", "Isn't it a Wav file? %s\r\n");
OtherError:
            LOG_BUFFER.write(error_text, filename);
            SAFE_FREE(SOUND_MANAGER.sound_effect_files[this->data->filename_index]);
            return ZUN_ERROR;
        }
    }
    return ZUN_SUCCESS;
}

// 0x476320
dllexport gnu_noinline int32_t SoundManager::__wait_and_close_handles() {
    if (SOUND_MANAGER.__thread_5718) {
        SOUND_MANAGER.__dword_5724 = SOUND_MANAGER.__dword_5724 == 0 ? 1 : SOUND_MANAGER.__dword_5724;
        while (WaitForSingleObject(SOUND_MANAGER.__thread_5718, 100) == WAIT_TIMEOUT) {
            Sleep(1);
        }
        while (WaitForSingleObject(SOUND_MANAGER.__handle_571C, 100) == WAIT_TIMEOUT) {
            Sleep(1);
        }
        CloseHandle(SOUND_MANAGER.__thread_5718);
        CloseHandle(SOUND_MANAGER.__handle_571C);
        SOUND_MANAGER.__thread_5718 = NULL;
        SOUND_MANAGER.__handle_571C = NULL;
    }
    return 0;
}

// 0x4763D0
dllexport gnu_noinline DWORD WINAPI SoundManager::sound_thread_func(void* self) {
    SOUND_MANAGER.__sub_476410(SOUND_MANAGER.main_window_hwnd);
    //while (!SOUND_MANAGER.__dword_5724) {
        //Sleep(1);
    //}
    SOUND_MANAGER.__dword_572C = 1;
    return 0;
}

// 0x476410
dllexport gnu_noinline ZUNResult SoundManager::__sub_476410(HWND window_hwnd_arg) {
    HWND window_hwnd = window_hwnd_arg;
    this->copy_sound_data();
    memset(this->active_sound_ids, -1, sizeof(this->active_sound_ids));
    CSoundManager* csound_manager_ptr = new CSoundManager();
    this->csound_manager_ptr = csound_manager_ptr;
    if (SUCCEEDED(csound_manager_ptr->Initialize(window_hwnd, DSSCL_PRIORITY))) {
        csound_manager_ptr->SetPrimaryBufferFormat(2, 44100, 16);
        LPDIRECTSOUND8 dsound = this->csound_manager_ptr->GetDirectSound();
        this->dsound = dsound;
        LPDIRECTSOUNDBUFFER* buffer_ptr_ptr = &this->sound_buffer_ptr;
        WAVEFORMATEX sound_format = {
            .wFormatTag = WAVE_FORMAT_1M08,
            .nChannels = 2,
            .nSamplesPerSec = 44100,
            .nAvgBytesPerSec = 176400,
            .nBlockAlign = 4,
            .wBitsPerSample = 16,
            .cbSize = 0
        };
        DSBUFFERDESC buffer_desc = {
            .dwSize = sizeof(DSBUFFERDESC),
            .dwFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_LOCSOFTWARE,
            .dwBufferBytes = 0x8000,
            .dwReserved = 0,
            .lpwfxFormat = &sound_format,
            .guid3DAlgorithm = DS3DALG_DEFAULT
        };
        if (FAILED(dsound->CreateSoundBuffer(&buffer_desc, buffer_ptr_ptr, NULL))) {
            return ZUN_ERROR;
        }
        LPVOID buffer_contents_ptr_A;
        DWORD buffer_contents_size_A;
        LPVOID buffer_contents_ptr_B;
        DWORD buffer_contents_size_B;
        if (FAILED((*buffer_ptr_ptr)->Lock(0, 0x8000, &buffer_contents_ptr_A, &buffer_contents_size_A, &buffer_contents_ptr_B, &buffer_contents_size_B, 0))) {
            return ZUN_ERROR;
        }
        memset(buffer_contents_ptr_A, 0, buffer_contents_size_A);
        (*buffer_ptr_ptr)->Unlock(buffer_contents_ptr_A, buffer_contents_size_A, buffer_contents_ptr_B, buffer_contents_size_B);
        (*buffer_ptr_ptr)->Play(0, 0, DSBPLAY_LOOPING);
        this->__int_5730 = 100;
        this->__int_5734 = 100;
        SetTimer(window_hwnd, 0, 250, NULL);
        this->timer_hwnd = window_hwnd;
        window_hwnd = NULL;
        SoundManagerUnknownB* unknown_b_ptr = this->__unknown_smb_array_1A84;
        SoundData* sound_data = SOUND_DATA;
        for (size_t i = 0; sound_data < array_end_addr(SOUND_DATA); ++i, ++sound_data, ++unknown_b_ptr) {
            if (SOUND_MANAGER.__dword_5724 == 2) {
                return ZUN_ERROR;
            }
            if (ZUN_FAILED(unknown_b_ptr->__sub_4776F0(SOUND_EFFECT_FILENAMES[sound_data->filename_index]))) {
                LOG_BUFFER.write(
                    JpEnStr("error : Sound t@C f[^mF %s\r\n", "error : Sound File cannot read Check data %s\r\n")
                    , SOUND_EFFECT_FILENAMES[SOUND_DATA[i].filename_index]
                );
                return ZUN_ERROR;
            }
        }
        LOG_BUFFER.write(JpEnStr("DirectSound \r\n", "DirectSound has been successfully initialized\r\n"));
        return ZUN_SUCCESS;
    } else {
        LOG_BUFFER.write(JpEnStr("DirectSound IuWFNgs\r\n", "Initialization of DirectSound object failed\r\n"));
        if (this->csound_manager_ptr) {
            SAFE_DELETE(this->csound_manager_ptr);
        }
        return ZUN_ERROR;
    }
}

// 0x476B40
dllexport gnu_noinline void thiscall SoundManager::__sub_476B40() {
    if (SoundManagerUnknownE* sme_ptr = this->__unknown_sme_ptr_5704) {
        sme_ptr->__sub_48A620(true);
        if (this->__handle_14) {
            do {
                PostThreadMessageA(this->sound_thread_id, WM_QUIT, 0, 0);
            } while (WaitForSingleObject(this->__handle_14, 256));
            CloseHandle(this->__handle_14);
            CloseHandle(this->__handle_570C);
            this->__handle_14 = 0;
        }
    }
    SAFE_DELETE(this->__unknown_sme_ptr_5704);
}

// 0x476BE0
dllexport gnu_noinline void stdcall SoundManager::play_sound_centered(int32_t sound_id, float) {
    int32_t idk = SOUND_DATA[sound_id].__short_A;
    nounroll for (size_t i = 0; i < countof(SOUND_MANAGER.active_sound_ids); ++i) {
        int32_t active_sound_id = SOUND_MANAGER.active_sound_ids[i];
        if (active_sound_id < 0) {
            SOUND_MANAGER.active_sound_ids[i] = sound_id;
            SOUND_MANAGER.__unknown_smf_array_7C[i].__int_array_0[0] = 0;
            SOUND_MANAGER.active_sound_id_counts[i] = 1;
            SOUND_MANAGER.__unknown_smb_array_1A84[i].__int_4 = idk;
            return;
        }
        if (active_sound_id == sound_id) {
            int32_t active_sound_id_count = SOUND_MANAGER.active_sound_id_counts[i];
            int32_t* active_sound_id_count_ptr = &SOUND_MANAGER.active_sound_id_counts[i];
            if (active_sound_id_count < 60 && active_sound_id_count >= 0) {
                SOUND_MANAGER.__unknown_smf_array_7C[i].__int_array_0[active_sound_id_count] = 0;
                ++*active_sound_id_count_ptr;
            }
            return;
        }
    }
}

// 0x476C70
dllexport gnu_noinline void vectorcall SoundManager::play_sound_positioned(int32_t sound_id, float position) {
    int32_t idk = SOUND_DATA[sound_id].__short_A;
    int32_t idk2 = (int32_t)(position * 1000.0f / 192.0f);
    nounroll for (size_t i = 0; i < countof(SOUND_MANAGER.active_sound_ids); ++i) {
        int32_t active_sound_id = SOUND_MANAGER.active_sound_ids[i];
        if (active_sound_id < 0) {
            SOUND_MANAGER.active_sound_ids[i] = sound_id;
            SOUND_MANAGER.__unknown_smf_array_7C[i].__int_array_0[0] = idk2;
            SOUND_MANAGER.active_sound_id_counts[i] = 1;
            SOUND_MANAGER.__unknown_smb_array_1A84[i].__int_4 = idk;
            return;
        }
        if (active_sound_id == sound_id) {
            int32_t active_sound_id_count = SOUND_MANAGER.active_sound_id_counts[i];
            int32_t* active_sound_id_count_ptr = &SOUND_MANAGER.active_sound_id_counts[i];
            if (active_sound_id_count < 60 && active_sound_id_count >= 0) {
                SOUND_MANAGER.__unknown_smf_array_7C[i].__int_array_0[active_sound_id_count] = idk2;
                ++*active_sound_id_count_ptr;
            }
            return;
        }
    }
}

inline void SoundManager::stop_sound(int32_t sound_id) {
    nounroll for (size_t i = 0; i < countof(SOUND_MANAGER.active_sound_ids); ++i) {
        int32_t active_sound_id = SOUND_MANAGER.active_sound_ids[i];
        if (active_sound_id < 0) {
            SOUND_MANAGER.active_sound_ids[i] = sound_id;
            SOUND_MANAGER.active_sound_id_counts[i] = -1;
            return;
        }
        if (active_sound_id == sound_id) {
            SOUND_MANAGER.active_sound_id_counts[i] = -1;
            return;
        }
    }
}

// 0x444D80
dllexport gnu_noinline void SoundManager::__stop_all() {
    SOUND_MANAGER.active_sound_ids[0] = -1;
    for (size_t i = 0; i < countof(SOUND_MANAGER.__unknown_smb_array_1A84); ++i) {
        SOUND_MANAGER.__unknown_smb_array_1A84[i].__dword_14 = 0;
        if (LPDIRECTSOUNDBUFFER sound_buffer = SOUND_MANAGER.__unknown_smb_array_1A84[i].sound_buffer) {
            DWORD status;
            sound_buffer->GetStatus(&status);
            SOUND_MANAGER.__unknown_smb_array_1A84[i].__dword_14 = status & 1;
            sound_buffer->Stop();
        }
    }
}

// size: 0x34
struct FontBlock {
    HANDLE handles[12]; // 0x0
    BOOL found_meiryo; // 0x30
    // 0x34
};

// size: 0x18
struct FontData {
    D3DFORMAT format; // 0x0
    int32_t bits_per_pixel; // 0x4
    uint32_t alpha_mask; // 0x8
    uint32_t red_mask; // 0xC
    uint32_t green_mask; // 0x10
    uint32_t blue_mask; // 0x14
    // 0x18
};

// size: 0x10
struct ZUN_RGBAQUAD {
    uint32_t red_mask; // 0x0
    uint32_t green_mask; // 0x4
    uint32_t blue_mask; // 0x8
    uint32_t alpha_mask; // 0xC
    // 0x10
};

// size: 0x6C
struct ZUN_BITMAPINFO {
    BITMAPINFOHEADER bmiHeader; // 0x0
    ZUN_RGBAQUAD bmiColors[1]; // 0x28
    unknown_fields(0x34); // 0x38
    // 0x6C
};

// size: 0x124
struct GdiManager {
    char junk_buffer[0x100]; // 0x0
    D3DFORMAT format = (D3DFORMAT)-1; // 0x100
    int32_t width; // 0x104
    int32_t height; // 0x108
    int32_t bitmap_size; // 0x10C
    int32_t stride; // 0x110
    HDC device_context; // 0x114
    HGDIOBJ screen_bitmap_object; // 0x118
    HBITMAP bitmap_handle; // 0x11C
    void* bitmap_data; // 0x120
    // 0x124

    inline ~GdiManager() {
        this->cleanup();
    }

    // 0x46FE00
    dllexport gnu_noinline bool thiscall cleanup() asm_symbol_rel(0x46FE000) {
        if (HDC device_context = this->device_context) {

            SelectObject(device_context, this->screen_bitmap_object);
            DeleteDC(this->device_context);
            DeleteObject(this->bitmap_handle);
            this->format = (D3DFORMAT)-1;
            this->width = 0;
            this->height = 0;
            this->device_context = NULL;
            this->bitmap_handle = NULL;
            this->screen_bitmap_object = NULL;
            this->bitmap_data = NULL;
            return true;
        }
        return false;
    }

private:
    // 0x46FE80
    dllexport gnu_noinline static bool stdcall __sub_46FE80(UNUSED_ARG(int32_t _width), UNUSED_ARG(int32_t _height), D3DFORMAT format) asm_symbol_rel(0x46FE80);
public:
    static inline bool __sub_46FE80(D3DFORMAT format) {
        return __sub_46FE80(UNUSED_DWORD, UNUSED_DWORD, format);
    }

    inline void fill_junk_buffer() {
        for (size_t i = 0; i < countof(this->junk_buffer); ++i) {
            clang_forceinline this->junk_buffer[i] = RNG.rand_ushort() >> 9;
        }
    }
};

extern "C" {
    // 0x4C9AD0
    externcg FontData FONT_DATA[7] cgasm("_FONT_DATA");
    // 0x570928
    externcg FontBlock FONT_BLOCK cgasm("_FONT_BLOCK");
    // 0x4CD9B0
    externcg GdiManager GDI_MANAGER cgasm("_GDI_MANAGER");
};

// 0x46FE80
dllexport gnu_noinline bool stdcall GdiManager::__sub_46FE80(UNUSED_ARG(int32_t _width), UNUSED_ARG(int32_t _height), D3DFORMAT format) {

    constexpr int32_t width = 1024;
    constexpr int32_t height = 128;

    GDI_MANAGER.cleanup();

    ZUN_BITMAPINFO bitmap_info = {};

    int32_t i = 0;
    for (
        FontData* font_data = FONT_DATA;
        font_data->format != (D3DFORMAT)-1;
        ++i, ++font_data
    ) {
        if (font_data->format == format) {
            break;
        }
    }

    if (format != (D3DFORMAT)-1) {
        FontData* font_data = &FONT_DATA[i];
        if (font_data) {
            int32_t bits_per_pixel = font_data->bits_per_pixel;

            int32_t stride = dword_align(width * bits_per_pixel / CHAR_BIT);;

            bitmap_info.bmiHeader.biSize = sizeof(bitmap_info);
            bitmap_info.bmiHeader.biWidth = width;
            bitmap_info.bmiHeader.biHeight = -(height + 1);
            bitmap_info.bmiHeader.biBitCount = bits_per_pixel;
            bitmap_info.bmiHeader.biPlanes = 1;
            bitmap_info.bmiHeader.biSizeImage = height * stride;
            if (format != D3DFMT_X1R5G5B5 && format != D3DFMT_X8R8G8B8) {
                bitmap_info.bmiHeader.biCompression = BI_BITFIELDS;
                bitmap_info.bmiColors[0].red_mask = font_data->red_mask;
                bitmap_info.bmiColors[0].green_mask = font_data->green_mask;
                bitmap_info.bmiColors[0].blue_mask = font_data->blue_mask;
                bitmap_info.bmiColors[0].alpha_mask = font_data->alpha_mask;
            }
            void* bitmap_data;
            HBITMAP bitmap_handle = CreateDIBSection(NULL, (BITMAPINFO*)&bitmap_info, DIB_RGB_COLORS, &bitmap_data, NULL, 0);
            if (bitmap_handle) {
                memset(bitmap_data, 0, bitmap_info.bmiHeader.biSizeImage);
                HDC device_context = CreateCompatibleDC(NULL);
                HGDIOBJ screen_bitmap_object = SelectObject(device_context, bitmap_handle);
                GDI_MANAGER.bitmap_handle = bitmap_handle;
                GDI_MANAGER.screen_bitmap_object = screen_bitmap_object;
                GDI_MANAGER.format = format;
                GDI_MANAGER.bitmap_data = bitmap_data;
                GDI_MANAGER.device_context = device_context;
                GDI_MANAGER.stride = stride;
                GDI_MANAGER.bitmap_size = bitmap_info.bmiHeader.biSizeImage;
                GDI_MANAGER.width = width;
                GDI_MANAGER.height = height;
                return true;
            }
        }
    }
    return false;
}

#define SJIS_MEIRYO "\x83\x81\x83\x43\x83\x8A\x83\x49"
#define SJIS_MS_GOTHIC "\x82\x6C\x82\x72 \x83\x53\x83\x56\x83\x62\x83\x4E"
#define JSIS_MS_MINCHO "\x82\x6C\x82\x72 \x96\xBE\x92\xA9"

// 0x470470
dllexport gnu_noinline int CALLBACK EnumFontFamiliesExACallback(const LOGFONTA* lpelfe, const TEXTMETRICA* lpntme, DWORD font_type, LPARAM lparam) asm_symbol_rel(0x470470);
dllexport gnu_noinline int CALLBACK EnumFontFamiliesExACallback(const LOGFONTA* lpelfe, const TEXTMETRICA* lpntme, DWORD font_type, LPARAM lparam) {
    if (!byteloop_strcmp(lpelfe->lfFaceName, SJIS_MEIRYO)) {
        FONT_BLOCK.found_meiryo = true;
        return 0;
    }
    return 1;
}

// 0x4704C0
dllexport gnu_noinline void __initialize_fonts() asm_symbol_rel(0x4704C0);
dllexport gnu_noinline void __initialize_fonts() {
    HDC hdc = GetDC(NULL);

    LOGFONTA log_font;
    log_font.lfWeight = 0;
    log_font.lfHeight = 0;
    log_font.lfWidth = 0;
    log_font.lfEscapement = 0;
    log_font.lfOrientation = 0;
    strncpy(log_font.lfFaceName, SJIS_MEIRYO, LF_FACESIZE);
    log_font.lfItalic = false;
    log_font.lfUnderline = false;
    log_font.lfStrikeOut = false;
    log_font.lfCharSet = DEFAULT_CHARSET;
    log_font.lfOutPrecision = 0;
    log_font.lfClipPrecision = 0;
    log_font.lfQuality = 0;
    log_font.lfPitchAndFamily = 0;

    EnumFontFamiliesExA(hdc, &log_font, &EnumFontFamiliesExACallback, NULL, 0);

    if (!GDI_MANAGER.__sub_46FE80(D3DFMT_A4R4G4B4)) {
        GDI_MANAGER.__sub_46FE80(D3DFMT_A8R8G8B8);
    }

    GDI_MANAGER.fill_junk_buffer();

    if (!FONT_BLOCK.found_meiryo) {
        FONT_BLOCK.handles[0] = CreateFontA(24, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_ROMAN, SJIS_MS_GOTHIC);
        FONT_BLOCK.handles[1] = CreateFontA(28, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_ROMAN, SJIS_MS_GOTHIC);
        FONT_BLOCK.handles[2] = CreateFontA(32, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_ROMAN, SJIS_MS_GOTHIC);
        FONT_BLOCK.handles[6] = CreateFontA(40, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_ROMAN, SJIS_MS_GOTHIC);
        FONT_BLOCK.handles[10] = CreateFontA(64, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_ROMAN, SJIS_MS_GOTHIC);
        FONT_BLOCK.handles[11] = CreateFontA(64, 0, 0, 0, FW_SEMIBOLD, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_ROMAN, JSIS_MS_MINCHO);
        FONT_BLOCK.handles[3] = CreateFontA(32, 0, 0, 0, FW_SEMIBOLD, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_ROMAN, JSIS_MS_MINCHO);
        FONT_BLOCK.handles[7] = CreateFontA(40, 0, 0, 0, FW_SEMIBOLD, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_ROMAN, JSIS_MS_MINCHO);
        FONT_BLOCK.handles[4] = CreateFontA(15, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_ROMAN, SJIS_MS_GOTHIC);
        FONT_BLOCK.handles[5] = CreateFontA(15, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_ROMAN, JSIS_MS_MINCHO);
        FONT_BLOCK.handles[8] = CreateFontA(15, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_ROMAN, SJIS_MS_GOTHIC);
        FONT_BLOCK.handles[9] = CreateFontA(15, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_ROMAN, JSIS_MS_MINCHO);
    } else {
        FONT_BLOCK.handles[0] = CreateFontA(36, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_DONTCARE, SJIS_MEIRYO);
        FONT_BLOCK.handles[1] = CreateFontA(42, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_DONTCARE, SJIS_MEIRYO);
        FONT_BLOCK.handles[2] = CreateFontA(48, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_DONTCARE, SJIS_MEIRYO);
        FONT_BLOCK.handles[6] = CreateFontA(60, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_DONTCARE, SJIS_MEIRYO);
        FONT_BLOCK.handles[3] = CreateFontA(32, 0, 0, 0, FW_SEMIBOLD, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_ROMAN, JSIS_MS_MINCHO);
        FONT_BLOCK.handles[7] = CreateFontA(40, 0, 0, 0, FW_SEMIBOLD, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_ROMAN, JSIS_MS_MINCHO);
        FONT_BLOCK.handles[4] = CreateFontA(16, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_DONTCARE, SJIS_MEIRYO);
        FONT_BLOCK.handles[5] = CreateFontA(15, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_ROMAN, JSIS_MS_MINCHO);
        FONT_BLOCK.handles[4] = CreateFontA(16, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_DONTCARE, SJIS_MEIRYO);
        FONT_BLOCK.handles[5] = CreateFontA(15, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_ROMAN, JSIS_MS_MINCHO);
        FONT_BLOCK.handles[10] = CreateFontA(96, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_DONTCARE, SJIS_MEIRYO);
        FONT_BLOCK.handles[11] = CreateFontA(64, 0, 0, 0, FW_SEMIBOLD, FALSE, FALSE, FALSE, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FIXED_PITCH | FF_ROMAN, JSIS_MS_MINCHO);
    }
}

typedef int32_t (*volatile fastcall AnmOnFunc)(AnmVM*);
typedef int32_t (*volatile fastcall AnmOnFuncArg)(AnmVM*, int32_t);

//extern inline const AnmOnFunc ANM_ON_TICK_FUNCS[];
//extern inline const AnmOnFunc ANM_ON_DRAW_FUNCS[];
//extern inline const AnmOnFunc ANM_ON_DESTROY_FUNCS[];
//extern inline const AnmOnFuncArg ANM_ON_INTERRUPT_FUNCS[];
extern inline const AnmOnFunc ANM_ON_COPY_A_FUNCS[];
extern inline const AnmOnFunc ANM_ON_COPY_B_FUNCS[];
//extern inline const AnmOnFuncArg ANM_ON_SPRITE_LOOKUP_FUNCS[];
extern "C" {
    // the wait func table isn't const
    externcg AnmOnFunc ANM_ON_WAIT_FUNCS[1] cgasm("_ANM_ON_WAIT_FUNCS");
    //externcg AnmOnFunc ANM_ON_TICK_FUNCS[] cgasm("_ANM_ON_TICK_FUNCS");
    externcg AnmOnFunc ANM_ON_DRAW_FUNCS[8] cgasm("_ANM_ON_DRAW_FUNCS");
    //externcg AnmOnFunc ANM_ON_DESTROY_FUNCS[] cgasm("_ANM_ON_DESTROY_FUNCS");
    //externcg AnmOnFuncArg ANM_ON_INTERRUPT_FUNCS[] cgasm("_ANM_ON_INTERRUPT_FUNCS");
    externcg AnmOnFuncArg ANM_ON_SPRITE_LOOKUP_FUNCS[4] cgasm("_ANM_ON_SPRITE_LOOKUP_FUNCS");
}

extern inline const AnmOnFunc ANM_ON_TICK_FUNCS[6];
extern inline const AnmOnFunc ANM_ON_DESTROY_FUNCS[5];
extern inline const AnmOnFuncArg ANM_ON_INTERRUPT_FUNCS[5];

extern "C" {
    // 0x5217DC
    externcg Float3 UNKNOWN_FLOAT3_A cgasm("_UNKNOWN_FLOAT3_A");
    // 0x56AD78
    externcg Float2 UNKNOWN_FLOAT2_A cgasm("_UNKNOWN_FLOAT2_A");
}

// size: 0x14
// D3DFVF_XYZRHW | D3DFVF_DIFFUSE (0x44)
struct PrimitiveVertex {
    Float4 position; // 0x0
    D3DCOLOR diffuse; // 0x10
    // 0x14

    static constexpr DWORD FVF_TYPE = D3DFVF_XYZRHW | D3DFVF_DIFFUSE;
    static inline constexpr size_t buffer_size(size_t count) {
        return count * sizeof(PrimitiveVertex);
    }
};
// size: 0x14
// D3DFVF_XYZ | D3DFVF_TEX1 (0x102)
struct UnknownVertexA {
    Float3 position; // 0x0
    Float2 texture_uv; // 0xC
    // 0x14

    static constexpr DWORD FVF_TYPE = D3DFVF_XYZ | D3DFVF_TEX1;
    static inline constexpr size_t buffer_size(size_t count) {
        return count * sizeof(UnknownVertexA);
    }
};
// size: 0x18
// D3DFVF_XYZRHW | D3DFVF_TEX1 (0x104)
struct SpriteVertexB {
    Float4 position; // 0x0
    Float2 texture_uv; // 0x10
    // 0x18

    static constexpr DWORD FVF_TYPE = D3DFVF_XYZRHW | D3DFVF_TEX1;
    static inline constexpr size_t buffer_size(size_t count) {
        return count * sizeof(SpriteVertexB);
    }
};
// size: 0x18
// D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1 (0x142)
struct SpriteVertexC {
    Float3 position; // 0x0
    D3DCOLOR diffuse; // 0xC
    Float2 texture_uv; // 0x10
    // 0x18

    static constexpr DWORD FVF_TYPE = D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1;
    static inline constexpr size_t buffer_size(size_t count) {
        return count * sizeof(SpriteVertexC);
    }
};
// size: 0x1C
// D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1 (0x144)
struct SpriteVertex {
    Float4 position; // 0x0
    D3DCOLOR diffuse; // 0x10
    Float2 texture_uv; // 0x14
    // 0x1C

    static constexpr DWORD FVF_TYPE = D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1;
    static inline constexpr size_t buffer_size(size_t count) {
        return count * sizeof(SpriteVertex);
    }
};
// size: 0x10
// D3DFVF_XYZ | D3DFVF_DIFFUSE (0x42)
struct UnknownVertexB {
    Float3 position; // 0x0
    D3DCOLOR diffuse; // 0xC
    // 0x10

    static constexpr DWORD FVF_TYPE = D3DFVF_XYZ | D3DFVF_DIFFUSE;
    static inline constexpr size_t buffer_size(size_t count) {
        return count * sizeof(UnknownVertexB);
    }
};

extern "C" {
    // 0x51F65C
    externcg AnmManager* ANM_MANAGER_PTR cgasm("_ANM_MANAGER_PTR");
    // 0x5704C0
    externcg SpriteVertexB SPRITE_VERTEX_BUFFER_B[4] cgasm("_SPRITE_VERTEX_BUFFER_B");
    // 0x570520
    externcg SpriteVertex SPRITE_VERTEX_BUFFER_A[4] cgasm("_SPRITE_VERTEX_BUFFER_A");
    // 0x570590
    externcg SpriteVertexC SPRITE_VERTEX_BUFFER_C[4] cgasm("_SPRITE_VERTEX_BUFFER_C");
}

namespace Anm {
enum Var : int32_t {
    I0 = 10000, // 10000
    I1, // 10001
    I2, // 10002
    I3, // 10003
    F0, // 10004
    F1, // 10005
    F2, // 10006
    F3, // 10007
    IC0, // 10008
    IC1, // 10009
    RAND_ANGLE, // 10010
    RAND_FLOAT, // 10011
    RAND_FLOAT_SIGNED, // 10012
    SELF_X, // 10013
    SELF_Y, // 10014
    SELF_Z, // 10015
    CAMERA_POS_X, // 10016
    CAMERA_POS_Y, // 10017
    CAMERA_POS_Z, // 10018
    CAMERA_FACING_X, // 10019
    CAMERA_FACING_Y, // 10020
    CAMERA_FACING_Z, // 10021
    RAND_UINT, // 10022
    SELF_X_ROT, // 10023
    SELF_Y_ROT, // 10024
    SELF_Z_ROT, // 10025
    __CONTROLLER_Z_ROT, // 10026
    RAND_SCALE, // 10027
    RAND_ANGLE_SCALE, // 10028
    RAND_UINT_RANGE, // 10029
    RAND_ANGLE_REPLAY, // 10030
    RAND_FLOAT_REPLAY, // 10031
    RAND_FLOAT_SIGNED_REPLAY, // 10032
    __UNKNOWN_X, // 10033
    __UNKNOWN_Y, // 10034
    __UNKNOWN_Z, // 10035
};
enum Opcode : int16_t {
    // Section A
    nop = 0, // 0
    anm_delete, // 1
    anm_static, // 2
    anm_halt, // 3
    anm_halt_invisible, // 4
    interrupt_label, // 5
    wait, // 6
    interrupt_return, // 7

    // Section B
    set_int = 100, // 100
    set_float, // 101
    math_int_add_assign, // 102
    math_float_add_assign, // 103
    math_int_sub_assign, // 104
    math_float_sub_assign, // 105
    math_int_mul_assign, // 106
    math_float_mul_assign, // 107
    math_int_div_assign, // 108
    math_float_div_assign, // 109
    math_int_mod_assign, // 110
    math_float_mod_assign, // 111
    math_int_add, // 112
    math_float_add, // 113
    math_int_sub, // 114
    math_float_sub, // 115
    math_int_mul, // 116
    math_float_mul, // 117
    math_int_div, // 118
    math_float_div, // 119
    math_int_mod, // 120
    math_float_mod, // 121
    set_int_rand_bound, // 122
    set_float_rand_bound, // 123
    math_sin, // 124
    math_cos, // 125
    math_tan, // 126
    math_acos, // 127
    math_atan, // 128
    math_reduce_angle, // 129
    math_circle_pos_fast, // 130
    math_circle_pos_rand, // 131

    // Section C
    jump = 200, // 200
    loop, // 201
    jump_int_equ, // 202
    jump_float_equ, // 203
    jump_int_neq, // 204
    jump_float_neq, // 205
    jump_int_les, // 206
    jump_float_les, // 207
    jump_int_leq, // 208
    jump_float_leq, // 209
    jump_int_gre, // 210
    jump_float_gre, // 211
    jump_int_geq, // 212
    jump_float_geq, // 213

    // Section D
    sprite_set = 300, // 300
    sprite_set_rand_bound, // 301
    render_mode, // 302
    blend_mode, // 303
    layer, // 304
    anm_flag_disable_z_write, // 305
    __anm_flag_unknown_std_A, // 306
    rand_mode, // 307
    scale_flip_x, // 308
    scale_flip_y, // 309
    anm_flag_visible, // 310
    resample_mode, // 311
    scroll_mode, // 312
    resolution_mode, // 313
    anm_flag_inherit_rotation, // 314
    anm_flag_color_children, // 315
    __anm_flag_set_visible2, // 316
    __anm_flag_clear_visible2, // 317
    __anm_flag_unknown_V, // 318
    __sprite_set_unknown, // 319

    // Section E
    move_position = 400, // 400
    rotation, // 401
    scale, // 402
    alpha, // 403
    color, // 404
    alpha_gradient, // 405
    color_gradient, // 406
    move_position_interp, // 407
    color_interp, // 408
    alpha_interp, // 409
    rotation_interp, // 410
    spin_interp, // 411
    scale_interp, // 412
    color_gradient_interp, // 413
    alpha_gradient_interp, // 414
    rotation_speed, // 415
    scale_speed, // 416
    alpha_interp_linear, // 417
    sprite_window, // 418
    __anm_flag_continual_sprite_window, // 419
    move_bezier, // 420
    anchor_mode, // 421
    position_inherit, // 422
    color_mode, // 423
    anm_flag_auto_rotate, // 424
    scroll_speed_x, // 425
    scroll_speed_y, // 426
    scroll_speed_x_interp, // 427
    scroll_speed_y_interp, // 428
    uv_scale, // 429
    uv_scale_interp, // 430
    __anm_flag_unknown_T, // 431
    anm_flag_slowdown_immune, // 432
    move_velocity_interp, // 433
    scale2, // 434
    scale2_interp, // 435
    anchor_offset, // 436
    rotation_mode, // 437
    origin_mode, // 438
    camera_fade, // 439
    scale_unflip, // 440

    // Section F
    anm_create_child_back = 500, // 500
    anm_create_child_ui_back, // 501
    anm_create_child_front, // 502
    anm_create_child_ui_front, // 503
    anm_create_back, // 504
    anm_create_child_back_rel, // 505
    anm_create_back_rel, // 506
    __anm_flag_treat_as_root, // 507
    effect_create, // 508
    copy_parent_context, // 509
    anm_create_child_front_rel, // 510

    // Section G
    textured_ring = 600, // 600
    textured_arc_A, // 601
    textured_arc_B, // 602
    polygon_rectangle, // 603
    polygon, // 604
    polygon_hollow, // 605
    polygon_rectangle_gradient, // 606
    polygon_rectangle_antialias, // 607
    polygon_rectangle_gradient_antialias, // 608
    textured_cylinder, // 609
    textured_ring_3D, // 610
    polygon_ring, // 611
    polygon_rectangle_hollow, // 612
    polygon_line, // 613
    __polygon_unknown_A, // 614
    __polygon_ring_unknown_A, // 615
    __polygon_ring_unknown_B, // 616
    __polygon_unknown_C, // 617
    __polygon_unknown_D, // 618
    __polygon_unknown_E, // 619
    __polygon_unknown_F1, // 620
    __polygon_unknown_F2, // 621
    __polygon_unknown_F3, // 622
    __polygon_unknown_G, // 623
    __polygon_unknown_H, // 624
    __polygon_unknown_I1, // 625
    __polygon_unknown_I2, // 626
    __polygon_unknown_I3, // 627
    __polygon_unknown_J, // 628
    __polygon_unknown_K, // 629
    __polygon_unknown_L1, // 630
    __polygon_unknown_L2, // 631
    __polygon_unknown_L3, // 632
};
}

// size: 0x8
struct AnmInstruction {
    int16_t opcode; // 0x0
    uint16_t offset_to_next; // 0x2
    int16_t time; // 0x4
    uint16_t param_mask; // 0x6
    unsigned char args[]; // 0x8
};

enum AnmVMCreationListType {
    WorldListBack = 0,
    WorldListFront = 1,
    UiListBack = 2,
    UiListFront = 3,
};
union AnmVMCreationFlags {
    uint32_t raw;
    struct {
        uint32_t __unknown_flag_A : 1; // 1
        uint32_t list_type : 2; // 2-3
        uint32_t __unknown_flag_B : 1; // 4
    };
};

// 0x4CDB00
static Float4 ANCHOR_X_TABLE[3] = {
    { -0.5f, 0.5f, -0.5f, 0.5f },
    { 0.0f, 0.5f, 0.0f, 0.5f },
    { -0.5f, 0.0f, -0.5f, 0.0f }
};

// 0x4CDB30
static Float4 ANCHOR_Y_TABLE[3] = {
    { -0.5f, -0.5f, 0.5f, 0.5f },
    { 0.0f, 0.0f, 0.5f, 0.5f },
    { -0.5f, -0.5f, 0.0f, 0.0f }
};

// 0x0
static inline constexpr AnmVMCreationFlags WORLD_LIST_BACK = { .list_type = WorldListBack };
// 0x2
static inline constexpr AnmVMCreationFlags WORLD_LIST_FRONT = { .list_type = WorldListFront };
// 0x4
static inline constexpr AnmVMCreationFlags UI_LIST_BACK = { .list_type = UiListBack };
// 0x6
static inline constexpr AnmVMCreationFlags UI_LIST_FRONT = { .list_type = UiListFront };

enum AnmVMState {
    Normal = 0, // 0
    MarkedForDelete, // 1
    Deleted // 2
};

enum AnmBlendMode : uint8_t {

};

enum AnmUVMode : uint8_t {
    Wrap = 0,
    Clamp = 1,
    Mirror = 2
};

enum AnmRNGMode : uint8_t {
    ReplayRNG = 0,
    NormalRNG = 1,
};

// size: 0x60C
struct AnmVM {
    struct AnmContext {
        int32_t int_vars[4]; // 0x0
        float float_vars[4]; // 0x10
        Float3 __float3_20; // 0x20
        int32_t counter_vars[2]; // 0x2C
        float rand_scale; // 0x34
        float rand_angle_scale; // 0x38
        int32_t rand_int_range; // 0x3C
    };
    struct AnmVMData {
        Timer interrupt_return_time; // 0x0
        int32_t interrupt_return_offset; // 0x14
        uint32_t layer; // 0x18
        int32_t slot; // 0x1C
        int32_t slot2; // 0x20
        int32_t sprite_id; // 0x24
        int32_t script_id; // 0x28
        int32_t current_instruction_offset; // 0x2C
        Float3 position; // 0x30
        Float3 rotation; // 0x3C
        Float3 angular_velocity; // 0x48
        Float2 scale; // 0x54
        Float2 scale2; // 0x5C
        Float2 scale_delta; // 0x64
        Float2 uv_scale; // 0x6C
        Float2 sprite_size; // 0x74
        Float2 uv_scroll; // 0x7C
        Float3 anchor_offset; // 0x84
        ZUNInterp<Float3> position_interp; // 0x90
        ZUNInterp<RGB> color_interp; // 0xE8
        ZUNInterp<int32_t> alpha_interp; // 0x140
        ZUNInterp<Float3> rotation_interp; // 0x170
        ZUNInterp<ZUNAngle> spin_interp; // 0x1C8
        ZUNInterp<Float2> scale_interp; // 0x1F8
        ZUNInterp<Float2> scale2_interp; // 0x23C
        ZUNInterp<Float2> uv_scale_interp; // 0x280
        ZUNInterp<RGB> color2_interp; // 0x2C4
        ZUNInterp<int32_t> alpha2_interp; // 0x31C
        ZUNInterp<float> u_scroll_speed_interp; // 0x34C
        ZUNInterp<float> v_scroll_speed_interp; // 0x37C
        Float2 sprite_uv_quad[4]; // 0x3AC
        Float2 uv_scroll_speed; // 0x3CC
        D3DMATRIXZ __matrix_3D4; // 0x3D4
        D3DMATRIXZ __matrix_414; // 0x414
        D3DMATRIXZ __matrix_454; // 0x454
        int32_t run_interrupt; // 0x494
        int32_t __last_sprite_set_time; // 0x498
        unknown_fields(0x4); // 0x49C
        uint16_t script_id2; // 0x4A0
        unknown_fields(0x2); // 0x4A2
        AnmContext current_context; // 0x4A4
        Float3 __position_2; // 0x4E4
        Float3 __render_quad[4]; // 0x4F0
        AnmVMCreationFlags creation_flags; // 0x520
        D3DCOLOR color1; // 0x524
        D3DCOLOR color2; // 0x528
        D3DCOLOR mixed_inherited_color; // 0x52C
        uint8_t font_width; // 0x530
        uint8_t font_height; // 0x531
        probably_padding_bytes(0x2); // 0x532
        union {
            uint32_t flags_low; // 0x534
            struct {
                uint32_t visible : 1; // 1
                uint32_t __visible2 : 1; // 2
                uint32_t rotation_enabled : 1; // 3
                uint32_t scale_enabled : 1; // 4
                uint32_t uv_scale_enabled : 1; // 5
                uint32_t blend_mode : 4; // 6-9
                uint32_t : 1; // 10
                uint32_t position_mode : 1; // 11
                uint32_t mirror_x : 1; // 12
                uint32_t mirror_y : 1; // 13
                uint32_t disable_z_write : 1; // 14
                uint32_t __visible3 : 1; // 15
                uint32_t __unknown_flag_W : 1; // 16
                uint32_t __unknown_std_flag_A : 1; // 17
                uint32_t color_mode : 3; // 18-20
                uint32_t : 1; // 21
                uint32_t __unknown_flag_O : 1; // 22
                uint32_t x_anchor_mode : 2; // 23-24
                uint32_t y_anchor_mode : 2; // 25-26
                uint32_t render_mode : 5; // 27-31
                uint32_t : 1; // 32
            };
        };
        union {
            uint32_t flags_high; // 0x538
            struct {
                uint32_t v_scroll_mode : 2; // 1-2
                uint32_t u_scroll_mode : 2; // 3-4
                uint32_t rotation_mode : 3; // 5-7
                uint32_t __vm_state : 2; // 8-9
                uint32_t auto_rotate : 1; // 10
                uint32_t __unknown_flag_T : 1; // 11
                uint32_t slowdown_immune : 1; // 12
                uint32_t rand_mode : 1; // 13
                uint32_t resample_mode : 1; // 14
                uint32_t : 1; // 15
                uint32_t __continual_sprite_window : 1; // 16
                uint32_t __unknown_field_B : 2; // 17-18
                uint32_t __treat_as_root : 1; // 19
                uint32_t : 1; // 20
                uint32_t origin_mode : 2; // 21-22
                uint32_t resolution_mode : 3; // 23-25
                uint32_t inherit_rotation : 1; // 26
                uint32_t __deltas_enabled : 1; // 27
                uint32_t colorize_children : 1; // 28
                uint32_t __unknown_flag_F : 1; // 29
                uint32_t : 1; // 30
                uint32_t enable_camera_fade : 1; // 31
                uint32_t : 1; // 32
            };
        };
        float camera_near_fade_end; // 0x53C
        float camera_near_clip; // 0x540
        // 0x544
    };
    static_assert(sizeof(AnmVMData) == 0x544);
    struct AnmVMController {
        AnmID id; // 0x0 (0x544)
        uint32_t fast_id; // 0x4 (0x548)
        Timer script_time; // 0x8 (0x54C)
        Timer __timer_1C; // 0x1C (0x560)
        ZUNList<AnmVM> global_list_node; // 0x30 (0x574)
        ZUNList<AnmVM> child_list_node; // 0x40 (0x584)
        ZUNListHead<AnmVM> child_list; // 0x50 (0x594)
        ZUNList<AnmVM> destroy_list_node; // 0x60 (0x5A4)
        AnmVM* next_in_layer; // 0x70 (0x5B4)
        AnmVM* prev_in_layer; // 0x74 (0x5B8)
        AnmVM* __root_vm; // 0x78 (0x5BC)
        AnmVM* parent; // 0x7C (0x5C0)
        float slowdown; // 0x80 (0x5C4)
        void* special_data; // 0x84 (0x5C8)
        uint32_t special_data_size; // 0x88 (0x5CC)
        uint32_t on_wait_index; // 0x8C (0x5D0)
        uint32_t on_tick_index; // 0x90 (0x5D4)
        uint32_t on_draw_index; // 0x94 (0x5D8)
        uint32_t on_destroy_index; // 0x98 (0x5DC)
        uint32_t on_interrupt_index; // 0x9C (0x5E0)
        uint32_t on_copy_A_index; // 0xA0 (0x5E4)
        uint32_t on_copy_B_index; // 0xA4 (0x5E8)
        uint32_t on_sprite_lookup_index; // 0xA8 (0x5EC)
        Float3 position; // 0xAC (0x5F0)
        void* associated_entity; // 0xB8 (0x5FC)
        Float3 rotation; // 0xBC (0x600)

        inline void zero_contents() {
            zero_this();
        }
    };
    ValidateStructSize32(0xC8, AnmVMController);

    AnmVMData data; // 0x0
    AnmVMController controller; // 0x544
    // 0x60C

    inline void zero_contents() {
        zero_this();
    }

    AnmVM() {
        this->zero_contents();
        this->data.sprite_id = -1;
        this->data.current_instruction_offset = -1;
    }

    // 0x4894D0
    dllexport gnu_noinline AnmLoaded* thiscall get_anm_loaded() asm_symbol_rel(0x4894D0);

    template <typename L>
    inline AnmVM* search_roots(L&& lambda) {
        AnmVM* search = this;
        //while ((search = search->controller.__root_vm) && !lambda(search));
        for (
            AnmVM* root = this->controller.__root_vm;
            root != NULL && !lambda(root);
            root = root->controller.__root_vm
        ) search = root;
        return search;
    }

    inline AnmVM* find_root_vm() {
        AnmVM* search = this;
        AnmVM* root;
        while (
            (root = search->controller.__root_vm) != NULL &&
            !search->data.__treat_as_root
        ) search = root;
        return search;
    }
    
    // 0x4066B0
    dllexport gnu_noinline void thiscall set_layer(int32_t layer) asm_symbol_rel(0x4066B0) {
        // IDFK how this one was originally structured
        this->data.layer = layer;
        switch (layer) {
            default:
                this->data.origin_mode = 0;
                break;
            case 3 ... 19:
                this->data.origin_mode = 1;
                break;
            case 20 ... 23:
                this->data.origin_mode = 2;
                break;
        }
        switch (layer) {
            case 20 ... 32: case 37 ... 45:
                this->data.resolution_mode = 1;
                break;
        }
    }

    // 0x405BB0
    dllexport gnu_noinline float vectorcall get_custom_slowdown() asm_symbol_rel(0x405BB0) {
        return this->find_root_vm()->controller.slowdown;
    }

    // 0x4063D0
    dllexport gnu_noinline Float3* thiscall __adjust_position_for_resolution_and_origin_modes(Float3* out) asm_symbol_rel(0x4063D0) {
        
        switch (this->data.resolution_mode) {
            case 1: case 3:
                *out *= WINDOW_DATA.__game_scale;
                break;
            case 2: case 4:
                *out *= WINDOW_DATA.__game_scale * 0.5f;
                break;
        }

        AnmVM* root_vm = this->controller.__root_vm;
        if (
            root_vm &&
            !this->data.__treat_as_root
        ) {
            if (this->data.inherit_rotation) {
                out->rotate_around_origin(root_vm->data.rotation.z);
                root_vm = this->controller.parent;
            }
            Float3 offset;
            root_vm->get_render_position(&offset);
            *out += offset;
            return out;
        }

        switch (this->data.origin_mode) {
            case 0:
                break;
            case 1:
                out->x += WINDOW_DATA.__int_208C;
                out->y += WINDOW_DATA.__int_2090;
                break;
            default:
                out->x += WINDOW_DATA.__int_2084;
                out->y += WINDOW_DATA.__int_2088;
                break;
        }

        return out;
    }

    // 0x4065A0
    dllexport gnu_noinline Float3* thiscall get_render_position(Float3* out) asm_symbol_rel(0x4065A0) {
        *out = this->data.position + this->controller.position + this->data.__position_2;
        this->__adjust_position_for_resolution_and_origin_modes(out);
        return out;
    }

    // 0x4097D0
    dllexport gnu_noinline Float3* thiscall get_controller_rotation() asm_symbol_rel(0x4097D0) {
        Float3* controller_rotation = &this->controller.rotation;
        *controller_rotation = this->data.rotation;
        
        AnmVM* root_vm = this->controller.__root_vm;
        if (
            root_vm &&
            !this->data.__treat_as_root
        ) {
            *controller_rotation += *root_vm->get_controller_rotation();

            // Is this supposed to be applied to controller rotation instead?
            this->data.rotation.x = reduce_angle(this->data.rotation.x);
            this->data.rotation.y = reduce_angle(this->data.rotation.y);
            this->data.rotation.z = reduce_angle(this->data.rotation.z);
        }

        return controller_rotation;
    }

    // 0x405CE0
    dllexport gnu_noinline float vectorcall get_z_rotation() asm_symbol_rel(0x405CE0) {
        return this->data.rotation.z;
    }

    // 0x429AD0
    dllexport gnu_noinline void thiscall initialize_position_interp(int32_t end_time, int32_t mode, Float3* initial_pos, Float3* final_pos) asm_symbol_rel(0x429AD0) {
        this->data.position_interp.end_time = end_time;
        this->data.position_interp.bezier1 = UNKNOWN_FLOAT3_A;
        this->data.position_interp.bezier2 = UNKNOWN_FLOAT3_A;
        this->data.position_interp.mode = mode;
        this->data.position_interp.initial_value = *initial_pos;
        this->data.position_interp.final_value = *final_pos;
        this->data.position_interp.time.reset();
    }

    // 0x405AD0
    dllexport gnu_noinline void thiscall initialize_position_interp_bezier(int32_t end_time, Float3* initial_pos, Float3* bezier1, Float3* final_pos, Float3* bezier2) asm_symbol_rel(0x405AD0) {
        this->data.position_interp.end_time = end_time;
        this->data.position_interp.mode = 8;
        this->data.position_interp.initial_value = *initial_pos;
        this->data.position_interp.final_value = *final_pos;
        this->data.position_interp.bezier1 = *bezier1;
        this->data.position_interp.bezier2 = *bezier2;
        this->data.position_interp.time.reset();
    }

    // 0x47D790
    dllexport gnu_noinline void thiscall initialize_color_interp(int32_t end_time, int32_t mode, D3DCOLOR& initial_color, D3DCOLOR& final_color) asm_symbol_rel(0x47D790) {
        this->data.color_interp.end_time = end_time;
        this->data.color_interp.bezier1 = {};
        this->data.color_interp.bezier2 = {};
        this->data.color_interp.mode = mode;
        this->data.color_interp.initial_value = { RED(initial_color), GREEN(initial_color), BLUE(initial_color) };
        this->data.color_interp.final_value = { RED(final_color), GREEN(final_color), BLUE(final_color) };
        this->data.color_interp.time.reset();
    }

    // 0x406630
    dllexport gnu_noinline void thiscall initialize_alpha_interp(int32_t end_time, int32_t mode, uint8_t initial_alpha, uint8_t final_alpha) asm_symbol_rel(0x406630) {
        this->data.alpha_interp.end_time = end_time;
        this->data.alpha_interp.mode = mode;
        this->data.alpha_interp.initial_value = initial_alpha;
        this->data.alpha_interp.bezier1 = 0;
        this->data.alpha_interp.bezier2 = 0;
        this->data.alpha_interp.final_value = final_alpha;
        this->data.alpha_interp.time.reset();
    }

    // 0x47D690
    dllexport gnu_noinline void thiscall initialize_color2_interp(int32_t end_time, int32_t mode, D3DCOLOR& initial_color, D3DCOLOR& final_color) asm_symbol_rel(0x47D790) {
        this->data.color2_interp.end_time = end_time;
        this->data.color2_interp.bezier1 = {};
        this->data.color2_interp.bezier2 = {};
        this->data.color2_interp.mode = mode;
        this->data.color2_interp.initial_value = { RED(initial_color), GREEN(initial_color), BLUE(initial_color) };
        this->data.color2_interp.final_value = { RED(final_color), GREEN(final_color), BLUE(final_color) };
        this->data.color2_interp.time.reset();
        if (this->data.color_mode == 0) {
            this->data.color_mode = 1;
        }
    }

    // 0x406630
    dllexport gnu_noinline void thiscall initialize_alpha2_interp(int32_t end_time, int32_t mode, uint8_t initial_alpha, uint8_t final_alpha) asm_symbol_rel(0x406630) {
        this->data.alpha2_interp.end_time = end_time;
        this->data.alpha2_interp.mode = mode;
        this->data.alpha2_interp.initial_value = initial_alpha;
        this->data.alpha2_interp.final_value = final_alpha;
        //this->data.alpha2_interp.bezier1 = 0;
        //this->data.alpha2_interp.bezier2 = 0;
        this->data.alpha2_interp.time.reset();
        if (this->data.color_mode == 0) {
            this->data.color_mode = 1;
        }
    }
    
    // 0x4614B0
    dllexport gnu_noinline void thiscall initialize_scale_interp(int32_t end_time, int32_t mode, Float2* initial_scale, Float2* final_scale) asm_symbol_rel(0x4614B0) {
        this->data.scale_interp.end_time = end_time;
        this->data.scale_interp.mode = mode;
        this->data.scale_interp.initial_value = *initial_scale;
        this->data.scale_interp.final_value = *final_scale;
        //this->data.scale_interp.bezier1 = UNKNOWN_FLOAT2_A;
        //this->data.scale_interp.bezier2 = UNKNOWN_FLOAT2_A;
        this->data.scale_interp.time.reset();
    }

    // 0x47D580
    dllexport gnu_noinline void thiscall initialize_scale2_interp(int32_t end_time, int32_t mode, Float2* initial_scale, Float2* final_scale) asm_symbol_rel(0x47D580) {
        this->data.scale2_interp.end_time = end_time;
        this->data.scale2_interp.mode = mode;
        this->data.scale2_interp.initial_value = *initial_scale;
        this->data.scale2_interp.final_value = *final_scale;
        //this->data.scale2_interp.bezier1 = UNKNOWN_FLOAT2_A;
        //this->data.scale2_interp.bezier2 = UNKNOWN_FLOAT2_A;
        this->data.scale2_interp.time.reset();
    }

    // 0x47D500
    dllexport gnu_noinline void thiscall initialize_uv_scale_interp(int32_t end_time, int32_t mode, Float2* initial_scale, Float2* final_scale) asm_symbol_rel(0x47D500) {
        this->data.uv_scale_interp.end_time = end_time;
        this->data.uv_scale_interp.mode = mode;
        this->data.uv_scale_interp.initial_value = *initial_scale;
        this->data.uv_scale_interp.final_value = *final_scale;
        //this->data.uv_scale_interp.bezier1 = UNKNOWN_FLOAT2_A;
        //this->data.uv_scale_interp.bezier2 = UNKNOWN_FLOAT2_A;
        this->data.uv_scale_interp.time.reset();
    }

    // 0x4890B0
    dllexport gnu_noinline AnmVM* thiscall __wtf_child_list_jank_A(int32_t script, uint32_t arg2) asm_symbol_rel(0x4890B0) {
        // This iterates the child list as a normal list instead of a list head...?
        for (
            ZUNList<AnmVM>* node = &this->controller.child_list;
            node;
            node = node->next
        ) {
            AnmVM* vm = node->data;
            if (vm && vm != this) {
                if (vm->data.script_id2 == script || script == -1) {
                    if (!arg2) {
                        return vm;
                    }
                    --arg2;
                }
                if (vm->controller.child_list.next) {
                    if (AnmVM* vm2 = vm->__wtf_child_list_jank_A(script, arg2)) {
                        return vm2;
                    }
                }
                if (
                    this->data.script_id2 == (uint16_t)-2 &&
                    !node->next
                ) {
                    return node->data;
                }
            }
        }
        return NULL;
    }

    inline void set_custom_slowdown(float slowdown_value) {
        this->controller.slowdown = slowdown_value;
    }

    inline void clear_all() {
        Float3 controller_position = this->controller.position;
        uint32_t vm_fast_id = this->controller.fast_id;
        int32_t vm_layer = this->data.layer;
        this->zero_contents();
        this->controller.position = controller_position;
        this->controller.fast_id = vm_fast_id;
        this->data.layer = vm_layer;
    }

    inline void clear_controller() {
        Float3 controller_position = this->controller.position;
        int32_t vm_layer = this->data.layer;
        uint32_t vm_fast_id = this->controller.fast_id;
        this->controller.zero_contents();
        this->controller.fast_id = vm_fast_id;
        this->data.layer = vm_layer;
        this->controller.position = controller_position;
    }
    
    // 0x406730
    dllexport gnu_noinline void set_controller_position(Float3* position) asm_symbol_rel(0x406730) {
        this->controller.position = *position;
    }

    // 0x47E8F0
    dllexport gnu_noinline void stdcall __get_vertex_positions(Float3* vert0, Float3* vert1, Float3* vert2, Float3* vert3) asm_symbol_rel(0x47E8F0) {
        Float4* anchor_offset_x = &ANCHOR_X_TABLE[this->data.x_anchor_mode];
        vert0->x = anchor_offset_x->x;
        vert1->x = anchor_offset_x->y;
        vert2->x = anchor_offset_x->z;
        vert3->x = anchor_offset_x->w;

        Float4* anchor_offset_y = &ANCHOR_Y_TABLE[this->data.y_anchor_mode];
        vert0->y = anchor_offset_y->x;
        vert1->y = anchor_offset_y->y;
        vert2->y = anchor_offset_y->z;
        vert3->y = anchor_offset_y->w;

        vert0->as2() *= this->data.sprite_size;
        vert1->as2() *= this->data.sprite_size;
        vert2->as2() *= this->data.sprite_size;
        vert3->as2() *= this->data.sprite_size;

        vert0->as2() -= this->data.anchor_offset;
        vert1->as2() -= this->data.anchor_offset;
        vert2->as2() -= this->data.anchor_offset;
        vert3->as2() -= this->data.anchor_offset;

        switch (this->data.resolution_mode) {
            case 1:
                vert0->as2() *= WINDOW_DATA.__game_scale;
                vert1->as2() *= WINDOW_DATA.__game_scale;
                vert2->as2() *= WINDOW_DATA.__game_scale;
                vert3->as2() *= WINDOW_DATA.__game_scale;
                break;
            case 2:
                vert0->as2() *= WINDOW_DATA.__game_scale * 0.5f;
                vert1->as2() *= WINDOW_DATA.__game_scale * 0.5f;
                vert2->as2() *= WINDOW_DATA.__game_scale * 0.5f;
                vert3->as2() *= WINDOW_DATA.__game_scale * 0.5f;
                break;
        }

        Float2 scale = this->data.scale * this->data.scale2;

        AnmVM* parent = this->controller.parent;
        if (
            parent &&
            !this->data.__treat_as_root
        ) {
            scale *= parent->data.scale * parent->data.scale2;
        }

        vert0->as2() *= scale;
        vert1->as2() *= scale;
        vert2->as2() *= scale;
        vert3->as2() *= scale;

        Float3 position;
        this->get_render_position(&position);

        *vert0 += position;
        *vert1 += position;
        *vert2 += position;
        *vert3 += position;

        float z_offset = this->data.position.z + this->controller.position.z + this->data.__position_2.z;
        vert0->z = z_offset;
        vert1->z = z_offset;
        vert2->z = z_offset;
        vert3->z = z_offset;
    }

    // 0x47ED50
    dllexport gnu_noinline void stdcall __get_rotated_vertex_positions(
        Float3* vert0, // EDI
        Float3* vert1, // ESP+14
        Float3* vert2, // ESP+18
        Float3* vert3  // ESP+1C
    ) asm_symbol_rel(0x47ED50) {
        // this; // ESI

        auto __temp = CRT::sincos_asm(this->get_controller_rotation()->z); // ESP+8 for rotation
        float unit_x = __temp[0]; // ESP+C
        float unit_y = __temp[1]; // ESP+10

        Float4 offset_x = ANCHOR_X_TABLE[this->data.x_anchor_mode]; // ESP+40
        Float4 offset_y = ANCHOR_Y_TABLE[this->data.y_anchor_mode]; // ESP+30

        offset_x *= this->data.sprite_size.x;
        offset_x -= this->data.anchor_offset.x;
        offset_y *= this->data.sprite_size.y;
        offset_y -= this->data.anchor_offset.y;

        switch (this->data.resolution_mode) {
            case 1: {
                float scale = WINDOW_DATA.__game_scale;
                offset_x *= scale;
                offset_y *= scale;
                break;
            }
            case 2: {
                float scale = WINDOW_DATA.__game_scale * 0.5f;
                offset_x *= scale;
                offset_y *= scale;
                break;
            }
        }

        // offset_x // ESP+30
        // offset_y // ESP+20

        Float3 position; // ESP+40
        clang_forceinline this->get_render_position(&position);

        Float2 scale = this->data.scale * this->data.scale2;

        AnmVM* parent = this->controller.parent;
        if (
            parent &&
            !this->data.__treat_as_root
        ) {
            scale *= parent->data.scale * parent->data.scale2;
        }

        offset_y *= scale.y;
        offset_x *= scale.x;

        vert0->x = (offset_x.x * unit_x - offset_y.x * unit_y) + position.x;
        vert0->y = (offset_y.x * unit_y + offset_x.x * unit_x) + position.y;

        vert1->x = (offset_x.y * unit_x - offset_y.y * unit_y) + position.x;
        vert1->y = (offset_y.y * unit_y + offset_x.y * unit_x) + position.y;

        vert2->x = (offset_x.z * unit_x - offset_y.z * unit_y) + position.x;
        vert2->y = (offset_y.z * unit_y + offset_x.z * unit_x) + position.y;
        
        vert3->x = (offset_x.w * unit_x - offset_y.w * unit_y) + position.x;
        vert3->y = (offset_y.w * unit_y + offset_x.w * unit_x) + position.y;

        float z_offset = this->data.position.z + this->controller.position.z + this->data.__position_2.z;
        vert0->z = z_offset;
        vert1->z = z_offset;
        vert2->z = z_offset;
        vert3->z = z_offset;
    }

    // 0x47F090
    dllexport gnu_noinline ZUNResult stdcall __sub_47F090() asm_symbol_rel(0x47F090) {
        // this; // ESI

        float rotation_z = this->get_controller_rotation()->z; // ESP+8
        auto __temp = CRT::sincos_asm(rotation_z);
        float unit_x = __temp[0]; // ESP+20
        float unit_y = __temp[1]; // ESP+4

        StageCamera* camera = SUPERVISOR.current_camera_ptr;

        Float3 projectedA; // ESP+24
        Float3 pV = { 0.0f, 0.0f, 0.0f };
        D3DMATRIXZ pWorld;
        pWorld.set_identity();
        pWorld.m[3][0] = this->data.position.x + this->controller.position.x + this->data.__position_2.x;
        pWorld.m[3][1] = this->data.position.y + this->controller.position.y + this->data.__position_2.y;
        pWorld.m[3][2] = this->data.position.z + this->controller.position.z + this->data.__position_2.z;
        D3DXVec3Project(&projectedA.D3DX(), &pV.D3DX(), &camera->viewport, &camera->projection_matrix.D3DX(), &camera->view_matrix.D3DX(), &pWorld.D3DX());

        if (
            !(projectedA.z < 0.0f) &&
            !(projectedA.z > 1.0f)
        ) {
            camera = SUPERVISOR.current_camera_ptr;

            Float3 projectedB; // ESP+3C
            D3DXVec3Project(&projectedB.D3DX(), &camera->__float3_30.D3DX(), &camera->viewport, &camera->projection_matrix.D3DX(), &camera->view_matrix.D3DX(), &pWorld.D3DX());

            float scale = projectedB.distance(&projectedA) * 0.5f;

            Float2 size = this->data.sprite_size * scale * this->data.scale * this->data.scale2;

            SPRITE_VERTEX_BUFFER_A[3].position.z = projectedA.z;
            SPRITE_VERTEX_BUFFER_A[2].position.z = projectedA.z;
            SPRITE_VERTEX_BUFFER_A[1].position.z = projectedA.z;
            SPRITE_VERTEX_BUFFER_A[0].position.z = projectedA.z;

            // Yup, we're just doing this again for no reason
            __temp = CRT::sincos_asm(rotation_z); // ESP+8 for rotation
            unit_x = __temp[0]; // ESP+20
            unit_y = __temp[1]; // ESP+4

            float X0, X1, X2, X3;
            switch (this->data.x_anchor_mode) {
                case 0:
                    X0 = -size.x * 0.5f;
                    X1 = size.x * 0.5f;
                    X2 = -size.x * 0.5f;
                    X3 = size.x * 0.5f;
                    break;
                case 1:
                    X0 = 0.0f;
                    X1 = size.x;
                    X2 = 0.0f;
                    X3 = size.x;
                    break;
                case 2:
                    X0 = -size.x;
                    X1 = 0.0f;
                    X2 = -size.x;
                    X3 = 0.0f;
                    break;
                default:
                    X0 = unit_y; // XMM1, ESP+14
                    X1 = unit_y; // ESP+C
                    X2 = unit_y; // XMM6
                    X3 = unit_y; // XMM4
                    break;
            }
            float Y0, Y1, Y2, Y3;
            switch (this->data.y_anchor_mode) {
                case 0:
                    Y0 = -size.y * 0.5f;
                    Y1 = size.y * 0.5f;
                    Y2 = -size.y * 0.5f;
                    Y3 = size.y * 0.5f;
                    break;
                case 1:
                    Y0 = 0.0f;
                    Y1 = size.y;
                    Y2 = 0.0f;
                    Y3 = size.y;
                    break;
                case 2:
                    Y0 = -size.y;
                    Y1 = 0.0f;
                    Y2 = -size.y;
                    Y3 = 0.0f;
                    break;
                default:
                    Y0 = unit_y; // XMM2, ESP+8
                    Y1 = unit_y; // XMM7
                    Y2 = unit_y; // ESP+10
                    Y3 = unit_y; // XMM5
                    break;
            }

            SPRITE_VERTEX_BUFFER_A[0].position.x = (X0 * unit_x - Y0 * unit_y) + projectedA.x;
            SPRITE_VERTEX_BUFFER_A[0].position.y = (X0 * unit_y + Y0 * unit_x) + projectedA.y;
            SPRITE_VERTEX_BUFFER_A[1].position.x = (X1 * unit_x - Y1 * unit_y) + projectedA.x;
            SPRITE_VERTEX_BUFFER_A[1].position.y = (X1 * unit_y + Y1 * unit_x) + projectedA.y;
            SPRITE_VERTEX_BUFFER_A[2].position.x = (X2 * unit_x - Y2 * unit_y) + projectedA.x;
            SPRITE_VERTEX_BUFFER_A[2].position.y = (X2 * unit_y + Y2 * unit_x) + projectedA.y;
            SPRITE_VERTEX_BUFFER_A[3].position.x = (X3 * unit_x - Y3 * unit_y) + projectedA.x;
            SPRITE_VERTEX_BUFFER_A[3].position.y = (X3 * unit_y + Y3 * unit_x) + projectedA.y;
            return ZUN_SUCCESS;
        }
        return ZUN_ERROR;
    }

    // 0x481D20
    dllexport gnu_noinline void thiscall __get_vertex_quad(Float3* out) asm_symbol_rel(0x481D20) {
        switch (this->data.render_mode) {
            case 1:
                this->__get_rotated_vertex_positions(&out[0], &out[1], &out[2], &out[3]);
                break;
            case 0: case 2: case 3:
                this->__get_vertex_positions(&out[0], &out[1], &out[2], &out[3]);
                break;
        }
    }

    // 0x41B430
    dllexport gnu_noinline void reset() asm_symbol_rel(0x41B430) {
        this->clear_all();
        this->data.scale = { 1.0f, 1.0f };
        this->data.scale2 = { 1.0f, 1.0f };
        this->data.uv_scale = { 1.0f, 1.0f };
        this->data.color1 = PackD3DCOLOR(255, 255, 255, 255);
        this->data.__matrix_3D4.set_identity();
        this->controller.script_time.default_values();
        this->controller.__timer_1C.default_values();
        this->data.position_interp.end_time = 0;
        //this->data.color_interp.end_time = 0;
        this->data.alpha_interp.end_time = 0;
        this->data.rotation_interp.end_time = 0;
        this->data.spin_interp.end_time = 0;
        //this->data.scale_interp.end_time = 0;
        this->data.scale2_interp.end_time = 0;
        this->data.uv_scale_interp.end_time = 0;
        this->data.color2_interp.end_time = 0;
        this->data.alpha2_interp.end_time = 0;
        this->data.u_scroll_speed_interp.end_time = 0;
        this->data.v_scroll_speed_interp.end_time = 0;
        this->data.__unknown_field_B = 1;
        this->data.current_context.rand_scale = 1.0f;
        this->data.current_context.rand_angle_scale = PI_f;
        this->data.current_context.rand_int_range = UINT16_MAX + 1;
        // Technically memset 0 isn't guaranteed to assign NULL to pointers
        // according to official C/C++ standards. Instead literal 0 is given
        // special meanings in the context of pointers.
        // Assigning 0 to a pointer will initialize it with the platform-dependent
        // null pointer value, which could be 0x55555555 or some BS on hypothetical
        // exotic platforms. Memset doesn't do this, instead copying the bytes
        // verbatum with no guarantees about pointer contents.
        //
        // TLDR: Even if you memset something to 0, the standard doesn't guarantee
        // pointers will be NULL. ZUN is *technically* following best practice here!
        //
        // It's still stupid though.
        this->controller.__root_vm = NULL;
        this->controller.parent = NULL;
        this->controller.global_list_node.initialize_with(this);
        this->controller.child_list_node.initialize_with(this);
        this->controller.child_list.initialize_with(this);
        this->controller.destroy_list_node.initialize_with(this);
    }

    // 0x41B6F0
    dllexport gnu_noinline void cleanup() asm_symbol_rel(0x41B6F0) {
        if (void* special_data = this->controller.special_data) {
            free(special_data);
        }
        this->controller.special_data = NULL;
        this->controller.special_data_size = 0;
        this->controller.id = 0;
        this->data.current_instruction_offset = -1;
        for (
            AnmVM* vm = this;
            vm->controller.next_in_layer;
            // vm = vm->controller.next_in_layer
        ) {
            vm->controller.id = 0;
        }
    }

    // 0x41B750
    inline ~AnmVM() {
        this->cleanup();
    }

    inline int32_t run_on_wait() {
        if (uint32_t index = this->controller.on_wait_index) {
            return ANM_ON_WAIT_FUNCS[index](this);
        }
        return 0;
    }
    inline int32_t run_on_tick() {
        if (uint32_t index = this->controller.on_tick_index) {
            return ANM_ON_TICK_FUNCS[index](this);
        }
        return 0;
    }
    inline int32_t run_on_draw() {
        if (uint32_t index = this->controller.on_draw_index) {
            return ANM_ON_DRAW_FUNCS[index](this);
        }
        return 0;
    }
    inline int32_t run_on_destroy() {
        if (uint32_t index = this->controller.on_destroy_index) {
            return ANM_ON_DESTROY_FUNCS[index](this);
        }
        return 0;
    }
    inline int32_t run_on_interrupt(int32_t interrupt) {
        if (uint32_t index = this->controller.on_interrupt_index) {
            return ANM_ON_INTERRUPT_FUNCS[index](this, interrupt);
        }
        return 0;
    }
    inline int32_t run_on_copy_A() {
        if (uint32_t index = this->controller.on_copy_A_index) {
            return ANM_ON_COPY_A_FUNCS[index](this);
        }
        return 0;
    }
    inline int32_t run_on_copy_B() {
        if (uint32_t index = this->controller.on_copy_B_index) {
            return ANM_ON_COPY_B_FUNCS[index](this);
        }
        return 0;
    }
    inline int32_t run_on_sprite_lookup(int32_t sprite) {
        if (uint32_t index = this->controller.on_sprite_lookup_index) {
            return ANM_ON_SPRITE_LOOKUP_FUNCS[index](this, sprite);
        }
        return 0;
    }

    inline void interrupt_and_run(int32_t interrupt) {
        this->run_on_interrupt(interrupt);
        this->run_anm();
    }

    // ====================
    // Special data funcs
    // ====================

    // 0x406AD0
    dllexport gnu_noinline static int fastcall on_create_special_dataA(AnmVM* vm, void* arg) asm_symbol_rel(0x406AD0);

    // 0x406C80
    dllexport gnu_noinline static int fastcall on_tick_special_dataA(AnmVM* vm) asm_symbol_rel(0x406C80);

    // 0x406D00
    dllexport gnu_noinline static int fastcall on_draw_special_dataA(AnmVM* vm) asm_symbol_rel(0x406D00);

    // 0x4072A0
    dllexport gnu_noinline static int fastcall on_destroy_special_dataA(AnmVM* vm) asm_symbol_rel(0x4072A0);

    // 0x4072B0
    dllexport gnu_noinline static int fastcall on_interrupt_special_dataA(AnmVM* vm, int32_t interrupt) asm_symbol_rel(0x4072B0);

    // 0x404FC0
    dllexport gnu_noinline static int fastcall on_create_special_dataB(AnmVM* vm, void* arg) asm_symbol_rel(0x404FC0);

    // 0x405030
    dllexport gnu_noinline static int fastcall on_tick_special_dataB(AnmVM* vm) asm_symbol_rel(0x405030);

    // 0x4058B0
    dllexport gnu_noinline static int fastcall on_draw_special_dataB(AnmVM* vm) asm_symbol_rel(0x4058B0);

    // 0x4058C0
    dllexport gnu_noinline static int fastcall on_destroy_special_dataB(AnmVM* vm) asm_symbol_rel(0x4058C0);

    // 0x405910
    dllexport gnu_noinline static int fastcall on_interrupt_special_dataB(AnmVM* vm, int32_t interrupt) asm_symbol_rel(0x405910);

    // 0x405D70
    dllexport gnu_noinline static int fastcall on_create_special_dataC1(AnmVM* vm, void* arg) asm_symbol_rel(0x405D70);

    // 0x405ED0
    dllexport gnu_noinline static int fastcall on_tick_special_dataC(AnmVM* vm) asm_symbol_rel(0x405ED0);

    // 0x406090
    dllexport gnu_noinline static int fastcall on_draw_special_dataC(AnmVM* vm) asm_symbol_rel(0x406090);

    // 0x406290
    dllexport gnu_noinline static int fastcall on_destroy_special_dataC(AnmVM* vm) asm_symbol_rel(0x406290);

    // 0x4062A0
    dllexport gnu_noinline static int fastcall on_interrupt_special_dataC(AnmVM* vm, int32_t interrupt) asm_symbol_rel(0x4062A0);

    // 0x4062B0
    dllexport gnu_noinline static int fastcall on_create_special_dataC2(AnmVM* vm, void* arg) asm_symbol_rel(0x4062B0);

    // 0x407590
    dllexport gnu_noinline static int fastcall on_create_special_dataD(AnmVM* vm, void* arg) asm_symbol_rel(0x407590);

    // 0x4078D0
    dllexport gnu_noinline static int fastcall on_tick_special_dataD(AnmVM* vm) asm_symbol_rel(0x4078D0);

    // 0x407C90
    dllexport gnu_noinline static int fastcall on_draw_special_dataD(AnmVM* vm) asm_symbol_rel(0x407C90);

    // 0x407D30
    dllexport gnu_noinline static int fastcall on_destroy_special_dataD(AnmVM* vm) asm_symbol_rel(0x407D30);
    
    // 0x407D40
    dllexport gnu_noinline static int fastcall on_interrupt_special_dataD(AnmVM* vm, int32_t interrupt) asm_symbol_rel(0x407D40);

    // ====================
    // Other funcs
    // ====================

    // 0x405D40
    dllexport gnu_noinline void thiscall allocate_special_vertex_buffer(size_t buffer_size) asm_symbol_rel(0x405D40) {
        this->controller.special_data_size = buffer_size;
        this->controller.special_data = malloc(buffer_size);
    }

    // 0x4832F0
    dllexport gnu_noinline int thiscall __sub_4832F0() asm_symbol_rel(0x4832F0) {
        // TODO: this creates the data for on tick 4
        return 0;
    }

    // 0x483560
    dllexport gnu_noinline static int fastcall on_tick_4(AnmVM* vm) asm_symbol_rel(0x483560) {
        // TODO
    }

    // 0x42B1E0
    dllexport gnu_noinline static int fastcall on_draw_4(AnmVM* vm) asm_symbol_rel(0x42B1E0) {
        // TODO
        return 0;
    }

    // 0x441130
    dllexport gnu_noinline static int fastcall on_draw_5(AnmVM* vm) asm_symbol_rel(0x441130) {
        MsgVM* msg_vm = GUI_PTR->msg_vm;
        AnmVM* vm2 = msg_vm->__textbox_related.__wtf_child_list_jank_A(msg_vm->__int_1D4 + 170, 0);
        if (vm2) {

        }
        return 0;
    }
    
    // 0x488FA0
    dllexport void thiscall set_sprite(int32_t sprite_id) asm_symbol_rel(0x488FA0);

    // 0x412F20
    dllexport inline void thiscall interrupt(int32_t interrupt_index) asm_symbol_rel(0x412F20) {
        this->run_on_interrupt(interrupt_index);
        this->data.run_interrupt = interrupt_index;
    }

    inline AnmInstruction* get_current_instruction();

    // 0x47D8B0
    dllexport gnu_noinline void vectorcall set_scale_delta(float x, float y) asm_symbol_rel(0x47D8B0) {
        this->data.__deltas_enabled = true;
        this->data.scale_delta.x = x;
        this->data.scale_delta.y = y;
    }
    // 0x47D8D0
    dllexport gnu_noinline void vectorcall set_angular_velocity(float x, float y, float z) asm_symbol_rel(0x47D8D0) {
        this->data.__deltas_enabled = true;
        this->data.angular_velocity.x = x;
        this->data.angular_velocity.y = y;
        this->data.angular_velocity.z = z;
    }

    inline uint8_t get_alpha() {
        return ALPHA(this->data.color1);
    }

    inline uint8_t get_alpha2() {
        return ALPHA(this->data.color2);
    }

    inline void set_rgb(const RGB& colors) {
        RED(this->data.color1) = colors.r;
        GREEN(this->data.color1) = colors.g;
        BLUE(this->data.color1) = colors.b;
    }

    inline void set_alpha(uint8_t value) {
        ALPHA(this->data.color1) = value;
    }

    inline void set_rgb2(const RGB& colors) {
        RED(this->data.color2) = colors.r;
        GREEN(this->data.color2) = colors.g;
        BLUE(this->data.color2) = colors.b;
    }

    inline void set_alpha2(uint8_t value) {
        ALPHA(this->data.color2) = value;
    }
    
    // 0x43A250
    dllexport float vectorcall get_scaled_sprite_x_size() asm_symbol_rel(0x43A250) {
        return this->data.sprite_size.x * this->data.scale.x;
    }
    
    // 0x43A260
    dllexport float vectorcall get_scaled_sprite_y_size() asm_symbol_rel(0x43A260) {
        return this->data.sprite_size.y * this->data.scale.y;
    }

    // 0x47BCE0
    dllexport gnu_noinline void thiscall __apply_deltas() asm_symbol_rel(0x47BCE0) {
        float x_rotation_delta = this->data.angular_velocity.x;
        if (x_rotation_delta != 0.0f) {
            this->set_x_rotation(reduce_angle(this->data.rotation.x + x_rotation_delta * GAME_SPEED));
        }
        float y_rotation_delta = this->data.angular_velocity.y;
        if (y_rotation_delta != 0.0f) {
            this->set_y_rotation(reduce_angle(this->data.rotation.y + y_rotation_delta * GAME_SPEED));
        }
        float z_rotation_delta = this->data.angular_velocity.z;
        if (z_rotation_delta != 0.0f) {
            this->set_z_rotation(reduce_angle(this->data.rotation.z + z_rotation_delta * GAME_SPEED));
        }

        float y_scale_delta = this->data.scale_delta.y;
        if (y_scale_delta != 0.0f) {
            this->set_y_scale(this->data.scale.y + y_scale_delta * GAME_SPEED);
        }
        float x_scale_delta = this->data.scale_delta.x;
        if (x_scale_delta != 0.0f) {
            this->set_x_scale(this->data.scale.x + x_scale_delta * GAME_SPEED);
        }

        float x_scroll_delta = this->data.uv_scroll_speed.x;
        if (x_scroll_delta != 0.0f) {
            float new_scroll = x_scroll_delta * GAME_SPEED + this->data.uv_scroll.x;
            this->data.uv_scroll.x = new_scroll;
            if (new_scroll >= 2.0f) {
                this->data.uv_scroll.x = new_scroll - 2.0f;
            } else if (new_scroll < 0.0f) {
                this->data.uv_scroll.x = new_scroll + 2.0f;
            }
        }

        float y_scroll_delta = this->data.uv_scroll_speed.y;
        if (y_scroll_delta != 0.0f) {
            float new_scroll = x_scroll_delta * GAME_SPEED + this->data.uv_scroll.y;
            this->data.uv_scroll.y = new_scroll;
            if (new_scroll >= 2.0f) {
                this->data.uv_scroll.y = new_scroll - 2.0f;
            } else if (new_scroll < 0.0f) {
                this->data.uv_scroll.y = new_scroll + 2.0f;
            }
        }
    }

private:
    // 0x477EA0
    dllexport gnu_noinline float vectorcall get_float_var(float, float index) asm_symbol_rel(0x477EA0) {
        using namespace Anm;
        switch ((int32_t)index) {
            case I0: // 10000
                return this->data.current_context.int_vars[0];
            case I1: // 10001
                return this->data.current_context.int_vars[1];
            case I2: // 10002
                return this->data.current_context.int_vars[2];
            case I3: // 10003
                return this->data.current_context.int_vars[3];
            case F0: // 10004
                return this->data.current_context.float_vars[0];
            case F1: // 10005
                return this->data.current_context.float_vars[1];
            case F2: // 10006
                return this->data.current_context.float_vars[2];
            case F3: // 10007
                return this->data.current_context.float_vars[3];
            case __UNKNOWN_X: // 10033
                return this->data.current_context.__float3_20.x;
            case __UNKNOWN_Y: // 10034
                return this->data.current_context.__float3_20.y;
            case __UNKNOWN_Z: // 10035
                return this->data.current_context.__float3_20.z;
            case IC0: // 10008
                return this->data.current_context.counter_vars[0];
            case IC1: // 10009
                return this->data.current_context.counter_vars[1];
            case RAND_FLOAT: // 10011
                return RNG.rand_float_range(this->data.current_context.rand_scale);
            case RAND_FLOAT_SIGNED: // 10012
                return RNG.rand_float_signed_range(this->data.current_context.rand_scale);
            case RAND_ANGLE: // 10010
                return RNG.rand_float_signed_range(this->data.current_context.rand_angle_scale);
            case SELF_X: // 10013
                return this->data.position.x;
            case SELF_Y: // 10014
                return this->data.position.x;
            case SELF_Z: // 10015
                return this->data.position.x;
            case SELF_X_ROT: // 10023
                return this->data.rotation.x;
            case SELF_Y_ROT: // 10024
                return this->data.rotation.y;
            case SELF_Z_ROT: // 10025
                return this->data.rotation.z;
            case __CONTROLLER_Z_ROT: // 10026
                return this->get_controller_rotation()->z;
            case CAMERA_POS_X: // 10016
                return SUPERVISOR.cameras[3].position.x + SUPERVISOR.cameras[3].__shaking_float3_A.x;
            case CAMERA_POS_Y: // 10017
                return SUPERVISOR.cameras[3].position.y + SUPERVISOR.cameras[3].__shaking_float3_A.y;
            case CAMERA_POS_Z: // 10018
                return SUPERVISOR.cameras[3].position.z + SUPERVISOR.cameras[3].__shaking_float3_A.z;
            case CAMERA_FACING_X: // 10019
                return SUPERVISOR.cameras[3].facing_normalized.x;
            case CAMERA_FACING_Y: // 10020
                return SUPERVISOR.cameras[3].facing_normalized.x;
            case CAMERA_FACING_Z: // 10021
                return SUPERVISOR.cameras[3].facing_normalized.x;
            case RAND_SCALE: // 10027
                return this->data.current_context.rand_scale;
            case RAND_ANGLE_SCALE: // 10028
                return this->data.current_context.rand_angle_scale;
            case RAND_UINT_RANGE: // 10029
                return this->data.current_context.rand_int_range;
            case RAND_UINT: // 10022
                // BUG: Range variable is not applied here
                return RNG.rand_uint();
            case RAND_FLOAT_REPLAY: // 10031
                return REPLAY_RNG.rand_float_range(this->data.current_context.rand_scale);
            case RAND_FLOAT_SIGNED_REPLAY: // 10032
                return REPLAY_RNG.rand_float_signed_range(this->data.current_context.rand_scale);
            case RAND_ANGLE_REPLAY: // 10030
                return REPLAY_RNG.rand_float_signed_range(this->data.current_context.rand_angle_scale);
            default:
                return index;
        }
    }
public:
    inline float get_float_var(float index) {
        return this->get_float_var(UNUSED_FLOAT, index);
    }

    // 0x4781E0
    dllexport gnu_noinline int32_t thiscall get_int_var(int32_t index) asm_symbol_rel(0x4781E0) {
        using namespace Anm;
        switch (index) {
            case I0: // 10000
                return this->data.current_context.int_vars[0];
            case I1: // 10001
                return this->data.current_context.int_vars[1];
            case I2: // 10002
                return this->data.current_context.int_vars[2];
            case I3: // 10003
                return this->data.current_context.int_vars[3];
            case F0: // 10004
                return this->data.current_context.float_vars[0];
            case F1: // 10005
                return this->data.current_context.float_vars[1];
            case F2: // 10006
                return this->data.current_context.float_vars[2];
            case F3: // 10007
                return this->data.current_context.float_vars[3];
            case __UNKNOWN_X: // 10033
                return this->data.current_context.__float3_20.x;
            case __UNKNOWN_Y: // 10034
                return this->data.current_context.__float3_20.y;
            case __UNKNOWN_Z: // 10035
                return this->data.current_context.__float3_20.z;
            case IC0: // 10008
                return this->data.current_context.counter_vars[0];
            case IC1: // 10009
                return this->data.current_context.counter_vars[1];
            case RAND_SCALE: // 10027
                return this->data.current_context.rand_scale;
            case RAND_ANGLE_SCALE: // 10028
                return this->data.current_context.rand_angle_scale;
            case RAND_UINT_RANGE: // 10029
                return this->data.current_context.rand_int_range;
            case RAND_UINT: // 10022
                clang_noinline return RNG.rand_uint_range(this->data.current_context.rand_int_range);
            default:
                return index;
        }
    }

    inline float* get_float_ptr(int32_t index) {
        using namespace Anm;
        switch ((int32_t)index) {
            case F0: // 10004
                return &this->data.current_context.float_vars[0];
            case F1: // 10005
                return &this->data.current_context.float_vars[1];
            case F2: // 10006
                return &this->data.current_context.float_vars[2];
            case F3: // 10007
                return &this->data.current_context.float_vars[3];
            case SELF_X: // 10013
                return &this->data.position.x;
            case SELF_Y: // 10014
                return &this->data.position.x;
            case SELF_Z: // 10015
                return &this->data.position.x;
            case SELF_X_ROT: // 10023
                return &this->data.rotation.x;
            case SELF_Y_ROT: // 10024
                return &this->data.rotation.y;
            case SELF_Z_ROT: // 10025
                return &this->data.rotation.z;
            case __UNKNOWN_X: // 10033
                return &this->data.current_context.__float3_20.x;
            case __UNKNOWN_Y: // 10034
                return &this->data.current_context.__float3_20.y;
            case __UNKNOWN_Z: // 10035
                return &this->data.current_context.__float3_20.z;
            case RAND_SCALE: // 10027
                return &this->data.current_context.rand_scale;
            case RAND_ANGLE_SCALE: // 10028
                return &this->data.current_context.rand_angle_scale;
            default:
                return NULL;
        }
    }

    inline int32_t* get_int_ptr(int32_t index) {
        using namespace Anm;
        switch (index) {
            case I0: // 10000
                return &this->data.current_context.int_vars[0];
            case I1: // 10001
                return &this->data.current_context.int_vars[1];
            case I2: // 10002
                return &this->data.current_context.int_vars[2];
            case I3: // 10003
                return &this->data.current_context.int_vars[3];
            case IC0: // 10008
                return &this->data.current_context.counter_vars[0];
            case IC1: // 10009
                return &this->data.current_context.counter_vars[1];
            case RAND_UINT_RANGE: // 10029
                return &this->data.current_context.rand_int_range;
            default:
                return NULL;
        }
    }

    inline float get_float_arg(float& value, uint16_t param_mask, int32_t index) {
        if (param_mask & 1 << index) {
            return this->get_float_var(value);
        } else {
            return value;
        }
    }

    inline int32_t get_int_arg(int32_t& value, uint16_t param_mask, int32_t index) {
        if (param_mask & 1 << index) {
            return this->get_int_var(value);
        } else {
            return value;
        }
    }

    // 0x478340
    dllexport gnu_noinline float* thiscall get_float_ptr_arg(float* value, uint16_t param_mask, int32_t index) {
        float* ret;
        if (
            !(param_mask & 1 << index) ||
            !(ret = this->get_float_ptr(*value))
        ) {
            ret = value;
        }
        return ret;
    }

    // 0x478480
    dllexport gnu_noinline int32_t* thiscall get_int_ptr_arg(int32_t* value, uint16_t param_mask, int32_t index = 0) {
        int32_t* ret;
        if (
            !(param_mask & 1) ||
            !(ret = this->get_int_ptr(*value))
        ) {
            ret = value;
        }
        return ret;
    }

    // 0x478580
    dllexport gnu_noinline int32_t thiscall run_anm() asm_symbol_rel(0x478580);

    // 0x47C750
    dllexport gnu_noinline void thiscall step_interps() asm_symbol_rel(0x47C750) {
        if (this->data.position_interp.end_time) {
            if (this->data.position_mode == 0) {
                this->data.position = this->data.position_interp.step();
            } else {
                this->data.__position_2 = this->data.position_interp.step();
            }
        }

        if (this->data.color_interp.end_time) {
            this->set_rgb(this->data.color_interp.step());
        }
        if (this->data.alpha_interp.end_time) {
            this->set_alpha(this->data.alpha_interp.step());
        }

        // TODO: double check if these are really normal float2 interps,
        // they call a separate function than the uv_scale right below.
        if (this->data.scale_interp.end_time) {
            this->set_scale(this->data.scale_interp.step());
        }
        if (this->data.scale2_interp.end_time) {
            this->set_scale2(this->data.scale2_interp.step());
        }

        if (this->data.uv_scale_interp.end_time) {
            this->set_uv_scale(this->data.uv_scale_interp.step());
        }

        if (this->data.rotation_interp.end_time) {
            this->set_rotation(this->data.rotation_interp.step());
        }
        if (this->data.spin_interp.end_time) {
            this->set_z_rotation(this->data.spin_interp.step());
        }

        if (this->data.color2_interp.end_time) {
            this->set_rgb2(this->data.color2_interp.step());
        }
        if (this->data.alpha2_interp.end_time) {
            this->set_alpha2(this->data.alpha2_interp.step());
        }

        if (this->data.u_scroll_speed_interp.end_time) {
            this->set_x_scroll_speed(this->data.u_scroll_speed_interp.step());
        }
        if (this->data.v_scroll_speed_interp.end_time) {
            this->set_y_scroll_speed(this->data.v_scroll_speed_interp.step());
        }
    }

    // 0x47BEF0
    dllexport gnu_noinline void thiscall __update_polygons() asm_symbol_rel(0x47BEF0) {
        switch (this->data.render_mode) {
            case 9:
            case 13: case 14:
            case 18: case 19:
        }
    }

    // 0x488EF0
    dllexport void __tree_set_visible2() asm_symbol_rel(0x488EF0) {
        this->data.__visible2 = true;
        this->controller.child_list.for_each([](AnmVM* vm) gnu_always_inline static_lambda {
            clang_noinline vm->__tree_set_visible2();
        });
    }

    // 0x488F20
    dllexport void __tree_clear_visible2() asm_symbol_rel(0x488F20) {
        this->data.__visible2 = false;
        this->controller.child_list.for_each([](AnmVM* vm) gnu_always_inline static_lambda {
            clang_noinline vm->__tree_clear_visible2();
        });
    }

    inline void set_x_rotation(float value) {
        this->data.rotation_enabled = true;
        this->data.rotation.x = value;
    }

    inline void set_y_rotation(float value) {
        this->data.rotation_enabled = true;
        this->data.rotation.y = value;
    }
    
private:
    // 0x4892E0
    dllexport void vectorcall set_z_rotation(float, float value) asm_symbol_rel(0x4892E0) {
        this->data.rotation_enabled = true;
        this->data.rotation.z = value;
    }
public:
    inline void set_z_rotation(float value) {
        return this->set_z_rotation(UNUSED_FLOAT, value);
    }

    inline void set_rotation(float x, float y, float z) {
        this->data.rotation.x = x;
        this->data.rotation.y = y;
        this->data.rotation.z = z;
        this->data.rotation_enabled = true;
    }

    inline void set_rotation(const Float3& values) {
        this->set_rotation(values.x, values.y, values.z);
    }

    inline void set_x_scale(float value) {
        this->data.scale_enabled = true;
        this->data.scale.x = value;
    }

    inline void set_y_scale(float value) {
        this->data.scale_enabled = true;
        this->data.scale.y = value;
    }

    inline void set_scale(float x, float y) {
        this->data.scale_enabled = true;
        this->data.scale.x = x;
        this->data.scale.y = y;
    }

    inline void set_scale(const Float2& values) {
        this->set_scale(values.x, values.y);
    }

    inline void set_scale(float value) {
        this->set_scale(value, value);
    }

    inline void set_x_scale2(float value) {
        this->data.scale_enabled = true;
        this->data.scale2.x = value;
    }

    inline void set_y_scale2(float value) {
        this->data.scale_enabled = true;
        this->data.scale2.y = value;
    }

    inline void set_scale2(float x, float y) {
        this->data.scale_enabled = true;
        this->data.scale2.x = x;
        this->data.scale2.y = y;
    }

    inline void set_scale2(const Float2& values) {
        this->set_scale2(values.x, values.y);
    }

    inline void set_scale2(float value) {
        this->set_scale2(value, value);
    }

    inline void set_u_scale(float value) {
        this->data.uv_scale_enabled = true;
        this->data.uv_scale.x = value;
    }

    inline void set_v_scale(float value) {
        this->data.uv_scale_enabled = true;
        this->data.uv_scale.y = value;
    }

    inline void set_uv_scale(float u, float v) {
        this->data.uv_scale_enabled = true;
        this->data.uv_scale.x = u;
        this->data.uv_scale.y = v;
    }

    inline void set_uv_scale(const Float2& values) {
        this->set_uv_scale(values.x, values.y);
    }

    inline void set_uv_scale(float value) {
        this->set_uv_scale(value, value);
    }

    inline void set_x_scroll_speed(float value) {
        this->data.__deltas_enabled = true;
        this->data.uv_scroll_speed.x = value;
    }

    inline void set_y_scroll_speed(float value) {
        this->data.__deltas_enabled = true;
        this->data.uv_scroll_speed.y = value;
    }

    inline void set_scroll_speed(float x, float y) {
        this->data.__deltas_enabled = true;
        this->data.uv_scroll_speed.x = x;
        this->data.uv_scroll_speed.y = y;
    }

    inline void set_scroll_speed(const Float2& values) {
        this->set_scroll_speed(values.x, values.y);
    }

    inline void set_scroll_speed(float value) {
        this->set_scroll_speed(value, value);
    }
};
ValidateStructSize32(0x60C, AnmVM);

using AnmVMOnCreateFunc = decltype(AnmVM::on_create_special_dataA);

// size: 0x624
struct FastAnmVM : AnmVM {
    ZUNList<FastAnmVM> fast_node; // 0x60C
    bool alive; // 0x61C
    probably_padding_bytes(0x3); // 0x61D
    uint32_t fast_id; // 0x620
};

typedef struct AnmEntry AnmEntry;

// size: 0x10
struct AnmTexture {
    ZUNMagic magic; // 0x0 (THTX)
    uint16_t __zero; // 0x4
    uint16_t format; // 0x6
    int16_t width; // 0x8
    int16_t height; // 0xA
    uint32_t num_bytes; // 0xC
    unsigned char data[]; // 0x10
};
#pragma region // AnmTexture Validation
ValidateFieldOffset32(0x0, AnmTexture, magic);
ValidateFieldOffset32(0x4, AnmTexture, __zero);
ValidateFieldOffset32(0x6, AnmTexture, format);
ValidateFieldOffset32(0x8, AnmTexture, width);
ValidateFieldOffset32(0xA, AnmTexture, height);
ValidateFieldOffset32(0xC, AnmTexture, num_bytes);
ValidateFieldOffset32(0x10, AnmTexture, data);
ValidateStructSize32(0x10, AnmTexture);
#pragma endregion

// size: 0x40+
struct AnmEntry {
    uint32_t version; // 0x0
    uint16_t sprite_count; // 0x4
    uint16_t script_count; // 0x6
    uint16_t __word_8; // 0x8
    uint16_t width; // 0xA
    uint16_t height; // 0xC
    uint16_t format; // 0xE
    uint32_t image_path_offset; // 0x10
    int16_t offset_x; // 0x14
    int16_t offset_y; // 0x16
    uint32_t memory_priority; // 0x18
    uint32_t texture_data_offset; // 0x1C
    bool has_data; // 0x20
    unknown_fields(0x1); // 0x21
    bool low_res_scale; // 0x22
    unknown_fields(0x1); // 0x23
    uint32_t offset_to_next; // 0x24
    padding_bytes(0x18); // 0x28
    unsigned char data[]; // 0x40
};
#pragma region // AnmEntry Validation
ValidateFieldOffset32(0x0, AnmEntry, version);
ValidateFieldOffset32(0x4, AnmEntry, sprite_count);
ValidateFieldOffset32(0x6, AnmEntry, script_count);
ValidateFieldOffset32(0x8, AnmEntry, __word_8);
ValidateFieldOffset32(0xA, AnmEntry, width);
ValidateFieldOffset32(0xC, AnmEntry, height);
ValidateFieldOffset32(0xE, AnmEntry, format);
ValidateFieldOffset32(0x10, AnmEntry, image_path_offset);
ValidateFieldOffset32(0x14, AnmEntry, offset_x);
ValidateFieldOffset32(0x16, AnmEntry, offset_y);
ValidateFieldOffset32(0x18, AnmEntry, memory_priority);
ValidateFieldOffset32(0x1C, AnmEntry, texture_data_offset);
ValidateFieldOffset32(0x20, AnmEntry, has_data);
ValidateFieldOffset32(0x22, AnmEntry, low_res_scale);
ValidateFieldOffset32(0x24, AnmEntry, offset_to_next);
ValidateFieldOffset32(0x40, AnmEntry, data);
ValidateStructSize32(0x40, AnmEntry);
#pragma endregion

typedef struct AnmImage AnmImage;

// 0x486560
dllexport gnu_noinline int32_t stdcall __create_render_target_texture(AnmImage* image, uint32_t width, uint32_t height) asm_symbol_rel(0x486560);

// size: 0x18
struct AnmImage {
    LPDIRECT3DTEXTURE9 d3d_texture; // 0x0
    void* file; // 0x4
    int32_t file_size; // 0x8
    uint32_t bytes_per_pixel; // 0xC
    AnmEntry* entry; // 0x10
    union {
        uint32_t flags; // 0x14
        struct {
            uint32_t __unknown_flag_A : 1;
            uint32_t : 31;
        };
    };
    // 0x18

    inline void cleanup() {
        SAFE_RELEASE(this->d3d_texture);
        SAFE_FREE(this->file);
    }

    inline void create_render_target_texture() {
        AnmEntry* entry = this->entry;
        clang_forceinline __create_render_target_texture(this, entry->width, entry->height);
    }

    // 0x489030
    dllexport gnu_noinline void thiscall __sub_489030() asm_symbol_rel(0x489030) {
        LPDIRECT3DSURFACE9 surface;
        this->d3d_texture->GetSurfaceLevel(0, &surface);
        D3DSURFACE_DESC surface_desc;
        surface->GetDesc(&surface_desc);
        D3DLOCKED_RECT rect;
        surface->LockRect(&rect, NULL, 0);
        memset(rect.pBits, 0, rect.Pitch * surface_desc.Height);
        surface->UnlockRect();
        SAFE_RELEASE(surface);
    }
};
#pragma region // AnmImage Validation
ValidateFieldOffset32(0x0, AnmImage, d3d_texture);
ValidateFieldOffset32(0x4, AnmImage, file);
ValidateFieldOffset32(0x8, AnmImage, file_size);
ValidateFieldOffset32(0xC, AnmImage, bytes_per_pixel);
ValidateFieldOffset32(0x10, AnmImage, entry);
ValidateFieldOffset32(0x14, AnmImage, flags);
ValidateStructSize32(0x18, AnmImage);
#pragma endregion

// size: 0x44
struct AnmSprite {
    unknown_fields(0x8); // 0x0
    int32_t __index_8; // 0x8
    unknown_fields(0x10); // 0xC
    float __float_1C; // 0x1C
    float __float_20; // 0x20
    float __uv_related_24[4]; // 0x24
    float __size_y; // 0x34
    float __size_x; // 0x38
    float __float_3C; // 0x3C
    float __float_40; // 0x40
    // 0x44
};
#pragma region // AnmSprite Validation
ValidateFieldOffset32(0x8, AnmSprite, __index_8);
ValidateFieldOffset32(0x1C, AnmSprite, __float_1C);
ValidateFieldOffset32(0x20, AnmSprite, __float_20);
ValidateFieldOffset32(0x24, AnmSprite, __uv_related_24);
ValidateFieldOffset32(0x34, AnmSprite, __size_y);
ValidateFieldOffset32(0x38, AnmSprite, __size_x);
ValidateFieldOffset32(0x3C, AnmSprite, __float_3C);
ValidateFieldOffset32(0x40, AnmSprite, __float_40);
ValidateStructSize32(0x44, AnmSprite);
#pragma endregion

//inline const AnmOnFunc ANM_ON_WAIT_FUNCS[] = { NULL, NULL };
inline const AnmOnFunc ANM_ON_TICK_FUNCS[6] = {
    NULL,
    &AnmVM::on_tick_special_dataA,
    &AnmVM::on_tick_special_dataB,
    &AnmVM::on_tick_special_dataC,
    &AnmVM::on_tick_4,
    &AnmVM::on_tick_special_dataD
};
//inline const AnmOnFunc ANM_ON_DRAW_FUNCS[] = { NULL, NULL };
inline const AnmOnFunc ANM_ON_DESTROY_FUNCS[] = { 
    NULL,
    &AnmVM::on_destroy_special_dataA,
    &AnmVM::on_destroy_special_dataB,
    &AnmVM::on_destroy_special_dataC,
    &AnmVM::on_destroy_special_dataD
};
inline const AnmOnFuncArg ANM_ON_INTERRUPT_FUNCS[] = {
    NULL,
    &AnmVM::on_interrupt_special_dataA,
    &AnmVM::on_interrupt_special_dataB,
    &AnmVM::on_interrupt_special_dataC,
    &AnmVM::on_interrupt_special_dataD
};
inline const AnmOnFunc ANM_ON_COPY_A_FUNCS[] = { NULL, NULL };
inline const AnmOnFunc ANM_ON_COPY_B_FUNCS[] = { NULL, NULL };
//inline const AnmOnFuncArg ANM_ON_SPRITE_LOOKUP_FUNCS[] = { NULL, NULL };

enum AnmListEnd {
    AnmListBack,
    AnmListFront
};

// 0x438D40
dllexport AnmLoaded* stdcall anm_file_lookup(int32_t file_index);

// size: 0x13C
struct AnmLoaded {
    int32_t slot_index; // 0x0
    char anm_path[MAX_PATH]; // 0x4
    void* anm_file; // 0x108
    AnmVM (*__vm_array)[]; // 0x10C
    int32_t entry_count; // 0x110
    int32_t script_count; // 0x114
    int32_t sprite_count; // 0x118
    AnmSprite* sprites; // 0x11C
    AnmInstruction* (*scripts)[]; // 0x120
    AnmImage* images; // 0x124
    int32_t __load_wait; // 0x128
    BOOL __unload_flag; // 0x12C
    int32_t total_image_sizes; // 0x130
    int32_t __counter_134; // 0x134
    void* __ptr_138; // 0x138
    // 0x13C

    inline void zero_contents() {
        zero_this();
    }

    inline AnmLoaded() {
        this->zero_contents();
    }

    inline ~AnmLoaded() {
        this->cleanup();
    }

    inline void cleanup();

    // 0x47D8F0
    dllexport gnu_noinline AnmInstruction* thiscall get_script(int32_t index) asm_symbol_rel(0x47D8F0) {
        return (*this->scripts)[index];
    }

    // 0x477B00
    dllexport gnu_noinline ZUNResult thiscall set_sprite(AnmVM* vm, int32_t sprite_id) asm_symbol_rel(0x477B00) {
        if (!this->anm_file) {
            return ZUN_ERROR;
        }
        vm->data.sprite_id = sprite_id;
        AnmSprite* sprite = &this->sprites[sprite_id];
        vm->data.sprite_uv_quad[2].x = sprite->__uv_related_24[0];
        vm->data.sprite_uv_quad[0].x = sprite->__uv_related_24[0];
        vm->data.sprite_uv_quad[3].x = sprite->__uv_related_24[1];
        vm->data.sprite_uv_quad[1].x = sprite->__uv_related_24[1];
        vm->data.sprite_uv_quad[1].y = sprite->__uv_related_24[2];
        vm->data.sprite_uv_quad[0].y = sprite->__uv_related_24[2];
        vm->data.sprite_uv_quad[3].y = sprite->__uv_related_24[3];
        vm->data.sprite_uv_quad[2].y = sprite->__uv_related_24[3];
        
        float sizeX = sprite->__size_x;
        vm->data.sprite_size.x = sizeX;
        float sizeY = sprite->__size_y;
        vm->data.sprite_size.y = sizeY;

        constexpr float scale_factor = 1.0f / 256.0f;
        vm->data.__matrix_3D4.set_scaled(
            sizeX * scale_factor,
            sizeY * scale_factor
        );
        vm->data.__matrix_454.set_scaled(
            sizeX / sprite->__float_20 * sprite->__float_3C,
            sizeY / sprite->__float_1C * sprite->__float_40
        );
        vm->data.__matrix_414 = vm->data.__matrix_3D4;

        return ZUN_SUCCESS;
    }

    // Definitely exists, found at 0x40CEF0 in DDC
    inline ZUNResult thiscall __set_initial_sprite(AnmVM* vm, int32_t sprite_id) {
        vm->reset();
        vm->data.slot2 = this->slot_index;
        return this->set_sprite(vm, sprite_id);
    }

    inline void __prepare_vm_data(AnmVM* vm, int32_t script_id);

    inline void __prepare_vm(AnmVM* vm, int32_t script_id);

    // 0x477D60
    dllexport void __sub_477D60(AnmVM* vm, int32_t sprite_id) asm_symbol_rel(0x477D60);

    // 0x407420
    dllexport gnu_noinline void __copy_data_to_vm(AnmVM* vm, int32_t index) asm_symbol_rel(0x407420) {
        vm->clear_controller();
        vm->controller.global_list_node.initialize_with(vm);
        vm->controller.child_list_node.initialize_with(vm);
        vm->controller.child_list.initialize_with(vm);
        rep_movsd(&vm->data, &(*this->__vm_array)[index].data, sizeof(AnmVM::AnmVMData) / sizeof(DWORD));
        vm->controller.__timer_1C.reset();
        vm->controller.script_time.reset();
    }

    // 0x41F920
    dllexport gnu_noinline int32_t __copy_data_to_vm_and_run(AnmVM* vm, int32_t index) asm_symbol_rel(0x41F920) {
        this->__copy_data_to_vm(vm, index);
        vm->controller.parent = NULL;
        vm->controller.__root_vm = NULL;
        return vm->run_anm();
    }

private:
    // 0x4894E0
    dllexport gnu_noinline void thiscall __copy_data_to_vm_unknown_A(AnmVM* vm, int32_t index) asm_symbol_rel(0x4894E0) {
        Float3 position = vm->data.position;
        this->__copy_data_to_vm(vm, 7);
        vm->data.position = position;
        vm->controller.__timer_1C.reset();
        vm->controller.script_time.reset();
    }
public:
    inline void __copy_data_to_vm_unknown_A(AnmVM* vm) {
        return this->__copy_data_to_vm_unknown_A(vm, UNUSED_DWORD);
    }

private:
    // 0x488770
    dllexport AnmID& thiscall instantiate_vm(AnmID& out, int32_t script_index, Float3* position, float z_rotation, int32_t layer, AnmVMCreationFlags flags, AnmVM** raw_out) asm_symbol_rel(0x488770);
public:
    inline AnmID instantiate_vm(int32_t script_index, Float3* position, float z_rotation, int32_t layer, AnmVMCreationFlags flags, AnmVM** raw_out) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return this->instantiate_vm(dummy, script_index, position, z_rotation, layer, flags, raw_out);
    }

    inline AnmID instantiate_vm_to_world_list_back(int32_t script_index) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return this->instantiate_vm_to_world_list_back(dummy, script_index, -1, nullptr);
    }

private:
    inline AnmID& thiscall instantiate_vm_to_world_list_back(AnmID& out, int32_t script_index, Float3* position);
public:
    inline AnmID instantiate_vm_to_world_list_back(int32_t script_index, Float3* position) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return this->instantiate_vm_to_world_list_back(dummy, script_index, position);
    }

private:
    inline AnmID& thiscall instantiate_vm_to_world_list_back(AnmID& out, int32_t script_index, int32_t layer);
public:
    inline AnmID instantiate_vm_to_world_list_back(int32_t script_index, int32_t layer) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return this->instantiate_vm_to_world_list_back(dummy, script_index, layer);
    }

private:
    inline AnmID& thiscall instantiate_vm_to_world_list_back(AnmID& out, int32_t script_index, Float3* position, AnmVM** raw_out);
public:
    inline AnmID instantiate_vm_to_world_list_back(int32_t script_index, Float3* position, AnmVM** raw_out) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return this->instantiate_vm_to_world_list_back(dummy, script_index, position, raw_out);
    }

private:
    inline AnmID& thiscall instantiate_vm_to_world_list_back(AnmID& out, int32_t script_index, Float3* position, int32_t layer);
public:
    inline AnmID instantiate_vm_to_world_list_back(int32_t script_index, Float3* position, int32_t layer) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return this->instantiate_vm_to_world_list_back(dummy, script_index, position, layer);
    }

private:
    // 0x405BF0
    dllexport AnmID& thiscall instantiate_vm_to_world_list_back(AnmID& out, int32_t script_index, int32_t layer, AnmVM** raw_out) asm_symbol_rel(0x405BF0);
public:
    inline AnmID instantiate_vm_to_world_list_back(int32_t script_index, int32_t layer, AnmVM** raw_out) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return this->instantiate_vm_to_world_list_back(dummy, script_index, layer, raw_out);
    }

private:
    inline AnmID& thiscall instantiate_vm_to_world_list_back(AnmID& out, int32_t script_index, Float3* position, float z_rotation, int32_t layer);
public:
    inline AnmID instantiate_vm_to_world_list_back(int32_t script_index, Float3* position, float z_rotation, int32_t layer) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return this->instantiate_vm_to_world_list_back(dummy, script_index, position, z_rotation, layer);
    }

private:
    // 0x413180
    dllexport AnmID& thiscall instantiate_vm_to_world_list_back(AnmID& out, int32_t script_index, Float3* position, float z_rotation, int32_t layer, AnmVM** raw_out) asm_symbol_rel(0x413180);
public:
    inline AnmID instantiate_vm_to_world_list_back(int32_t script_index, Float3* position, float z_rotation, int32_t layer, AnmVM** raw_out) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return this->instantiate_vm_to_world_list_back(dummy, script_index, position, z_rotation, layer, raw_out);
    }

private:
    inline AnmID& thiscall instantiate_vm_to_world_list_front(AnmID& out, int32_t script_index);
public:
    inline AnmID instantiate_vm_to_world_list_front(int32_t script_index) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return this->instantiate_vm_to_world_list_front(dummy, script_index);
    }

private:
    inline AnmID& thiscall instantiate_vm_to_world_list_front(AnmID& out, int32_t script_index, Float3* position);
public:
    inline AnmID instantiate_vm_to_world_list_front(int32_t script_index, Float3* position) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return this->instantiate_vm_to_world_list_front(dummy, script_index, position);
    }

private:
    // 0x43A030
    dllexport AnmID& thiscall instantiate_vm_to_world_list_front(AnmID& out, int32_t script_index, int32_t layer, UNUSED_ARG(AnmVMCreationFlags flags)) asm_symbol_rel(0x43A030);
public:
    inline AnmID instantiate_vm_to_world_list_front(int32_t script_index, int32_t layer, AnmVMCreationFlags flags = GARBAGE_ARG(AnmVMCreationFlags)) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return this->instantiate_vm_to_world_list_front(dummy, script_index, layer, flags);
    }

private:
    // 0x43A110
    dllexport AnmID& thiscall instantiate_vm_to_world_list_front(AnmID& out, int32_t script_index, Float3* position, float z_rotation, UNUSED_ARG(int32_t layer), UNUSED_ARG(AnmVMCreationFlags flags)) asm_symbol_rel(0x43A110);
public:
    inline AnmID instantiate_vm_to_world_list_front(int32_t script_index, Float3* position, float z_rotation, int32_t layer = -1, AnmVMCreationFlags flags = {}) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return this->instantiate_vm_to_world_list_front(dummy, script_index, position, z_rotation, layer, flags);
    }

private:
    // 0x416A10
    dllexport AnmID& thiscall instantiate_vm_to_ui_list_back(AnmID& out, int32_t script_index, UNUSED_ARG(AnmVMCreationFlags flags)) asm_symbol_rel(0x416A10);
public:
    inline AnmID instantiate_vm_to_ui_list_back(int32_t script_index) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return this->instantiate_vm_to_ui_list_back(dummy, script_index, GARBAGE_ARG(AnmVMCreationFlags));
    }

private:
    // 0x409670
    dllexport AnmID& thiscall instantiate_vm_to_ui_list_back(AnmID& out, int32_t script_index, Float3* position, UNUSED_ARG(AnmVMCreationFlags flags)) asm_symbol_rel(0x409670);
public:
    inline AnmID instantiate_vm_to_ui_list_back(int32_t script_index, Float3* position) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return this->instantiate_vm_to_ui_list_back(dummy, script_index, position, GARBAGE_ARG(AnmVMCreationFlags));
    }

private:
    // 0x409590
    dllexport AnmID& thiscall instantiate_vm_to_ui_list_front(AnmID& out, int32_t script_index, Float3* position, UNUSED_ARG(AnmVMCreationFlags flags)) asm_symbol_rel(0x409590);
public:
    inline AnmID instantiate_vm_to_ui_list_front(int32_t script_index, Float3* position) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return this->instantiate_vm_to_ui_list_front(dummy, script_index, position, GARBAGE_ARG(AnmVMCreationFlags));
    }

private:
    // 0x4888F0
    dllexport AnmID& thiscall instantiate_child_vm(AnmID& out, int32_t script_index, AnmVM* parent, AnmVMCreationFlags flags) asm_symbol_rel(0x4888F0);
public:
    inline AnmID instantiate_child_vm(int32_t script_index, AnmVM* parent, AnmVMCreationFlags flags) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return this->instantiate_child_vm(dummy, script_index, parent, flags);
    }

private:
    // 0x488A40
    dllexport AnmID& thiscall instantiate_orphan_vm_to_world_list_back(AnmID& out, int32_t script_index, AnmVM* parent, UNUSED_ARG(AnmVMCreationFlags flags)) asm_symbol_rel(0x488A40);
public:
    inline AnmID instantiate_orphan_vm_to_world_list_back(int32_t script_index, AnmVM* parent, AnmVMCreationFlags flags = {}) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return this->instantiate_orphan_vm_to_world_list_back(dummy, script_index, parent, flags);
    }

    // 0x4865B0
    dllexport gnu_noinline ZUNResult thiscall preload(const char* filename) asm_symbol_rel(0x4865B0) {
        char path[MAX_PATH + 1];
        sprintf(path, "%s", filename);
        void* anm_file = read_file_to_buffer(path, NULL, false);
        if (!anm_file) {
            return ZUN_ERROR;
        }
        this->anm_file = anm_file;
        byteloop_strcpy(this->anm_path, filename);
        AnmEntry* current_entry = (AnmEntry*)anm_file;
        int32_t entry_count = 1;
        int32_t total_script_count = current_entry->script_count;
        int32_t total_sprite_count = current_entry->sprite_count;
        while (uint32_t offset_to_next = current_entry->offset_to_next) {
            current_entry = based_pointer(current_entry, offset_to_next);
            ++entry_count;
            total_script_count += current_entry->script_count;
            total_sprite_count += current_entry->sprite_count;
        }
        this->entry_count = entry_count;

        size_t image_array_size = sizeof(AnmImage) * entry_count;
        AnmImage* images = (AnmImage*)malloc(image_array_size);
        this->images = images;
        memset(images, 0, image_array_size);

        this->sprites = (AnmSprite*)malloc(sizeof(AnmSprite[total_sprite_count]));
        this->scripts = (AnmInstruction*(*)[])malloc(sizeof(AnmInstruction*[total_script_count]));
        this->script_count = total_script_count;
        this->sprite_count = total_sprite_count;

        current_entry = (AnmEntry*)anm_file;
        
        for (int32_t entry_index = 0;;) {
            if (expect(!current_entry, false)) {
                LOG_BUFFER.write_error(JpEnStr("", "Can't load animation. data is lost or corrupted\r\n"));
                break;
            }
            if (expect(current_entry->version != 8, false)) {
                LOG_BUFFER.write_error(JpEnStr("", "different version of animation\r\n"));
                break;
            }
            if (!current_entry->has_data) {
                const char* image_filename = based_pointer<const char>(current_entry, current_entry->image_path_offset);
                if (image_filename[0] != '@') {
                    char image_path[MAX_PATH];
                    sprintf(image_path, "%s", image_filename);
                    int32_t image_file_size;
                    void* image_file = read_file_to_buffer(image_path, &image_file_size, true);
                    if (expect(!image_file, false)) {
                        LOG_BUFFER.write_error(JpEnStr("", "Unable to load texture %s. data is lost or corrupted\r\n"), image_filename);
                        break;
                    }
                    this->images[entry_index].file_size = image_file_size;
                    this->images[entry_index].file = image_file;
                }
            }
            ++entry_index;
            size_t offset_to_next = current_entry->offset_to_next;
            if (expect(!offset_to_next, false)) {
                size_t vm_array_size = sizeof(AnmVM) * total_script_count;
                auto vm_array = (AnmVM(*)[])malloc(vm_array_size);
                this->__vm_array = vm_array;
                memset(vm_array, 0, vm_array_size);
                break;
            }
            current_entry = based_pointer(current_entry, offset_to_next);
        }
        return ZUN_SUCCESS;
    }
};
#pragma region // AnmLoaded Validation
ValidateFieldOffset32(0x0, AnmLoaded, slot_index);
ValidateFieldOffset32(0x4, AnmLoaded, anm_path);
ValidateFieldOffset32(0x108, AnmLoaded, anm_file);
ValidateFieldOffset32(0x10C, AnmLoaded, __vm_array);
ValidateFieldOffset32(0x110, AnmLoaded, entry_count);
ValidateFieldOffset32(0x114, AnmLoaded, script_count);
ValidateFieldOffset32(0x118, AnmLoaded, sprite_count);
ValidateFieldOffset32(0x11C, AnmLoaded, sprites);
ValidateFieldOffset32(0x120, AnmLoaded, scripts);
ValidateFieldOffset32(0x124, AnmLoaded, images);
ValidateFieldOffset32(0x128, AnmLoaded, __load_wait);
ValidateFieldOffset32(0x12C, AnmLoaded, __unload_flag);
ValidateFieldOffset32(0x130, AnmLoaded, total_image_sizes);
ValidateFieldOffset32(0x134, AnmLoaded, __counter_134);
ValidateFieldOffset32(0x138, AnmLoaded, __ptr_138);
ValidateStructSize32(0x13C, AnmLoaded);
#pragma endregion

enum AnmFileIndex {
    TEXT_ANM_INDEX = 0,
    SIG_ANM_INDEX = 1,
    ASCII_ANM_INDEX = 2,
    STAGE_ANM_INDEX_A = 3,
    STAGE_ANM_INDEX_B = 4,
    FRONT_ANM_INDEX = 5,
    STAGE_LOGO_ANM_INDEX = 6,
    BULLET_ANM_INDEX = 7,
    EFFECT_ANM_INDEX = 8,
    PLAYER_ANM_INDEX = 9,

    TITLE_ANM_INDEX = 16,
    TITLEV_ANM_INDEX = 17,

    HELP_ANM_INDEX = 19,

    TROPHY_ANM_INDEX = 27,

    ABILITY_ANM_INDEX = 30,
    ABCARD_ANM_INDEX = 31,
    ABMENU_ANM_INDEX = 32,


    ENUM_MAX_VALUE_DECLARE(CmdType)
};

// 0x4B4920
static inline constexpr int D3DFORMAT_SIZES_TABLE[] = {
    4,
    sizeof(PixelA8R8G8B8), // 4
    sizeof(PixelA1R5G5B5), // 2
    sizeof(PixelR5G6B5), // 2
    sizeof(PixelR8G8B8), // 3
    sizeof(PixelA4R4G4B4), // 2
    sizeof(PixelA8R3G3B2), // 2
    sizeof(PixelA8), // 1
    sizeof(PixelR3G3B2) // 1
};

// 0x4B4944
static inline constexpr D3DFORMAT D3DFORMAT_TABLE[] = {
    D3DFMT_UNKNOWN,
    D3DFMT_A8R8G8B8,
    D3DFMT_A1R5G5B5,
    D3DFMT_R5G6B5,
    D3DFMT_R8G8B8,
    D3DFMT_A4R4G4B4,
    D3DFMT_A8R3G3B2,
    D3DFMT_A8,
    D3DFMT_R3G3B2
};

// size: 0x39724B8
struct AnmManager {

#define WORLD_LAYER_A_COUNT 24
#define WORLD_LAYER_B_COUNT 13
#define WORLD_LAYER_COUNT (WORLD_LAYER_A_COUNT + WORLD_LAYER_B_COUNT)
#define UI_LAYER_COUNT 9

    ZUNThreadB __thread_0; // 0x0
    unknown_fields(0x4); // 0x1C
    int32_t __int_20; // 0x20
    unknown_fields(0x24); // 0x24
    int __dword_48; // 0x48
    unknown_fields(0x24); // 0x4C
    int __dword_70; // 0x70
    unknown_fields(0x24); // 0x74
    int __dword_98; // 0x98
    unknown_fields(0x24); // 0x9C
    int __dword_C0; // 0xC0
    int __dword_C4; // 0xC4
    int __dword_C8; // 0xC8
    int __int_CC; // 0xCC
    Float2 __float2_D0; // 0xD0
    Float2 __float2_D8; // 0xD8
    unknown_fields(0x4); // 0xE0
    AnmVM __vm_E4; // 0xE4
    ZUNListEnds<AnmVM> world_list; // 0x6F0
    ZUNListEnds<AnmVM> ui_list; // 0x6F8
    FastAnmVM fast_array[uint_width_max(ANM_FAST_ID_BITS)]; // 0x700
    FastAnmVM fast_array_end; // 0x31200DC
    int32_t next_snapshot_fast_id; // 0x3120700
    int32_t next_snapshot_discriminator; // 0x3120704
    ZUNListHead<AnmVM> snapshot_list_head; // 0x3120708
    ZUNListHead<FastAnmVM> free_list_head; // 0x3120718
    unknown_fields(0x4); // 0x3120728
    AnmLoaded* loaded_anm_files[33]; // 0x312072C
    D3DMATRIXZ __matrix_31207B0; // 0x31207B0
    AnmVM __vm_31207F0; // 0x31207F0
    unknown_fields(0x4); // 0x3120DFC
    D3DCOLOR current_texture_blend_color; // 0x3120E00
    int32_t __index_3120E04; // 0x3120E04
    AnmBlendMode current_blend_mode; // 0x3120E08
    char __byte_3120E09; // 0x3120E09
    int8_t __sbyte_3120E0A; // 0x3120E0A
    char __byte_3120E0B; // 0x3120E0B
    char __byte_3120E0C; // 0x3120E0C
    unknown_fields(0x1); // 0x3120E0D
    int8_t current_resample_mode; // 0x3120E0E
    int8_t current_texture_op; // 0x3120E0F
    AnmUVMode current_u_sample_mode; // 0x3120E10
    AnmUVMode current_v_sample_mode; // 0x3120E11
    probably_padding_bytes(0x2); // 0x3120E12
    AnmSprite* __current_sprite; // 0x3120E14
    LPDIRECT3DVERTEXBUFFER9 __d3d_vertex_buffer_3120E18; // 0x3120E18
    UnknownVertexA __vertex_array_3120E1C[4]; // 0x3120E1C
    int32_t unrendered_sprite_count; // 0x3120E6C
    SpriteVertex sprite_vertex_data[0x40000]; // 0x3120E70
    SpriteVertex* sprite_write_cursor; // 0x3820E70
    SpriteVertex* sprite_render_cursor; // 0x3820E74
    int32_t unrendered_primitive_count; // 0x3820E78
    PrimitiveVertex primitive_vertex_data[0x10000]; // 0x3820E7C
    PrimitiveVertex* primitive_write_cursor; // 0x3960E7C
    PrimitiveVertex* primitive_render_cursor; // 0x3960E80
    AnmVM layer_heads[WORLD_LAYER_COUNT + UI_LAYER_COUNT]; // 0x3960E84
    uint32_t prev_slow_id; // 0x39724AC
    D3DCOLOR __color_39724B0; // 0x39724B0
    int __int_39724B4; // 0x39724B4
    // 0x39724B8

    inline void zero_contents() {
        zero_this();
    }

    inline static void set_modulate_op();

    // 0x47E6E0
    dllexport gnu_noinline static void reset_vertex_buffers() asm_symbol_rel(0x47E6E0) {
        AnmManager* anm_manager = ANM_MANAGER_PTR;
        anm_manager->unrendered_sprite_count = 0;
        anm_manager->sprite_write_cursor = anm_manager->sprite_vertex_data;
        anm_manager->sprite_render_cursor = anm_manager->sprite_vertex_data;
        anm_manager->unrendered_primitive_count = 0;
        anm_manager->primitive_write_cursor = anm_manager->primitive_vertex_data;
        anm_manager->primitive_render_cursor = anm_manager->primitive_vertex_data;
    }

    // 0x47E730
    dllexport gnu_noinline void thiscall flush_sprites() asm_symbol_rel(0x47E730) {
        if (this->unrendered_sprite_count) {
            this->set_modulate_op();
            SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
            SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
            SUPERVISOR.d3d_device->SetFVF(SpriteVertex::FVF_TYPE);
            SUPERVISOR.d3d_device->DrawPrimitiveUP(D3DPT_TRIANGLELIST, this->unrendered_sprite_count * 2, this->sprite_render_cursor, sizeof(SpriteVertex));
            this->sprite_render_cursor = this->sprite_write_cursor;
            ++this->__int_CC;
            this->unrendered_sprite_count = 0;
        }
    }

    // 0x471120
    dllexport gnu_noinline static void __release_render_targets() asm_symbol_rel(0x471120) {
        AnmLoaded** anm_loaded_ptr = ANM_MANAGER_PTR->loaded_anm_files;
        for (
            size_t i = 0;
            i < countof(ANM_MANAGER_PTR->loaded_anm_files);
            ++i, ++anm_loaded_ptr
        ) {
            if (AnmLoaded* anm_loaded = *anm_loaded_ptr) {
                for (int32_t j = 0; j < anm_loaded->entry_count; ++j) {
                    AnmImage* image = &anm_loaded->images[j];
                    if (image->__unknown_flag_A) {
                        SAFE_RELEASE(image->d3d_texture);
                    }
                }
            }
        }
    }

    // 0x4711B0
    dllexport gnu_noinline static void __create_render_targets() asm_symbol_rel(0x4711B0) {
        AnmLoaded** anm_loaded_ptr = ANM_MANAGER_PTR->loaded_anm_files;
        for (
            size_t i = 0;
            i < countof(ANM_MANAGER_PTR->loaded_anm_files);
            ++i, ++anm_loaded_ptr
        ) {
            if (AnmLoaded* anm_loaded = *anm_loaded_ptr) {
                for (int32_t j = 0; j < anm_loaded->entry_count; ++j) {
                    AnmImage* image = &anm_loaded->images[j];
                    if (image->__unknown_flag_A) {
                        image->create_render_target_texture();
                    }
                }
            }
        }
    }

    // 0x485110
    dllexport gnu_noinline static void __sub_485110() asm_symbol_rel(0x485110) {
        AnmManager* anm_manager = ANM_MANAGER_PTR;

        anm_manager->__vertex_array_3120E1C[0].position = { -128.0f, -128.0f, 0.0f };
        anm_manager->__vertex_array_3120E1C[0].texture_uv = { 0.0f, 0.0f };
        anm_manager->__vertex_array_3120E1C[1].position = { 128.0f, -128.0f, 0.0f };
        anm_manager->__vertex_array_3120E1C[1].texture_uv = { 1.0f, 0.0f };
        anm_manager->__vertex_array_3120E1C[2].position = { -128.0f, 128.0f, 0.0f };
        anm_manager->__vertex_array_3120E1C[2].texture_uv = { 0.0f, 1.0f };
        anm_manager->__vertex_array_3120E1C[3].position = { 128.0f, 128.0f, 0.0f };
        anm_manager->__vertex_array_3120E1C[3].texture_uv = { 1.0f, 1.0f };

        SPRITE_VERTEX_BUFFER_C[0].position = anm_manager->__vertex_array_3120E1C[0].position;
        SPRITE_VERTEX_BUFFER_C[1].position = anm_manager->__vertex_array_3120E1C[1].position;
        SPRITE_VERTEX_BUFFER_C[2].position = anm_manager->__vertex_array_3120E1C[2].position;
        SPRITE_VERTEX_BUFFER_C[3].position = anm_manager->__vertex_array_3120E1C[3].position;

        SPRITE_VERTEX_BUFFER_C[0].texture_uv = anm_manager->__vertex_array_3120E1C[0].texture_uv;
        SPRITE_VERTEX_BUFFER_C[1].texture_uv = anm_manager->__vertex_array_3120E1C[1].texture_uv;
        SPRITE_VERTEX_BUFFER_C[2].texture_uv = anm_manager->__vertex_array_3120E1C[2].texture_uv;
        SPRITE_VERTEX_BUFFER_C[3].texture_uv = anm_manager->__vertex_array_3120E1C[3].texture_uv;

        SUPERVISOR.d3d_device->CreateVertexBuffer(UnknownVertexA::buffer_size(36), 0, UnknownVertexA::FVF_TYPE, D3DPOOL_MANAGED, &anm_manager->__d3d_vertex_buffer_3120E18, NULL);

        UnknownVertexA* vertices;
        anm_manager->__d3d_vertex_buffer_3120E18->Lock(0, 0, (void**)&vertices, 0);

        memcpy(&vertices[0], anm_manager->__vertex_array_3120E1C, sizeof(UnknownVertexA[4])); // 0x000

        anm_manager->__vertex_array_3120E1C[0].position.y += 128.0f;
        anm_manager->__vertex_array_3120E1C[1].position.y += 128.0f;
        anm_manager->__vertex_array_3120E1C[2].position.y += 128.0f;
        anm_manager->__vertex_array_3120E1C[3].position.y += 128.0f;

        memcpy(&vertices[12], anm_manager->__vertex_array_3120E1C, sizeof(UnknownVertexA[4])); // 0x0F0

        anm_manager->__vertex_array_3120E1C[0].position.y -= 256.0f;
        anm_manager->__vertex_array_3120E1C[1].position.y -= 256.0f;
        anm_manager->__vertex_array_3120E1C[2].position.y -= 256.0f;
        anm_manager->__vertex_array_3120E1C[3].position.y -= 256.0f;

        memcpy(&vertices[24], anm_manager->__vertex_array_3120E1C, sizeof(UnknownVertexA[4])); // 0x1E0

        anm_manager->__vertex_array_3120E1C[0].position.x += 128.0f;
        anm_manager->__vertex_array_3120E1C[1].position.x += 128.0f;
        anm_manager->__vertex_array_3120E1C[2].position.x += 128.0f;
        anm_manager->__vertex_array_3120E1C[3].position.x += 128.0f;
        anm_manager->__vertex_array_3120E1C[0].position.y += 128.0f;
        anm_manager->__vertex_array_3120E1C[1].position.y += 128.0f;
        anm_manager->__vertex_array_3120E1C[2].position.y += 128.0f;
        anm_manager->__vertex_array_3120E1C[3].position.y += 128.0f;

        memcpy(&vertices[4], anm_manager->__vertex_array_3120E1C, sizeof(UnknownVertexA[4])); // 0x050

        anm_manager->__vertex_array_3120E1C[0].position.y += 128.0f;
        anm_manager->__vertex_array_3120E1C[1].position.y += 128.0f;
        anm_manager->__vertex_array_3120E1C[2].position.y += 128.0f;
        anm_manager->__vertex_array_3120E1C[3].position.y += 128.0f;

        memcpy(&vertices[16], anm_manager->__vertex_array_3120E1C, sizeof(UnknownVertexA[4])); // 0x140

        anm_manager->__vertex_array_3120E1C[0].position.y -= 256.0f;
        anm_manager->__vertex_array_3120E1C[1].position.y -= 256.0f;
        anm_manager->__vertex_array_3120E1C[2].position.y -= 256.0f;
        anm_manager->__vertex_array_3120E1C[3].position.y -= 256.0f;

        memcpy(&vertices[28], anm_manager->__vertex_array_3120E1C, sizeof(UnknownVertexA[4])); // 0x230

        anm_manager->__vertex_array_3120E1C[0].position.x -= 256.0f;
        anm_manager->__vertex_array_3120E1C[1].position.x -= 256.0f;
        anm_manager->__vertex_array_3120E1C[2].position.x -= 256.0f;
        anm_manager->__vertex_array_3120E1C[3].position.x -= 256.0f;
        anm_manager->__vertex_array_3120E1C[0].position.y += 128.0f;
        anm_manager->__vertex_array_3120E1C[1].position.y += 128.0f;
        anm_manager->__vertex_array_3120E1C[2].position.y += 128.0f;
        anm_manager->__vertex_array_3120E1C[3].position.y += 128.0f;

        memcpy(&vertices[8], anm_manager->__vertex_array_3120E1C, sizeof(UnknownVertexA[4])); // 0x0A0

        anm_manager->__vertex_array_3120E1C[0].position.y += 128.0f;
        anm_manager->__vertex_array_3120E1C[1].position.y += 128.0f;
        anm_manager->__vertex_array_3120E1C[2].position.y += 128.0f;
        anm_manager->__vertex_array_3120E1C[3].position.y += 128.0f;

        memcpy(&vertices[20], anm_manager->__vertex_array_3120E1C, sizeof(UnknownVertexA[4])); // 0x190

        anm_manager->__vertex_array_3120E1C[0].position.y -= 256.0f;
        anm_manager->__vertex_array_3120E1C[1].position.y -= 256.0f;
        anm_manager->__vertex_array_3120E1C[2].position.y -= 256.0f;
        anm_manager->__vertex_array_3120E1C[3].position.y -= 256.0f;

        memcpy(&vertices[32], anm_manager->__vertex_array_3120E1C, sizeof(UnknownVertexA[4])); // 0x280

        anm_manager->__d3d_vertex_buffer_3120E18->Unlock();

        SUPERVISOR.d3d_device->SetStreamSource(0, anm_manager->__d3d_vertex_buffer_3120E18, 0, sizeof(UnknownVertexA));
    }

    // 0x47D910
    dllexport gnu_noinline void thiscall setup_render_state_for_vm(AnmVM* vm) asm_symbol_rel(0x47D910) {
        if (this->current_blend_mode != vm->data.blend_mode) {
            this->flush_sprites();
            this->current_blend_mode = (AnmBlendMode)vm->data.blend_mode;

            // Set default states
            SUPERVISOR.d3d_device->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
            SUPERVISOR.d3d_device->SetRenderState(D3DRS_SEPARATEALPHABLENDENABLE, TRUE);
            SUPERVISOR.d3d_device->SetRenderState(D3DRS_SRCBLENDALPHA, D3DBLEND_ONE);
            SUPERVISOR.d3d_device->SetRenderState(D3DRS_DESTBLENDALPHA, D3DBLEND_ZERO);
            SUPERVISOR.d3d_device->SetRenderState(D3DRS_BLENDOPALPHA, D3DBLENDOP_ADD);

            switch (this->current_blend_mode) {
                case 0:
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
                    break;
                case 1:
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
                    break;
                case 2:
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_REVSUBTRACT);
                    break;
                case 3:
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
                    break;
                case 4:
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_INVDESTCOLOR);
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCCOLOR);
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
                    break;
                case 6: // why are 5 and 6 swapped?
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_INVSRCCOLOR);
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
                    break;
                case 5:
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_DESTCOLOR);
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
                    break;
                case 7:
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_DESTALPHA);
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVDESTALPHA);
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
                    break;
                case 8:
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_MIN);
                    break;
                case 9:
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
                    SUPERVISOR.d3d_device->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_MAX);
                    break;
            }
        }

        if (this->current_resample_mode != vm->data.resample_mode) {
            this->flush_sprites();
            this->current_resample_mode = vm->data.resample_mode;
            if (!this->current_resample_mode) {
                SUPERVISOR.d3d_device->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
                SUPERVISOR.d3d_device->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
            } else {
                SUPERVISOR.d3d_device->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_POINT);
                SUPERVISOR.d3d_device->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_POINT);
            }
        }

        if (this->current_u_sample_mode != vm->data.u_scroll_mode) {
            this->flush_sprites();
            this->current_u_sample_mode = (AnmUVMode)vm->data.u_scroll_mode;
            switch (this->current_u_sample_mode) {
                case Wrap: // 0
                    SUPERVISOR.d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);
                    break;
                case Clamp: // 1
                    SUPERVISOR.d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
                    break;
                case Mirror: // 2
                    SUPERVISOR.d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_MIRROR);
                    break;
            }
        }

        if (this->current_v_sample_mode != vm->data.v_scroll_mode) {
            this->flush_sprites();
            this->current_v_sample_mode = (AnmUVMode)vm->data.v_scroll_mode;
            switch (this->current_v_sample_mode) {
                case Wrap: // 0
                    SUPERVISOR.d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);
                    break;
                case Clamp: // 1
                    SUPERVISOR.d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);
                    break;
                case Mirror: // 2
                    SUPERVISOR.d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_MIRROR);
                    break;
            }
        }
    }

    // 0x47FEB0
    dllexport gnu_noinline ZUNResult thiscall __draw_vm_type_5_7(AnmVM* vm) asm_symbol_rel(0x47FEB0) {
        if (!vm->data.__unknown_std_flag_A) {
            vm->data.scale_enabled = false;
            vm->data.__matrix_414 = vm->data.__matrix_3D4;
            vm->data.__matrix_414.m[0][0] *= vm->data.scale.x * vm->data.scale2.x;
            vm->data.__matrix_414.m[1][1] *= vm->data.scale.y * vm->data.scale2.y;

            Float3 rotation = *vm->get_controller_rotation();

            vm->data.__matrix_414.rotate_x(rotation.x);
            vm->data.__matrix_414.rotate_y(rotation.y);
            vm->data.__matrix_414.rotate_z(rotation.z);

            vm->data.rotation_enabled = false;
        }

        D3DMATRIXZ matrix = vm->data.__matrix_414;
        matrix.m[0][0] += vm->data.position.x + vm->controller.position.x + vm->data.__position_2.x;
        if (
            vm->data.origin_mode != 0 &&
            !vm->controller.parent
        ) {
            matrix.m[0][0] += WINDOW_DATA.__scaled_width * 0.5f;
            matrix.m[0][1] += (WINDOW_DATA.__scaled_height - 448.0f) * 0.5f;
        }
        matrix.m[0][1] += vm->data.position.y + vm->controller.position.y + vm->data.__position_2.y;
        matrix.m[0][2] += vm->data.position.z + vm->controller.position.z + vm->data.__position_2.z;

        AnmVM* parent = vm->controller.parent;
        if (
            !parent &&
            !vm->data.__treat_as_root
        ) {
            matrix.m[0][0] += parent->data.position.x + parent->controller.position.x + parent->data.__position_2.x;
            matrix.m[0][1] += parent->data.position.y + parent->controller.position.y + parent->data.__position_2.y;
            matrix.m[0][2] += parent->data.position.z + parent->controller.position.z + parent->data.__position_2.z;
        }

        this->__matrix_31207B0 = matrix;

        return ZUN_SUCCESS;
    }

    // 0x47E800
    dllexport gnu_noinline int32_t thiscall write_sprite(SpriteVertex* vertices) asm_symbol_rel(0x47E800) {
        SpriteVertex* sprite_write_cursor = this->sprite_write_cursor;
        
        // 6 because 2 triangles
        if (sprite_write_cursor + 6 >= array_end_addr(this->sprite_vertex_data)) {
            return 1;
        }

        sprite_write_cursor[0] = vertices[0];
        sprite_write_cursor[1] = vertices[1];
        sprite_write_cursor[2] = vertices[2];

        sprite_write_cursor[3] = vertices[1];
        sprite_write_cursor[4] = vertices[2];
        sprite_write_cursor[5] = vertices[3];

        this->sprite_write_cursor += 6;

        ++this->unrendered_sprite_count;

        return 0;
    }

#if INCLUDE_PATCH_CODE
    dllexport gnu_noinline int32_t thiscall write_rainbow_sprite(SpriteVertex* vertices) {
        SpriteVertex* sprite_write_cursor = this->sprite_write_cursor;

        // 6 because 2 triangles
        if (sprite_write_cursor + 6 >= array_end_addr(this->sprite_vertex_data)) {
            return 1;
        }
        rand_s((unsigned int*)&sprite_write_cursor[0].diffuse);
        rand_s((unsigned int*)&sprite_write_cursor[1].diffuse);
        rand_s((unsigned int*)&sprite_write_cursor[2].diffuse);
        rand_s((unsigned int*)&sprite_write_cursor[5].diffuse);
        
        ALPHA(sprite_write_cursor[0].diffuse) = ALPHA(vertices[0].diffuse);
        ALPHA(sprite_write_cursor[1].diffuse) = ALPHA(vertices[1].diffuse);
        ALPHA(sprite_write_cursor[2].diffuse) = ALPHA(vertices[2].diffuse);
        ALPHA(sprite_write_cursor[5].diffuse) = ALPHA(vertices[3].diffuse);

        sprite_write_cursor[0].position = vertices[0].position;
        sprite_write_cursor[0].texture_uv = vertices[0].texture_uv;
        sprite_write_cursor[1].position = vertices[1].position;
        sprite_write_cursor[1].texture_uv = vertices[1].texture_uv;
        sprite_write_cursor[2].position = vertices[2].position;
        sprite_write_cursor[2].texture_uv = vertices[2].texture_uv;

        sprite_write_cursor[3].position = vertices[1].position;
        sprite_write_cursor[3].texture_uv = vertices[1].texture_uv;
        sprite_write_cursor[3].diffuse = sprite_write_cursor[1].diffuse;
        sprite_write_cursor[4].position = vertices[2].position;
        sprite_write_cursor[4].texture_uv = vertices[2].texture_uv;
        sprite_write_cursor[4].diffuse = sprite_write_cursor[2].diffuse;
        sprite_write_cursor[5].position = vertices[3].position;
        sprite_write_cursor[5].texture_uv = vertices[3].texture_uv;
        

        this->sprite_write_cursor += 6;

        ++this->unrendered_sprite_count;

        return 0;
    }
#endif

#define RENDER_VERTICES_DEFAULT 0
#define RENDER_VERTICES_ROUND_INPUTS 0x01
#define RENDER_VERTICES_IGNORE_COLORS 0x02

    // 0x47DCE0
    dllexport gnu_noinline ZUNResult thiscall __render_vertices(AnmVM* vm, uint32_t flags) asm_symbol_rel(0x47DCE0) {
        SPRITE_VERTEX_BUFFER_A[0].position.as2() += this->__float2_D0;
        SPRITE_VERTEX_BUFFER_A[1].position.as2() += this->__float2_D0;
        SPRITE_VERTEX_BUFFER_A[2].position.as2() += this->__float2_D0;
        SPRITE_VERTEX_BUFFER_A[3].position.as2() += this->__float2_D0;
        SPRITE_VERTEX_BUFFER_A[0].position.as2() += this->__float2_D8;
        SPRITE_VERTEX_BUFFER_A[1].position.as2() += this->__float2_D8;
        SPRITE_VERTEX_BUFFER_A[2].position.as2() += this->__float2_D8;
        SPRITE_VERTEX_BUFFER_A[3].position.as2() += this->__float2_D8;
        if (flags & RENDER_VERTICES_ROUND_INPUTS) {
            long double A = CRT::rint_asm(SPRITE_VERTEX_BUFFER_A[0].position.x) - 0.5f;
            long double B = CRT::rint_asm(SPRITE_VERTEX_BUFFER_A[1].position.x) - 0.5f;
            long double C = CRT::rint_asm(SPRITE_VERTEX_BUFFER_A[0].position.y) - 0.5f;
            long double D = CRT::rint_asm(SPRITE_VERTEX_BUFFER_A[2].position.y) - 0.5f;
            SPRITE_VERTEX_BUFFER_A[2].position.y = D;
            SPRITE_VERTEX_BUFFER_A[3].position.y = D;
            SPRITE_VERTEX_BUFFER_A[0].position.y = C;
            SPRITE_VERTEX_BUFFER_A[1].position.y = C;
            SPRITE_VERTEX_BUFFER_A[1].position.x = B;
            SPRITE_VERTEX_BUFFER_A[3].position.x = B;
            SPRITE_VERTEX_BUFFER_A[0].position.x = A;
            SPRITE_VERTEX_BUFFER_A[2].position.x = A;
        }
        vm->data.__render_quad[0] = SPRITE_VERTEX_BUFFER_A[0].position.as3();
        vm->data.__render_quad[1] = SPRITE_VERTEX_BUFFER_A[1].position.as3();
        vm->data.__render_quad[2] = SPRITE_VERTEX_BUFFER_A[2].position.as3();
        vm->data.__render_quad[3] = SPRITE_VERTEX_BUFFER_A[3].position.as3();

        SPRITE_VERTEX_BUFFER_A[0].texture_uv.x = vm->data.sprite_uv_quad[0].x + vm->data.uv_scroll.x;
        SPRITE_VERTEX_BUFFER_A[0].texture_uv.y = vm->data.sprite_uv_quad[0].y + vm->data.uv_scroll.y;
        SPRITE_VERTEX_BUFFER_A[1].texture_uv.x = vm->data.sprite_uv_quad[0].x + vm->data.uv_scroll.x + (vm->data.sprite_uv_quad[1].x - vm->data.sprite_uv_quad[0].x) * vm->data.uv_scale.x;
        SPRITE_VERTEX_BUFFER_A[1].texture_uv.y = vm->data.sprite_uv_quad[1].y + vm->data.uv_scroll.y;
        SPRITE_VERTEX_BUFFER_A[2].texture_uv.x = vm->data.sprite_uv_quad[2].x + vm->data.uv_scroll.x;
        SPRITE_VERTEX_BUFFER_A[2].texture_uv.y = vm->data.sprite_uv_quad[0].y + vm->data.uv_scroll.y + (vm->data.sprite_uv_quad[2].y - vm->data.sprite_uv_quad[0].y) * vm->data.uv_scale.y;
        SPRITE_VERTEX_BUFFER_A[3].texture_uv.x = vm->data.sprite_uv_quad[2].x + vm->data.uv_scroll.x + (vm->data.sprite_uv_quad[3].x - vm->data.sprite_uv_quad[2].x) * vm->data.uv_scale.x;
        SPRITE_VERTEX_BUFFER_A[3].texture_uv.y = vm->data.sprite_uv_quad[1].y + vm->data.uv_scroll.y + (vm->data.sprite_uv_quad[3].y - vm->data.sprite_uv_quad[1].y) * vm->data.uv_scale.y;

        StageCamera* camera = SUPERVISOR.current_camera_ptr;

        float max_x = __max(__max(__max(SPRITE_VERTEX_BUFFER_A[0].position.x, SPRITE_VERTEX_BUFFER_A[1].position.x), SPRITE_VERTEX_BUFFER_A[2].position.x), SPRITE_VERTEX_BUFFER_A[3].position.x);
        if (
            !(max_x < camera->__viewport_10C.X)
        ) {
            float max_y = __max(__max(__max(SPRITE_VERTEX_BUFFER_A[0].position.y, SPRITE_VERTEX_BUFFER_A[1].position.y), SPRITE_VERTEX_BUFFER_A[2].position.y), SPRITE_VERTEX_BUFFER_A[3].position.y);
            if (
                !(max_y < camera->__viewport_10C.Y)
            ) {
                float min_x = __min(__min(__min(SPRITE_VERTEX_BUFFER_A[0].position.x, SPRITE_VERTEX_BUFFER_A[1].position.x), SPRITE_VERTEX_BUFFER_A[2].position.x), SPRITE_VERTEX_BUFFER_A[3].position.x);
                if (
                    !(min_x > (camera->__viewport_10C.X + camera->__viewport_10C.Width))
                ) {
                    float min_y = __min(__min(__min(SPRITE_VERTEX_BUFFER_A[0].position.y, SPRITE_VERTEX_BUFFER_A[1].position.y), SPRITE_VERTEX_BUFFER_A[2].position.y), SPRITE_VERTEX_BUFFER_A[3].position.y);
                    if (
                        !(min_y > (camera->__viewport_10C.Y + camera->__viewport_10C.Height))
                    ) {

                        int32_t sprite_index = ANM_MANAGER_PTR->loaded_anm_files[vm->data.slot2]->sprites[vm->data.sprite_id].__index_8;
                        if (this->__index_3120E04 != sprite_index) {
                            this->__index_3120E04 = sprite_index;
                            this->flush_sprites();
                            sprite_index = this->__index_3120E04;
                            SUPERVISOR.d3d_device->SetTexture(0, this->loaded_anm_files[sprite_index >> 8]->images[(uint8_t)sprite_index].d3d_texture);
                        }

                        if (!this->__sbyte_3120E0A) {
                            this->flush_sprites();
                            this->__sbyte_3120E0A = 1;
                        }

                        if (!(flags & RENDER_VERTICES_IGNORE_COLORS)) {
                            uint32_t color_mode = vm->data.color_mode;
                            switch (color_mode) {
                                case 0: case 1: {
                                    uint8_t r, g, b, a;
                                    D3DCOLOR color = color_mode == 0 ? vm->data.color1 : vm->data.color2;
                                    if (
                                        vm->data.colorize_children &&
                                        vm->controller.parent
                                    ) {
                                        D3DCOLOR parent_color = vm->controller.parent->data.mixed_inherited_color;
                                        r = std::max(RED(color) * RED(parent_color) >> 7, 0xFF);
                                        g = std::max(GREEN(color) * GREEN(parent_color) >> 7, 0xFF);
                                        b = std::max(BLUE(color) * BLUE(parent_color) >> 7, 0xFF);
                                        a = std::max(ALPHA(color) * ALPHA(parent_color) >> 7, 0xFF);
                                        color = PackD3DCOLOR(a, r, g, b);
                                    } else {
                                        a = ALPHA(color);
                                        r = RED(color);
                                        g = GREEN(color);
                                        b = BLUE(color);
                                    }
                                    vm->data.mixed_inherited_color = color;
                                    if (this->__int_39724B4) {
                                        r = std::max(r * RED(this->__color_39724B0) >> 7, 0xFF);
                                        g = std::max(g * GREEN(this->__color_39724B0) >> 7, 0xFF);
                                        b = std::max(b * BLUE(this->__color_39724B0) >> 7, 0xFF);
                                        a = std::max(a * ALPHA(this->__color_39724B0) >> 7, 0xFF);
                                        color = PackD3DCOLOR(a, r, g, b);
                                    }
                                    SPRITE_VERTEX_BUFFER_A[0].diffuse = color;
                                    SPRITE_VERTEX_BUFFER_A[1].diffuse = color;
                                    SPRITE_VERTEX_BUFFER_A[3].diffuse = color;
                                    SPRITE_VERTEX_BUFFER_A[2].diffuse = color;
                                    break;
                                }
                                case 2: case 3: {
                                    uint8_t r1, g1, b1, a1;
                                    uint8_t r2, g2, b2, a2;
                                    D3DCOLOR color1 = vm->data.color1;
                                    D3DCOLOR color2 = vm->data.color2;
                                    if (this->__int_39724B4) {
                                        r1 = std::max(RED(color1) * RED(this->__color_39724B0) >> 7, 0xFF);
                                        g1 = std::max(GREEN(color1) * GREEN(this->__color_39724B0) >> 7, 0xFF);
                                        b1 = std::max(BLUE(color1) * BLUE(this->__color_39724B0) >> 7, 0xFF);
                                        a1 = std::max(ALPHA(color1) * ALPHA(this->__color_39724B0) >> 7, 0xFF);
                                        r2 = std::max(RED(color2) * RED(this->__color_39724B0) >> 7, 0xFF);
                                        g2 = std::max(GREEN(color2) * GREEN(this->__color_39724B0) >> 7, 0xFF);
                                        b2 = std::max(BLUE(color2) * BLUE(this->__color_39724B0) >> 7, 0xFF);
                                        a2 = std::max(ALPHA(color2) * ALPHA(this->__color_39724B0) >> 7, 0xFF);
                                        color1 = PackD3DCOLOR(a1, r1, g1, b1);
                                        color2 = PackD3DCOLOR(a2, r2, g2, b2);
                                    }
                                    SPRITE_VERTEX_BUFFER_A[0].diffuse = color1;
                                    SPRITE_VERTEX_BUFFER_A[3].diffuse = color2;
                                    if (color_mode == 2) {
                                        SPRITE_VERTEX_BUFFER_A[1].diffuse = color2;
                                        SPRITE_VERTEX_BUFFER_A[2].diffuse = color1;
                                    } else {
                                        SPRITE_VERTEX_BUFFER_A[1].diffuse = color1;
                                        SPRITE_VERTEX_BUFFER_A[2].diffuse = color2;
                                    }
                                    break;
                                }
                                case 4: {
                                    uint8_t r, g, b, a;
                                    D3DCOLOR color = vm->data.color1;
                                    r = RED(color) * RED(vm->data.color2) / 0xFF;
                                    g = GREEN(color) * GREEN(vm->data.color2) / 0xFF;
                                    b = BLUE(color) * BLUE(vm->data.color2) / 0xFF;
                                    a = ALPHA(color) * ALPHA(vm->data.color2) / 0xFF;
                                    if (
                                        vm->data.colorize_children &&
                                        vm->controller.parent
                                    ) {
                                        D3DCOLOR parent_color = vm->controller.parent->data.mixed_inherited_color;
                                        r = std::max(r * RED(parent_color) >> 7, 0xFF);
                                        g = std::max(g * GREEN(parent_color) >> 7, 0xFF);
                                        parent_color = vm->controller.parent->data.mixed_inherited_color; // why tho
                                        b = std::max(b * BLUE(parent_color) >> 7, 0xFF);
                                        a = std::max(a * ALPHA(parent_color) >> 7, 0xFF);
                                    }
                                    color = PackD3DCOLOR(a, r, g, b);
                                    vm->data.mixed_inherited_color = color;
                                    if (this->__int_39724B4) {
                                        r = std::max(r * RED(this->__color_39724B0) >> 7, 0xFF);
                                        g = std::max(g * GREEN(this->__color_39724B0) >> 7, 0xFF);
                                        b = std::max(b * BLUE(this->__color_39724B0) >> 7, 0xFF);
                                        a = std::max(a * ALPHA(this->__color_39724B0) >> 7, 0xFF);
                                        color = PackD3DCOLOR(a, r, g, b);
                                    }
                                    SPRITE_VERTEX_BUFFER_A[0].diffuse = color;
                                    SPRITE_VERTEX_BUFFER_A[1].diffuse = color;
                                    SPRITE_VERTEX_BUFFER_A[3].diffuse = color;
                                    SPRITE_VERTEX_BUFFER_A[2].diffuse = color;
                                    break;
                                }
                                case 5: case 6: case 7: // no, these don't just use default. It's actually empty cases
                                    break;
                            }
                        }

                        this->setup_render_state_for_vm(vm);
                        this->write_sprite(SPRITE_VERTEX_BUFFER_A);
                    }
                }
            }
        }
        return ZUN_SUCCESS;
    }

    // 0x47F530
    dllexport gnu_noinline ZUNResult thiscall __sub_47F530(AnmVM* vm) asm_symbol_rel(0x47F530) {
        if (ZUN_SUCCEEDED(vm->__sub_47F090())) {

            Float3 position = vm->data.position + vm->controller.position + vm->data.__position_2;

            StageCamera* camera = SUPERVISOR.current_camera_ptr;

            position.as2() -= camera->position.as2();

            float draw_begin = camera->sky.begin_distance;
            float draw_distance = draw_begin - camera->sky.end_distance;

            if (
                vm->data.origin_mode != 0 &&
                !vm->controller.parent
            ) {
                position.x += WINDOW_DATA.__scaled_width * 0.5f;
                position.y += (WINDOW_DATA.__scaled_height - 448.0f) * 0.5f;
            }

            float length = position.length();

            int32_t color_mode = vm->data.color_mode;
            switch (color_mode) {
                case 0: case 1: {
                    uint8_t r, g, b, a;
                    D3DCOLOR color = color_mode == 0 ? vm->data.color1 : vm->data.color2;
                    r = RED(color);
                    g = GREEN(color);
                    b = BLUE(color);
                    a = ALPHA(color);
                    if (this->__int_39724B4) {
                        r = std::max(r * RED(this->__color_39724B0) >> 7, 0xFF);
                        g = std::max(g * GREEN(this->__color_39724B0) >> 7, 0xFF);
                        b = std::max(b * BLUE(this->__color_39724B0) >> 7, 0xFF);
                        a = std::max(a * ALPHA(this->__color_39724B0) >> 7, 0xFF);
                        color = PackD3DCOLOR(a, r, g, b);
                    }
                    if (length < draw_begin) {
                        float E = (draw_begin - length) / draw_distance;
                        if (E >= 1.0f) {
                            return ZUN_ERROR;
                        }
                        BLUE(SPRITE_VERTEX_BUFFER_A[0].diffuse) = b - (int32_t)((b - (int32_t)camera->sky.color_components.b) * E);
                        GREEN(SPRITE_VERTEX_BUFFER_A[0].diffuse) = g - (int32_t)((g - (int32_t)camera->sky.color_components.g) * E);
                        RED(SPRITE_VERTEX_BUFFER_A[0].diffuse) = r - (int32_t)((r - (int32_t)camera->sky.color_components.r) * E);
                        ALPHA(SPRITE_VERTEX_BUFFER_A[0].diffuse) = a * (1.0f - E * E * E);
                        color = SPRITE_VERTEX_BUFFER_A[0].diffuse;
                    } else {
                        SPRITE_VERTEX_BUFFER_A[0].diffuse = color;
                    }
                    if (vm->data.enable_camera_fade) {
                        float F = vm->data.camera_near_clip;
                        if (F >= length) {
                            return ZUN_ERROR;
                        }
                        float G = vm->data.camera_near_fade_end;
                        if (G > length) {
                            ALPHA(SPRITE_VERTEX_BUFFER_A[0].diffuse) = ALPHA(color) * (1.0f - (G - length) / (G - F));
                            color = SPRITE_VERTEX_BUFFER_A[0].diffuse;
                        }
                    }
                    SPRITE_VERTEX_BUFFER_A[3].diffuse = color;
                    SPRITE_VERTEX_BUFFER_A[2].diffuse = color;
                    SPRITE_VERTEX_BUFFER_A[1].diffuse = color;
                    break;
                }
                case 2: case 3: {
                    uint8_t r1, g1, b1, a1;
                    uint8_t r2, g2, b2, a2;
                    D3DCOLOR color1 = vm->data.color1;
                    D3DCOLOR color2 = vm->data.color2;
                    if (this->__int_39724B4) {
                        r1 = std::max(RED(color1) * RED(this->__color_39724B0) >> 7, 0xFF);
                        g1 = std::max(GREEN(color1) * GREEN(this->__color_39724B0) >> 7, 0xFF);
                        b1 = std::max(BLUE(color1) * BLUE(this->__color_39724B0) >> 7, 0xFF);
                        a1 = std::max(ALPHA(color1) * ALPHA(this->__color_39724B0) >> 7, 0xFF);
                        r2 = std::max(RED(color2) * RED(this->__color_39724B0) >> 7, 0xFF);
                        g2 = std::max(GREEN(color2) * GREEN(this->__color_39724B0) >> 7, 0xFF);
                        b2 = std::max(BLUE(color2) * BLUE(this->__color_39724B0) >> 7, 0xFF);
                        a2 = std::max(ALPHA(color2) * ALPHA(this->__color_39724B0) >> 7, 0xFF);
                        color1 = PackD3DCOLOR(a1, r1, g1, b1);
                        color2 = PackD3DCOLOR(a2, r2, g2, b2);
                    }
                    if (length > draw_begin) {
                        float E = (draw_begin - length) / draw_distance;
                        if (E >= 1.0f) {
                            return ZUN_ERROR;
                        }
                        float F = 1.0f - E;
                        BLUE(SPRITE_VERTEX_BUFFER_A[0].diffuse) = b1 - (int32_t)((b1 - (int32_t)camera->sky.color_components.b) * E);
                        GREEN(SPRITE_VERTEX_BUFFER_A[0].diffuse) = g1 - (int32_t)((g1 - (int32_t)camera->sky.color_components.g) * E);
                        RED(SPRITE_VERTEX_BUFFER_A[0].diffuse) = r1 - (int32_t)((r1 - (int32_t)camera->sky.color_components.r) * E);
                        ALPHA(SPRITE_VERTEX_BUFFER_A[0].diffuse) = a1 * F;
                        BLUE(SPRITE_VERTEX_BUFFER_A[3].diffuse) = b2 - (int32_t)((b2 - (int32_t)camera->sky.color_components.b) * E);
                        GREEN(SPRITE_VERTEX_BUFFER_A[3].diffuse) = g2 - (int32_t)((g2 - (int32_t)camera->sky.color_components.g) * E);
                        RED(SPRITE_VERTEX_BUFFER_A[3].diffuse) = r2 - (int32_t)((r2 - (int32_t)camera->sky.color_components.r) * E);
                        ALPHA(SPRITE_VERTEX_BUFFER_A[3].diffuse) = a2 * F;
                        color1 = SPRITE_VERTEX_BUFFER_A[0].diffuse;
                        color2 = SPRITE_VERTEX_BUFFER_A[3].diffuse;
                    }
                    else {
                        SPRITE_VERTEX_BUFFER_A[0].diffuse = color1;
                        SPRITE_VERTEX_BUFFER_A[3].diffuse = color2;
                    }
                    if (vm->data.color_mode == 2) {
                        SPRITE_VERTEX_BUFFER_A[1].diffuse = color2;
                        SPRITE_VERTEX_BUFFER_A[2].diffuse = color1;
                    } else {
                        SPRITE_VERTEX_BUFFER_A[1].diffuse = color1;
                        SPRITE_VERTEX_BUFFER_A[2].diffuse = color2;
                    }
                    break;
                }
                case 4: {
                    uint8_t r, g, b, a;
                    D3DCOLOR color = vm->data.color1;
                    r = RED(color) * RED(vm->data.color2) / 0xFF;
                    g = GREEN(color) * GREEN(vm->data.color2) / 0xFF;
                    b = BLUE(color) * BLUE(vm->data.color2) / 0xFF;
                    a = ALPHA(color) * ALPHA(vm->data.color2) / 0xFF;
                    if (this->__int_39724B4) {
                        r = std::max(r * RED(this->__color_39724B0) >> 7, 0xFF);
                        g = std::max(g * GREEN(this->__color_39724B0) >> 7, 0xFF);
                        b = std::max(b * BLUE(this->__color_39724B0) >> 7, 0xFF);
                        a = std::max(a * ALPHA(this->__color_39724B0) >> 7, 0xFF);
                        color = PackD3DCOLOR(a, r, g, b);
                    }
                    if (length > draw_begin) {
                        float E = (draw_begin - length) / draw_distance;
                        if (E >= 1.0f) {
                            return ZUN_ERROR;
                        }
                        BLUE(SPRITE_VERTEX_BUFFER_A[0].diffuse) = b - (int32_t)((b - (int32_t)camera->sky.color_components.b) * E);
                        GREEN(SPRITE_VERTEX_BUFFER_A[0].diffuse) = g - (int32_t)((g - (int32_t)camera->sky.color_components.g) * E);
                        RED(SPRITE_VERTEX_BUFFER_A[0].diffuse) = r - (int32_t)((r - (int32_t)camera->sky.color_components.r) * E);
                        ALPHA(SPRITE_VERTEX_BUFFER_A[0].diffuse) = a * (1.0f - E * E * E);
                        color = SPRITE_VERTEX_BUFFER_A[0].diffuse;
                    } else {
                        SPRITE_VERTEX_BUFFER_A[0].diffuse = color;
                    }
                    SPRITE_VERTEX_BUFFER_A[3].diffuse = color;
                    SPRITE_VERTEX_BUFFER_A[2].diffuse = color;
                    SPRITE_VERTEX_BUFFER_A[1].diffuse = color;
                    break;
                }
            }
            return this->__render_vertices(vm, RENDER_VERTICES_IGNORE_COLORS);
        }
        return ZUN_ERROR;
    }

    // 0x480160
    dllexport gnu_noinline ZUNResult thiscall __draw_vm_type_8_F(AnmVM* vm) asm_symbol_rel(0x480160) {
        if (
            vm->data.visible &&
            vm->data.__visible2 &&
            vm->get_alpha()
        ) {
            if (this->unrendered_sprite_count) {
                this->flush_sprites();
            }
            if (vm->data.disable_z_write) {
                SUPERVISOR.d3d_disable_zwrite();
            } else {
                SUPERVISOR.d3d_enable_zwrite();
            }
            if (!vm->data.__unknown_std_flag_A) {
                vm->data.scale_enabled = false;
                vm->data.__matrix_414 = vm->data.__matrix_3D4;
                vm->data.__matrix_414.m[0][0] *= vm->data.scale.x * vm->data.scale2.x;
                vm->data.__matrix_414.m[1][1] *= vm->data.scale.y * vm->data.scale2.y;

                switch (vm->data.resolution_mode) {
                    case 1:
                        vm->data.__matrix_414.m[0][0] *= WINDOW_DATA.__game_scale;
                        vm->data.__matrix_414.m[1][1] *= WINDOW_DATA.__game_scale;
                        break;
                    case 2:
                        vm->data.__matrix_414.m[0][0] *= WINDOW_DATA.__game_scale * 0.5f;
                        vm->data.__matrix_414.m[1][1] *= WINDOW_DATA.__game_scale * 0.5f;
                        break;
                }

                Float3 rotation = *vm->get_controller_rotation();

                switch (vm->data.rotation_mode) {
                    case 0:
                        vm->data.__matrix_414.rotate_x(rotation.x);
                        vm->data.__matrix_414.rotate_y(rotation.y);
                        vm->data.__matrix_414.rotate_z(rotation.z);
                        break;
                    case 1:
                        vm->data.__matrix_414.rotate_x(rotation.x);
                        vm->data.__matrix_414.rotate_z(rotation.z);
                        vm->data.__matrix_414.rotate_y(rotation.y);
                        break;
                    case 2:
                        vm->data.__matrix_414.rotate_y(rotation.y);
                        vm->data.__matrix_414.rotate_x(rotation.x);
                        vm->data.__matrix_414.rotate_z(rotation.z);
                        break;
                    case 3:
                        vm->data.__matrix_414.rotate_y(rotation.y);
                        vm->data.__matrix_414.rotate_z(rotation.z);
                        vm->data.__matrix_414.rotate_x(rotation.x);
                        break;
                    case 4:
                        vm->data.__matrix_414.rotate_z(rotation.z);
                        vm->data.__matrix_414.rotate_x(rotation.x);
                        vm->data.__matrix_414.rotate_y(rotation.y);
                        break;
                    case 5:
                        vm->data.__matrix_414.rotate_z(rotation.z);
                        vm->data.__matrix_414.rotate_y(rotation.y);
                        vm->data.__matrix_414.rotate_z(rotation.z);
                        break;
                }
                vm->data.rotation_enabled = false;
            }

            D3DMATRIXZ matrix = vm->data.__matrix_414;

            Float3 position;
            clang_forceinline vm->get_render_position(&position);

            this->setup_render_state_for_vm(vm);

            D3DCOLOR color = vm->data.color_mode == 0 ? vm->data.color1 : vm->data.color2;

            if (this->__int_39724B4) {
                uint8_t r = std::max(RED(color) * RED(this->__color_39724B0) >> 7, 0xFF);
                uint8_t g = std::max(GREEN(color) * GREEN(this->__color_39724B0) >> 7, 0xFF);
                uint8_t b = std::max(BLUE(color) * BLUE(this->__color_39724B0) >> 7, 0xFF);
                uint8_t a = std::max(ALPHA(color) * ALPHA(this->__color_39724B0) >> 7, 0xFF);
                color = PackD3DCOLOR(a, r, g, b);
            }

            if (this->current_texture_blend_color != color) {
                this->flush_sprites();
                this->current_texture_blend_color = color;
                SUPERVISOR.d3d_device->SetRenderState(D3DRS_TEXTUREFACTOR, color);
            }

            matrix.m[3][2] += vm->data.position.z + vm->controller.position.z + vm->data.__position_2.z;
            
            SUPERVISOR.d3d_device->SetTransform(D3DTS_WORLDMATRIX(0), &matrix.D3DX());

            AnmSprite* sprite = &ANM_MANAGER_PTR->loaded_anm_files[vm->data.slot2]->sprites[vm->data.sprite_id];
            int32_t sprite_index = sprite->__index_8;
            if (this->__index_3120E04 != sprite_index) {
                this->__index_3120E04 = sprite_index;
                this->flush_sprites();
                sprite_index = this->__index_3120E04;
                SUPERVISOR.d3d_device->SetTexture(0, this->loaded_anm_files[sprite_index >> 8]->images[(uint8_t)sprite_index].d3d_texture);
            }

            if (
                this->__current_sprite != sprite ||
                vm->data.uv_scroll.x != 0.0f ||
                vm->data.uv_scroll.y != 1.0f ||
                vm->data.uv_scale.y != 1.0f
            ) {
                this->__current_sprite = sprite;

                D3DMATRIXZ temp = vm->data.__matrix_454;
                *(Float2*)&temp.m[2][0] = vm->data.sprite_uv_quad[0] + vm->data.uv_scroll;
                temp.m[0][0] *= vm->data.uv_scale.x;
                temp.m[1][1] *= vm->data.uv_scale.y;
                SUPERVISOR.d3d_device->SetTransform(D3DTS_TEXTURE0, &temp.D3DX());
            }

            if (this->__sbyte_3120E0A != 2) {
                SUPERVISOR.d3d_device->SetStreamSource(0, this->__d3d_vertex_buffer_3120E18, 0, sizeof(UnknownVertexA));
                SUPERVISOR.d3d_device->SetFVF(UnknownVertexA::FVF_TYPE);
                SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TFACTOR);
                SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_TFACTOR);
                this->__sbyte_3120E0A = 2;
            }

            this->set_modulate_op();

            SUPERVISOR.d3d_device->DrawPrimitive(D3DPT_TRIANGLESTRIP, (vm->data.y_anchor_mode * 3 + vm->data.x_anchor_mode) * 4, 2);
            return ZUN_SUCCESS;
        }
        return ZUN_ERROR;
    }

    // 0x480F70
    dllexport gnu_noinline ZUNResult thiscall __draw_vm_type_9_C_D_E(AnmVM* vm, void* special_data, int32_t arg3) asm_symbol_rel(0x480F70) {
        // TODO
    }

    // 0x4810D0
    dllexport gnu_noinline ZUNResult thiscall __draw_vm_type_B(AnmVM* vm, void* special_data, int32_t arg3) asm_symbol_rel(0x4810D0) {
        // TODO
    }

    // 0x480A50
    dllexport gnu_noinline ZUNResult thiscall __draw_vm_type_18_19(AnmVM* vm, void* special_data, int32_t arg3) asm_symbol_rel(0x480A50) {
        // TODO
    }

    // 0x481210
    dllexport gnu_noinline ZUNResult thiscall draw_vm(AnmVM* vm) asm_symbol_rel(0x481210) {
        vm->run_on_draw();
        if (
            !vm->data.visible ||
            !vm->data.__visible2 ||
            vm->data.__vm_state != Normal
        ) {
            return ZUN_ERROR;
        }

        SUPERVISOR.d3d_disable_zwrite();

        switch (vm->data.render_mode) {
            case 0:
                if (!vm->get_alpha() && !vm->get_alpha2()) {
                    return ZUN_ERROR;
                }
                vm->__get_vertex_positions(&SPRITE_VERTEX_BUFFER_A[0].position, &SPRITE_VERTEX_BUFFER_A[1].position, &SPRITE_VERTEX_BUFFER_A[2].position, &SPRITE_VERTEX_BUFFER_A[3].position);
                return this->__render_vertices(vm, RENDER_VERTICES_ROUND_INPUTS);
            case 1: case 3:
                if (!vm->get_alpha() && !vm->get_alpha2()) {
                    return ZUN_ERROR;
                }
                vm->__get_rotated_vertex_positions(&SPRITE_VERTEX_BUFFER_A[0].position, &SPRITE_VERTEX_BUFFER_A[1].position, &SPRITE_VERTEX_BUFFER_A[2].position, &SPRITE_VERTEX_BUFFER_A[3].position);
                return this->__render_vertices(vm, RENDER_VERTICES_DEFAULT);
            case 4:
                if (!vm->get_alpha() && !vm->get_alpha2()) {
                    return ZUN_ERROR;
                }
                vm->__sub_47F090();
                return this->__render_vertices(vm, RENDER_VERTICES_DEFAULT);
            case 5: {
                if (!vm->get_alpha() && !vm->get_alpha2()) {
                    return ZUN_ERROR;
                }
                this->__draw_vm_type_5_7(vm);
                ZUNResult ret = this->__render_vertices(vm, RENDER_VERTICES_DEFAULT);
                SPRITE_VERTEX_BUFFER_A[3].position.w = 1.0f;
                SPRITE_VERTEX_BUFFER_A[2].position.w = 1.0f;
                SPRITE_VERTEX_BUFFER_A[1].position.w = 1.0f;
                SPRITE_VERTEX_BUFFER_A[0].position.w = 1.0f;
                return ret;
            }
            case 6:
                if (!vm->get_alpha() && !vm->get_alpha2()) {
                    return ZUN_ERROR;
                }
                return this->__sub_47F530(vm);
            case 7: {
                if (!vm->get_alpha() && !vm->get_alpha2()) {
                    return ZUN_ERROR;
                }
                this->__draw_vm_type_5_7(vm);

                StageCamera* camera = SUPERVISOR.current_camera_ptr;
                float draw_diff = camera->sky.begin_distance - camera->sky.end_distance;

                D3DCOLOR color = vm->data.color_mode == 0 ? vm->data.color1 : vm->data.color2;

                Float4 float4_array[4];

                Float4* float4_ptr = float4_array;
                SpriteVertex* sprite_vertex_ptr = SPRITE_VERTEX_BUFFER_A;
                UnknownVertexA* vertexA_ptr = this->__vertex_array_3120E1C;
                nounroll for (
                    size_t i = 0;
                    i < 4;
                    ++i, ++sprite_vertex_ptr, ++vertexA_ptr, ++float4_ptr
                ) {
                    D3DXVec3Transform(&float4_ptr->D3DX(), &vertexA_ptr->position.D3DX(), &this->__matrix_31207B0.D3DX());
                    camera = SUPERVISOR.current_camera_ptr;
                    float length = float4_ptr->distance3(&camera->position);
                    float draw_begin = camera->sky.begin_distance;
                    if (length > draw_begin) {
                        float E = (draw_begin - length) / draw_diff;
                        if (E >= 1.0f) {
                            sprite_vertex_ptr->diffuse = camera->sky.color;
                            ALPHA(sprite_vertex_ptr->diffuse) = ALPHA(color);
                        } else {
                            uint8_t b = BLUE(color);
                            uint8_t g = GREEN(color);
                            uint8_t r = RED(color);
                            uint8_t a = ALPHA(color);
                            BLUE(sprite_vertex_ptr->diffuse) = b - (int32_t)((b - camera->sky.color_components.b) * E);
                            camera = SUPERVISOR.current_camera_ptr; // why
                            GREEN(sprite_vertex_ptr->diffuse) = g - (int32_t)((g - camera->sky.color_components.g) * E);
                            RED(sprite_vertex_ptr->diffuse) = r - (int32_t)((r - camera->sky.color_components.r) * E);
                            ALPHA(sprite_vertex_ptr->diffuse) = a;
                        }
                    } else {
                        sprite_vertex_ptr->diffuse = color;
                    }
                }

                ZUNResult ret = this->__render_vertices(vm, RENDER_VERTICES_IGNORE_COLORS);
                SPRITE_VERTEX_BUFFER_A[3].position.w = 1.0f;
                SPRITE_VERTEX_BUFFER_A[2].position.w = 1.0f;
                SPRITE_VERTEX_BUFFER_A[1].position.w = 1.0f;
                SPRITE_VERTEX_BUFFER_A[0].position.w = 1.0f;
                return ret;
            }
            case 8:
                if (!vm->get_alpha() && !vm->get_alpha2()) {
                    return ZUN_ERROR;
                }
                return this->__draw_vm_type_8_F(vm);
            case 15: {
                if (!vm->get_alpha() && !vm->get_alpha2()) {
                    return ZUN_ERROR;
                }
                SUPERVISOR.d3d_enable_fog();
                ZUNResult ret = this->__draw_vm_type_8_F(vm);
                SUPERVISOR.d3d_disable_fog();
                return ret;
            }
            case 9: case 12: case 13: case 14:
                return this->__draw_vm_type_9_C_D_E(vm, vm->controller.special_data, vm->data.current_context.int_vars[0]);
            case 11:
                return this->__draw_vm_type_B(vm, vm->controller.special_data, vm->data.current_context.int_vars[0]);
            case 24: case 25:
                return this->__draw_vm_type_18_19(vm, vm->controller.special_data, vm->data.current_context.int_vars[0]);
            case 2:
                if (!vm->get_alpha() && !vm->get_alpha2()) {
                    return ZUN_ERROR;
                }
                vm->__get_vertex_positions(&SPRITE_VERTEX_BUFFER_A[0].position, &SPRITE_VERTEX_BUFFER_A[1].position, &SPRITE_VERTEX_BUFFER_A[2].position, &SPRITE_VERTEX_BUFFER_A[3].position);
                return this->__render_vertices(vm, RENDER_VERTICES_DEFAULT);
            case 16: case 20: case 21: case 22: case 26: case 27:

            case 17: case 18: case 19:


        }
    }

    // 0x488260
    dllexport gnu_noinline UpdateFuncRet thiscall render_layer(uint32_t layer_index) asm_symbol_rel(0x488260) {
        CRITICAL_SECTION_MANAGER.enter_section(AnmList_CS);
        {
            this->world_list.for_each_safeB([&, this](AnmVM* vm) {
                if (!vm->data.__vm_state) {
                    uint32_t vm_layer = vm->data.layer;
                    vm_layer = (vm_layer - WORLD_LAYER_COUNT) >= UI_LAYER_COUNT ? vm_layer : vm_layer - WORLD_LAYER_B_COUNT;
                    if (vm_layer == layer_index) {
                        this->draw_vm(vm);
                        ++vm->data.position_interp.end_time;
                    }
                }
            });
            this->ui_list.for_each_safeB([=](AnmVM* vm) {
                if (!vm->data.__vm_state) {
                    int32_t vm_layer = vm->data.layer;
                    if ((uint32_t)(vm_layer - WORLD_LAYER_A_COUNT) < UI_LAYER_COUNT) {
                        vm_layer += WORLD_LAYER_B_COUNT;
                    }
                    else if (
                        vm_layer < WORLD_LAYER_COUNT ||
                        vm_layer >= (WORLD_LAYER_COUNT + UI_LAYER_COUNT)
                    ) {
                        vm_layer = 39;
                    }
                    if (vm_layer == layer_index) {
                        this->draw_vm(vm);
                        ++vm->data.position_interp.end_time;
                    }
                }
            });
        }
        CRITICAL_SECTION_MANAGER.leave_section(AnmList_CS);
        return UpdateFuncNext;
    }

    // 0x488220
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC on_tick_world(void* ptr) asm_symbol_rel(0x488220) {
        GameThread* game_thread_ptr = GAME_THREAD_PTR;
        if (
            game_thread_ptr &&
            (game_thread_ptr->__unknown_flag_A | game_thread_ptr->skip_flag) &&
            game_thread_ptr->__unknown_flag_B
        ) {
            return UpdateFuncNext;
        }
        return ((AnmManager*)ptr)->on_tick_world();
    }
    // 0x488250
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC on_tick_ui(void* ptr) asm_symbol_rel(0x488250) {
        return ((AnmManager*)ptr)->on_tick_ui();
    }

    /* // 0x487670 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_0(void* self) asm_symbol_rel(0x487670) { return ((AnmManager*)self)->render_layer(0); }
    /* // 0x487680 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_1(void* self) asm_symbol_rel(0x487680) { return ((AnmManager*)self)->render_layer(1); }
    /* // 0x487690 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_2(void* self) asm_symbol_rel(0x487690) { return ((AnmManager*)self)->render_layer(2); }
    /* // 0x4876A0 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_4(void* self) asm_symbol_rel(0x4876A0) { return ((AnmManager*)self)->render_layer(4); }
    // 0x4876B0
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_3(void* self) asm_symbol_rel(0x4876B0) {
        Supervisor::__sub_454950(&SUPERVISOR.cameras[3]);
        SUPERVISOR.set_camera_by_index_disable_fog(3);
        return ((AnmManager*)self)->render_layer(3);
    }
    /* // 0x487770 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_5(void* self) asm_symbol_rel(0x487770) { return ((AnmManager*)self)->render_layer(5); }
    /* // 0x487780 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_6(void* self) asm_symbol_rel(0x487780) { return ((AnmManager*)self)->render_layer(6); }
    /* // 0x487790 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_7(void* self) asm_symbol_rel(0x487790) { return ((AnmManager*)self)->render_layer(7); }
    /* // 0x4877A0 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_8(void* self) asm_symbol_rel(0x4877A0) { return ((AnmManager*)self)->render_layer(8); }
    /* // 0x4877B0 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_9(void* self) asm_symbol_rel(0x4877B0) { return ((AnmManager*)self)->render_layer(9); }
    /* // 0x4877C0 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_10(void* self) asm_symbol_rel(0x4877C0) { return ((AnmManager*)self)->render_layer(10); }
    /* // 0x4877D0 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_11(void* self) asm_symbol_rel(0x4877D0) { return ((AnmManager*)self)->render_layer(11); }
    /* // 0x4877E0 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_13(void* self) asm_symbol_rel(0x4877E0) { return ((AnmManager*)self)->render_layer(13); }
    /* // 0x4877F0 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_14(void* self) asm_symbol_rel(0x4877F0) { return ((AnmManager*)self)->render_layer(14); }
    /* // 0x487800 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_15(void* self) asm_symbol_rel(0x487800) { return ((AnmManager*)self)->render_layer(15); }
    /* // 0x487810 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_16(void* self) asm_symbol_rel(0x487810) { return ((AnmManager*)self)->render_layer(16); }
    /* // 0x487820 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_17(void* self) asm_symbol_rel(0x487820) { return ((AnmManager*)self)->render_layer(17); }
    /* // 0x487830 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_18(void* self) asm_symbol_rel(0x487830) { return ((AnmManager*)self)->render_layer(18); }
    /* // 0x487840 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_12(void* self) asm_symbol_rel(0x487840) { return ((AnmManager*)self)->render_layer(12); }
    /* // 0x487850 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_19(void* self) asm_symbol_rel(0x487850) { return ((AnmManager*)self)->render_layer(19); }
    /* // 0x487860 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_21(void* self) asm_symbol_rel(0x487860) { return ((AnmManager*)self)->render_layer(21); }
    /* // 0x487870 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_22(void* self) asm_symbol_rel(0x487870) { return ((AnmManager*)self)->render_layer(22); }
    /* // 0x487880 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_31(void* self) asm_symbol_rel(0x487880) { return ((AnmManager*)self)->render_layer(31); }
    /* // 0x487890 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_32(void* self) asm_symbol_rel(0x487890) { return ((AnmManager*)self)->render_layer(32); }
    /* // 0x4878A0 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_30(void* self) asm_symbol_rel(0x4878A0) { return ((AnmManager*)self)->render_layer(30); }
    /* // 0x4878B0 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_26(void* self) asm_symbol_rel(0x4878B0) { return ((AnmManager*)self)->render_layer(26); }
    /* // 0x4878C0 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_27(void* self) asm_symbol_rel(0x4878C0) { return ((AnmManager*)self)->render_layer(27); }
    /* // 0x4878D0 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_25(void* self) asm_symbol_rel(0x4878D0) { return ((AnmManager*)self)->render_layer(25); }
    /* // 0x4878E0 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_38(void* self) asm_symbol_rel(0x4878E0) { return ((AnmManager*)self)->render_layer(38); }
    /* // 0x4878F0 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_39(void* self) asm_symbol_rel(0x4878F0) { return ((AnmManager*)self)->render_layer(39); }
    /* // 0x487900 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_40(void* self) asm_symbol_rel(0x487900) { return ((AnmManager*)self)->render_layer(40); }
    /* // 0x487910 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_43(void* self) asm_symbol_rel(0x487910) { return ((AnmManager*)self)->render_layer(43); }
    /* // 0x487920 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_44(void* self) asm_symbol_rel(0x487920) { return ((AnmManager*)self)->render_layer(44); }
    /* // 0x487930 */ dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_45(void* self) asm_symbol_rel(0x487930) { return ((AnmManager*)self)->render_layer(45); }
    // 0x487940
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_20(void* self) asm_symbol_rel(0x487940) {
        SUPERVISOR.set_camera_by_index_disable_fog(1);
        SUPERVISOR.d3d_zfunc_always();
        return ((AnmManager*)self)->render_layer(20);
    }
    // 0x487A10
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_23(void* self) asm_symbol_rel(0x487A10) {
        SUPERVISOR.set_camera_by_index_disable_fog(1);
        SUPERVISOR.d3d_zfunc_always();
        return ((AnmManager*)self)->render_layer(23);
    }
    // 0x487AE0
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_24(void* self) asm_symbol_rel(0x487AE0) {
        SUPERVISOR.set_camera_by_index_disable_fog(2);
        SUPERVISOR.d3d_zfunc_always();
        AnmManager* anm_manager = (AnmManager*)self;
        anm_manager->__float2_D0.x = 0.0f;
        anm_manager->__float2_D0.y = 0.0f;
        return anm_manager->render_layer(24);
    }
    // 0x487BC0
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_28(void* self) asm_symbol_rel(0x487BC0) {
        AnmManager* anm_manager = (AnmManager*)self;
        SUPERVISOR.set_camera2_alt();
        UpdateFuncRet ret = anm_manager->render_layer(28);
        SUPERVISOR.set_camera_by_index(2);
        return ret;
    }
    // 0x487C50
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_29(void* self) asm_symbol_rel(0x487C50) {
        AnmManager* anm_manager = (AnmManager*)self;
        SUPERVISOR.set_camera2_alt();
        UpdateFuncRet ret = anm_manager->render_layer(29);
        SUPERVISOR.set_camera_by_index(2);
        return ret;
    }
    // 0x487CE0
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_37(void* self) asm_symbol_rel(0x487CE0) {
        SUPERVISOR.set_camera_by_index_disable_fog(2);
        SUPERVISOR.d3d_zfunc_always();
        return ((AnmManager*)self)->render_layer(37);
    }
    // 0x487DB0
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_41A(void* self) asm_symbol_rel(0x487DB0) {
        AnmManager* anm_manager = (AnmManager*)self;
        SUPERVISOR.set_camera2_alt();
        UpdateFuncRet ret = anm_manager->render_layer(41);
        SUPERVISOR.set_camera_by_index(2);
        return ret;
    }
    // Was this supposed to be 42?
    // 0x487E40
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC draw_layer_41B(void* self) asm_symbol_rel(0x487E40) {
        AnmManager* anm_manager = (AnmManager*)self;
        SUPERVISOR.set_camera2_alt();
        UpdateFuncRet ret = anm_manager->render_layer(41);
        SUPERVISOR.set_camera_by_index(2);
        return ret;
    }

    // 0x483820
    dllexport gnu_noinline AnmManager() : prev_slow_id(0) {
        this->zero_contents();
        SPRITE_VERTEX_BUFFER_B[3].position.w = 1.0f;
        SPRITE_VERTEX_BUFFER_B[2].position.w = 1.0f;
        SPRITE_VERTEX_BUFFER_B[1].position.w = 1.0f;
        SPRITE_VERTEX_BUFFER_B[0].position.w = 1.0f;
        
        SPRITE_VERTEX_BUFFER_B[0].texture_uv = { 0.0f, 0.0f };
        SPRITE_VERTEX_BUFFER_B[1].texture_uv = { 1.0f, 0.0f };
        SPRITE_VERTEX_BUFFER_B[2].texture_uv = { 0.0f, 1.0f };
        SPRITE_VERTEX_BUFFER_B[3].texture_uv = { 1.0f, 1.0f };
        
        SPRITE_VERTEX_BUFFER_A[3].position.w = 1.0f;
        SPRITE_VERTEX_BUFFER_A[2].position.w = 1.0f;
        SPRITE_VERTEX_BUFFER_A[1].position.w = 1.0f;
        SPRITE_VERTEX_BUFFER_A[0].position.w = 1.0f;
        
        SPRITE_VERTEX_BUFFER_A[0].texture_uv = { 0.0f, 0.0f };
        SPRITE_VERTEX_BUFFER_A[1].texture_uv = { 1.0f, 0.0f };
        SPRITE_VERTEX_BUFFER_A[2].texture_uv = { 0.0f, 1.0f };
        SPRITE_VERTEX_BUFFER_A[3].texture_uv = { 1.0f, 1.0f };
        
        this->__d3d_vertex_buffer_3120E18 = NULL;
        this->__index_3120E04 = -1;
        this->current_blend_mode = (AnmBlendMode)0;
        this->__byte_3120E09 = 0;
        this->__sbyte_3120E0A = 0;
        this->__byte_3120E0B = 0;
        this->current_texture_blend_color = PackD3DCOLOR(0, 0, 0, 0);
        this->__byte_3120E0C = -1;
        this->__int_20 = -1;
        this->__dword_48 = -1;
        this->__dword_70 = -1;
        this->__dword_98 = -1;
        ZUNListHead<FastAnmVM>* free_list_head_ptr = &this->free_list_head;
        free_list_head_ptr->initialize_with((FastAnmVM*)&free_list_head_ptr);
        FastAnmVM* fast_array_ptr = this->fast_array;
        int32_t i = 0;
        do {
            fast_array_ptr->reset();
            fast_array_ptr->controller.fast_id = i;
            fast_array_ptr->alive = false;
            fast_array_ptr->fast_id = i;
            fast_array_ptr->fast_node.initialize_with(fast_array_ptr);
            free_list_head_ptr->append(&fast_array_ptr->fast_node);
            ++i;
            ++fast_array_ptr;
        } while (i < countof(this->fast_array));
        this->next_snapshot_fast_id = 0;
        UpdateFunc* update_func;
        update_func = new UpdateFunc(&AnmManager::on_tick_world, true, this);
        UpdateFuncRegistry::register_on_tick(update_func, 34);
        update_func = new UpdateFunc(&AnmManager::on_tick_ui, true, this);
        UpdateFuncRegistry::register_on_tick(update_func, 11);
        update_func = new UpdateFunc(&AnmManager::draw_layer_0, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 5);
        update_func = new UpdateFunc(&AnmManager::draw_layer_1, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 7);
        update_func = new UpdateFunc(&AnmManager::draw_layer_2, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 9);
        update_func = new UpdateFunc(&AnmManager::draw_layer_4, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 11);
        update_func = new UpdateFunc(&AnmManager::draw_layer_3, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 10);
        update_func = new UpdateFunc(&AnmManager::draw_layer_5, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 13);
        update_func = new UpdateFunc(&AnmManager::draw_layer_6, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 16);
        update_func = new UpdateFunc(&AnmManager::draw_layer_7, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 18);
        update_func = new UpdateFunc(&AnmManager::draw_layer_8, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 20);
        update_func = new UpdateFunc(&AnmManager::draw_layer_9, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 21);
        update_func = new UpdateFunc(&AnmManager::draw_layer_10, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 22);
        update_func = new UpdateFunc(&AnmManager::draw_layer_11, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 24);
        update_func = new UpdateFunc(&AnmManager::draw_layer_12, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 27);
        update_func = new UpdateFunc(&AnmManager::draw_layer_13, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 28);
        update_func = new UpdateFunc(&AnmManager::draw_layer_14, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 31);
        update_func = new UpdateFunc(&AnmManager::draw_layer_15, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 32);
        update_func = new UpdateFunc(&AnmManager::draw_layer_16, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 35);
        update_func = new UpdateFunc(&AnmManager::draw_layer_17, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 37);
        update_func = new UpdateFunc(&AnmManager::draw_layer_18, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 40);
        update_func = new UpdateFunc(&AnmManager::draw_layer_19, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 43);
        update_func = new UpdateFunc(&AnmManager::draw_layer_20, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 46);
        update_func = new UpdateFunc(&AnmManager::draw_layer_21, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 47);
        update_func = new UpdateFunc(&AnmManager::draw_layer_22, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 54);
        update_func = new UpdateFunc(&AnmManager::draw_layer_23, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 56);
        update_func = new UpdateFunc(&AnmManager::draw_layer_26, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 64);
        update_func = new UpdateFunc(&AnmManager::draw_layer_27, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 66);
        update_func = new UpdateFunc(&AnmManager::draw_layer_30, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 84);
        update_func = new UpdateFunc(&AnmManager::draw_layer_31, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 86);
        update_func = new UpdateFunc(&AnmManager::draw_layer_32, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 89);
        update_func = new UpdateFunc(&AnmManager::draw_layer_25, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 61);
        update_func = new UpdateFunc(&AnmManager::draw_layer_24, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 60);
        update_func = new UpdateFunc(&AnmManager::draw_layer_28, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 69);
        update_func = new UpdateFunc(&AnmManager::draw_layer_29, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 71);
        update_func = new UpdateFunc(&AnmManager::draw_layer_37, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 57);
        update_func = new UpdateFunc(&AnmManager::draw_layer_38, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 62);
        update_func = new UpdateFunc(&AnmManager::draw_layer_39, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 65);
        update_func = new UpdateFunc(&AnmManager::draw_layer_40, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 67);
        update_func = new UpdateFunc(&AnmManager::draw_layer_41A, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 68);
        update_func = new UpdateFunc(&AnmManager::draw_layer_41B, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 70);
        update_func = new UpdateFunc(&AnmManager::draw_layer_43, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 85);
        update_func = new UpdateFunc(&AnmManager::draw_layer_44, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 87);
        update_func = new UpdateFunc(&AnmManager::draw_layer_45, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 90);
        SUPERVISOR.d3d_device->SetVertexShader(NULL);
        this->next_snapshot_discriminator = 0;
    }

    // 0x4867E0
    dllexport gnu_noinline AnmLoaded* thiscall create_anm_loaded(int32_t file_index, const char* filename) asm_symbol_rel(0x4867E0) {
        DebugLogger::__debug_log_stub_6("::preloadAnim : %s\n", filename);
        if (file_index >= countof(this->loaded_anm_files)) {
            LOG_BUFFER.write_error("Not enough space to store textures\r\n");
            return NULL;
        }
        AnmLoaded* anm_loaded = new AnmLoaded();
        this->loaded_anm_files[file_index] = anm_loaded;
        anm_loaded->slot_index = file_index;
        if (ZUN_FAILED(anm_loaded->preload(filename))) {
            delete anm_loaded;
            return NULL;
        }
        return anm_loaded;
    }

    // 0x486880
    dllexport static gnu_noinline AnmLoaded* stdcall preload_anm(int32_t file_index, const char* filename) asm_symbol_rel(0x486880) {
        AnmManager* anm_manager = ANM_MANAGER_PTR;
        if (anm_manager->loaded_anm_files[file_index]) {
            DebugLogger::__debug_log_stub_6("::preloadAnim already : %s\n", filename);
            return anm_manager->loaded_anm_files[file_index];
        }
        AnmLoaded* anm_loaded = anm_manager->create_anm_loaded(file_index, filename);
        if (expect(anm_loaded != NULL, false)) {
            anm_loaded->__load_wait = 1;
            while (anm_loaded->__load_wait && !SUPERVISOR.__unknown_bitfield_A) {
                Sleep(1);
            }
            DebugLogger::__debug_log_stub_6("::preloadAnimEnd : %s\n", filename);
        }
        return anm_loaded;
    }

    // 0x4858E0
    dllexport gnu_noinline void thiscall __screw_with_texture_bits(LPDIRECT3DTEXTURE9 d3d_texture) asm_symbol_rel(0x4858E0) {
        LPDIRECT3DSURFACE9 surface = NULL;
        d3d_texture->GetSurfaceLevel(0, &surface);
        D3DSURFACE_DESC surface_desc;
        surface->GetDesc(&surface_desc);
        D3DLOCKED_RECT rect;
        surface->LockRect(&rect, NULL, 0);
        // Syntax highlighting doesn't understand lambda templates. :/
        auto process_pixels = [&](auto dummy_pixel) {
            using PixelT = decltype(dummy_pixel);
            for (uint32_t y = 0; y < surface_desc.Height; ++y) {
                PixelT* pixel = based_pointer<PixelT>(rect.pBits, rect.Pitch * y);
                for (uint32_t x = 0; x < surface_desc.Width; ++x) {
                    if (!pixel[0].a) {
                        uint32_t count = 0;
                        uint32_t R = 0, G = 0, B = 0;
                        if (x > 0 && pixel[-1].a) {
                            R = pixel[-1].r; G = pixel[-1].g; B = pixel[-1].b;
                            count = 1;
                        }
                        if (x < surface_desc.Width - 1 && pixel[1].a) {
                            R += pixel[1].r; G += pixel[1].g; B += pixel[1].b;
                            ++count;
                        }
                        if (y > 0) {
                            PixelT* prev_row_pixel = pixel - rect.Pitch / sizeof(PixelT);
                            if (prev_row_pixel->a) {
                                R += prev_row_pixel->r; G += prev_row_pixel->g; B += prev_row_pixel->b;
                                ++count;
                            }
                        }
                        if (y < surface_desc.Height - 1) {
                            PixelT* next_row_pixel = pixel - rect.Pitch / sizeof(PixelT);
                            if (next_row_pixel->a) {
                                R += next_row_pixel->r; G += next_row_pixel->g; B += next_row_pixel->b;
                                ++count;
                            }
                        }
                        if (count > 1) {
                            R /= count; G /= count; B /= count;
                        }
                        if constexpr (PixelT::a_is_bitfield) {
                            pixel[0] = (PixelT){
                                .r = R, .g = G, .b = B, .a = 0
                            };
                        } else {
                            PixelT temp = pixel[0];
                            temp.r = R; temp.g = G; temp.b = B;
                            pixel[0] = temp;
                        }
                    }
                    ++pixel;
                }
            }
        };
        switch (surface_desc.Format) {
            case D3DFMT_UNKNOWN: case D3DFMT_A8R8G8B8:
                process_pixels((PixelA8R8G8B8){});
                break;
            case D3DFMT_A1R5G5B5:
                process_pixels((PixelA1R5G5B5){});
                break;
            case D3DFMT_A4R4G4B4:
                process_pixels((PixelA4R4G4B4){});
                break;
            case D3DFMT_A8R3G3B2:
                process_pixels((PixelA8R3G3B2){});
                break;
        }
        surface->UnlockRect();
        surface->Release();
    }

    // 0x4860C0
    dllexport gnu_noinline static int stdcall __sub_4860C0(AnmImage* image, LPCVOID image_data, UINT image_size, int = UNUSED_DWORD, int = UNUSED_DWORD, int = UNUSED_DWORD) asm_symbol_rel(0x4860C0) {
        AnmManager* anm_manager = ANM_MANAGER_PTR;
        image->__unknown_flag_A = false;
        image->file_size = image_size;
        LPDIRECT3DSURFACE9 surface = NULL;
        image->d3d_texture->GetSurfaceLevel(0, &surface);
        D3DXLoadSurfaceFromFileInMemory(surface, NULL, NULL, image_data, image_size, NULL, D3DX_FILTER_NONE, 0, NULL);
        surface->Release();
        anm_manager->__screw_with_texture_bits(image->d3d_texture);
        image->bytes_per_pixel = 4;
        return 0;
    }

    // 0x486140
    dllexport gnu_noinline int32_t thiscall __sub_486140(AnmImage* image, uint32_t format_index, uint32_t entry_index, int32_t width, int32_t height, int32_t offset_x, int32_t offset_y) asm_symbol_rel(0x486140);

    // 0x486BC0
    dllexport gnu_noinline int32_t thiscall __sub_486BC0(AnmLoaded* anm_loaded, uint32_t entry_index, uint32_t sprite_count, uint32_t script_count, AnmEntry* anm_entry) asm_symbol_rel(0x486BC0);

    // 0x486920
    dllexport gnu_noinline AnmLoaded* thiscall __sub_486920(AnmLoaded* anm_loaded) asm_symbol_rel(0x486920) {
        AnmEntry* anm_entry_ptr = (AnmEntry*)anm_loaded->anm_file;
        int32_t wait_index = 0;
        int32_t load_wait = anm_loaded->__load_wait;
        uint32_t script_count = 0;
        uint32_t sprite_count = 0;
        uint32_t entry_index = 0;
        BOOL idk = false;
        do {
            if (load_wait - 1 == wait_index) {
                if (this->__sub_486BC0(anm_loaded, entry_index, sprite_count, script_count, anm_entry_ptr) < 0) {
                    anm_loaded->__load_wait = 0;
                    return NULL;
                }
                idk = true;
            }
            sprite_count += anm_entry_ptr->sprite_count;
            script_count += anm_entry_ptr->script_count;
            ++entry_index;
            if (uint32_t offset_to_next = anm_entry_ptr->offset_to_next) {
                load_wait = anm_loaded->__load_wait;
                ++wait_index;
                anm_entry_ptr = based_pointer(anm_entry_ptr, offset_to_next);
            } else {
                for (int32_t i = 0; i < anm_loaded->script_count; ++i) {
                    (*anm_loaded->__vm_array)[i].reset();
                    anm_loaded->__prepare_vm(&(*anm_loaded->__vm_array)[i], i);
                    (*anm_loaded->__vm_array)[i].controller.script_time.set(-1);
                    (*anm_loaded->__vm_array)[i].controller.__timer_1C.set(-1);
                    (*anm_loaded->__vm_array)[i].run_anm();
                }
                anm_loaded->__load_wait = 0;
                return anm_loaded;
            }
        } while (load_wait != wait_index && idk == false);
        anm_loaded->__load_wait = load_wait + 1;
        return anm_loaded;
    }

    inline void unlink_node_from_list_ends(ZUNList<AnmVM>* node) {
        node->unlink_from(this->world_list);
        node->unlink_from(this->ui_list);
    }

    // 0x488B40
    dllexport gnu_noinline AnmVM* get_vm_with_id(const AnmID& vm_id) asm_symbol_rel(0x488B40) {
        if (vm_id) {
            uint32_t fast_id = vm_id.fast_id;
            if (fast_id == INVALID_FAST_ID) {
                auto id_match = [=](AnmVM* vm){
                    return vm->controller.id == vm_id;
                };
                if (AnmVM* ret = this->world_list.find_if(id_match)) return ret;
                if (AnmVM* ret = this->ui_list.find_if(id_match)) return ret;
            }
            else {
                FastAnmVM& fast_vm = this->fast_array[fast_id];
                if (fast_vm.alive && fast_vm.controller.id == vm_id) {
                    return &this->fast_array[fast_id];
                }
            }
        }
        return NULL;
    }

    // 0x488BE0
    dllexport static void interrupt_tree(const AnmID& id, int32_t interrupt_index) asm_symbol_rel(0x488BE0) {
        if (AnmVM* vm = ANM_MANAGER_PTR->get_vm_with_id(id)) {
            vm->interrupt(interrupt_index);
            vm->controller.child_list.for_each([=](AnmVM* vm) {
                vm->interrupt(interrupt_index);
            });
        }
    }

    // 0x488C60
    dllexport static void interrupt_and_run_tree(const AnmID& id, int32_t interrupt_index) asm_symbol_rel(0x488C60) {
        if (AnmVM* vm = ANM_MANAGER_PTR->get_vm_with_id(id)) {
            vm->interrupt(interrupt_index);
            vm->run_anm();
            vm->controller.child_list.for_each([=](AnmVM*& vm) {
                vm->interrupt(interrupt_index);
                vm->run_anm();
            });
        }
    }

    // 0x488D50
    dllexport void thiscall mark_tree_for_delete(AnmVM* vm) asm_symbol_rel(0x488D50) {
        if (vm && !vm->data.__unknown_flag_F) {
            vm->data.__vm_state = AnmVMState::MarkedForDelete;
            vm->controller.child_list.for_each([=](AnmVM* vm) gnu_always_inline {
                clang_noinline this->mark_tree_for_delete(vm);
            });
        }
    }

    inline void mark_tree_id_for_delete(AnmID& id) {
        this->mark_tree_for_delete(this->get_vm_with_id(id));
    }

    // 0x488CF0
    dllexport static gnu_noinline void stdcall mark_tree_id_for_delete(const AnmID& id) asm_symbol_rel(0x488CF0) {
        ANM_MANAGER_PTR->mark_tree_id_for_delete((AnmID&)id);
    }

    // 0x489320
    dllexport static AnmVM* allocate_new_vm() asm_symbol_rel(0x489320) {
        AnmManager* anm_manager = ANM_MANAGER_PTR;
        if (ZUNList<FastAnmVM>* free_node = anm_manager->free_list_head.next) {
            FastAnmVM* vm = free_node->data;
            vm->fast_node.unlink();
            vm->controller.fast_id = vm->fast_id;
            vm->alive = true;
            vm->controller.__root_vm = NULL;
            vm->controller.parent = NULL;
            vm->controller.global_list_node.initialize_with(vm);
            vm->controller.child_list_node.initialize_with(vm);
            vm->controller.child_list.initialize_with(vm);
            return vm;
        } else {
            AnmVM* vm = new AnmVM;
            vm->zero_contents();
            vm->data.sprite_id = -1;
            vm->data.current_instruction_offset = -1;
            vm->reset();
            vm->controller.fast_id = INVALID_FAST_ID;
            return vm;
        }
    }

    // 0x488110
    dllexport gnu_noinline void thiscall __recursive_remove(AnmVM* vm, ZUNList<AnmVM>* list_node) asm_symbol_rel(0x488110) {
        vm->controller.child_list.for_each_safe([=](AnmVM* current_vm) gnu_always_inline {
            clang_noinline this->__recursive_remove(current_vm, list_node);
        });
        if (vm->data.__vm_state != AnmVMState::Deleted) {
            ZUNList<AnmVM>* current_node = &vm->controller.destroy_list_node;
            current_node->initialize_with(vm);
            list_node->append(current_node);
        }
        vm->data.__vm_state = AnmVMState::Deleted;
        vm->controller.__root_vm = NULL;
        vm->controller.parent = NULL;
        vm->controller.next_in_layer = NULL;
        vm->controller.prev_in_layer = NULL;
        vm->controller.child_list_node.unlink();
    }

    // 0x4885D0
    dllexport int32_t thiscall destroy_possibly_managed_vm(AnmVM* vm) asm_symbol_rel(0x4885D0) {
        this->unlink_node_from_list_ends(&vm->controller.global_list_node);
        vm->run_on_destroy();
        vm->controller.global_list_node.unlink();
        vm->controller.destroy_list_node.unlink();
        vm->controller.__root_vm = NULL;
        vm->controller.parent = NULL;
        if (vm >= this->fast_array && vm < array_end_addr(this->fast_array)) {
            FastAnmVM* fast_vm = &this->fast_array[vm->controller.fast_id];
            fast_vm->alive = false;
            this->free_list_head.append(&fast_vm->fast_node);
            vm->cleanup();
            vm->controller.id = 0;
            return 0;
        }
        else {
            vm->cleanup();
            delete vm;
            return 0;
        }
    }

    // 0x487ED0
    dllexport gnu_noinline UpdateFuncRet thiscall on_tick_world() asm_symbol_rel(0x487ED0) {
        CRITICAL_SECTION_MANAGER.enter_section(AnmList_CS);
        {
            ZUNListHead<AnmVM> destroy_list;
            destroy_list.initialize_with(NULL);

            AnmVM* layer_lists[WORLD_LAYER_COUNT];
            int32_t i = 0;
            AnmVM* layer_heads = &this->layer_heads[0];
            NoUnroll do {
                //layer_lists[i] = &layer_heads[i];
                layer_heads[i].controller.next_in_layer = NULL;
            } while (++i < WORLD_LAYER_COUNT);

            this->world_list.for_each([&, this](AnmVM* vm) {
                vm->controller.next_in_layer = NULL;
                vm->controller.prev_in_layer = NULL;
                switch (vm->data.__vm_state) {
                    case AnmVMState::Normal:
                        if (vm->run_anm()) {
                    case AnmVMState::MarkedForDelete:
                            this->__recursive_remove(vm, &destroy_list);
                        }
                }
            });

            destroy_list.for_each([this](AnmVM* vm) {
                this->destroy_possibly_managed_vm(vm);
            });
        }
        CRITICAL_SECTION_MANAGER.leave_section(AnmList_CS);
        return UpdateFuncNext;
    }

    // 0x487FE0
    dllexport gnu_noinline UpdateFuncRet thiscall on_tick_ui() asm_symbol_rel(0x487FE0) {
        CRITICAL_SECTION_MANAGER.enter_section(AnmList_CS);
        {
            ZUNListHead<AnmVM> destroy_list;
            destroy_list.initialize_with(NULL);

            //AnmVM* layer_lists[UI_LAYER_COUNT];
            int32_t i = 0;
            AnmVM* layer_heads = &this->layer_heads[WORLD_LAYER_COUNT];
            do {
                //layer_lists[i] = &layer_heads[i];
                layer_heads[i].controller.next_in_layer = NULL;
            } while (++i < UI_LAYER_COUNT);

            this->ui_list.for_each([&, this](AnmVM* vm) {
                vm->controller.next_in_layer = NULL;
                vm->controller.prev_in_layer = NULL;
                switch (vm->data.__vm_state) {
                    case AnmVMState::Normal:
                        if (vm->run_anm()) {
                    case AnmVMState::MarkedForDelete:
                            this->__recursive_remove(vm, &destroy_list);
                        }
                }
            });

            destroy_list.for_each([this](AnmVM* vm) {
                this->destroy_possibly_managed_vm(vm);
            });
        }
        CRITICAL_SECTION_MANAGER.leave_section(AnmList_CS);
        return UpdateFuncNext;
    }

    forceinline void assign_next_id_to_ref(AnmID& out, AnmVM* vm) {
        UBitInt(ANM_SLOW_ID_BITS) slow_id = this->prev_slow_id + 1;
        this->prev_slow_id = slow_id;
        if (!slow_id) {
            this->prev_slow_id = ++slow_id;
        }
        AnmID new_id;
        new_id.fast_id = vm->controller.fast_id;
        new_id.slow_id = slow_id;
        out = vm->controller.id = new_id;
    }

private:
    // 0x488350
    // This function never uses a pointer for the first arg
    // even though the return value is typically used instead,
    // so I can only assume it must be a reference type.
    dllexport static gnu_noinline AnmID& stdcall add_vm_to_world_list_back(AnmID& out, AnmVM* vm) asm_symbol_rel(0x488350) {
        AnmManager* anm_manager = ANM_MANAGER_PTR;
        ZUNList<AnmVM>* world_node = &vm->controller.global_list_node;
        world_node->initialize_with(vm);
        anm_manager->world_list.append(world_node);
        anm_manager->assign_next_id_to_ref(out, vm);
        return out;
    }
public:
    static inline AnmID add_vm_to_world_list_back(AnmVM* vm) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return add_vm_to_world_list_back(dummy, vm);
    }

private:
    // 0x488400
    dllexport static gnu_noinline AnmID& stdcall add_vm_to_world_list_front(AnmID& out, AnmVM* vm) asm_symbol_rel(0x488400) {
        AnmManager* anm_manager = ANM_MANAGER_PTR;
        ZUNList<AnmVM>* world_node = &vm->controller.global_list_node;
        world_node->initialize_with(vm);
        anm_manager->world_list.prepend(world_node);
        anm_manager->assign_next_id_to_ref(out, vm);
        return out;
    }
public:
    static inline AnmID add_vm_to_world_list_front(AnmVM* vm) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return add_vm_to_world_list_front(dummy, vm);
    }

private:
    // 0x488490
    dllexport static gnu_noinline AnmID& stdcall add_vm_to_ui_list_back(AnmID& out, AnmVM* vm) asm_symbol_rel(0x488490) {
        AnmManager* anm_manager = ANM_MANAGER_PTR;
        ZUNList<AnmVM>* world_node = &vm->controller.global_list_node;
        world_node->initialize_with(vm);
        anm_manager->ui_list.append(world_node);
        anm_manager->assign_next_id_to_ref(out, vm);
        return out;
    }
public:
    static inline AnmID add_vm_to_ui_list_back(AnmVM* vm) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return add_vm_to_ui_list_back(dummy, vm);
    }

private:
    // 0x488540
    dllexport static gnu_noinline AnmID& stdcall add_vm_to_ui_list_front(AnmID& out, AnmVM* vm) asm_symbol_rel(0x488540) {
        AnmManager* anm_manager = ANM_MANAGER_PTR;
        ZUNList<AnmVM>* world_node = &vm->controller.global_list_node;
        world_node->initialize_with(vm);
        anm_manager->ui_list.prepend(world_node);
        anm_manager->assign_next_id_to_ref(out, vm);
        return out;
    }
public:
    static inline AnmID add_vm_to_ui_list_front(AnmVM* vm) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return add_vm_to_ui_list_front(dummy, vm);
    }

    // 0x488DA0
    dllexport gnu_noinline void thiscall mark_all_vms_from_loaded_for_delete(AnmLoaded* anm_loaded) asm_symbol_rel(0x488DA0) {
        if (anm_loaded) {
            auto set_state1_if_slot_matches = [=](AnmVM* vm) {
                int32_t slot = anm_loaded->slot_index;
                if (
                    vm->data.slot == slot ||
                    vm->data.slot2 == slot
                ) {
                    vm->data.__vm_state = 1;
                }
            };
            this->world_list.for_each_safe(set_state1_if_slot_matches);
            this->ui_list.for_each_safe(set_state1_if_slot_matches);
        }
    }

    inline void mark_all_vms_from_loaded_slot_for_delete(int32_t slot) {
        this->mark_all_vms_from_loaded_for_delete(this->loaded_anm_files[slot]);
    }

    // 0x486FC0
    dllexport gnu_noinline void thiscall unload_anm(int32_t slot) asm_symbol_rel(0x486FC0) {
        if (
            slot >= 0 && slot < countof(this->loaded_anm_files)
        ) {
            SAFE_DELETE(this->loaded_anm_files[slot]);
        }
    }
};
#pragma region // AnmManager Validation
ValidateFieldOffset32(0x0, AnmManager, __thread_0);
ValidateFieldOffset32(0x20, AnmManager, __int_20);
ValidateFieldOffset32(0x48, AnmManager, __dword_48);
ValidateFieldOffset32(0x70, AnmManager, __dword_70);
ValidateFieldOffset32(0x98, AnmManager, __dword_98);
ValidateFieldOffset32(0xC0, AnmManager, __dword_C0);
ValidateFieldOffset32(0xC4, AnmManager, __dword_C4);
ValidateFieldOffset32(0xC8, AnmManager, __dword_C8);
ValidateFieldOffset32(0xCC, AnmManager, __int_CC);
ValidateFieldOffset32(0xD0, AnmManager, __float2_D0);
ValidateFieldOffset32(0xD8, AnmManager, __float2_D8);
ValidateFieldOffset32(0xE4, AnmManager, __vm_E4);
ValidateFieldOffset32(0x6F0, AnmManager, world_list);
ValidateFieldOffset32(0x6F8, AnmManager, ui_list);
ValidateFieldOffset32(0x700, AnmManager, fast_array);
ValidateFieldOffset32(0x31200DC, AnmManager, fast_array_end);
ValidateFieldOffset32(0x3120700, AnmManager, next_snapshot_fast_id);
ValidateFieldOffset32(0x3120704, AnmManager, next_snapshot_discriminator);
ValidateFieldOffset32(0x3120708, AnmManager, snapshot_list_head);
ValidateFieldOffset32(0x3120718, AnmManager, free_list_head);
ValidateFieldOffset32(0x312072C, AnmManager, loaded_anm_files);
ValidateFieldOffset32(0x31207B0, AnmManager, __matrix_31207B0);
ValidateFieldOffset32(0x31207F0, AnmManager, __vm_31207F0);
ValidateFieldOffset32(0x3120E00, AnmManager, current_texture_blend_color);
ValidateFieldOffset32(0x3120E04, AnmManager, __index_3120E04);
ValidateFieldOffset32(0x3120E08, AnmManager, current_blend_mode);
ValidateFieldOffset32(0x3120E09, AnmManager, __byte_3120E09);
ValidateFieldOffset32(0x3120E0A, AnmManager, __sbyte_3120E0A);
ValidateFieldOffset32(0x3120E0B, AnmManager, __byte_3120E0B);
ValidateFieldOffset32(0x3120E0C, AnmManager, __byte_3120E0C);
ValidateFieldOffset32(0x3120E0E, AnmManager, current_resample_mode);
ValidateFieldOffset32(0x3120E0F, AnmManager, current_texture_op);
ValidateFieldOffset32(0x3120E10, AnmManager, current_u_sample_mode);
ValidateFieldOffset32(0x3120E11, AnmManager, current_v_sample_mode);
ValidateFieldOffset32(0x3120E14, AnmManager, __current_sprite);
ValidateFieldOffset32(0x3120E18, AnmManager, __d3d_vertex_buffer_3120E18);
ValidateFieldOffset32(0x3120E1C, AnmManager, __vertex_array_3120E1C);
ValidateFieldOffset32(0x3120E6C, AnmManager, unrendered_sprite_count);
ValidateFieldOffset32(0x3120E70, AnmManager, sprite_vertex_data);
ValidateFieldOffset32(0x3820E70, AnmManager, sprite_write_cursor);
ValidateFieldOffset32(0x3820E74, AnmManager, sprite_render_cursor);
ValidateFieldOffset32(0x3820E78, AnmManager, unrendered_primitive_count);
ValidateFieldOffset32(0x3820E7C, AnmManager, primitive_vertex_data);
ValidateFieldOffset32(0x3960E7C, AnmManager, primitive_write_cursor);
ValidateFieldOffset32(0x3960E80, AnmManager, primitive_render_cursor);
ValidateFieldOffset32(0x3960E84, AnmManager, layer_heads);
ValidateFieldOffset32(0x39724AC, AnmManager, prev_slow_id);
ValidateFieldOffset32(0x39724B0, AnmManager, __color_39724B0);
ValidateFieldOffset32(0x39724B4, AnmManager, __int_39724B4);
ValidateStructSize32(0x39724B8, AnmManager);
#pragma endregion

// 0x4553B0
dllexport gnu_noinline UpdateFuncRet UpdateFuncCC Supervisor::on_draw_A(void* ptr) {
    if (SUPERVISOR.__surface_1AC) {
        SUPERVISOR.d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, PackD3DCOLOR(255, 255, 255, 255), 1.0f, 0);
        SUPERVISOR.d3d_device->SetRenderTarget(0, SUPERVISOR.__surface_1AC);
        D3DRECT rect = SUPERVISOR.cameras[3].get_viewport_d3d_rect();
        SUPERVISOR.d3d_device->Clear(1, &rect, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, SUPERVISOR.background_color, 1.0f, 0);

        WINDOW_DATA.__int_2080 = 384;
        WINDOW_DATA.__int_208C = WINDOW_DATA.__scaled_width / 2;
        WINDOW_DATA.__int_207C = 448;
        WINDOW_DATA.__int_2090 = (int32_t)(WINDOW_DATA.__scaled_height - 448.0f) / 2;
    } else {
        SUPERVISOR.d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, SUPERVISOR.background_color, 1.0f, 0);
    }

    AnmManager* anm_manager = ANM_MANAGER_PTR;
    anm_manager->__current_sprite = NULL;
    anm_manager->__index_3120E04 = -1;
    anm_manager->current_blend_mode = (AnmBlendMode)-1;
    anm_manager->__byte_3120E09 = -1;
    anm_manager->__byte_3120E0B = -1;
    anm_manager->__byte_3120E0C = -1;
    anm_manager->__int_39724B4 = FALSE;
    anm_manager->__color_39724B0 = PackD3DCOLOR(128, 128, 128, 128);
    anm_manager->current_resample_mode = -1;
    anm_manager->current_texture_op = -1;
    anm_manager->__float2_D0.y = 0.0f;
    anm_manager->__float2_D0.x = 0.0f;
    anm_manager->__sbyte_3120E0A = -1;

    ((Supervisor*)ptr)->set_camera_by_index(2);

    return UpdateFuncNext;
}

// 0x455610
dllexport gnu_noinline UpdateFuncRet UpdateFuncCC Supervisor::on_draw_B(void* ptr) {
    if (SUPERVISOR.__surface_1AC) {
        SUPERVISOR.d3d_zfunc_always();
        ANM_MANAGER_PTR->flush_sprites();
        SUPERVISOR.d3d_device->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
        SUPERVISOR.d3d_device->SetRenderState(D3DRS_SEPARATEALPHABLENDENABLE, TRUE);
        SUPERVISOR.d3d_device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ZERO);
        SUPERVISOR.d3d_device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
        SUPERVISOR.d3d_device->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
        SUPERVISOR.d3d_device->SetRenderState(D3DRS_SRCBLENDALPHA, D3DBLEND_ONE);
        SUPERVISOR.d3d_device->SetRenderState(D3DRS_DESTBLENDALPHA, D3DBLEND_ONE);
        SUPERVISOR.d3d_device->SetRenderState(D3DRS_BLENDOPALPHA, D3DBLENDOP_ADD);

        PrimitiveVertex verts[4];

        Float2 viewport_position = SUPERVISOR.cameras[3].get_viewport_position();
        
        verts[3].position.z = 0.0f;
        verts[2].position.z = 0.0f;
        verts[1].position.z = 0.0f;
        verts[3].position.as2() = viewport_position;
        verts[2].position.as2() = viewport_position;
        verts[1].position.as2() = viewport_position;
        verts[0].position.as2() = viewport_position;
        verts[0].position.z = 0.0f;
        verts[3].position.w = 1.0f;
        verts[2].position.w = 1.0f;
        verts[1].position.w = 1.0f;
        verts[0].position.w = 1.0f;
        verts[0].diffuse = PackD3DCOLOR(255, 0, 0, 0);
        verts[1].diffuse = PackD3DCOLOR(255, 0, 0, 0);
        verts[2].diffuse = PackD3DCOLOR(255, 0, 0, 0);
        verts[3].diffuse = PackD3DCOLOR(255, 0, 0, 0);

        Float2 viewport_size = SUPERVISOR.cameras[3].get_viewport_size();
        verts[1].position.x += viewport_size.x;
        verts[3].position.as2() += viewport_size;
        verts[2].position.y += viewport_size.y;

        SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
        SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
        SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
        SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);

        SUPERVISOR.d3d_device->SetFVF(PrimitiveVertex::FVF_TYPE);

        SUPERVISOR.d3d_device->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &verts, sizeof(PrimitiveVertex));

        SUPERVISOR.d3d_device->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
        SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
        SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
        SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
        SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

        ANM_MANAGER_PTR->current_blend_mode = (AnmBlendMode)11;
        SUPERVISOR.d3d_device->SetRenderState(D3DRS_SRCBLENDALPHA, D3DBLEND_SRCALPHA);
        SUPERVISOR.d3d_device->SetRenderState(D3DRS_DESTBLENDALPHA, D3DBLEND_ONE);
        SUPERVISOR.d3d_device->SetRenderState(D3DRS_BLENDOPALPHA, D3DBLENDOP_ADD);

        ANM_MANAGER_PTR->flush_sprites();
        SUPERVISOR.d3d_device->SetRenderTarget(0, SUPERVISOR.__surface_1B0);
        D3DRECT rect = SUPERVISOR.cameras[3].get_viewport_d3d_rect();
        SUPERVISOR.d3d_device->Clear(1, &rect, D3DCLEAR_ZBUFFER, SUPERVISOR.background_color, 1.0f, 0);
    }
    return UpdateFuncNext;
}

// 0x455530
dllexport gnu_noinline UpdateFuncRet UpdateFuncCC Supervisor::on_draw_arcade_vm_A(void* ptr) {
    if (SUPERVISOR.__surface_1AC) {
        auto* unknown_func_A = UNKNOWN_FUNC_PTR_A;
        if (!unknown_func_A) {
            SUPERVISOR.d3d_device->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
            SUPERVISOR.d3d_device->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);

            SUPERVISOR.d3d_disable_zwrite();
            SUPERVISOR.set_camera_by_index(3);

            ANM_MANAGER_PTR->draw_vm(SUPERVISOR.__arcade_vm_ptr_A);
            SUPERVISOR.__arcade_vm_ptr_A->data.color1 = PackD3DCOLOR(255, 255, 255, 255);

            ANM_MANAGER_PTR->render_layer(35);
            ANM_MANAGER_PTR->flush_sprites();

            SUPERVISOR.d3d_device->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
        }
        else {
            unknown_func_A();
        }
    }
    return UpdateFuncNext;
}

// 0x455A70
dllexport gnu_noinline UpdateFuncRet UpdateFuncCC Supervisor::on_draw_D(void* ptr) {
    if (SUPERVISOR.__surface_1AC) {
        ANM_MANAGER_PTR->flush_sprites();
        SUPERVISOR.d3d_device->SetRenderTarget(0, SUPERVISOR.__surface_1AC);

        D3DRECT rect = SUPERVISOR.cameras[3].get_viewport_d3d_rect();
        SUPERVISOR.d3d_device->Clear(1, &rect, D3DCLEAR_ZBUFFER, SUPERVISOR.background_color, 1.0f, 0);
    }
    return UpdateFuncNext;
}

// 0x4559A0
dllexport gnu_noinline UpdateFuncRet UpdateFuncCC Supervisor::on_draw_arcade_vm_B(void* ptr) {
    if (SUPERVISOR.__surface_1AC) {
        auto* unknown_func_B = UNKNOWN_FUNC_PTR_B;
        if (!unknown_func_B) {
            SUPERVISOR.d3d_device->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
            SUPERVISOR.d3d_device->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);

            SUPERVISOR.d3d_disable_zwrite();
            SUPERVISOR.set_camera_by_index(3);

            ANM_MANAGER_PTR->draw_vm(SUPERVISOR.__arcade_vm_ptr_B);
            SUPERVISOR.__arcade_vm_ptr_B->data.color1 = PackD3DCOLOR(255, 255, 255, 255);

            ANM_MANAGER_PTR->flush_sprites();

            SUPERVISOR.d3d_device->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
        }
        else {
            unknown_func_B();
        }
    }
    return UpdateFuncNext;
}

// 0x455BC0
dllexport gnu_noinline UpdateFuncRet UpdateFuncCC Supervisor::on_draw_F(void* ptr) {
    if (SUPERVISOR.__surface_1AC) {
        ANM_MANAGER_PTR->flush_sprites();
        SUPERVISOR.d3d_device->SetRenderTarget(0, SUPERVISOR.__surface_1B0);

        D3DRECT rect = SUPERVISOR.cameras[1].get_viewport_d3d_rect();
        SUPERVISOR.d3d_device->Clear(1, &rect, D3DCLEAR_ZBUFFER, SUPERVISOR.background_color, 1.0f, 0);

        float scale = WINDOW_DATA.__game_scale;
        float height = SCREEN_HEIGHT * scale;
        float width = SCREEN_WIDTH * scale;
        WINDOW_DATA.__int_2080 = width;
        WINDOW_DATA.__int_207C = height;
    }
    return UpdateFuncNext;
}

// 0x455B10
dllexport gnu_noinline UpdateFuncRet UpdateFuncCC Supervisor::on_draw_arcade_vm_C(void* ptr) {
    if (SUPERVISOR.__surface_1AC) {
        SUPERVISOR.d3d_device->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
        SUPERVISOR.d3d_device->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);

        SUPERVISOR.d3d_disable_zwrite();

        ANM_MANAGER_PTR->draw_vm(SUPERVISOR.__arcade_vm_ptr_C);

        ANM_MANAGER_PTR->flush_sprites();

        SUPERVISOR.__arcade_vm_ptr_C->data.color1 = PackD3DCOLOR(255, 255, 255, 255);

        SUPERVISOR.d3d_device->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
    }
    return UpdateFuncNext;
}

// 0x455CF0
dllexport gnu_noinline UpdateFuncRet UpdateFuncCC Supervisor::on_draw_H(void* ptr) {
    ANM_MANAGER_PTR->flush_sprites();
    SUPERVISOR.d3d_device->SetRenderTarget(0, SUPERVISOR.back_buffer);
    SUPERVISOR.d3d_device->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, PackD3DCOLOR(255, 0, 0, 0), 1.0f, 0);
    return UpdateFuncNext;
}

// 0x455C90
dllexport gnu_noinline UpdateFuncRet UpdateFuncCC Supervisor::on_draw_arcade_vm_D(void* ptr) {
    if (SUPERVISOR.__surface_1AC) {
        SUPERVISOR.d3d_device->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);

        ANM_MANAGER_PTR->draw_vm(SUPERVISOR.__arcade_vm_ptr_D);
        SUPERVISOR.__arcade_vm_ptr_D->data.color1 = PackD3DCOLOR(255, 255, 255, 255);

        ANM_MANAGER_PTR->flush_sprites();

        SUPERVISOR.d3d_device->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
    }
    return UpdateFuncNext;
}

// 0x455D40
dllexport gnu_noinline UpdateFuncRet UpdateFuncCC Supervisor::on_draw_J(void* ptr) {
    ANM_MANAGER_PTR->flush_sprites();
    SUPERVISOR.cameras[3].__float2_FC = { 0.0f, 0.0f };
    SUPERVISOR.cameras[1].__float2_FC = { 0.0f, 0.0f };
    return UpdateFuncNext;
}

// 0x453640
dllexport gnu_noinline ZUNResult UpdateFuncCC Supervisor::on_registration(void* self) {
    if (THDAT_ARCFILE.__sub_46EB80()) {
        char ver_file_name[64];
        int32_t ver_file_size;
        sprintf(ver_file_name, "th18_%.4x%c.ver", 100, 'a');
        void* ver_file = read_file_to_buffer(ver_file_name, &ver_file_size, false);
        SUPERVISOR.ver_file_buffer = ver_file;
        if (!ver_file) {
            LOG_BUFFER.write_error(JpEnStr("", "error : Wrong data version\r\n"));
        }
    }
    else {
        LOG_BUFFER.write_error(JpEnStr("", "error : data file does not exist\r\n"));
    }
    GAME_SPEED.value = 1.0f;
    SUPERVISOR.background_color = PackD3DCOLOR(255, 0, 0, 0);
    SUPERVISOR.__initialize_cameras();
    SUPERVISOR.__camera2_sub_454F50();
    DWORD time = timeGetTime();
    SUPERVISOR.initial_rng_seed = time;
    REPLAY_RNG.value = time;
    RNG.value = time;
    DWORD thread_id;
    SOUND_MANAGER.__handle_571C = CreateThread(
        NULL,
        0,
        &SoundManager::load_sound_effects,
        &SOUND_MANAGER,
        0,
        &thread_id
    );
    // TODO

    FpsCounter::allocate();
    TICK_COUNTER_PTR = TickCounter::allocate();

    ANM_MANAGER_PTR->__sub_485110();
    __initialize_fonts();

    SUPERVISOR.__arcade_vm_ptr_A = new AnmVM();
    SUPERVISOR.__arcade_vm_ptr_B = new AnmVM();
    SUPERVISOR.__arcade_vm_ptr_C = new AnmVM();
    SUPERVISOR.__arcade_vm_ptr_D = new AnmVM();

    UNKNOWN_FUNC_PTR_A = NULL;
    UNKNOWN_FUNC_PTR_B = NULL;

    return ZUN_SUCCESS;
}

inline UpdateFuncRet thiscall Supervisor::on_tick() {
    if (this->__unknown_bitfield_A == 1) {
        if (!this->__thread_A94.__bool_10) {
            SUPERVISOR.gamemode_switch = 3;
        }
    }
    //SOUND_MANAGER.__sub_476D20();
    if (SoundManagerUnknownE* sme_ptr = SOUND_MANAGER.__unknown_sme_ptr_5704) {
        // TODO
    }

    get_hardware_inputs();

    AnmManager* anm_manager = ANM_MANAGER_PTR;

    nounroll for (size_t i = 0; i < countof(anm_manager->loaded_anm_files); ++i) {
        if (AnmLoaded* anm_loaded = anm_manager->loaded_anm_files[i]) {
            if (anm_loaded->__unload_flag) {
                anm_manager->unload_anm(i);
                anm_loaded->__unload_flag = false;
            } else if (anm_loaded->__load_wait) {
                if (anm_manager->__sub_486920(anm_loaded)) {
                    break;
                }
                return UpdateFuncEnd0;
            }
        }
    }

    if (uint32_t counter = WINDOW_DATA.__counter_2044) {
        WINDOW_DATA.__counter_2044 = counter - 1;
    }

    UpdateFuncRet ret = UpdateFuncNext;
    switch (this->__int_ACC) {
        case 2:
            return UpdateFuncEnd0;
        case 0:
            ret = this->__sub_455040();
            if (ret == UpdateFuncNext) {
                WINDOW_DATA.__int_208C = WINDOW_DATA.__scaled_width / 2;
                WINDOW_DATA.__int_2090 = (WINDOW_DATA.__scaled_height - 448) / 2;
            }
    }

    return ret;
}

// 0x455EC0
dllexport gnu_noinline void thiscall Supervisor::__sub_455EC0() {
    if (!this->__surface_1AC) {
        if (!this->back_buffer) {
            this->d3d_device->GetBackBuffer(0, 0, D3DBACKBUFFER_TYPE_MONO, &this->back_buffer);
        }

        // This doesn't look like the best idea...
        // text_anm might not exist here.
        this->text_anm->images[2].d3d_texture->GetSurfaceLevel(0, &this->__surface_1AC);
        this->text_anm->images[3].d3d_texture->GetSurfaceLevel(0, &this->__surface_1B0);

        AnmVM* arcade_vmA = this->__arcade_vm_ptr_A;
        if (arcade_vmA->data.visible) {
            switch (WINDOW_DATA.__scaled_width) {
                case 640:
                    this->text_anm->__copy_data_to_vm_and_run(arcade_vmA, 66);
                    this->text_anm->__copy_data_to_vm_and_run(this->__arcade_vm_ptr_B, 72);
                    this->text_anm->__copy_data_to_vm_and_run(this->__arcade_vm_ptr_C, 69);
                    this->text_anm->__copy_data_to_vm_and_run(this->__arcade_vm_ptr_D, 75);
                    break;
                case 960:
                    this->text_anm->__copy_data_to_vm_and_run(arcade_vmA, 67);
                    this->text_anm->__copy_data_to_vm_and_run(this->__arcade_vm_ptr_B, 73);
                    this->text_anm->__copy_data_to_vm_and_run(this->__arcade_vm_ptr_C, 70);
                    this->text_anm->__copy_data_to_vm_and_run(this->__arcade_vm_ptr_D, 76);
                    break;
                case 1280:
                    this->text_anm->__copy_data_to_vm_and_run(arcade_vmA, 68);
                    this->text_anm->__copy_data_to_vm_and_run(this->__arcade_vm_ptr_B, 74);
                    this->text_anm->__copy_data_to_vm_and_run(this->__arcade_vm_ptr_C, 71);
                    this->text_anm->__copy_data_to_vm_and_run(this->__arcade_vm_ptr_D, 77);
                    break;
            }
        }
        if (WINDOW_DATA.__game_scale == 1.5f) {
            this->__arcade_vm_ptr_C->data.resample_mode = false;
        }
    }
    else {
        this->cameras[0] = this->cameras[3];
    }
}

inline void AnmLoaded::cleanup() {
    if (this->anm_file) {
        ANM_MANAGER_PTR->mark_all_vms_from_loaded_for_delete(this);

        for (int32_t i = 0; i < this->entry_count; ++i) {
            this->images[i].cleanup();
        }

        SAFE_FREE(this->images);
        SAFE_FREE(this->sprites);
        SAFE_FREE(this->scripts);
        SAFE_FREE(this->__ptr_138);
        SAFE_FREE(this->anm_file);
        SAFE_FREE(this->__vm_array); // Shouldn't this be a delete?
    }
}

// 0x443D80
dllexport gnu_noinline UpdateFuncRet fastcall GameThread::on_draw(void* ptr) {
    AnmManager* anm_manager = ANM_MANAGER_PTR;
    anm_manager->__dword_C4 = 0;
    anm_manager->__dword_C8 = 0;
    anm_manager->__dword_C0 = 0;
    anm_manager->__int_CC = 0;
    return UpdateFuncNext;
}

// 0x43A3F0
dllexport gnu_noinline MsgVM::~MsgVM() {
    nounroll for (size_t i = 0; i < MAX_PORTRAIT_COUNT; ++i) {
        this->player_portraits[i].mark_tree_for_delete();
        this->enemy_portraits[i].mark_tree_for_delete();
    }
    this->__anm_id_60.mark_tree_for_delete();
    for (size_t i = 0; i < MAX_DIALOG_LINE_COUNT; ++i) {
        this->dialogue_lines[i].mark_tree_for_delete();
    }
    for (size_t i = 0; i < MAX_DIALOG_LINE_COUNT; ++i) {
        this->furigana_lines[i].mark_tree_for_delete();
    }
    this->intro.mark_tree_for_delete();
    this->__textbox_related.mark_tree_for_delete();
    // doesn't delete id 7C?
}

// 0x43B350
dllexport gnu_noinline void thiscall Gui::cleanup() {
    AnmManager* anm_manager = ANM_MANAGER_PTR;
    if (!(GAME_MANAGER.__unknown_flag_A | GAME_MANAGER.__unknown_flag_D)) {
        anm_manager->unload_anm(6);
    } else {
        anm_manager->mark_all_vms_from_loaded_slot_for_delete(6);
    }

    SAFE_DELETE(this->msg_vm);

    void* msg_file = this->msg_file;
    if (!(GAME_MANAGER.__unknown_flag_A | GAME_MANAGER.__unknown_flag_D)) {
        SAFE_FREE(this->msg_file);
        msg_file = NULL;
    }
    CACHED_MSG_FILE_PTR = msg_file;

    this->disable_tick();

    this->__anm_id_B8.mark_tree_for_delete();
    this->__anm_id_BC.mark_tree_for_delete();
    this->__anm_id_C8.mark_tree_for_delete();

    // this doesn't look like a good idea
    for (size_t i = 0; i < MAX_BOSS_LIFE_MARKERS; ++i) {
        this->__boss_life_markers[i] = 0;
    }
    nounroll for (size_t i = 0; i < countof(this->__anm_id_array_90); ++i) {
        this->__anm_id_array_90[i].mark_tree_for_delete();
    }

    this->__unknown_field_D = -1;
    this->__boss_life_count = 0;

    // this looks like a worse idea
    for (size_t i = 0; i < MAX_LIFEBARS_IN_GUI; ++i) {
        this->lifebars[i].vms_initialized = false;
    }
}

// 0x43B560
dllexport gnu_noinline Gui::~Gui() {
    this->cleanup();

    UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
    UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);
    UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func_B);
    this->on_tick_func = NULL; // ???

    this->__anm_id_F4.mark_tree_for_delete();
    this->__anm_id_10C.mark_tree_for_delete();
    nounroll for (size_t i = 0; i < countof(this->__anm_id_array_90); ++i) {
        this->__anm_id_array_90[i].mark_tree_for_delete();
    }
    this->__anm_id_44.mark_tree_for_delete();
    this->__anm_id_48.mark_tree_for_delete();

    ANM_MANAGER_PTR->mark_all_vms_from_loaded_slot_for_delete(5);

    GUI_PTR = NULL;
}

inline void Lifebar::interrupt_vms(int32_t interrupt) {
    AnmID* anm_id = &this->main_vm;
    nounroll for (size_t i = 0; i < 3 + MAX_LIFEBAR_MARKERS; ++i) {
        anm_id++->interrupt_tree(interrupt);
    }
}

inline void Lifebar::delete_vms() {
    if (this->vms_initialized) {
        AnmID* anm_id = &this->main_vm;
        nounroll for (size_t i = 0; i < 3 + MAX_LIFEBAR_MARKERS; ++i) {
            anm_id++->mark_tree_for_delete();
        }
        this->vms_initialized = FALSE;
    }
}

// 0x4422C0
dllexport gnu_noinline void thiscall Gui::__sub_4422C0() {
    if (!this->__anm_id_C8.get_vm_ptr()) {
        int32_t script;

        StageData* stage_data = STAGE_DATA_PTR;
        if (GAME_MANAGER.globals.chapter >= 41) {
            script = stage_data->innner[0].__anm_script_24;
        }
        else {
            script = stage_data->__anm_script_80;
        }

        if (script >= 0) {
            script += 154;
            if (script >= 0) {
                this->__anm_id_C8 = this->__anm_loaded_2C0->instantiate_vm_to_world_list_back(script);
            }
        }
    }
}

// 0x441ED0
dllexport gnu_noinline void thiscall Gui::__display_stage_logo() {
    if (SUPERVISOR.gamemode_switch != 8 && GAME_MANAGER.__unknown_flag_E) {
        GUI_PTR->stage_logo_anm->instantiate_vm_to_world_list_back(0);
    }
}

// 0x457570
dllexport gnu_noinline void thiscall Globals::add_life_fragments(int32_t) {
    if (this->life_stocks >= this->life_stock_max) {
        this->life_fragments = 0;
        return;
    }
    int32_t life_fragments = this->life_fragments + 1;
    int32_t life_cost_index = this->lives_added;
    this->life_fragments = life_fragments;

    int32_t fragment_cost;
    if (GAME_MANAGER.globals.difficulty == EXTRA) {
        fragment_cost = LIFE_FRAGMENT_COST_TABLE_EXTRA[life_cost_index];
    } else {
        fragment_cost = LIFE_FRAGMENT_COST_TABLE[life_cost_index];
    }

    if (life_fragments >= fragment_cost) {
        do {
            this->life_fragments -= fragment_cost;
            this->add_life();
        } while (this->life_fragments >= fragment_cost);
    }

    __update_life_ui();
}

// 0x4575F0
dllexport gnu_noinline void thiscall Globals::add_life() {
    int32_t lives = this->life_stocks;
    int32_t max_lives = this->life_stock_max;
    if (lives >= max_lives) {
        this->life_fragments = 0;
    }
    ++lives;
    this->life_stocks = lives;
    if (lives > max_lives) {
        this->life_stocks = max_lives;
        this->life_fragments = 0;
    }

    Gui* gui = GUI_PTR;
    if (gui) {
        gui->__update_life_ui(GAME_MANAGER.globals.life_stocks, GAME_MANAGER.globals.life_fragments, GAME_MANAGER.globals.life_stock_max);
        gui = GUI_PTR;
    }
    
    SOUND_MANAGER.play_sound(17);

    if (gui) {
        gui->__anm_id_BC.mark_tree_for_delete();
        gui->__anm_id_BC = gui->__anm_loaded_2C0->instantiate_vm_to_world_list_back(53);
    }

    ++this->lives_added;
}

// 0x488FA0
dllexport void thiscall AnmVM::set_sprite(int32_t sprite_id) {
    if (AnmLoaded* anm_loaded = ANM_MANAGER_PTR->loaded_anm_files[this->data.slot]) {
        anm_loaded->set_sprite(this, sprite_id);
    }
}

// 0x4894D0
dllexport gnu_noinline AnmLoaded* thiscall AnmVM::get_anm_loaded() {
    return ANM_MANAGER_PTR->loaded_anm_files[this->data.slot];
}

extern "C" {
    // 0x4CF3F8
    externcg LoadingThread* LOADING_THREAD_PTR cgasm("_LOADING_THREAD_PTR");
}

// size: 0x64C
struct LoadingThread : ZUNTask {
    // ZUNTask base; // 0x0
    ZUNThread __thread_C; // 0xC
    unknown_fields(0x4); // 0x28
    AnmVM __vm_2C; // 0x2C
    AnmID __anm_id_638; // 0x638
    AnmLoaded* sig_anm; // 0x63C
    int32_t sig_loaded; // 0x640
    int32_t __ascii_manager_loaded; // 0x644
    int __int_648; // 0x648
    // 0x64C

    inline void zero_contents() {
        zero_this();
    }

    inline LoadingThread() {
        this->zero_contents();
        this->__unknown_task_flag_A = true;
    }

    // 0x452F80
    dllexport gnu_noinline ~LoadingThread();

    inline UpdateFuncRet on_tick();

    inline UpdateFuncRet on_draw();

    // 0x453380
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_tick(void* ptr) asm_symbol_rel(0x453380) {
        return ((LoadingThread*)ptr)->on_tick();
    }

    // 0x4533F0
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw(void* ptr) asm_symbol_rel(0x4533F0) {
        return ((LoadingThread*)ptr)->on_draw();
    }

    // 0x43A870
    dllexport gnu_noinline static unsigned stdcall thread_func_load_front_anm(void* arg) asm_symbol_rel(0x43A870) {
        AnmLoaded* front_anm = ANM_MANAGER_PTR->preload_anm(5, "front.anm");
        if (!front_anm) {
            LOG_BUFFER.write(JpEnStr("", "data is corrupted\r\n"));
            return 1;
        }
        FRONT_ANM_IS_LOADED = true;
        return 0;
    }

    // 0x452CB0
    dllexport gnu_noinline static unsigned cdecl thread_func_A(void* arg) asm_symbol_rel(0x452CB0);

    inline ZUNResult initialize() {
        UpdateFunc* update_func = new UpdateFunc(&on_tick, false, this);
        UpdateFuncRegistry::register_on_tick(update_func, 4);
        this->on_tick_func = update_func;
        update_func = new UpdateFunc(&on_draw, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 74);
        this->on_draw_func = update_func;

        clang_forceinline this->__thread_C.stop_and_cleanup();

        this->__thread_C.start((_beginthreadex_proc_type)thread_func_A, this);

        return ZUN_SUCCESS;
    }

    // 0x4531B0
    dllexport gnu_noinline static LoadingThread* allocate() asm_symbol_rel(0x4531B0) {
        LoadingThread* loading_thread = new LoadingThread();
        LOADING_THREAD_PTR = loading_thread;
        if (ZUN_FAILED(loading_thread->initialize())) {
            delete loading_thread;
            return NULL;
        }
        return loading_thread;
    }
};
#pragma region // LoadingThread Validation
ValidateFieldOffset32(0x0, LoadingThread, task_flags);
ValidateFieldOffset32(0x4, LoadingThread, on_tick_func);
ValidateFieldOffset32(0x8, LoadingThread, on_draw_func);
ValidateFieldOffset32(0xC, LoadingThread, __thread_C);
ValidateFieldOffset32(0x2C, LoadingThread, __vm_2C);
ValidateFieldOffset32(0x638, LoadingThread, __anm_id_638);
ValidateFieldOffset32(0x63C, LoadingThread, sig_anm);
ValidateFieldOffset32(0x640, LoadingThread, sig_loaded);
ValidateFieldOffset32(0x644, LoadingThread, __ascii_manager_loaded);
ValidateFieldOffset32(0x648, LoadingThread, __int_648);
ValidateStructSize32(0x64C, LoadingThread);
#pragma endregion

// size: 0x20
struct EffectData {
    int16_t __effect_anm_file_index; // 0x0
    int16_t __script_id; // 0x2
    AnmVMOnCreateFunc* on_create_func; // 0x4
    int32_t on_tick_index; // 0x8
    int32_t on_draw_index; // 0xC
    int32_t on_destroy_index; // 0x10
    int32_t on_interrupt_index; // 0x14
    int32_t on_copyA_index; // 0x18
    int32_t on_copyB_index; // 0x1C
    // 0x20
};
#pragma region // EffectData Validation
ValidateFieldOffset32(0x0, EffectData, __effect_anm_file_index);
ValidateFieldOffset32(0x2, EffectData, __script_id);
ValidateFieldOffset32(0x4, EffectData, on_create_func);
ValidateFieldOffset32(0x8, EffectData, on_tick_index);
ValidateFieldOffset32(0xC, EffectData, on_draw_index);
ValidateFieldOffset32(0x10, EffectData, on_destroy_index);
ValidateFieldOffset32(0x14, EffectData, on_interrupt_index);
ValidateFieldOffset32(0x18, EffectData, on_copyA_index);
ValidateFieldOffset32(0x1C, EffectData, on_copyB_index);
ValidateStructSize32(0x20, EffectData);
#pragma endregion

// 0x4CCBF8
// this isn't marked const again...
static EffectData EFFECT_DATA_TABLE[5] = {
    { 
        .__effect_anm_file_index = 0,
        .on_create_func = &AnmVM::on_create_special_dataA,
        .on_tick_index = 1,
        .on_draw_index = 1,
        .on_destroy_index = 1,
        .on_interrupt_index = 1,
        .on_copyA_index = 0,
        .on_copyB_index = 0
    },
    {
        .__effect_anm_file_index = 0,
        .on_create_func = &AnmVM::on_create_special_dataB,
        .on_tick_index = 2,
        .on_draw_index = 2,
        .on_destroy_index = 2,
        .on_interrupt_index = 2,
        .on_copyA_index = 1,
        .on_copyB_index = 1,
    },
    {
        .__effect_anm_file_index = 0,
        .on_create_func = &AnmVM::on_create_special_dataC1,
        .on_tick_index = 3,
        .on_draw_index = 3,
        .on_destroy_index = 3,
        .on_interrupt_index = 3,
        .on_copyA_index = 0,
        .on_copyB_index = 0
    },
    {
        .__effect_anm_file_index = 0,
        .on_create_func = &AnmVM::on_create_special_dataC2,
        .on_tick_index = 3,
        .on_draw_index = 3,
        .on_destroy_index = 3,
        .on_interrupt_index = 3,
        .on_copyA_index = 0,
        .on_copyB_index = 0
    },
    {
        .__effect_anm_file_index = 0,
        .on_create_func = &AnmVM::on_create_special_dataD,
        .on_tick_index = 5,
        .on_draw_index = 7,
        .on_destroy_index = 4,
        .on_interrupt_index = 4,
        .on_copyA_index = 0,
        .on_copyB_index = 0
    }
};

typedef struct Effect Effect;

struct Effect {

};
#pragma region // Effect Validation
ValidateFieldOffset32(0x39724B0, AnmManager, __color_39724B0);
ValidateStructSize32(0x39724B8, AnmManager);
#pragma endregion

typedef struct EffectManager EffectManager;
extern "C" {
    // 0x4CF2C8
    externcg EffectManager* EFFECT_MANAGER_PTR cgasm("_EFFECT_MANAGER_PTR");
}

static inline constexpr int32_t MAX_EFFECTS = 0x400;

// size: 0x2040
struct EffectManager : ZUNTask {
    // ZUNTask base; // 0x0
    union {
        AnmLoaded* anm_loaded_array[2]; // 0xC
        struct {
            AnmLoaded* effect_anm; // 0xC
            AnmLoaded* bullet_anm; // 0x10
        };
    };
    unknown_fields(0x4); // 0x14
    int32_t slot_index; // 0x18
    AnmID vm_slots[MAX_EFFECTS]; // 0x1C
    int32_t __slot_indexB; // 0x101C
    AnmID __vm_slotsB[MAX_EFFECTS]; // 0x1020
    ZUNThreadB __thread_2020; // 0x2020
    BOOL __done_loading; // 0x203C
    // 0x2040

    inline void zero_contents() {
        zero_this();
    }

    inline EffectManager() {
        this->zero_contents();
        this->__unknown_task_flag_A = true;
    }

    // 0x42ADD0
    dllexport gnu_noinline ~EffectManager() {
        this->__thread_2020.stop_and_cleanup();
        AnmManager* anm_manager = ANM_MANAGER_PTR;
        anm_manager->mark_all_vms_from_loaded_slot_for_delete(8);
        anm_manager->mark_all_vms_from_loaded_slot_for_delete(7);

        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);

        ANM_MANAGER_PTR->unload_anm(8);
        ANM_MANAGER_PTR->unload_anm(7);

        EFFECT_MANAGER_PTR = NULL;
    }

    // 0x42AF30
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_tick(void* ptr) {
        EffectManager* self = (EffectManager*)ptr;
        for (size_t i = 0; i < MAX_EFFECTS; ++i) {
            (void)self->vm_slots[i].get_vm_ptr();
        }
        return UpdateFuncNext;
    }

    // 0x42AF60
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw(void* ptr) {
        return UpdateFuncNext;
    }

    inline ZUNResult initialize() {
        if (
            (this->bullet_anm = ANM_MANAGER_PTR->preload_anm(7, "bullet.anm")) &&
            (this->effect_anm = ANM_MANAGER_PTR->preload_anm(8, "effect.anm"))
        ) {
            this->__done_loading = 1;
        }
        else {
            LOG_BUFFER.write(JpEnStr("", "data is corrupted\r\n"));
            // no return here?
        }

        UpdateFunc* update_func = new UpdateFunc(&on_tick, false, this);
        UpdateFuncRegistry::register_on_tick(update_func, 32);
        this->on_tick_func = update_func;
        update_func = new UpdateFunc(&on_draw, false, this);
        UpdateFuncRegistry::register_on_draw(update_func, 39);
        this->on_draw_func = update_func;
        this->enable_funcs();

        return ZUN_SUCCESS;
    }

    // 0x42AC70
    dllexport gnu_noinline static EffectManager* allocate() asm_symbol_rel(0x42AC70) {
        EffectManager* effect_manager = new EffectManager();
        EFFECT_MANAGER_PTR = effect_manager;
        if (ZUN_FAILED(effect_manager->initialize())) {
            delete effect_manager;
            return NULL;
        }
        return effect_manager;
    }

    // 0x422D00
    dllexport gnu_noinline int32_t thiscall find_available_slot() asm_symbol_rel(0x422D00) {
        for (int32_t i = 0; i < MAX_EFFECTS; ++i) {
            int32_t cur_slot = this->slot_index;
            int32_t next_slot = cur_slot + 1;
            this->slot_index = next_slot % MAX_EFFECTS;
            if (
                !this->vm_slots[next_slot] ||
                !this->vm_slots[next_slot].get_vm_ptr()
            ) {
                return cur_slot;
            }
        }
        return -1;
    }

    // 0x42D5D0
    dllexport int32_t thiscall fill_available_slot(AnmID id) asm_symbol_rel(0x42D5D0) {
        EffectManager* effect_manager = EFFECT_MANAGER_PTR;

        int32_t slot = effect_manager->find_available_slot();
        if (slot != -1 && slot < MAX_EFFECTS) {
            effect_manager->vm_slots[slot] = id;
            return slot | 0x80000000;
        }
        return 0;
    }

private:
    // 0x422DD0
    dllexport gnu_noinline static AnmID& stdcall __get_slot_vm_id(AnmID& out, int32_t slot) {
        uint32_t masked_slot = slot % (MAX_EFFECTS * 2u);
        if (
            masked_slot < MAX_EFFECTS &&
            slot < 0
        ) {
            out = EFFECT_MANAGER_PTR->vm_slots[masked_slot];
        }
        else {
            out = 0;
        }
        return out;
    }
public:
    inline static AnmID __get_slot_vm_id(int32_t slot) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return __get_slot_vm_id(dummy, slot);
    }

private:
    // 0x42AF70
    dllexport gnu_noinline AnmID& thiscall instantiate_effect_vm_to_world_list_back(AnmID& out, int32_t type, void* on_create_arg, AnmVM* vm) asm_symbol_rel(0x42AF70) {
        out = 0;
        const EffectData& effect_data = EFFECT_DATA_TABLE[type];
        int32_t script = effect_data.__script_id;
        if (script >= 0) {
            if (!vm) {
                out = this->anm_loaded_array[effect_data.__effect_anm_file_index]->instantiate_vm_to_world_list_back(script, -1, NULL);
                vm = out.get_vm_ptr();
            }
            if (AnmVMOnCreateFunc* create_func = effect_data.on_create_func) {
                create_func(vm, on_create_arg);
            }
            vm->controller.on_tick_index = effect_data.on_tick_index;
            vm->controller.on_draw_index = effect_data.on_draw_index;
            vm->controller.on_destroy_index = effect_data.on_destroy_index;
            vm->controller.on_interrupt_index = effect_data.on_interrupt_index;
            vm->controller.on_copy_A_index = effect_data.on_copyA_index;
            vm->controller.on_copy_B_index = effect_data.on_copyB_index;
        }
        return out;
    }
public:
    inline AnmID instantiate_effect_vm_to_world_list_back(int32_t type, void* on_create_arg, AnmVM* vm) {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return this->instantiate_effect_vm_to_world_list_back(dummy, type, on_create_arg, vm);
    }

private:
    // 0x42B0A0
    dllexport gnu_noinline static AnmID& thiscall instantiate_effect_vm_to_ui_list_back(AnmID& out, UNUSED_ARG(int32_t type), UNUSED_ARG(void* on_create_arg), UNUSED_ARG(AnmVM* vm)) {
        EffectManager* effect_manager = EFFECT_MANAGER_PTR;

        out = 0;
        int32_t script = EFFECT_DATA_TABLE[0].__script_id;
        if (script >= 0) {
            out = effect_manager->anm_loaded_array[EFFECT_DATA_TABLE[0].__effect_anm_file_index]->instantiate_vm_to_ui_list_back(script);
            AnmVM* vm = out.get_vm_ptr();
            if (AnmVMOnCreateFunc* create_func = EFFECT_DATA_TABLE[0].on_create_func) {
                create_func(vm, NULL);
            }
            vm->controller.on_tick_index = EFFECT_DATA_TABLE[0].on_tick_index;
            vm->controller.on_draw_index = EFFECT_DATA_TABLE[0].on_draw_index;
            vm->controller.on_destroy_index = EFFECT_DATA_TABLE[0].on_destroy_index;
            vm->controller.on_interrupt_index = EFFECT_DATA_TABLE[0].on_interrupt_index;
            vm->controller.on_copy_A_index = EFFECT_DATA_TABLE[0].on_copyA_index;
            vm->controller.on_copy_B_index = EFFECT_DATA_TABLE[0].on_copyB_index;
        }
        return out;
    }
public:
    inline static AnmID instantiate_effect0_vm_to_ui_list_back() {
        AnmID dummy{ GARBAGE_VALUE(int) };
        return instantiate_effect_vm_to_ui_list_back(dummy, UNUSED_DWORD, GARBAGE_VALUE(void*), GARBAGE_VALUE(AnmVM*));
    }

    // 0x422D70
    dllexport gnu_noinline static int32_t stdcall create_effect(int32_t type, Float3* position, int = UNUSED_DWORD) {
        EffectManager* effect_manager = EFFECT_MANAGER_PTR;
        int32_t slot = effect_manager->find_available_slot();
        if (slot != -1 && slot < MAX_EFFECTS) {
            effect_manager->vm_slots[slot] = effect_manager->instantiate_effect_vm_to_world_list_back(type, position, NULL);
        }
        return 0;
    }

    inline void instantiate_effect_vm_to_world_list_back(int32_t script, Float3* position) {
        int32_t slot = this->find_available_slot();
        if (slot != -1 && slot < MAX_EFFECTS) {
            this->vm_slots[slot] = this->effect_anm->instantiate_vm_to_world_list_back(script, position);
        }
    }
};
#pragma region // EffectManager Validation
ValidateFieldOffset32(0x0, EffectManager, task_flags);
ValidateFieldOffset32(0x4, EffectManager, on_tick_func);
ValidateFieldOffset32(0x8, EffectManager, on_draw_func);
ValidateFieldOffset32(0xC, EffectManager, effect_anm);
ValidateFieldOffset32(0x10, EffectManager, bullet_anm);
ValidateFieldOffset32(0x18, EffectManager, slot_index);
ValidateFieldOffset32(0x1C, EffectManager, vm_slots);
ValidateFieldOffset32(0x101C, EffectManager, __slot_indexB);
ValidateFieldOffset32(0x1020, EffectManager, __vm_slotsB);
ValidateFieldOffset32(0x2020, EffectManager, __thread_2020);
ValidateFieldOffset32(0x203C, EffectManager, __done_loading);
ValidateStructSize32(0x2040, EffectManager);
#pragma endregion

inline void StageCamera::__copy_float2_FC_to_anm_manager() {
    if (AnmManager* anm_manager = ANM_MANAGER_PTR) {
        anm_manager->__float2_D0 = this->__float2_FC;
    }
}

// 0x454760
dllexport HRESULT thiscall Supervisor::d3d_enable_fog() {
    if (this->fog_enabled != TRUE) {
        ANM_MANAGER_PTR->flush_sprites();
        this->fog_enabled = TRUE;
        return this->d3d_device->SetRenderState(D3DRS_FOGENABLE, TRUE);
    }
    return D3D_OK;
}

// 0x4547A0
dllexport HRESULT thiscall Supervisor::d3d_disable_fog() {
    if (this->fog_enabled != FALSE) {
        ANM_MANAGER_PTR->flush_sprites();
        this->fog_enabled = FALSE;
        return this->d3d_device->SetRenderState(D3DRS_FOGENABLE, FALSE);
    }
    return D3D_OK;
}

// 0x4547E0
dllexport HRESULT thiscall Supervisor::d3d_enable_zwrite() {
    if (this->zwrite_enabled != TRUE) {
        ANM_MANAGER_PTR->flush_sprites();
        this->zwrite_enabled = TRUE;
        return this->d3d_device->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
    }
    return D3D_OK;
}

// 0x454820
dllexport HRESULT thiscall Supervisor::d3d_disable_zwrite() {
    if (this->zwrite_enabled != FALSE) {
        ANM_MANAGER_PTR->flush_sprites();
        this->zwrite_enabled = FALSE;
        return this->d3d_device->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
    }
    return D3D_OK;
}

inline HRESULT Supervisor::d3d_zfunc_always() {
    ANM_MANAGER_PTR->flush_sprites();
    return this->d3d_device->SetRenderState(D3DRS_ZFUNC, D3DCMP_ALWAYS);
}

inline HRESULT Supervisor::d3d_zfunc_lessequal() {
    ANM_MANAGER_PTR->flush_sprites();
    return this->d3d_device->SetRenderState(D3DRS_ZFUNC, D3DCMP_LESSEQUAL);
}

// 0x41B330
dllexport void thiscall Supervisor::set_camera_by_index(uint32_t index) {
    StageCamera* camera = &this->cameras[index];
    this->current_camera_ptr = camera;
    this->__sub_4548E0(camera);
    this->d3d_device->SetViewport(&this->current_camera_ptr->__viewport_10C);
    AnmManager* anm_manager = ANM_MANAGER_PTR;
    anm_manager->__float2_D8 = (Float2)this->current_camera_ptr->__int2_104;
    this->current_camera_index = index;
}
// 0x41B3B0
dllexport gnu_noinline void stdcall Supervisor::set_camera2_alt(uint32_t) {
    StageCamera* camera = &SUPERVISOR.cameras[2];
    SUPERVISOR.current_camera_ptr = camera;
    SUPERVISOR.__sub_4548E0(camera);
    SUPERVISOR.d3d_device->SetViewport(&SUPERVISOR.current_camera_ptr->__viewport_124);
    AnmManager* anm_manager = ANM_MANAGER_PTR;
    anm_manager->__float2_D8 = (Float2)SUPERVISOR.current_camera_ptr->__int2_104;
    SUPERVISOR.current_camera_index = 2;
}

inline void thiscall Supervisor::set_camera_by_index_disable_fog(uint32_t index) {
    StageCamera* camera = &this->cameras[index];
    this->current_camera_ptr = camera;
    this->__sub_4548E0(camera);
    this->d3d_device->SetViewport(&this->current_camera_ptr->__viewport_10C);
    AnmManager* anm_manager = ANM_MANAGER_PTR;
    anm_manager->__float2_D8 = (Float2)this->current_camera_ptr->__int2_104;
    this->current_camera_index = index;
    if (this->fog_enabled != FALSE) {
        anm_manager->flush_sprites();
        this->fog_enabled = FALSE;
        this->d3d_device->SetRenderState(D3DRS_FOGENABLE, FALSE);
    }
}

inline void AnmManager::set_modulate_op() {
    if (!ANM_MANAGER_PTR->current_texture_op) {
        SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
        SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
        ANM_MANAGER_PTR->current_texture_op = 1;
    }
}

// 0x4548E0
dllexport gnu_noinline void stdcall Supervisor::__sub_4548E0(StageCamera* camera) {
    if (AnmManager* anm_manager = ANM_MANAGER_PTR) {
        anm_manager->flush_sprites();
    }
    SUPERVISOR.d3d_device->SetTransform(D3DTS_VIEW, &camera->view_matrix);
    SUPERVISOR.d3d_device->SetTransform(D3DTS_PROJECTION, &camera->projection_matrix);
    camera->__copy_float2_FC_to_anm_manager();
}

#pragma region // AnmLoaded instantiate funcs
// 0x488770
dllexport AnmID& thiscall AnmLoaded::instantiate_vm(AnmID& out, int32_t script_index, Float3* position, float z_rotation, int32_t layer, AnmVMCreationFlags flags, AnmVM** raw_out) {
    CRITICAL_SECTION_MANAGER.enter_section(AnmList_CS);
    {
        this->__counter_134++;
        AnmVM* vm = AnmManager::allocate_new_vm();
        if (raw_out) {
            *raw_out = vm;
        }
        this->__copy_data_to_vm(vm, script_index);
        vm->data.rand_mode = NormalRNG;
        if (layer >= 0) {
            vm->data.layer = layer;
            if (layer < 23) {
                vm->data.origin_mode = 1;
            }
        }
        if (!position && !flags.__unknown_flag_B) {
            vm->controller.position = { 0.0f, 0.0f, 0.0f };
        }
        else if (position) {
            if (flags.__unknown_flag_A) {
                vm->controller.position = *position + (Float2){ 320.0f, 16.0f };
            } else {
                vm->controller.position = *position;
            }
        }
        vm->data.rotation.z = z_rotation;
        vm->run_anm();
        vm->data.creation_flags = flags;
        out = 0;
        switch (flags.list_type) {
            case UiListFront:
                out = AnmManager::add_vm_to_ui_list_front(vm);
                vm->data.__unknown_field_B = 0;
                break;
            case UiListBack:
                out = AnmManager::add_vm_to_ui_list_back(vm);
                vm->data.__unknown_field_B = 0;
                break;
            case WorldListFront:
                out = AnmManager::add_vm_to_world_list_front(vm);
                break;
            case WorldListBack:
                out = AnmManager::add_vm_to_world_list_back(vm);
                break;
        }
    }
    CRITICAL_SECTION_MANAGER.leave_section(AnmList_CS);
    return out;
}

inline AnmID& thiscall AnmLoaded::instantiate_vm_to_world_list_back(AnmID& out, int32_t script_index, Float3* position) {
    CRITICAL_SECTION_MANAGER.enter_section(AnmList_CS);
    {
        this->__counter_134++;
        AnmVM* vm = AnmManager::allocate_new_vm();
        this->__copy_data_to_vm(vm, script_index);
        vm->data.rand_mode = NormalRNG;
        vm->controller.position.safe_copy(position);
        vm->data.rotation.z = 0.0f;
        vm->run_anm();
        vm->data.creation_flags = WORLD_LIST_BACK;
        out = AnmManager::add_vm_to_world_list_back(vm);
    }
    CRITICAL_SECTION_MANAGER.leave_section(AnmList_CS);
    return out;
}

inline AnmID& thiscall AnmLoaded::instantiate_vm_to_world_list_back(AnmID& out, int32_t script_index, int32_t layer) {
    CRITICAL_SECTION_MANAGER.enter_section(AnmList_CS);
    {
        this->__counter_134++;
        AnmVM* vm = AnmManager::allocate_new_vm();
        this->__copy_data_to_vm(vm, script_index);
        vm->data.rand_mode = NormalRNG;
        if (layer >= 0) {
            vm->data.layer = layer;
            if (layer < 23) {
                vm->data.origin_mode = 1;
            }
        }
        vm->controller.position = (Float3){ 0.0f, 0.0f, 0.0f };
        vm->data.rotation.z = 0.0f;
        vm->run_anm();
        vm->data.creation_flags = WORLD_LIST_BACK;
        out = AnmManager::add_vm_to_world_list_back(vm);
    }
    CRITICAL_SECTION_MANAGER.leave_section(AnmList_CS);
    return out;
}

inline AnmID& thiscall AnmLoaded::instantiate_vm_to_world_list_back(AnmID& out, int32_t script_index, Float3* position, AnmVM** raw_out) {
    CRITICAL_SECTION_MANAGER.enter_section(AnmList_CS);
    {
        this->__counter_134++;
        AnmVM* vm = AnmManager::allocate_new_vm();
        if (raw_out) {
            *raw_out = vm;
        }
        this->__copy_data_to_vm(vm, script_index);
        vm->data.rand_mode = NormalRNG;
        vm->controller.position.safe_copy(position);
        vm->data.rotation.z = 0.0f;
        vm->run_anm();
        vm->data.creation_flags = WORLD_LIST_BACK;
        out = AnmManager::add_vm_to_world_list_back(vm);
    }
    CRITICAL_SECTION_MANAGER.leave_section(AnmList_CS);
    return out;
}

inline AnmID& thiscall AnmLoaded::instantiate_vm_to_world_list_back(AnmID& out, int32_t script_index, Float3* position, int32_t layer) {
    CRITICAL_SECTION_MANAGER.enter_section(AnmList_CS);
    {
        this->__counter_134++;
        AnmVM* vm = AnmManager::allocate_new_vm();
        this->__copy_data_to_vm(vm, script_index);
        vm->data.rand_mode = NormalRNG;
        if (layer >= 0) {
            vm->data.layer = layer;
            if (layer < 23) {
                vm->data.origin_mode = 1;
            }
        }
        vm->controller.position.safe_copy(position);
        vm->data.rotation.z = 0.0f;
        vm->run_anm();
        vm->data.creation_flags = WORLD_LIST_BACK;
        out = AnmManager::add_vm_to_world_list_back(vm);
    }
    CRITICAL_SECTION_MANAGER.leave_section(AnmList_CS);
    return out;
}

// 0x405BF0
dllexport AnmID& thiscall AnmLoaded::instantiate_vm_to_world_list_back(AnmID& out, int32_t script_index, int32_t layer, AnmVM** raw_out) {
    CRITICAL_SECTION_MANAGER.enter_section(AnmList_CS);
    {
        this->__counter_134++;
        AnmVM* vm = AnmManager::allocate_new_vm();
        if (raw_out) {
            *raw_out = vm;
        }
        this->__copy_data_to_vm(vm, script_index);
        vm->data.rand_mode = NormalRNG;
        if (layer >= 0) {
            vm->data.layer = layer;
            if (layer < 23) {
                vm->data.origin_mode = 1;
            }
        }
        vm->controller.position = (Float3){ 0.0f, 0.0f, 0.0f };
        vm->data.rotation.z = 0.0f;
        vm->run_anm();
        vm->data.creation_flags = WORLD_LIST_BACK;
        out = 0;
        out = AnmManager::add_vm_to_world_list_back(vm);
    }
    CRITICAL_SECTION_MANAGER.leave_section(AnmList_CS);
    return out;
}

inline AnmID& thiscall AnmLoaded::instantiate_vm_to_world_list_back(AnmID& out, int32_t script_index, Float3* position, float z_rotation, int32_t layer) {
    CRITICAL_SECTION_MANAGER.enter_section(AnmList_CS);
    {
        this->__counter_134++;
        AnmVM* vm = AnmManager::allocate_new_vm();
        vm->data.rand_mode = NormalRNG;
        if (layer >= 0) {
            vm->data.layer = layer;
            if (layer < 23) {
                vm->data.origin_mode = 1;
            }
        }
        vm->controller.position.safe_copy(position);
        vm->data.rotation.z = z_rotation;
        vm->run_anm();
        vm->data.creation_flags = WORLD_LIST_BACK;
        out = 0;
        out = AnmManager::add_vm_to_world_list_back(vm);
    }
    CRITICAL_SECTION_MANAGER.leave_section(AnmList_CS);
    return out;
}

// 0x413180
dllexport AnmID& thiscall AnmLoaded::instantiate_vm_to_world_list_back(AnmID& out, int32_t script_index, Float3* position, float z_rotation, int32_t layer, AnmVM** raw_out) {
    CRITICAL_SECTION_MANAGER.enter_section(AnmList_CS);
    {
        this->__counter_134++;
        AnmVM* vm = AnmManager::allocate_new_vm();
        if (raw_out) {
            *raw_out = vm;
        }
        vm->data.rand_mode = NormalRNG;
        if (layer >= 0) {
            vm->data.layer = layer;
            if (layer < 23) {
                vm->data.origin_mode = 1;
            }
        }
        vm->controller.position.safe_copy(position);
        vm->data.rotation.z = z_rotation;
        vm->run_anm();
        vm->data.creation_flags = WORLD_LIST_BACK;
        out = 0;
        out = AnmManager::add_vm_to_world_list_back(vm);
    }
    CRITICAL_SECTION_MANAGER.leave_section(AnmList_CS);
    return out;
}

inline AnmID& thiscall AnmLoaded::instantiate_vm_to_world_list_front(AnmID& out, int32_t script_index) {
    CRITICAL_SECTION_MANAGER.enter_section(AnmList_CS);
    {
        this->__counter_134++;
        AnmVM* vm = AnmManager::allocate_new_vm();
        this->__copy_data_to_vm(vm, script_index);
        vm->data.rand_mode = NormalRNG;
        vm->controller.position = (Float3){ 0.0f, 0.0f, 0.0f };
        vm->data.rotation.z = 0.0f;
        vm->run_anm();
        vm->data.creation_flags = WORLD_LIST_FRONT;
        out = 0;
        out = AnmManager::add_vm_to_world_list_front(vm);
    }
    CRITICAL_SECTION_MANAGER.leave_section(AnmList_CS);
    return out;
}

inline AnmID& thiscall AnmLoaded::instantiate_vm_to_world_list_front(AnmID& out, int32_t script_index, Float3* position) {
    CRITICAL_SECTION_MANAGER.enter_section(AnmList_CS);
    {
        this->__counter_134++;
        AnmVM* vm = AnmManager::allocate_new_vm();
        this->__copy_data_to_vm(vm, script_index);
        vm->data.rand_mode = NormalRNG;
        vm->controller.position.safe_copy(position);
        vm->data.rotation.z = 0.0f;
        vm->run_anm();
        vm->data.creation_flags = WORLD_LIST_FRONT;
        out = 0;
        out = AnmManager::add_vm_to_world_list_front(vm);
    }
    CRITICAL_SECTION_MANAGER.leave_section(AnmList_CS);
    return out;
}

// 0x43A030
dllexport AnmID& thiscall AnmLoaded::instantiate_vm_to_world_list_front(AnmID& out, int32_t script_index, int32_t layer, UNUSED_ARG(AnmVMCreationFlags flags)) {
    CRITICAL_SECTION_MANAGER.enter_section(AnmList_CS);
    {
        this->__counter_134++;
        AnmVM* vm = AnmManager::allocate_new_vm();
        this->__copy_data_to_vm(vm, script_index);
        vm->data.rand_mode = NormalRNG;
        if (layer >= 0) {
            vm->data.layer = layer;
            if (layer < 23) {
                vm->data.origin_mode = 1;
            }
        }
        vm->controller.position = (Float3){ 0.0f, 0.0f, 0.0f };
        vm->data.rotation.z = 0.0f;
        vm->run_anm();
        vm->data.creation_flags = WORLD_LIST_FRONT;
        out = 0;
        out = AnmManager::add_vm_to_world_list_front(vm);
    }
    CRITICAL_SECTION_MANAGER.leave_section(AnmList_CS);
    return out;
}

// 0x43A110
dllexport AnmID& thiscall AnmLoaded::instantiate_vm_to_world_list_front(AnmID& out, int32_t script_index, Float3* position, float z_rotation, UNUSED_ARG(int32_t layer), UNUSED_ARG(AnmVMCreationFlags flags)) {
    CRITICAL_SECTION_MANAGER.enter_section(AnmList_CS);
    {
        this->__counter_134++;
        AnmVM* vm = AnmManager::allocate_new_vm();
        this->__copy_data_to_vm(vm, script_index);
        vm->data.rand_mode = NormalRNG;
        vm->controller.position.safe_copy(position);
        vm->data.rotation.z = z_rotation;
        vm->run_anm();
        vm->data.creation_flags = WORLD_LIST_FRONT;
        out = 0;
        out = AnmManager::add_vm_to_world_list_front(vm);
    }
    CRITICAL_SECTION_MANAGER.leave_section(AnmList_CS);
    return out;
}

// 0x416A10
dllexport AnmID& thiscall AnmLoaded::instantiate_vm_to_ui_list_back(AnmID& out, int32_t script_index, UNUSED_ARG(AnmVMCreationFlags flags)) {
    CRITICAL_SECTION_MANAGER.enter_section(AnmList_CS);
    {
        this->__counter_134++;
        AnmVM* vm = AnmManager::allocate_new_vm();
        this->__copy_data_to_vm(vm, script_index);
        vm->data.rand_mode = NormalRNG;
        vm->controller.position = (Float3){ 0.0f, 0.0f, 0.0f };
        vm->data.rotation.z = 0.0f;
        vm->run_anm();
        vm->data.creation_flags = UI_LIST_BACK;
        out = 0;
        out = AnmManager::add_vm_to_ui_list_back(vm);
        vm->data.__unknown_field_B = 0;
    }
    CRITICAL_SECTION_MANAGER.leave_section(AnmList_CS);
    return out;
}

// 0x409670
dllexport AnmID& thiscall AnmLoaded::instantiate_vm_to_ui_list_back(AnmID& out, int32_t script_index, Float3* position, UNUSED_ARG(AnmVMCreationFlags flags)) {
    CRITICAL_SECTION_MANAGER.enter_section(AnmList_CS);
    {
        this->__counter_134++;
        AnmVM* vm = AnmManager::allocate_new_vm();
        this->__copy_data_to_vm(vm, script_index);
        vm->data.rand_mode = NormalRNG;
        vm->controller.position.safe_copy(position);
        vm->data.rotation.z = 0.0f;
        vm->run_anm();
        vm->data.creation_flags = UI_LIST_BACK;
        out = 0;
        out = AnmManager::add_vm_to_ui_list_back(vm);
        vm->data.__unknown_field_B = 0;
    }
    CRITICAL_SECTION_MANAGER.leave_section(AnmList_CS);
    return out;
}

// 0x409590
dllexport AnmID& thiscall AnmLoaded::instantiate_vm_to_ui_list_front(AnmID& out, int32_t script_index, Float3* position, UNUSED_ARG(AnmVMCreationFlags flags)) {
    CRITICAL_SECTION_MANAGER.enter_section(AnmList_CS);
    {
        this->__counter_134++;
        AnmVM* vm = AnmManager::allocate_new_vm();
        this->__copy_data_to_vm(vm, script_index);
        vm->data.rand_mode = NormalRNG;
        vm->controller.position.safe_copy(position);
        vm->data.rotation.z = 0.0f;
        vm->run_anm();
        vm->data.creation_flags = UI_LIST_FRONT;
        out = 0;
        out = AnmManager::add_vm_to_ui_list_front(vm);
        vm->data.__unknown_field_B = 0;
    }
    CRITICAL_SECTION_MANAGER.leave_section(AnmList_CS);
    return out;
}

// 0x4888F0
dllexport AnmID& thiscall AnmLoaded::instantiate_child_vm(AnmID& out, int32_t script_index, AnmVM* parent, AnmVMCreationFlags flags) {
    CRITICAL_SECTION_MANAGER.enter_section(AnmList_CS);
    {
        this->__counter_134++;
        AnmVM* vm = AnmManager::allocate_new_vm();
        vm->data.rand_mode = NormalRNG;
        vm->data.layer = parent->data.layer;
        vm->controller.position = (Float3){ 0.0f, 0.0f, 0.0f };
        this->__copy_data_to_vm(vm, script_index);
        vm->data.colorize_children = parent->data.colorize_children;
        vm->controller.parent = parent;
        AnmVM* root = parent->controller.__root_vm;
        vm->controller.__root_vm = root ? root : parent;
        vm->run_anm();
        vm->data.creation_flags = flags;
        out = 0;
        switch (flags.list_type) {
            case UiListFront:
                out = AnmManager::add_vm_to_ui_list_front(vm);
                break;
            case UiListBack:
                out = AnmManager::add_vm_to_ui_list_back(vm);
                break;
            case WorldListFront:
                out = AnmManager::add_vm_to_world_list_front(vm);
                break;
            case WorldListBack:
                out = AnmManager::add_vm_to_world_list_back(vm);
                break;
        }
        parent->controller.child_list.append(&vm->controller.child_list_node);
    }
    CRITICAL_SECTION_MANAGER.leave_section(AnmList_CS);
    return out;
}

// 0x488A40
dllexport AnmID& thiscall AnmLoaded::instantiate_orphan_vm_to_world_list_back(AnmID& out, int32_t script_index, AnmVM* parent, UNUSED_ARG(AnmVMCreationFlags flags)) {
    CRITICAL_SECTION_MANAGER.enter_section(AnmList_CS);
    {
        this->__counter_134++;
        AnmVM* vm = AnmManager::allocate_new_vm();
        this->__copy_data_to_vm(vm, script_index);
        vm->data.rand_mode = NormalRNG;
        vm->data.layer = parent->data.layer;
        vm->data.colorize_children = parent->data.colorize_children;
        vm->controller.position = parent->controller.position;
        vm->data.rotation = parent->data.rotation;
        vm->data.__position_2 = parent->data.position;
        vm->run_anm();
        vm->data.creation_flags = WORLD_LIST_BACK;
        out = 0;
        out = AnmManager::add_vm_to_world_list_back(vm);
    }
    CRITICAL_SECTION_MANAGER.leave_section(AnmList_CS);
    return out;
}
#pragma endregion

inline AnmInstruction* AnmVM::get_current_instruction() {
    int32_t anm_slot = this->data.slot;
    AnmManager* anm_manager = ANM_MANAGER_PTR;
    int32_t script_index = this->data.script_id;
    AnmInstruction* current_instruction = (*anm_manager->loaded_anm_files[anm_slot]->scripts)[script_index];
    return IndexInstr(this->data.current_instruction_offset);
}

// 0x488E30
dllexport AnmVM* AnmID::get_vm_ptr() {
    AnmVM* vm = ANM_MANAGER_PTR->get_vm_with_id(*this);
    if (!vm) {
        this->full = 0;
    }
    return vm;
}

inline int32_t AnmID::run_vm() {
    AnmManager* anm_manager = ANM_MANAGER_PTR;
    AnmVM* vm = ANM_MANAGER_PTR->get_vm_with_id(*this);
    if (!vm) {
        this->full = 0;
        vm = &anm_manager->__vm_E4;
    }
    return vm->run_anm();
}

// 0x488E50
dllexport void AnmID::interrupt_tree(int32_t interrupt_index) {
    AnmManager::interrupt_tree(*this, interrupt_index);
}

inline void AnmID::interrupt_and_run_tree(int32_t interrupt_index) {
    AnmManager::interrupt_and_run_tree(*this, interrupt_index);
}

inline void AnmID::__tree_set_visible2(AnmManager* anm_manager) {
    if (AnmVM* vm = anm_manager->get_vm_with_id(*this)) {
        vm->data.__visible2 = true;
        vm->controller.child_list.for_each([](AnmVM* vm) static_lambda {
            vm->__tree_set_visible2();
        });
    }
}

// 0x488E70
dllexport void AnmID::__tree_set_visible2() {
    this->__tree_set_visible2(ANM_MANAGER_PTR);
}

// 0x488EB0
dllexport void AnmID::__tree_clear_visible2() {
    if (AnmVM* vm = ANM_MANAGER_PTR->get_vm_with_id(*this)) {
        vm->data.__visible2 = false;
        vm->controller.child_list.for_each([](AnmVM* vm) static_lambda {
            vm->__tree_clear_visible2();
        });
    }
}

inline void AnmID::mark_tree_for_delete(AnmManager* anm_manager) {
    anm_manager->mark_tree_id_for_delete(*this);
    this->full = NULL;
}

// 0x488F50
dllexport void AnmID::mark_tree_for_delete() {
    AnmManager::mark_tree_id_for_delete(*this);
    this->full = NULL;
}

inline void AnmID::set_position(Float3* position) {
    if (AnmVM* vm = ANM_MANAGER_PTR->get_vm_with_id(*this)) {
        vm->data.position.set(*position);
    }
}

// 0x488F70
dllexport void thiscall AnmID::set_controller_position(Float3* position) {
    if (AnmVM* vm = ANM_MANAGER_PTR->get_vm_with_id(*this)) {
        vm->controller.position.set(*position);
    }
}

// 0x488FD0
dllexport void thiscall AnmID::__sub_488FD0(int32_t script) {
    AnmManager* anm_manager_ptr = ANM_MANAGER_PTR;
    if (AnmVM* vm = anm_manager_ptr->get_vm_with_id(*this)) {
        AnmLoaded* anm_loaded = anm_manager_ptr->loaded_anm_files[vm->data.slot];
        vm->data.visible = false;
        *this = anm_loaded->instantiate_vm_to_world_list_back(script);
        vm->data.slot = anm_loaded->slot_index;
        vm->data.slot2 = anm_loaded->slot_index;
    }
}

// 0x4892F0
dllexport void thiscall AnmID::set_color1(D3DCOLOR color) {
    AnmVM* vm = ANM_MANAGER_PTR->get_vm_with_id(*this);
    if (!vm) {
        this->full = 0;
        return;
    }
    vm->data.color1 = color;
}

// 0x489230
dllexport gnu_noinline AnmVM* thiscall AnmID::__wtf_child_list_jank_A(int32_t script, uint32_t arg2) {
    AnmVM* vm = ANM_MANAGER_PTR->get_vm_with_id(*this);
    if (!vm) {
        this->full = 0;
        return NULL;
    }
    // zun, you literally just checked the ID
    // why
    return this->get_vm_ptr()->__wtf_child_list_jank_A(script, arg2);
}

inline void AnmLoaded::__prepare_vm_data(AnmVM* vm, int32_t script_id) {
    vm->data.script_id2 = script_id;
    vm->data.slot = this->slot_index;
    vm->data.slot2 = this->slot_index;
    vm->data.mirror_x = false;
    vm->data.mirror_y = false;
    vm->data.__unknown_field_B = 2;
    vm->data.script_id = script_id;
    vm->data.current_instruction_offset = 0;
    vm->controller.__timer_1C.reset();
    vm->controller.script_time.reset();
    vm->data.visible = false;
}

inline void AnmLoaded::__prepare_vm(AnmVM* vm, int32_t script_id) {
    if ((*this->scripts)[script_id]) {
        vm->reset();
        this->__prepare_vm_data(vm, script_id);
    } else {
        vm->zero_contents();
    }
}

dllexport void AnmLoaded::__sub_477D60(AnmVM* vm, int32_t script_id) {
    if ((*this->scripts)[script_id] && !this->__load_wait) {
        this->__prepare_vm_data(vm, script_id);
        vm->run_anm();
        ANM_MANAGER_PTR->__dword_C0++;
        if (vm->data.__unknown_field_B == 2) {
            vm->data.__unknown_field_B = 1;
        }
    } else {
        vm->zero_contents();
    }
}

//template<size_t initial_size, size_t batch_size>
//struct AnmVMIDHack {
//    AnmVM** id_array = (AnmVM**)calloc(initial_size, sizeof(AnmVM*));
//    size_t array_size = initial_size;
//    size_t previous_index = 0;
//
//    dllexport gnu_noinline AnmVM** allocate_anm_id() {
//        AnmVM** id_array = this->id_array;
//        AnmVM** new_id = &id_array[this->previous_index];
//        AnmVM** starting_id = new_id;
//        AnmVM** array_end_id = &id_array[this->array_size];
//        do {
//            if (unpredictable(!*new_id)) {
//                this->previous_index = new_id - id_array;
//                return new_id;
//            }
//            ++new_id;
//            if (expect(new_id == array_end_id, false)) {
//                new_id = id_array;
//            }
//        } while (expect(new_id != starting_id, true));
//        size_t prev_size = this->array_size;
//        size_t new_size = prev_size + batch_size;
//        auto new_array = (AnmVM**)realloc(id_array, sizeof(AnmVM*) * new_size);
//        if (expect(new_array != NULL, true)) {
//            this->id_array = new_array;
//            this->array_size = new_size;
//            this->previous_index = prev_size;
//            return (AnmVM**)__builtin_memset(&new_array[prev_size], 0, sizeof(AnmVM*) * batch_size);
//        }
//        return NULL;
//    }
//};
//
//dllexport AnmVMIDHack<0x8000, 0x100> anm_hack;

// 0x4573F0
dllexport gnu_noinline BOOL thiscall Globals::add_power(int32_t amount) {
    int32_t power = this->current_power;
    int32_t max_power = this->max_power;
    if (power >= max_power) {
        return false;
    }
    power += amount;
    this->current_power = power;
    if (power > max_power) {
        this->current_power = max_power;
        Gui* gui = GUI_PTR;
        gui->__anm_id_BC.mark_tree_for_delete();
        gui->__anm_id_BC = gui->__anm_loaded_2C0->instantiate_vm_to_world_list_back(33);
        power = this->current_power;
    }
    int32_t prev_level = (power - amount) / this->power_per_level;
    int32_t new_level = power / this->power_per_level;
    return prev_level != new_level;
}

// 0x457480
dllexport gnu_noinline BOOL thiscall Globals::subtract_power(int32_t amount) {
    int32_t power = this->current_power;
    int32_t min_power = this->power_per_level;
    if (power <= min_power) {
        return false;
    }
    power -= amount;
    this->current_power = power;
    if (power < min_power) {
        this->current_power = min_power;
        power = min_power;
    }
    int32_t prev_level = (power + amount) / min_power; // power_per_level
    int32_t new_level = power / min_power; // power_per_level
    return prev_level != new_level;
}

// 0x4B660C
static inline constexpr int32_t LIFE_FRAGMENT_INTERRUPT_TABLE[] = {
    0, 1, 2, 0, 0
};

// 0x441F10
dllexport gnu_noinline void thiscall Gui::__update_life_ui(int32_t life_count, int32_t life_fragments, int32_t life_max) {
    AnmVM* life_icon0 = this->player_life_icons[0];
    
    AnmVM** life_vms = this->player_life_icons;
    if (life_icon0) {
        float offset = (LIFE_ICONS_IN_GUI - life_max) * 28.0f;

        Float3 position(offset, 0.0f, 0.0f);

        int32_t final_life_index = 0;

        life_icon0->controller.position = position;
        for (size_t i = 1; i < LIFE_ICONS_IN_GUI; ++i) {
            this->player_life_icons[i]->controller.position = position;
        }

        if (life_count > 0) {
            final_life_index = life_count;
            do {
                (*life_vms++)->interrupt(2);
            } while (--life_count);
        }
        if (final_life_index < life_max) {
            AnmVM* partial_life_vm = this->player_life_icons[final_life_index];

            partial_life_vm->interrupt(7 + LIFE_FRAGMENT_INTERRUPT_TABLE[life_fragments]);

            ++final_life_index;

            if (final_life_index < life_max) {
                AnmVM** empty_life_vms = &this->player_life_icons[final_life_index];

                uint32_t empty_life_icons = life_max - final_life_index;
                do {
                    (*empty_life_vms++)->interrupt(3);
                } while (--empty_life_icons);
            }
        }

        if (final_life_index < (uint32_t)LIFE_ICONS_IN_GUI) {
            life_vms = this->player_life_icons;

            AnmVM** empty_life_vms = &this->player_life_icons[final_life_index];

            uint32_t empty_life_icons = LIFE_ICONS_IN_GUI - final_life_index;
            do {
                (*empty_life_vms++)->interrupt(5);
            } while (--empty_life_icons);
        }
    }
}

// 0x4B6600
static inline constexpr int32_t BOMB_FRAGMENT_INTERRUPT_TABLE[] = {
    0, 1, 2
};

// 0x4420E0
dllexport gnu_noinline void thiscall Gui::__update_bomb_ui(int32_t bomb_count, int32_t bomb_fragments, int32_t bomb_max) {
    AnmVM* bomb_icon0 = this->player_bomb_icons[0];
    
    AnmVM** bomb_vms = this->player_bomb_icons;
    if (bomb_icon0) {
        float offset = (BOMB_ICONS_IN_GUI - bomb_max) * 28.0f;

        Float3 position(offset, 0.0f, 0.0f);

        int32_t final_bomb_index = 0;

        bomb_icon0->controller.position = position;
        for (size_t i = 1; i < BOMB_ICONS_IN_GUI; ++i) {
            this->player_bomb_icons[i]->controller.position = position;
        }

        if (bomb_count > 0) {
            final_bomb_index = bomb_count;
            do {
                (*bomb_vms++)->interrupt(2);
            } while (--bomb_count);
        }
        if (final_bomb_index < bomb_max) {
            AnmVM* partial_bomb_vm = this->player_bomb_icons[final_bomb_index];

            partial_bomb_vm->interrupt(7 + BOMB_FRAGMENT_INTERRUPT_TABLE[bomb_fragments]);

            ++final_bomb_index;

            if (final_bomb_index < bomb_max) {
                AnmVM** empty_bomb_vms = &this->player_bomb_icons[final_bomb_index];

                uint32_t empty_bomb_icons = bomb_max - final_bomb_index;
                do {
                    (*empty_bomb_vms++)->interrupt(3);
                } while (--empty_bomb_icons);
            }
        }

        if (final_bomb_index < (uint32_t)BOMB_ICONS_IN_GUI) {
            bomb_vms = this->player_bomb_icons;

            AnmVM** empty_bomb_vms = &this->player_bomb_icons[final_bomb_index];

            uint32_t empty_bomb_icons = BOMB_ICONS_IN_GUI - final_bomb_index;
            do {
                (*empty_bomb_vms++)->interrupt(5);
            } while (--empty_bomb_icons);
        }
    }
}

// 0x43A730
dllexport gnu_noinline ZUNResult thiscall Gui::__initialize() {
    AnmLoaded* stage_logo_anm = AnmManager::preload_anm(STAGE_LOGO_ANM_INDEX, STAGE_DATA_PTR->logo_anm_filename);
    this->stage_logo_anm = stage_logo_anm;
    if (!stage_logo_anm) goto corrupted_data_error;
    if (void* cached_msg_file = CACHED_MSG_FILE_PTR) {
        this->msg_file = cached_msg_file;
        DebugLogger::__debug_log_stub_8("%s load Skip\n", STAGE_DATA_PTR->msg_filenames[GAME_MANAGER.globals.shottype_index()]);
        CACHED_MSG_FILE_PTR = NULL;
    } else {
        void* msg_file = read_file_from_dat(STAGE_DATA_PTR->msg_filenames[GAME_MANAGER.globals.shottype_index()]);
        this->msg_file = msg_file;
        if (!msg_file) goto corrupted_data_error;
    }
    this->__timer_13C.reset();
    this->__score = GAME_MANAGER.globals.score;
    this->spell_timer_seconds = -1;
    this->spell_timer_hundredths = -1;
    return ZUN_SUCCESS;
corrupted_data_error:
    LOG_BUFFER.write(JpEnStr("", "data is corrupted\r\n"));
    return ZUN_ERROR;
}

// 0x43B800
dllexport gnu_noinline Gui* Gui::allocate() {
    Gui* gui = new Gui();
    GUI_PTR = gui;

    while (!FRONT_ANM_IS_LOADED) {
        Sleep(10);
    }

    AnmLoaded* anm_loaded = ANM_MANAGER_PTR->preload_anm(5, "fronttr.anm");
    gui->__anm_loaded_2C0 = anm_loaded;

    if (
        !anm_loaded ||
        ZUN_FAILED(gui->__initialize())
    ) {
        LOG_BUFFER.write(JpEnStr("", "data is corrupted\r\n"));
        delete gui;
        return NULL;
    }

    UpdateFunc* update_func = new UpdateFunc(&on_tick, false, gui);
    UpdateFuncRegistry::register_on_tick(update_func, 33);
    gui->on_tick_func = update_func;
    update_func = new UpdateFunc(&on_draw, false, gui);
    UpdateFuncRegistry::register_on_draw(update_func, 53);
    gui->on_draw_func = update_func;
    update_func = new UpdateFunc(&on_draw_B, false, gui);
    UpdateFuncRegistry::register_on_draw(update_func, 49);
    gui->on_draw_func_B = update_func;

    return gui;
}

typedef struct AsciiManager AsciiManager;

// size: 0x138
struct AsciiString {
    char text[0x100]; // 0x0
    Float3 position; // 0x100
    D3DCOLOR color; // 0x10C
    Float2 scale; // 0x110
    int __dword_118; // 0x118
    int __dword_11C; // 0x11C
    int font_id; // 0x120
    BOOL enable_shadows; // 0x124
    uint32_t group; // 0x128
    int32_t duration; // 0x12C
    int __horizontal_positioning_mode; // 0x130
    int __vertical_positioning_mode; // 0x134
    // 0x138
};
#pragma region // AsciiString Validation
ValidateFieldOffset32(0x0, AsciiString, text);
ValidateFieldOffset32(0x100, AsciiString, position);
ValidateFieldOffset32(0x10C, AsciiString, color);
ValidateFieldOffset32(0x110, AsciiString, scale);
ValidateFieldOffset32(0x120, AsciiString, font_id);
ValidateFieldOffset32(0x124, AsciiString, enable_shadows);
ValidateFieldOffset32(0x128, AsciiString, group);
ValidateFieldOffset32(0x12C, AsciiString, duration);
ValidateFieldOffset32(0x130, AsciiString, __horizontal_positioning_mode);
ValidateFieldOffset32(0x134, AsciiString, __vertical_positioning_mode);
ValidateStructSize32(0x138, AsciiString);
#pragma endregion

extern "C" {
    // 0x4CF2AC
    externcg AsciiManager* ASCII_MANAGER_PTR cgasm("_ASCII_MANAGER_PTR");
}

#if INCLUDE_PATCH_CODE
dllexport uint32_t score_upper[3] = { rand(), rand(), rand() };
#endif

// size: 0x19278
struct AsciiManager : ZUNTask {
    // ZUNTask base; // 0x0
    AnmVM __vm_C; // 0xC
    AnmVM __vm_618; // 0x618
    AsciiString strings[320]; // 0xC24
    int32_t string_count; // 0x19224
    D3DCOLOR color; // 0x19228
    D3DCOLOR color2; // 0x1922C
    Float2 scale; // 0x19230
    int __dword_19238; // 0x19238
    int __dword_1923C; // 0x1923C
    BOOL enable_shadows; // 0x19240
    int font_id; // 0x19244
    uint32_t group; // 0x19248
    int32_t duration; // 0x1924C
    int __horizontal_positioning_mode; // 0x19250
    int __vertical_positioning_mode; // 0x19254
    int __character_spacing_for_font_0; // 0x19258
    int frame_count; // 0x1925C
    AnmLoaded* ascii_anm; // 0x19260
    AnmID __vm_id_19264; // 0x19264
    AnmID __vm_id_19268; // 0x19268
    UpdateFunc* on_draw_func_group_1; // 0x1926C
    UpdateFunc* on_draw_func_group_2; // 0x19270
    UpdateFunc* on_draw_func_group_3; // 0x19274
    // 0x19278

    inline void zero_contents() {
        zero_this();
    }

    inline AsciiManager() {
        this->zero_contents();
        this->__unknown_task_flag_A = true;
        this->color = PackD3DCOLOR(255, 255, 255, 255);
        this->color2 = PackD3DCOLOR(255, 0, 0, 0);
        this->scale.x = 1.0f;
        this->scale.y = 1.0f;
        this->__dword_1923C = 0;
        this->__character_spacing_for_font_0 = 9;
        this->__horizontal_positioning_mode = 1;
        this->__vertical_positioning_mode = 1;
    }

    // 0x419690
    dllexport gnu_noinline ~AsciiManager() {
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func_group_1);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func_group_2);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func_group_3);

        ANM_MANAGER_PTR->unload_anm(2);
        ANM_MANAGER_PTR->unload_anm(0);

        ASCII_MANAGER_PTR = NULL;
    }

    // This functions is disgusting
    // 0x41A2B0
    dllexport gnu_noinline void thiscall draw_string(AsciiString* string) asm_symbol_rel(0x41A2B0) {
        use_var(string);
    }

    // 0x41A180
    dllexport gnu_noinline UpdateFuncRet thiscall draw_group(uint32_t group) asm_symbol_rel(0x41A180) {
        for (int32_t i = 0; i < this->string_count; ++i) {
            if (this->strings[i].group == group) {
                this->draw_string(&this->strings[i]);
            }
        }
        ANM_MANAGER_PTR->flush_sprites();
        SUPERVISOR.set_camera_by_index(2);
        return UpdateFuncNext;
    }

    // Yes, the original code was something terrible like this
    // 0x4198B0
    dllexport static UpdateFuncRet UpdateFuncCC on_tick(void* ptr) {
        AsciiManager* self = (AsciiManager*)ptr;
        int32_t live_index = 0;
        AsciiString* cur_string = self->strings;
        AsciiString* live_string = cur_string;
        for (int32_t cur_index = 0; cur_index < self->string_count; ++cur_index) {
            if (--self->strings[cur_index].duration >= 0) {
                if (cur_index != live_index) {
                    *live_string++ = *cur_string;
                }
                ++live_index;
            }
            ++cur_string;
        }
        ++self->frame_count;
        self->string_count = live_index;
        return UpdateFuncNext;
    }

    // 0x419940
    dllexport static UpdateFuncRet UpdateFuncCC on_draw_group_0(void* ptr) {
        return ((AsciiManager*)ptr)->draw_group(0);
    }

    // 0x419950
    dllexport static UpdateFuncRet UpdateFuncCC on_draw_group_1(void* ptr) {
        AsciiManager* self = (AsciiManager*)ptr;
        SUPERVISOR.set_camera_by_index(0);
        ANM_MANAGER_PTR->flush_sprites();
        self->__vm_C.data.origin_mode = 2;
        self->draw_group(1);
        self->__vm_C.data.origin_mode = 0;
        SUPERVISOR.set_camera_by_index(2);
        return UpdateFuncNext;
    }

    // 0x419A80
    dllexport static UpdateFuncRet UpdateFuncCC on_draw_group_2(void* ptr) {
        AsciiManager* self = (AsciiManager*)ptr;
        SUPERVISOR.set_camera2_alt();
        UpdateFuncRet ret = self->draw_group(2);
        SUPERVISOR.set_camera_by_index(2);
        return ret;
    }

    // 0x419B10
    dllexport static UpdateFuncRet UpdateFuncCC on_draw_group_3(void* ptr) {
        AsciiManager* self = (AsciiManager*)ptr;
        SUPERVISOR.set_camera_by_index(2);
        return self->draw_group(3);
    }

    // 0x419B90
    dllexport gnu_noinline void thiscall add_string(Float3* position, const char* str) asm_symbol_rel(0x419B90) {
        int32_t next_index = this->string_count;
        if (next_index < countof(this->strings)) {
            AsciiString& string = this->strings[next_index];
            this->string_count = next_index + 1;

            byteloop_strcpy(string.text, str);
            string.position = *position;
            string.position *= WINDOW_DATA.__game_scale;
            string.group = this->group;
            string.color = this->color;
            string.scale = this->scale; // Copied as integers
            string.__dword_11C = this->__dword_19238;
            string.font_id = this->font_id;
            string.enable_shadows = this->enable_shadows;
            string.duration = this->duration;
            string.__horizontal_positioning_mode = this->__horizontal_positioning_mode;
            string.__vertical_positioning_mode = this->__vertical_positioning_mode;
        }
    }

    // 0x419CB0
    dllexport gnu_noinline void cdecl printf(Float3* position, const char* format, ...) asm_symbol_rel(0x419CB0) {
        va_list va;
        va_start(va, format);
        char buffer[0x100];
        vsprintf(buffer, format, va);
        //va_end(va);
        switch (this->font_id) {
            case 10: {
                D3DCOLOR prev_color = this->color;
                this->color = this->color2;
                this->font_id = 11;
                this->add_string(position, buffer);
                this->font_id = 10;
                this->color = prev_color;
                break;
            }
            case 7: {
                D3DCOLOR prev_color = this->color;
                this->color = this->color2;
                this->font_id = 9;
                this->add_string(position, buffer);
                this->font_id = 7;
                this->color = prev_color;
                break;
            }
            case 6: {
                D3DCOLOR prev_color = this->color;
                this->color = this->color2;
                this->font_id = 8;
                this->add_string(position, buffer);
                this->font_id = 6;
                this->color = prev_color;
                break;
            }
        }
        this->add_string(position, buffer);
    }

private:
    inline void print_number_impl(Float3* position, uint32_t number) {
        char buffer[0x100];
        if (number < 1000) {
            sprintf(buffer, "%d", number);
        }
        else {
            uint32_t hundreds = number % 1000;
            uint32_t thousands = number / 1000;
            if (number < 1000000) {
                sprintf(buffer, "%d,%.3d", thousands, hundreds);
            }
            else {
                thousands %= 1000;
                uint32_t millions = (number / 1000000) % 1000;
                if (number < 1000000000) {
                    sprintf(buffer, "%d,%.3d,%.3d", millions, thousands, hundreds);
                }
                else {
                    uint32_t billions = (number / 1000000000) % 1000;
                    sprintf(buffer, "%d,%.3d,%.3d,%.3d", billions, millions, thousands, hundreds);
                }
            }
        }
        switch (this->font_id) {
            case 10: {
                D3DCOLOR prev_color = this->color;
                this->color = this->color2;
                this->font_id = 11;
                this->add_string(position, buffer);
                this->font_id = 10;
                this->color = prev_color;
                break;
            }
        }
        this->add_string(position, buffer);
    }
public:
    // 0x419DD0
    dllexport gnu_noinline void thiscall print_number(Float3* position, uint32_t number) asm_symbol_rel(0x419DD0) {
        ASCII_MANAGER_PTR->print_number_impl(position, number);
    }
    
private:
    inline void print_score_impl(Float3* position, uint32_t score, uint32_t continues) {
        char buffer[0x100];
        if (score < 100) {
            sprintf(buffer, "%d", score * 10 + continues);
        }
        else {
            uint32_t hundreds = score % 100;
            uint32_t thousands = score / 100;
            if (score < 100000) {
                sprintf(buffer, "%d,%.2d%d", thousands, hundreds, continues);
            }
            else {
                thousands %= 1000;
                uint32_t millions = (score / 100000) % 1000;
                if (score < 10000000) {
                    sprintf(buffer, "%d,%.3d,%.2d%d", millions, thousands, hundreds, continues);
                }
                else {
                    uint32_t billions = (score / 100000000) % 1000;
                    sprintf(buffer, "%d,%.3d,%.3d,%.2d%d", billions, millions, thousands, hundreds, continues);
                }
            }
        }
        switch (this->font_id) {
            case 10: {
                D3DCOLOR prev_color = this->color;
                this->color = this->color2;
                this->font_id = 11;
                this->add_string(position, buffer);
                this->font_id = 10;
                this->color = prev_color;
                break;
            }
            case 7: {
                D3DCOLOR prev_color = this->color;
                this->color = this->color2;
                this->font_id = 9;
                this->add_string(position, buffer);
                this->font_id = 7;
                this->color = prev_color;
                break;
            }
            case 6: {
                D3DCOLOR prev_color = this->color;
                this->color = this->color2;
                this->font_id = 8;
                this->add_string(position, buffer);
                this->font_id = 6;
                this->color = prev_color;
                break;
            }
        }
        this->add_string(position, buffer);
    }
public:
    // 0x419F30
    dllexport gnu_noinline static void stdcall print_score(Float3* position, uint32_t score, uint32_t continues) asm_symbol_rel(0x419F30) {
        ASCII_MANAGER_PTR->print_score_impl(position, score, continues);
    }

#if INCLUDE_PATCH_CODE
    dllexport gnu_noinline static void stdcall print_score_bigger(Float3* position, uint32_t score, uint32_t continues) {
        uint64_t big_score = score | (uint64_t)score_upper[1 + (*(uint32_t*)&position->y == 0x42800000)] << 32;

        char buffer[32];
        char* buffer_write = &buffer[31];
        *buffer_write = '\0';
        *--buffer_write = '0' + continues;
        uint8_t comma_counter = 2;

        while (big_score) {
            uint8_t digit = big_score % 10;
            big_score /= 10;
            *--buffer_write = '0' + digit;
            if (!--comma_counter && big_score) {
                comma_counter = 3;
                *--buffer_write = ',';
            }
        }

        AsciiManager* ascii_manager = ASCII_MANAGER_PTR;

        switch (ascii_manager->font_id) {
            case 10: {
                D3DCOLOR prev_color = ascii_manager->color;
                ascii_manager->color = ascii_manager->color2;
                ascii_manager->font_id = 11;
                ascii_manager->add_string(position, buffer_write);
                ascii_manager->font_id = 10;
                ascii_manager->color = prev_color;
                break;
            }
            case 7: {
                D3DCOLOR prev_color = ascii_manager->color;
                ascii_manager->color = ascii_manager->color2;
                ascii_manager->font_id = 9;
                ascii_manager->add_string(position, buffer_write);
                ascii_manager->font_id = 7;
                ascii_manager->color = prev_color;
                break;
            }
            case 6: {
                D3DCOLOR prev_color = ascii_manager->color;
                ascii_manager->color = ascii_manager->color2;
                ascii_manager->font_id = 8;
                ascii_manager->add_string(position, buffer_write);
                ascii_manager->font_id = 6;
                ascii_manager->color = prev_color;
                break;
            }
        }
        ascii_manager->add_string(position, buffer_write);
    }
#endif

    // 0x41A110
    dllexport gnu_noinline void cdecl debugf(Float3* position, const char* format, ...) asm_symbol_rel(0x41A110) {
        va_list va;
        va_start(va, format);
        char buffer[0x100];
        vsprintf(buffer, format, va);
        //va_end(va);
        this->add_string(position, buffer);
        this->strings[this->string_count - 1].font_id = 1;
    }

    inline ZUNResult initialize() {
        const char* ascii_filename;
        if (WINDOW_DATA.__game_scale <= 1.1f) {
            ascii_filename = "ascii.anm";
        }
        else if (WINDOW_DATA.__game_scale <= 1.6f) {
            ascii_filename = "ascii_960.anm";
        }
        else {
            ascii_filename = "ascii1280.anm";
        }

        AnmLoaded* ascii_anm = ANM_MANAGER_PTR->preload_anm(2, ascii_filename);
        this->ascii_anm = ascii_anm;
        if (!ascii_anm) {
            LOG_BUFFER.write(JpEnStr("", "data is corrupted\r\n"));
            return ZUN_ERROR;
        }

        UpdateFunc* update_func = new UpdateFunc(&on_tick, false, this);
        UpdateFuncRegistry::register_on_tick(update_func, 5);
        this->on_tick_func = update_func;
        update_func = new UpdateFunc(&on_draw_group_0, false, this);
        UpdateFuncRegistry::register_on_draw(update_func, 88);
        this->on_draw_func = update_func;
        update_func = new UpdateFunc(&on_draw_group_1, false, this);
        UpdateFuncRegistry::register_on_draw(update_func, 55);
        this->on_draw_func_group_1 = update_func;
        update_func = new UpdateFunc(&on_draw_group_2, false, this);
        UpdateFuncRegistry::register_on_draw(update_func, 72);
        this->on_draw_func_group_2 = update_func;
        update_func = new UpdateFunc(&on_draw_group_3, false, this);
        UpdateFuncRegistry::register_on_draw(update_func, 63);
        this->on_draw_func_group_3 = update_func;

        this->ascii_anm->__set_initial_sprite(&this->__vm_C, 0);
        this->ascii_anm->__set_initial_sprite(&this->__vm_618, 98);
        return ZUN_SUCCESS;
    }

    // 0x419390
    dllexport gnu_noinline static AsciiManager* allocate() asm_symbol_rel(0x419390) {
        AsciiManager* ascii_manager = new AsciiManager();
        ASCII_MANAGER_PTR = ascii_manager;
        if (ZUN_FAILED(ascii_manager->initialize())) {
            delete ascii_manager;
            return NULL;
        }
        return ascii_manager;
    }

private:
    inline void set_defaults_impl() {
        this->color = PackD3DCOLOR(255, 255, 255, 255);
        this->color2 = PackD3DCOLOR(255, 0, 0, 0);
        this->__dword_1923C = 0;
        this->__character_spacing_for_font_0 = 9;
        this->scale.x = 1.0f;
        this->scale.y = 1.0f;
        this->enable_shadows = FALSE;
        this->font_id = 0;
        this->group = 0;
        this->duration = 0;
        this->__horizontal_positioning_mode = 1;
        this->__vertical_positioning_mode = 1;
    }

public:
    // 0x416AE0
    dllexport gnu_noinline static void set_defaults() {
        ASCII_MANAGER_PTR->set_defaults_impl();
    }

    inline uint8_t get_alpha() {
        return ALPHA(this->color);
    }

    inline void set_alpha(uint8_t value) {
        ALPHA(this->color) = value;
    }

    inline uint8_t get_alpha2() {
        return ALPHA(this->color2);
    }

    inline void set_alpha2(uint8_t value) {
        ALPHA(this->color2) = value;
    }

    // 0x42CB60
    dllexport gnu_noinline static void __interrupt_1_and_wipe_vm_id_19268() {
        AnmID& anm_id = ASCII_MANAGER_PTR->__vm_id_19268;
        anm_id.interrupt_tree(1);
        anm_id = 0;
    }

private:
    // 0x42CB90
    dllexport gnu_noinline static void vectorcall __instantiate_vm_id_19268(float, float x, float y) {
        AsciiManager* ascii_manager_ptr = ASCII_MANAGER_PTR;
        Float3 position = { x + x, y + y, 0.0f };
        if (!ascii_manager_ptr->__vm_id_19268) {
            ascii_manager_ptr->__vm_id_19268 = ascii_manager_ptr->ascii_anm->instantiate_vm_to_world_list_back(17, &position);
        }
    }
public:
    inline static void __instantiate_vm_id_19268(float x, float y) {
        return __instantiate_vm_id_19268(UNUSED_FLOAT, x, y);
    }
};
#pragma region // AsciiManager Validation
ValidateFieldOffset32(0x0, AsciiManager, task_flags);
ValidateFieldOffset32(0x4, AsciiManager, on_tick_func);
ValidateFieldOffset32(0x8, AsciiManager, on_draw_func);
ValidateFieldOffset32(0xC, AsciiManager, __vm_C);
ValidateFieldOffset32(0x618, AsciiManager, __vm_618);
ValidateFieldOffset32(0xC24, AsciiManager, strings);
ValidateFieldOffset32(0x19224, AsciiManager, string_count);
ValidateFieldOffset32(0x19228, AsciiManager, color);
ValidateFieldOffset32(0x1922C, AsciiManager, color2);
ValidateFieldOffset32(0x19230, AsciiManager, scale);
ValidateFieldOffset32(0x19240, AsciiManager, enable_shadows);
ValidateFieldOffset32(0x19244, AsciiManager, font_id);
ValidateFieldOffset32(0x19248, AsciiManager, group);
ValidateFieldOffset32(0x1924C, AsciiManager, duration);
ValidateFieldOffset32(0x19250, AsciiManager, __horizontal_positioning_mode);
ValidateFieldOffset32(0x19254, AsciiManager, __vertical_positioning_mode);
ValidateFieldOffset32(0x19258, AsciiManager, __character_spacing_for_font_0);
ValidateFieldOffset32(0x1925C, AsciiManager, frame_count);
ValidateFieldOffset32(0x19260, AsciiManager, ascii_anm);
ValidateFieldOffset32(0x19264, AsciiManager, __vm_id_19264);
ValidateFieldOffset32(0x19268, AsciiManager, __vm_id_19268);
ValidateFieldOffset32(0x1926C, AsciiManager, on_draw_func_group_1);
ValidateFieldOffset32(0x19270, AsciiManager, on_draw_func_group_2);
ValidateFieldOffset32(0x19274, AsciiManager, on_draw_func_group_3);
ValidateStructSize32(0x19278, AsciiManager);
#pragma endregion

#define ParseIntArg(number) \
this->get_int_arg(IntArg(number), current_instruction->param_mask, number)

#define ParseIntPtrArg(number) \
this->get_int_ptr_arg(&IntArg(number), current_instruction->param_mask, number)

#define ParseFloatArg(number) \
this->get_float_arg(FloatArg(number), current_instruction->param_mask, number)

#define ParseFloatPtrArg(number) \
this->get_float_ptr_arg(&FloatArg(number), current_instruction->param_mask, number)

// 0x478580
dllexport gnu_noinline int32_t thiscall AnmVM::run_anm() {
    using namespace Anm;

    float previous_gamespeed = GAME_SPEED; // ESP+1C
    if (this->data.slowdown_immune) {
        GAME_SPEED.value = 1.0f;
    }
    if (this->get_custom_slowdown() > 0.0f) {
        float new_gamespeed = previous_gamespeed - (this->get_custom_slowdown() * previous_gamespeed);
        GAME_SPEED.value = new_gamespeed;
        if (new_gamespeed < 0.0f) {
            GAME_SPEED.value = 0.0f;
        }
    }
    if (ZUN_FAILED(this->run_on_tick())) {
        goto return_delete;
    }
    if (
        this->data.current_instruction_offset < 0 ||
        this->data.__unknown_flag_O
    ) {
        goto return_static;
    }
    clang_noinline ++this->controller.__timer_1C;

    AnmInstruction* current_instruction;
    if (this->data.run_interrupt) {
        current_instruction = this->get_current_instruction();
        goto run_interrupt;
    }
    if (this->data.__unknown_field_B == 1) {
        GameThread* game_thread = GAME_THREAD_PTR;
        if (
            game_thread && game_thread->__unknown_flag_B
        ) {
            goto return_static;
        }
    }
    for (;;) {
        current_instruction = this->get_current_instruction();
        if ((int32_t)current_instruction->time > this->controller.script_time) break;
        switch (current_instruction->opcode) {
            case jump: // 200
                clang_noinline this->controller.script_time.set(IntArg(1));
                this->data.current_instruction_offset = IntArg(0);
                continue;
            case loop: { // 201
                int32_t* write = ParseIntPtrArg(0);
                *write -= 1;
                if (ParseIntArg(0) <= 0) {
                    break;
                }
                clang_noinline this->controller.script_time.set(IntArg(2));
                this->data.current_instruction_offset = IntArg(1);
                continue;
            }
            case wait: // 6
                this->controller.script_time.add_raw(-ParseIntArg(0));
                break;
            case anm_halt_invisible: // 4
                this->data.visible = false;
            case anm_halt: // 3
                // Volatile read to force the compiler to emit
                // the code rather than optimizing it out based
                // on the earlier check of this same variable.
                if (*(volatile int32_t*)&this->data.run_interrupt) {
            run_interrupt:
                    int32_t search_offset = 0; // ESP+18
                    int32_t last_good_offset = 0; // ESP+14
                    AnmInstruction* last_good_instruction = NULL; // ESP+20
                    AnmInstruction* search_instruction = this->get_anm_loaded()->get_script(this->data.script_id);
                    for (;;) {
                        switch ((uint16_t)search_instruction->opcode) {
                            case interrupt_label: { // 5
                                int32_t interrupt_number = *(int32_t*)&search_instruction->args[0];
                                if (this->data.run_interrupt == interrupt_number) {
                                    goto end_interrupt_search;
                                }
                                if (interrupt_number == -1) {
                                    uint32_t offset_to_next = search_instruction->offset_to_next;
                                    last_good_offset = search_offset;
                                    search_offset += offset_to_next;
                                    last_good_instruction = search_instruction;
                                    search_instruction = pointer_raw_offset(search_instruction, offset_to_next);
                                    continue;
                                }
                                break;
                            }
                            case 0xFFFF:
                                goto end_interrupt_search;
                        }
                        uint32_t offset_to_next = search_instruction->offset_to_next;
                        search_offset += offset_to_next;
                        search_instruction = pointer_raw_offset(search_instruction, offset_to_next);
                    }
            end_interrupt_search:
                    this->data.__visible3 = false;
                    this->data.run_interrupt = 0;

                    if (search_instruction->opcode != interrupt_label) {
                        if (!last_good_instruction) {
                            // Is this bugged because it's not
                            // checking for anm_halt_invisible?
                            if (current_instruction->opcode != anm_halt) {
                                continue;
                            }
                            goto interrupt_fail;
                        }
                        current_instruction = last_good_instruction;
                        search_offset = last_good_offset;
                    } else {
                        current_instruction = search_instruction;
                    }

                    this->data.interrupt_return_time.set_from_timer(this->controller.script_time);
                    this->data.interrupt_return_offset = this->data.current_instruction_offset;
                    search_offset += current_instruction->offset_to_next;
                    clang_noinline this->controller.script_time.set(current_instruction->time);
                    this->data.visible = true;
                    this->data.current_instruction_offset = search_offset;
                    continue;
                }
                else {
                    this->data.__visible3 = true;
                }
            interrupt_fail:
                clang_noinline this->controller.script_time--;
                goto anm_break;
            case interrupt_return: // 7
                this->controller.script_time.set_from_timer(this->data.interrupt_return_time);
                this->data.current_instruction_offset = this->data.interrupt_return_offset;
                continue;
            case set_int: { // 100
                int32_t value = ParseIntArg(1);
                int32_t* write = ParseIntPtrArg(0);
                *write = value;
                break;
            }
            case set_float: { // 101
                float value = ParseFloatArg(1);
                float* write = ParseFloatPtrArg(0);
                *write = value;
                break;
            }
            case math_int_add: { // 112
                int32_t lhs = ParseIntArg(1);
                int32_t rhs = ParseIntArg(2);
                int32_t* write = ParseIntPtrArg(0);
                *write = lhs + rhs;
                break;
            }
            case math_float_add: { // 113
                float lhs = ParseFloatArg(1);
                float rhs = ParseFloatArg(2);
                float* write = ParseFloatPtrArg(0);
                *write = lhs + rhs;
                break;
            }
            case math_int_sub: { // 114
                int32_t lhs = ParseIntArg(1);
                int32_t rhs = ParseIntArg(2);
                int32_t* write = ParseIntPtrArg(0);
                *write = lhs - rhs;
                break;
            }
            case math_float_sub: { // 115
                float lhs = ParseFloatArg(1);
                float rhs = ParseFloatArg(2);
                float* write = ParseFloatPtrArg(0);
                *write = lhs - rhs;
                break;
            }
            case math_int_mul: { // 116
                int32_t lhs = ParseIntArg(1);
                int32_t rhs = ParseIntArg(2);
                int32_t* write = ParseIntPtrArg(0);
                *write = lhs * rhs;
                break;
            }
            case math_float_mul: { // 117
                float lhs = ParseFloatArg(1);
                float rhs = ParseFloatArg(2);
                float* write = ParseFloatPtrArg(0);
                *write = lhs * rhs;
                break;
            }
            case math_int_div: { // 118
                int32_t lhs = ParseIntArg(1);
                int32_t rhs = ParseIntArg(2);
                int32_t* write = ParseIntPtrArg(0);
                *write = lhs / rhs;
                break;
            }
            case math_float_div: { // 119
                float lhs = ParseFloatArg(1);
                float rhs = ParseFloatArg(2);
                float* write = ParseFloatPtrArg(0);
                *write = lhs / rhs;
                break;
            }
            case math_int_mod: { // 120
                int32_t lhs = ParseIntArg(1);
                int32_t rhs = ParseIntArg(2);
                int32_t* write = ParseIntPtrArg(0);
                *write = lhs % rhs;
                break;
            }
            case math_float_mod: { // 121
                float rhs = ParseFloatArg(2);
                float lhs = ParseFloatArg(1);
                float* write = ParseFloatPtrArg(0);
                *write = zfmodf(lhs, rhs);
                break;
            }
            case math_int_add_assign: { // 102
                int32_t value = ParseIntArg(1);
                int32_t* write = ParseIntPtrArg(0);
                *write += value;
                break;
            }
            case math_float_add_assign: { // 103
                float value = ParseFloatArg(1);
                float* write = ParseFloatPtrArg(0);
                *write += value;
                break;
            }
            case math_int_sub_assign: { // 104
                int32_t value = ParseIntArg(1);
                int32_t* write = ParseIntPtrArg(0);
                *write -= value;
                break;
            }
            case math_float_sub_assign: { // 105
                float value = ParseFloatArg(1);
                float* write = ParseFloatPtrArg(0);
                *write -= value;
                break;
            }
            case math_int_mul_assign: { // 106
                int32_t value = ParseIntArg(1);
                int32_t* write = ParseIntPtrArg(0);
                *write *= value;
                break;
            }
            case math_float_mul_assign: { // 107
                float value = ParseFloatArg(1);
                float* write = ParseFloatPtrArg(0);
                *write *= value;
                break;
            }
            case math_int_div_assign: { // 108
                int32_t value = ParseIntArg(1);
                int32_t* write = ParseIntPtrArg(0);
                *write /= value;
                break;
            }
            case math_float_div_assign: { // 109
                float value = ParseFloatArg(1);
                float* write = ParseFloatPtrArg(0);
                *write /= value;
                break;
            }
            case math_int_mod_assign: { // 110
                int32_t value = ParseIntArg(1);
                int32_t* write = ParseIntPtrArg(0);
                *write %= value;
                break;
            }
            case math_float_mod_assign: { // 111
                float rhs = ParseFloatArg(1);
                float lhs = ParseFloatArg(0);
                float* write = ParseFloatPtrArg(0);
                *write = zfmodf(lhs, rhs);
                break;
            }
            case set_int_rand_bound: { // 122
                int32_t range = ParseIntArg(1);
                int32_t* write = ParseIntPtrArg(0);
                *write = RNG.rand_uint_range(range);
                break;
            }
            case set_float_rand_bound: { // 123
                float range = ParseFloatArg(1);
                float* write = ParseFloatPtrArg(0);
                *write = RNG.rand_float_range(range);
                break;
            }
            case math_sin: { // 124
                float angle = ParseFloatArg(1);
                float* write = ParseFloatPtrArg(0);
                *write = zsinf(angle);
                break;
            }
            case math_cos: { // 125
                float angle = ParseFloatArg(1);
                float* write = ParseFloatPtrArg(0);
                *write = zcosf(angle);
                break;
            }
            case math_tan: { // 126
                float angle = ParseFloatArg(1);
                float* write = ParseFloatPtrArg(0);
                *write = ztanf(angle);
                break;
            }
            case math_acos: { // 127
                float angle = ParseFloatArg(1);
                float* write = ParseFloatPtrArg(0);
                *write = zacosf(angle);
                break;
            }
            case math_atan: { // 128
                float angle = ParseFloatArg(1);
                float* write = ParseFloatPtrArg(0);
                *write = zatanf(angle);
                break;
            }
            case math_reduce_angle: { // 129
                float value = ParseFloatArg(0);
                float* write = ParseFloatPtrArg(0);
                *write = reduce_angle_add(value, 0.0f); // This looks a *lot* like old engine code
                break;
            }
            case math_circle_pos_fast: { // 130
                float radius = ParseFloatArg(3);
                float angle = ParseFloatArg(2);
                float* y = ParseFloatPtrArg(1);
                float* x = ParseFloatPtrArg(0);
                circle_pos(x, y, angle, radius);
                break;
            }
            case math_circle_pos_rand: { // 131
                Float3 position;
                float min = ParseFloatArg(2);
                float max = ParseFloatArg(3);
                float rand = RNG.rand_float_signed();
                float radius = lerp(min, max, rand);
                float angle = RNG.rand_angle();
                position.make_from_vector(angle, radius);
                float* x = ParseFloatPtrArg(0);
                *x = position.x;
                float* y = ParseFloatPtrArg(1);
                *y = position.y;
                break;
            }
            case jump_int_equ: { // 202
                int32_t lhs = ParseIntArg(0);
                int32_t rhs = ParseIntArg(1);
                if (lhs == rhs) {
                    clang_noinline this->controller.script_time.set(IntArg(3));
                    this->data.current_instruction_offset = IntArg(2);
                    continue;
                }
                break;
            }
            case jump_float_equ: { // 203
                float lhs = ParseFloatArg(0);
                float rhs = ParseFloatArg(1);
                if (lhs == rhs) {
                    clang_noinline this->controller.script_time.set(IntArg(3));
                    this->data.current_instruction_offset = IntArg(2);
                    continue;
                }
                break;
            }
            case jump_int_neq: { // 204
                int32_t lhs = ParseIntArg(0);
                int32_t rhs = ParseIntArg(1);
                if (lhs != rhs) {
                    clang_noinline this->controller.script_time.set(IntArg(3));
                    this->data.current_instruction_offset = IntArg(2);
                    continue;
                }
                break;
            }
            case jump_float_neq: { // 205
                float lhs = ParseFloatArg(0);
                float rhs = ParseFloatArg(1);
                if (lhs != rhs) {
                    clang_noinline this->controller.script_time.set(IntArg(3));
                    this->data.current_instruction_offset = IntArg(2);
                    continue;
                }
                break;
            }
            case jump_int_les: { // 206
                int32_t lhs = ParseIntArg(0);
                int32_t rhs = ParseIntArg(1);
                if (lhs < rhs) {
                    clang_noinline this->controller.script_time.set(IntArg(3));
                    this->data.current_instruction_offset = IntArg(2);
                    continue;
                }
                break;
            }
            case jump_float_les: { // 207
                float lhs = ParseFloatArg(0);
                float rhs = ParseFloatArg(1);
                if (lhs < rhs) {
                    clang_noinline this->controller.script_time.set(IntArg(3));
                    this->data.current_instruction_offset = IntArg(2);
                    continue;
                }
                break;
            }
            case jump_int_leq: { // 208
                int32_t lhs = ParseIntArg(0);
                int32_t rhs = ParseIntArg(1);
                if (lhs <= rhs) {
                    clang_noinline this->controller.script_time.set(IntArg(3));
                    this->data.current_instruction_offset = IntArg(2);
                    continue;
                }
                break;
            }
            case jump_float_leq: { // 209
                float lhs = ParseFloatArg(0);
                float rhs = ParseFloatArg(1);
                if (lhs <= rhs) {
                    clang_noinline this->controller.script_time.set(IntArg(3));
                    this->data.current_instruction_offset = IntArg(2);
                    continue;
                }
                break;
            }          
            case jump_int_gre: { // 210
                int32_t lhs = ParseIntArg(0);
                int32_t rhs = ParseIntArg(1);
                if (lhs > rhs) {
                    clang_noinline this->controller.script_time.set(IntArg(3));
                    this->data.current_instruction_offset = IntArg(2);
                    continue;
                }
                break;
            }
            case jump_float_gre: { // 211
                float lhs = ParseFloatArg(0);
                float rhs = ParseFloatArg(1);
                if (lhs > rhs) {
                    clang_noinline this->controller.script_time.set(IntArg(3));
                    this->data.current_instruction_offset = IntArg(2);
                    continue;
                }
                break;
            }
            case jump_int_geq: { // 212
                int32_t lhs = ParseIntArg(0);
                int32_t rhs = ParseIntArg(1);
                if (lhs >= rhs) {
                    clang_noinline this->controller.script_time.set(IntArg(3));
                    this->data.current_instruction_offset = IntArg(2);
                    continue;
                }
                break;
            }
            case jump_float_geq: { // 213
                float lhs = ParseFloatArg(0);
                float rhs = ParseFloatArg(1);
                if (lhs >= rhs) {
                    clang_noinline this->controller.script_time.set(IntArg(3));
                    this->data.current_instruction_offset = IntArg(2);
                    continue;
                }
                break;
            }
            
            case sprite_set: { // 300
                this->data.visible = true;

                int32_t sprite;
                if (int32_t index = this->controller.on_sprite_lookup_index) {
                    sprite = ANM_ON_SPRITE_LOOKUP_FUNCS[index](this, ParseIntArg(0));
                } else {
                    sprite = ParseIntArg(0);
                }

                AnmLoaded* anm_loaded;
                if (sprite < 0) { // why is this here?
                    sprite = 288;
                    anm_loaded = ASCII_MANAGER_PTR->ascii_anm;
                } else {
                    // this doesn't check if the slot is actually loaded...
                    anm_loaded = ANM_MANAGER_PTR->loaded_anm_files[this->data.slot];
                }

                anm_loaded->set_sprite(this, sprite);

                this->data.__last_sprite_set_time = this->controller.script_time;
                break;
            }
            case anm_flag_slowdown_immune: // 432
                this->data.slowdown_immune = ParseIntArg(0);
                break;
            case anm_create_child_back: { // 500
                int32_t script = ParseIntArg(0);
                ANM_MANAGER_PTR->loaded_anm_files[this->data.slot]->instantiate_child_vm(script, this, WORLD_LIST_BACK);
                break;
            }
            case anm_create_child_back_rel: { // 505
                int32_t script = ParseIntArg(0);
                AnmID child = ANM_MANAGER_PTR->loaded_anm_files[this->data.slot]->instantiate_child_vm(script, this, WORLD_LIST_BACK);
                AnmVM* child_vm = child.get_vm_ptr();
                child_vm->data.__position_2.x = ParseFloatArg(1);
                child_vm->data.__position_2.y = ParseFloatArg(2);
                break;
            }
            case anm_create_child_front: { // 502
                int32_t script = ParseIntArg(0);
                ANM_MANAGER_PTR->loaded_anm_files[this->data.slot]->instantiate_child_vm(script, this, WORLD_LIST_FRONT);
                break;
            }
            case anm_create_child_ui_back: { // 501
                int32_t script = ParseIntArg(0);
                ANM_MANAGER_PTR->loaded_anm_files[this->data.slot]->instantiate_child_vm(script, this, UI_LIST_BACK);
                break;
            }
            case anm_create_child_ui_front: { // 503
                int32_t script = ParseIntArg(0);
                ANM_MANAGER_PTR->loaded_anm_files[this->data.slot]->instantiate_child_vm(script, this, UI_LIST_FRONT);
                break;
            }
            case copy_parent_context: // 509
                if (AnmVM* parent = this->controller.parent) {
                    this->data.current_context = parent->data.current_context;
                }
                break;
            case anm_create_back_rel: { // 506
                int32_t script = ParseIntArg(0);
                AnmID orphan = ANM_MANAGER_PTR->loaded_anm_files[this->data.slot]->instantiate_orphan_vm_to_world_list_back(script, this, WORLD_LIST_BACK);
                AnmVM* orphan_vm = orphan.get_vm_ptr();
                orphan_vm->data.__position_2.x = ParseFloatArg(1);
                orphan_vm->data.__position_2.y = ParseFloatArg(2);
                break;
            }
            case anm_create_back: { // 504
                int32_t script = ParseIntArg(0);
                ANM_MANAGER_PTR->loaded_anm_files[this->data.slot]->instantiate_orphan_vm_to_world_list_back(script, this, WORLD_LIST_BACK);
                break;
            }
            case effect_create: { // 508
                // this effectively overrides the current VM state
                int32_t type = ParseIntArg(0);
                EFFECT_MANAGER_PTR->instantiate_effect_vm_to_world_list_back(type, this, this);
                break;
            }
            case sprite_set_rand_bound: { // 301
                this->data.visible = true;

                int32_t sprite;
                if (int32_t index = this->controller.on_sprite_lookup_index) {
                    int32_t min_sprite = ParseIntArg(0);
                    int32_t range = ParseIntArg(1);
                    sprite = min_sprite + RNG.rand_uint_range(range);
                    sprite = ANM_ON_SPRITE_LOOKUP_FUNCS[index](this, ParseIntArg(0));
                } else {
                    int32_t min_sprite = ParseIntArg(0);
                    int32_t range = ParseIntArg(1);
                    sprite = min_sprite + RNG.rand_uint_range(range);
                }

                AnmLoaded* anm_loaded;
                if (sprite < 0) { // why is this here?
                    sprite = 288;
                    anm_loaded = ASCII_MANAGER_PTR->ascii_anm;
                } else {
                    // this doesn't check if the slot is actually loaded...
                    anm_loaded = ANM_MANAGER_PTR->loaded_anm_files[this->data.slot];
                }

                anm_loaded->set_sprite(this, sprite);

                this->data.__last_sprite_set_time = this->controller.script_time;
                break;
            }
            case scale: // 402
                this->data.scale.x = ParseFloatArg(0);
                this->set_y_scale(ParseFloatArg(1));
                break;
            case scale2: // 434
                this->data.scale2.x = ParseFloatArg(0);
                this->set_y_scale2(ParseFloatArg(1));
                break;
            case uv_scale: // 429
                this->data.uv_scale.x = ParseFloatArg(0);
                this->set_v_scale(ParseFloatArg(1));
                break;
            case alpha: // 403
                this->set_alpha(ParseIntArg(0));
                break;
            case color: // 404
                RED(this->data.color1) = ParseIntArg(0);
                GREEN(this->data.color1) = ParseIntArg(1);
                BLUE(this->data.color1) = ParseIntArg(2);
                break;
            case alpha_gradient: // 405
                this->set_alpha2(ParseIntArg(0));
                break;
            case color_gradient: // 406
                RED(this->data.color2) = ParseIntArg(0);
                GREEN(this->data.color2) = ParseIntArg(1);
                BLUE(this->data.color2) = ParseIntArg(2);
                break;
            case scale_flip_x: // 308
                this->data.mirror_x ^= true;
                this->data.scale_enabled = true;
                this->data.scale.x *= -1.0f;
                break;
            case scale_flip_y: // 309
                this->data.mirror_y ^= true;
                this->data.scale_enabled = true;
                this->data.scale.y *= -1.0f;
                break;
            case anm_flag_color_children: // 315
                this->data.colorize_children = IntArg(0); // IMMEDIATE ARGUMENT
                break;
            case __anm_flag_set_visible2: // 316
                this->data.__visible2 = true;
                break;
            case __anm_flag_clear_visible2: // 317
                this->data.__visible2 = false;
                break;
            case camera_fade: // 439
                this->data.enable_camera_fade = IntArg(0); // IMMEDIATE ARGUMENT
                this->data.camera_near_fade_end = FloatArg(1); // IMMEDIATE ARGUMENT
                this->data.camera_near_clip = FloatArg(2); // IMMEDIATE ARGUMENT
                break;
            case rotation: // 401
                this->data.rotation.x = ParseFloatArg(0);
                this->data.rotation.y = ParseFloatArg(1);
                this->set_z_rotation(ParseFloatArg(2));
                break;
            case rotation_speed: { // 415
                float velocity_z = ParseFloatArg(2);
                float velocity_y = ParseFloatArg(1);
                float velocity_x = ParseFloatArg(0);
                this->set_angular_velocity(velocity_x, velocity_y, velocity_z);
                break;
            }
            case scale_speed: { // 416
                float velocity_y = ParseFloatArg(1);
                float velocity_x = ParseFloatArg(0);
                this->set_scale_delta(velocity_x, velocity_y);
                break;
            }
            case alpha_interp_linear: { // 417
                int32_t end_time = ParseIntArg(1);
                uint8_t final_alpha = IntArg(0); // IMMEDIATE ARGUMENT
                this->initialize_alpha_interp(end_time, Linear, this->get_alpha(), final_alpha);
                break;
            }
            case blend_mode: // 303
                this->data.blend_mode = IntArg(0); // IMMEDIATE_ARGUMENT
                break;
            case move_position: // 400
                if (this->data.position_mode == 0) {
                    float position_z = ParseFloatArg(2);
                    float position_y = ParseFloatArg(1);
                    float position_x = ParseFloatArg(0);
                    this->data.position = { position_x, position_y, position_z };
                } else {
                    float position_z = ParseFloatArg(2);
                    float position_y = ParseFloatArg(1);
                    float position_x = ParseFloatArg(0);
                    this->data.__position_2 = { position_x, position_y, position_z };
                }
                break;
            case anchor_offset: // 436
                this->data.anchor_offset.x = ParseFloatArg(0);
                this->data.anchor_offset.y = ParseFloatArg(1);
                break;
            case rotation_mode: // 437
                this->data.rotation_mode = ParseIntArg(0);
                break;
            case anm_flag_visible: // 310
                this->data.visible = IntArg(0); // IMMEDIATE ARGUMENT
                break;
            case anchor_mode: // 421
                this->data.x_anchor_mode = UShortArg(0); // IMMEDIATE ARGUMENT
                this->data.y_anchor_mode = UShortArg(1); // IMMEDIATE ARGUMENT
                break;
            case scroll_speed_x: // 425
                this->set_x_scroll_speed(ParseFloatArg(0));
                break;
            case scroll_speed_y: // 426
                this->set_y_scroll_speed(ParseFloatArg(0));
                break;
            case anm_flag_disable_z_write: // 305
                this->data.disable_z_write = IntArg(0); // IMMEDIATE ARGUMENT
                break;
            case __anm_flag_unknown_std_A: // 306
                this->data.__unknown_std_flag_A = IntArg(0); // IMMEDIATE ARGUMENT
                break;
            case resample_mode: // 311
                this->data.resample_mode = IntArg(0); // IMMEDIATE ARGUMENT
                break;
            case move_position_interp: { // 407
                int32_t end_time = ParseIntArg(0);
                this->data.position_interp.set_end_time(end_time);
                this->data.position_interp.set_bezier1(UNKNOWN_FLOAT3_A);
                this->data.position_interp.set_bezier2(UNKNOWN_FLOAT3_A);
                int32_t mode = IntArg(1); // IMMEDIATE ARGUMENT
                this->data.position_interp.set_mode(mode);
                this->data.position_interp.set_initial_value(this->data.position_mode == 0 ? this->data.position : this->data.__position_2);
                float position_z = ParseFloatArg(4);
                float position_y = ParseFloatArg(3);
                float position_x = ParseFloatArg(2);
                Float3 position = { position_x, position_y, position_z };
                this->data.position_interp.set_final_value(position);
                this->data.position_interp.reset_timer();
                break;
            }
            case move_velocity_interp: { // 433
                int32_t end_time = ParseIntArg(0);
                this->data.position_interp.set_end_time(end_time);
                this->data.position_interp.set_bezier1(UNKNOWN_FLOAT3_A);
                this->data.position_interp.set_bezier2(UNKNOWN_FLOAT3_A);
                int32_t mode = IntArg(1); // IMMEDIATE ARGUMENT
                this->data.position_interp.set_mode(mode);
                this->data.position_interp.set_initial_value(this->data.position_mode == 0 ? this->data.position : this->data.__position_2);
                Float3 position;
                float magnitude = ParseFloatArg(3);
                float angle = ParseFloatArg(2);
                position.make_from_vector3(angle, magnitude);
                this->data.position_interp.set_final_value(position);
                this->data.position_interp.reset_timer();
                break;
            }
            case move_bezier: { // 420
                Float3 bezier1; // ESP+88
                Float3 bezier2; // ESP+94
                bezier1.x = ParseFloatArg(1);
                bezier1.y = ParseFloatArg(2);
                bezier1.z = ParseFloatArg(3);
                bezier2.x = ParseFloatArg(7);
                bezier2.y = ParseFloatArg(8);
                bezier2.z = ParseFloatArg(9);
                int32_t end_time = ParseIntArg(0);
                this->data.position_interp.set_end_time(end_time);
                this->data.position_interp.set_bezier1(bezier1);
                this->data.position_interp.set_bezier2(bezier2);
                this->data.position_interp.set_mode(Bezier);
                this->data.position_interp.set_initial_value(this->data.position_mode == 0 ? this->data.position : this->data.__position_2);
                float position_z = ParseFloatArg(6);
                float position_y = ParseFloatArg(5);
                float position_x = ParseFloatArg(4);
                Float3 position = { position_x, position_y, position_z };
                this->data.position_interp.set_final_value(position);
                this->data.position_interp.reset_timer();
                break;
            }
            case color_interp: { // 408
                D3DCOLOR initial_color;
                pack_rgb(initial_color, RED(this->data.color1), GREEN(this->data.color1), BLUE(this->data.color1));
                int32_t b = ParseIntArg(4);
                int32_t g = ParseIntArg(3);
                int32_t r = ParseIntArg(2);
                D3DCOLOR final_color;
                pack_rgb(final_color, r, g, b);
                int32_t end_time = ParseIntArg(0);
                uint8_t mode = ByteArg(4); // IMMEDIATE ARGUMENT
                this->initialize_color_interp(end_time, mode, initial_color, final_color);
                break;
            }
            case alpha_interp: { // 409
                int32_t final_alpha = ParseIntArg(2);
                int32_t end_time = ParseIntArg(0);
                uint8_t mode = ByteArg(4); // IMMEDIATE ARGUMENT
                this->initialize_alpha_interp(end_time, mode, this->get_alpha(), final_alpha);
                break;
            }
            case color_gradient_interp: { // 413
                D3DCOLOR initial_color;
                pack_rgb(initial_color, RED(this->data.color1), GREEN(this->data.color1), BLUE(this->data.color1));
                int32_t b = ParseIntArg(4);
                int32_t g = ParseIntArg(3);
                int32_t r = ParseIntArg(2);
                D3DCOLOR final_color;
                pack_rgb(final_color, r, g, b);
                int32_t end_time = ParseIntArg(0);
                uint8_t mode = ByteArg(4); // IMMEDIATE ARGUMENT
                this->initialize_color2_interp(end_time, mode, initial_color, final_color);
                break;
            }
            case alpha_gradient_interp: { // 414
                int32_t final_alpha = ParseIntArg(2);
                int32_t end_time = ParseIntArg(0);
                uint8_t mode = ByteArg(4); // IMMEDIATE ARGUMENT
                this->initialize_alpha2_interp(end_time, mode, this->get_alpha2(), final_alpha);
                break;
            }
            case rotation_interp: { // 410
                float rotation_z = ParseFloatArg(4);
                float rotation_y = ParseFloatArg(3);
                float rotation_x = ParseFloatArg(2);
                Float3 rotation = { rotation_x, rotation_y, rotation_z };
                int32_t end_time = ParseIntArg(0);
                this->data.rotation_interp.set_end_time(end_time);
                this->data.rotation_interp.set_bezier1(UNKNOWN_FLOAT3_A);
                this->data.rotation_interp.set_bezier2(UNKNOWN_FLOAT3_A);
                int32_t mode = IntArg(1); // IMMEDIATE ARGUMENT
                this->data.rotation_interp.set_mode(mode);
                this->data.rotation_interp.set_initial_value(this->data.rotation);
                this->data.rotation_interp.set_final_value(rotation);
                this->data.rotation_interp.reset_timer();
                this->data.rotation_enabled = true;
                break;
            }
            case spin_interp: { // 411
                float angle = ParseFloatArg(2);
                ZUNAngle final_angle = angle;
                ZUNAngle initial_angle = this->data.rotation.z;
                ZUNAngle zero_angle = 0.0f;
                int32_t end_time = ParseIntArg(0);
                this->data.spin_interp.set_end_time(end_time);
                this->data.spin_interp.set_bezier1(zero_angle);
                this->data.spin_interp.set_bezier2(zero_angle);
                int32_t mode = IntArg(1); // IMMEDIATE ARGUMENT
                this->data.spin_interp.set_mode(mode);
                this->data.spin_interp.set_initial_value(initial_angle);
                this->data.spin_interp.set_final_value(final_angle);
                this->data.spin_interp.reset_timer();
                this->data.rotation_enabled = true;
                break;
            }
            case scale_interp: { // 412
                float scale_y = ParseFloatArg(3);
                float scale_x = ParseFloatArg(2);
                Float2 scale = { scale_x, scale_y };
                int32_t end_time = ParseIntArg(0);
                uint8_t mode = ByteArg(4); // IMMEDIATE ARGUMENT
                this->initialize_scale_interp(end_time, mode, &this->data.scale, &scale);
                this->data.scale_enabled = true;
                break;
            }
            case scale2_interp: { // 435
                float scale_y = ParseFloatArg(3);
                float scale_x = ParseFloatArg(2);
                Float2 scale = { scale_x, scale_y };
                int32_t end_time = ParseIntArg(0);
                uint8_t mode = ByteArg(4); // IMMEDIATE ARGUMENT
                this->initialize_scale2_interp(end_time, mode, &this->data.scale, &scale);
                this->data.scale_enabled = true;
                break;
            }
            case uv_scale_interp: { // 430
                float scale_v = ParseFloatArg(3);
                float scale_u = ParseFloatArg(2);
                Float2 scale = { scale_u, scale_v };
                int32_t end_time = ParseIntArg(0);
                uint8_t mode = ByteArg(4); // IMMEDIATE ARGUMENT
                this->initialize_uv_scale_interp(end_time, mode, &this->data.uv_scale, &scale);
                this->data.uv_scale_enabled = true;
                break;
            }
            case scroll_speed_x_interp: { // 427
                float scroll_speed_x = ParseFloatArg(2);
                float zero = 0.0f;
                int32_t end_time = ParseIntArg(0);
                this->data.u_scroll_speed_interp.set_end_time(end_time);
                this->data.u_scroll_speed_interp.set_bezier1(zero);
                this->data.u_scroll_speed_interp.set_bezier2(zero);
                int32_t mode = IntArg(1); // IMMEDIATE ARGUMENT
                this->data.u_scroll_speed_interp.set_mode(mode);
                this->data.u_scroll_speed_interp.set_initial_value(this->data.uv_scroll_speed.x);
                this->data.u_scroll_speed_interp.set_final_value(scroll_speed_x);
                this->data.u_scroll_speed_interp.reset_timer();
                break;
            }
            case scroll_speed_y_interp: { // 428
                float scroll_speed_y = ParseFloatArg(2);
                float zero = 0.0f;
                int32_t end_time = ParseIntArg(0);
                this->data.v_scroll_speed_interp.set_end_time(end_time);
                this->data.v_scroll_speed_interp.set_bezier1(zero);
                this->data.v_scroll_speed_interp.set_bezier2(zero);
                int32_t mode = IntArg(1); // IMMEDIATE ARGUMENT
                this->data.v_scroll_speed_interp.set_mode(mode);
                this->data.v_scroll_speed_interp.set_initial_value(this->data.uv_scroll_speed.y);
                this->data.v_scroll_speed_interp.set_final_value(scroll_speed_y);
                this->data.v_scroll_speed_interp.reset_timer();
                break;
            }
            case render_mode: // 302
                this->data.render_mode = IntArg(0); // IMMEDIATE ARGUMENT
                if (this->data.render_mode == 10) {
                    this->__sub_4832F0();
                }
                break;
            case position_inherit: // 422
                this->data.position = this->controller.position;
                this->controller.position = {};
                break;
            case textured_ring: { // 600
                this->data.render_mode = 9;
                int32_t max_count = ParseIntArg(0);
                this->allocate_special_vertex_buffer(max_count * 0x38); // TODO: convert to vertex type
                break;
            }
            case textured_arc_A: { // 601
                this->data.render_mode = 13;
                int32_t max_count = ParseIntArg(0);
                this->allocate_special_vertex_buffer(max_count * 0x38); // TODO: convert to vertex type
                break;
            }
            case textured_arc_B: { // 602
                this->data.render_mode = 14;
                int32_t max_count = ParseIntArg(0);
                this->allocate_special_vertex_buffer(max_count * 0x38); // TODO: convert to vertex type
                break;
            }
            case textured_cylinder: { // 609
                this->data.render_mode = 24;
                int32_t max_count = ParseIntArg(0);
                this->allocate_special_vertex_buffer(max_count * 0x30); // TODO: convert to vertex type
                break;
            }
            case textured_ring_3D: { // 609
                this->data.render_mode = 25;
                int32_t max_count = ParseIntArg(0);
                this->allocate_special_vertex_buffer(max_count * 0x30); // TODO: convert to vertex type
                break;
            }
            case sprite_window: { // 418
                Float3 quad_positions[4];
                this->__get_vertex_quad(quad_positions);
                __convert_position_to_window_uv(&this->data.sprite_uv_quad[0], &quad_positions[0]);
                __convert_position_to_window_uv(&this->data.sprite_uv_quad[1], &quad_positions[1]);
                __convert_position_to_window_uv(&this->data.sprite_uv_quad[2], &quad_positions[2]);
                __convert_position_to_window_uv(&this->data.sprite_uv_quad[3], &quad_positions[3]);
                break;
            }
            case __anm_flag_continual_sprite_window: // 419
                this->data.__continual_sprite_window = ParseIntArg(0);
                break;
            case polygon_rectangle: // 603
                this->data.render_mode = 16;
                this->data.sprite_size.x = ParseFloatArg(0);
                this->data.sprite_size.y = ParseFloatArg(1);
                break;
            case polygon_rectangle_gradient: // 606
                this->data.render_mode = 20;
                this->data.sprite_size.x = ParseFloatArg(0);
                this->data.sprite_size.y = ParseFloatArg(1);
                break;
            case polygon_rectangle_antialias: // 607
                this->data.render_mode = 21;
                this->data.sprite_size.x = ParseFloatArg(0);
                this->data.sprite_size.y = ParseFloatArg(1);
                break;
            case polygon_rectangle_gradient_antialias: // 608
                this->data.render_mode = 22;
                this->data.sprite_size.x = ParseFloatArg(0);
                this->data.sprite_size.y = ParseFloatArg(1);
                break;
            case polygon_line: // 613
                this->data.render_mode = 26;
                this->data.sprite_size.x = ParseFloatArg(0);
                this->data.sprite_size.y = ParseFloatArg(1);
                break;
            case polygon_rectangle_hollow: // 612
                this->data.render_mode = 27;
                this->data.sprite_size.x = ParseFloatArg(0);
                this->data.sprite_size.y = ParseFloatArg(1);
                break;
            case polygon: // 604
                this->data.render_mode = 17;
                this->data.sprite_size.x = ParseFloatArg(0);
                this->data.current_context.int_vars[0] = ParseIntArg(1);
                break;
            case polygon_hollow: // 605
                this->data.render_mode = 18;
                this->data.sprite_size.x = ParseFloatArg(0);
                this->data.current_context.int_vars[0] = ParseIntArg(1);
                break;
            case polygon_ring: // 611
                this->data.render_mode = 19;
                this->data.sprite_size.x = ParseFloatArg(0);
                this->data.sprite_size.y = ParseFloatArg(1);
                this->data.current_context.int_vars[0] = ParseIntArg(2);
                break;
            case __polygon_unknown_A: // 614
                this->data.render_mode = 28;
                this->data.sprite_size.x = ParseFloatArg(0);
                this->data.sprite_size.y = ParseFloatArg(1);
                break;
            case __anm_flag_treat_as_root: // 507
                this->data.__treat_as_root = ParseIntArg(0);
                break;
            case scroll_mode: // 312
                this->data.u_scroll_mode = ParseIntArg(0);
                this->data.v_scroll_mode = ParseIntArg(1);
                break;
            case resolution_mode: // 313
                this->data.resolution_mode = ParseIntArg(0);
                break;
            case anm_flag_inherit_rotation: // 314
                this->data.inherit_rotation = ParseIntArg(0);
                break;
            case origin_mode: // 438
                this->data.origin_mode = ByteArg(0); // IMMEDIATE ARGUMENT
                break;
            case __anm_flag_unknown_T: // 431
                this->data.__unknown_flag_T = ByteArg(0); // IMMEDIATE ARGUMENT
                break;
            case layer: { // 304
                uint8_t layer = ByteArg(0); // IMMEDIATE ARGUMENT
                this->set_layer(layer);
                break;
            }
            case color_mode: // 423
                this->data.color_mode = ByteArg(0); // IMMEDIATE ARGUMENT
                break;
            case anm_flag_auto_rotate: // 424
                this->data.auto_rotate = ByteArg(0); // IMMEDIATE ARGUMENT
                break;
            case rand_mode: // 307
                this->data.rand_mode = ByteArg(0); // IMMEDIATE ARGUMENT
                break;
            case nop: // 0
                break;
        }

        this->data.current_instruction_offset += current_instruction->offset_to_next;
    }

anm_break:
    if (this->data.__deltas_enabled) {
        this->__apply_deltas();
    }
    if (this->data.__unknown_flag_W) {
        this->controller.position += SUPERVISOR.cameras[3].__float3_13C;
    }
    if (this->data.__continual_sprite_window) {
        Float3 quad_positions[4];
        this->__get_vertex_quad(quad_positions);
        __convert_position_to_window_uv(&this->data.sprite_uv_quad[0], &quad_positions[0]);
        __convert_position_to_window_uv(&this->data.sprite_uv_quad[1], &quad_positions[1]);
        __convert_position_to_window_uv(&this->data.sprite_uv_quad[2], &quad_positions[2]);
        __convert_position_to_window_uv(&this->data.sprite_uv_quad[3], &quad_positions[3]);
    }
    this->step_interps();
    this->__update_polygons();

    if (ZUN_FAILED(this->run_on_wait())) {
return_delete:
        GAME_SPEED.set(previous_gamespeed);
        return 1;
    }
    else {
return_static:
        GAME_SPEED.set(previous_gamespeed);
        return 0;
    }
}

// 0x43A340
dllexport gnu_noinline UpdateFuncRet UpdateFuncCC FpsCounter::on_draw(void* ptr) {
    switch (SUPERVISOR.gamemode_switch) {
        default: {
            float fps = ((FpsCounter*)ptr)->__fps;
            if (AsciiManager* ascii_manager = ASCII_MANAGER_PTR) {

                D3DCOLOR color;
                if (fps < 30.0f) {
                    color = PackD3DCOLOR(255, 80, 80, 255);
                } else if (fps < 40.0f) {
                    color = PackD3DCOLOR(255, 160, 160, 255);
                } else {
                    color = PackD3DCOLOR(255, 255, 255, 255);
                }
                ascii_manager->color = color;

                Float3 position = { 588.0f, 470.0f, 0.0f };

                ascii_manager->debugf(&position, "%2.1ffps", fps + 0.05);

                ASCII_MANAGER_PTR->color = PackD3DCOLOR(255, 255, 255, 255);
            }
        }
        case 4: case 15:
            return UpdateFuncNext;
    }
}

inline UpdateFuncRet LoadingThread::on_tick() {
    if (this->__unknown_task_flag_A) {
        SUPERVISOR.__sub_455EC0();

        AsciiManager* ascii_manager = ASCII_MANAGER_PTR;
        WINDOW_DATA.__int_20D0 = 1;
        ascii_manager->enable_tick_unsafe();
        ascii_manager->enable_draw_unsafe();
        ascii_manager->on_draw_func_group_1->run_on_update = true;
        ascii_manager->on_draw_func_group_2->run_on_update = true;
        ascii_manager->on_draw_func_group_3->run_on_update = true;

        SUPERVISOR.__unknown_flag_G = false;
        SUPERVISOR.gamemode_switch = 4;
        this->__unknown_task_flag_A = false;
    }
    return UpdateFuncNext;
}

inline UpdateFuncRet LoadingThread::on_draw() {
    if (this->sig_loaded == 1) {
        this->__anm_id_638 = this->sig_anm->instantiate_vm_to_world_list_back(0, -1, NULL);
        ++this->sig_loaded;
    }
    if (this->__ascii_manager_loaded == 1) {
        ASCII_MANAGER_PTR->__instantiate_vm_id_19268(480.0f, 392.0f);
        ++this->__ascii_manager_loaded;
    }
    ++this->__int_648;
    return UpdateFuncNext;
}

enum CancelType : int32_t {
    CancelType0 = 0,
    CancelType1 = 1,
    CancelType2 = 2,
    CancelType3 = 3,
    CancelType4 = 4
};

static inline int bullet_cancel_radius(Float3* position, float radius, CancelType cancel_type);
static inline int bullet_cancel_radius_as_bomb(Float2* position, float radius, CancelType cancel_type, int32_t max_count, int arg5);
static inline int laser_cancel_radius(Float3* position, float radius, int arg3, int arg4);

typedef struct PlayerDamageSource PlayerDamageSource;
typedef struct PlayerBullet PlayerBullet;

using DamageSourceFunc = int32_t fastcall(PlayerDamageSource* self, Float3* position, Float2* size, float rotation, float radius);
using BulletDamageFunc = int32_t fastcall(PlayerBullet* self, Float3* position, Float2* size, float rotation, float radius);
using BulletInitFunc = int32_t fastcall(PlayerBullet* self, PlayerDamageSource* damage_source);

typedef struct ShtFile ShtFile;
extern "C" {
    // 0x570920
    externcg ShtFile* CACHED_SHT_FILE_PTR cgasm("_CACHED_SHT_FILE_PTR");

    // 0x4B4230
    externcg BulletInitFunc *const PLAYER_BULLET_INIT_FUNCS[8] cgasm("_PLAYER_BULLET_INIT_FUNCS")
#if !USE_EXTERN_FOR_CODEGEN
    = {}
#endif
    ;
    // 0x4B4210
    externcg void *const PLAYER_FUNC_TABLE_B[8] cgasm("_PLAYER_FUNC_TABLE_B")
#if !USE_EXTERN_FOR_CODEGEN
        = {}
#endif
    ;
    // 0x4CF414
    externcg void* PLAYER_FUNC_TABLE_C[1] cgasm("_PLAYER_FUNC_TABLE_C"); // No, the missing const isn't a typo
    // 0x4B41F0
    externcg BulletDamageFunc *const PLAYER_BULLET_DAMAGE_FUNCS[8] cgasm("_PLAYER_BULLET_DAMAGE_FUNCS")
#if !USE_EXTERN_FOR_CODEGEN
        = {}
#endif
    ;
}

static inline constexpr size_t MAX_SHT_UNKNOWN_A_COUNT = 40;

// size: 0x5C
struct ShtFileUnknownA {
    union {
        int32_t __int_0; // 0x0
        struct {
            int8_t __byte_0; // 0x0
            int8_t __sbyte_1; // 0x1
            int16_t __anm_script; // 0x2
        };
    };
    Float2 position; // 0x4
    Float2 size; // 0xC
    float angle; // 0x14
    float speed; // 0x18
    unknown_fields(0x4);
    int8_t __option_index; // 0x20
    uint8_t __byte_21; // 0x21
    int16_t sound_id; // 0x22
    unknown_fields(0x6); // 0x24
    int8_t __sbyte_2A; // 0x2A
    int8_t __sbyte_2B; // 0x2B
    union {
        BulletInitFunc* __init_func; // 0x2C
        uint32_t __init_func_index; // 0x2C
    };
    union {
        void* __unknown_func_B; // 0x30
        uint32_t __unknown_func_B_index; // 0x30
    };
    union {
        void* __unknown_func_C; // 0x34
        uint32_t __unknown_func_C_index; // 0x34
    };
    union {
        BulletDamageFunc* __damage_func; // 0x38
        uint32_t __damage_func_index; // 0x38
    };
    unknown_fields(0x20); // 0x3C
    // 0x5C
};
#pragma region // ShtFileUnknownA Validation
ValidateFieldOffset32(0x0, ShtFileUnknownA, __int_0);
ValidateFieldOffset32(0x4, ShtFileUnknownA, position);
ValidateFieldOffset32(0xC, ShtFileUnknownA, size);
ValidateFieldOffset32(0x14, ShtFileUnknownA, angle);
ValidateFieldOffset32(0x18, ShtFileUnknownA, speed);
ValidateFieldOffset32(0x20, ShtFileUnknownA, __option_index);
ValidateFieldOffset32(0x21, ShtFileUnknownA, __byte_21);
ValidateFieldOffset32(0x22, ShtFileUnknownA, sound_id);
ValidateFieldOffset32(0x2A, ShtFileUnknownA, __sbyte_2A);
ValidateFieldOffset32(0x2B, ShtFileUnknownA, __sbyte_2B);
ValidateFieldOffset32(0x2C, ShtFileUnknownA, __init_func);
ValidateFieldOffset32(0x30, ShtFileUnknownA, __unknown_func_B);
ValidateFieldOffset32(0x34, ShtFileUnknownA, __unknown_func_C);
ValidateFieldOffset32(0x38, ShtFileUnknownA, __damage_func);
ValidateStructSize32(0x5C, ShtFileUnknownA);
#pragma endregion

// size: 
struct ShtFile {
    unknown_fields(0x2); // 0x0
    uint16_t __unknownA_count; // 0x2
    float __float_4; // 0x4
    float __float_8; // 0x8
    float __float_C; // 0xC
    float movement_speeds[4]; // 0x10
    int32_t max_level; // 0x20
    int32_t power_per_level; // 0x24
    unknown_fields(0x18); // 0x28
    Float2 __float2_array_40[10]; // 0x40
    Float2 __float2_array_90[10]; // 0x90
    ShtFileUnknownA* __unknownA_ptr_array_E0[MAX_SHT_UNKNOWN_A_COUNT]; // 0xE0
    ShtFileUnknownA __unknownA_array_180[]; // 0x180
};

typedef struct Player Player;
extern "C" {
    // 0x4CF410
    externcg Player* PLAYER_PTR cgasm("_PLAYER_PTR");
}

static inline constexpr float INTERNAL_POSITION_RATIO = 128.0f;

enum MovementDirection : int32_t {
    MovementNone = 0,
    MovementUp = 1,
    MovementDown = 2,
    MovementLeft = 3,
    MovementRight = 4,
    MovementUpLeft = 5,
    MovementUpRight = 6,
    MovementDownLeft = 7,
    MovementDownRight = 8
};

enum CollisionResult : int32_t {
    NoCollision = 0,
    DeathCollision = 1,
    GrazeCollision = 2
};

enum CollisionTestType : int32_t {
    LethalCollisionTest = 0,
    GrazeCollisionTest = 1
};

enum DamageSourceHitboxType {
    RectangleHitbox = 0,
    CircleHitbox = 1
};

struct RectPoints {
    Float2 points[4];

    inline void offset(float X, float Y) {
        for (size_t i = 0; i < countof(this->points); ++i) {
            this->points[i].x += X;
            this->points[i].y += Y;
        }
    }

    inline void rotate_around_origin(float angle) {
        float y_unit = zsin(angle);
        float x_unit = zcos(angle);
        // repeated rotate_around_origin
        for (size_t i = 0; i < countof(this->points); ++i) {
            float y = this->points[i].y;
            float x = this->points[i].x;
            this->points[i].y = (x_unit * y) + (y_unit * x);
            this->points[i].x = (x_unit * x) - (y_unit * y);
        }
    }

private:
    // 0x403660
    dllexport gnu_noinline BOOL vectorcall __sub_403660(float x, float y, float width, float height, float, float, float angle) asm_symbol_rel(0x403660) {
        RectPoints rect; // ESP+1C

        Float2 position = { x, y };

        rect.points[0] = this->points[0] - position;
        rect.points[1] = this->points[1] - position;
        rect.points[2] = this->points[2] - position;
        rect.points[3] = this->points[3] - position;

        if (angle != 0.0f) {
            rect.rotate_around_origin(-angle);
        }

        float half_height = height * 0.5f;
        float half_width = width * 0.5f;

        if (
            (half_width < zfabsf(rect.points[0].x) || half_height < zfabsf(rect.points[0].y)) &&
            (half_width < zfabsf(rect.points[1].x) || half_height < zfabsf(rect.points[1].y)) &&
            (half_width < zfabsf(rect.points[2].x) || half_height < zfabsf(rect.points[2].y)) &&
            (half_width < zfabsf(rect.points[3].x) || half_height < zfabsf(rect.points[3].y))
        ) {
            return TRUE;
        }

        return FALSE;
    }
public:
    inline BOOL __sub_403660(float x, float y, float width, float height, float angle) {
        return this->__sub_403660(x, y, width, height, UNUSED_FLOAT, UNUSED_FLOAT, angle);
    }
};

// 0x4B35A0
// this could've been just +1 and a mask ZUN...
static const int32_t AWFUL_RECTANGLE_INDEX_TABLE[] = {
    0, 1,
    1, 2,
    2, 3,
    3, 0
};

inline namespace HitboxManager {

namespace Impl {
    forceinline float squared(float value) {
        return value * value;
    }
    forceinline float hypot_squared(float x, float y) {
        return squared(x) + squared(y);
    }
    forceinline float hypot(float x, float y) {
        return zsqrt(hypot_squared(x, y));
    }
    forceinline float distance_squared(float x1, float y1, float x2, float y2) {
        return hypot_squared(x1 - x2, y1 - y2);
    }
    forceinline float distance(float x1, float y1, float x2, float y2) {
        return zsqrt(distance_squared(x1, y1, x2, y2));
    }

    forceinline BOOL __inline_sub_A(
        float A1x, float A1y,
        float A2x, float A2y,
        float B1x, float B1y,
        float B2x, float B2y
    ) {
        float C = (A1x - B1x) * (A1y - A2y) + (B1y - A1y) * (A1x - A2x);
        float D = (A1x - B2x) * (A1y - A2y) + (B2y - A1y) * (A1x - A2x);
        if (!(C * D > 0.0f)) {
            if (C == 0.0f && D == 0.0f) {
                if (A1x > A2x) {
                    std::swap(A1x, A2x);
                    std::swap(A1y, A2y);
                }
                if (B1x > B2x) {
                    std::swap(B1x, B2x);
                    std::swap(B1y, B2y);
                }
                if (
                    B2x >= A1x &&
                    B2y >= A1y &&
                    A2x >= B1x &&
                    A2y >= B1y
                ) {
                    return TRUE;
                }
            }
            else {
                C = (B1x - A1x) * (B1y - B2y) + (A1y - B1y) * (B1x - B2x);
                D = (B1x - A2x) * (B1y - B2y) + (A2y - B1y) * (B1x - B2x);
                if (!(C * D > 0.0f)) {
                    return TRUE;
                }
            }
        }
        return FALSE;
    }
}

namespace Impl {
    forceinline BOOL vectorcall __sub_4038A0(
        float* x_out, float* y_out, // ECX, EDX,
        float x1, float y1,         // XMM2, XMM3,
        float x2, float y2,         // 
        float x3, float y3,         // 
        float x4, float y4          // 
    ) {

        if (__inline_sub_A(
            x1, y1, x2, y2,
            x3, y3, x4, y4
        )) {
            BOOL A;
            float B = x2 - x1;
            float C;
            if (zfabsf(B) < 0.01f) {
                A = true;
                B = 0.0f;
                C = x1;
            } else {
                A = false;
                B = (y2 - y1) / (x2 - x1);
                C = y1 - ((y2 - y1) * x1 / (x2 - x1));
            }

            BOOL D;
            float E = x4 - x3;
            float F;
            if (zfabsf(E) < 0.01f) {
                D = true;
                E = 0.0f;
                F = x3;
            } else {
                D = false;
                E = (y4 - y3) / (x4 - x3);
                F = y3 - ((y4 - y3) * x3 / (x4 - x3));
            }

            if (!A) {
                if (!D) {
                    *x_out = (F - C) / (B - E);
                    *y_out = C + ((F - C) * B / (B - E));
                    return TRUE;
                } else {
                    *x_out = x3;
                    *y_out = B * x3 + C;
                    return TRUE;
                }
            } else {
                if (D) {
                    if (zfabsf(x1 - x3) < 0.001f) {
                        *x_out = x1;
                        *y_out = y1;
                        return TRUE;
                    }
                } else {
                    *x_out = x1;
                    *y_out = E * x1 + F;
                    return TRUE;
                }
            }
        }
        return FALSE;
    }
    // 0x4038A0
    dllexport gnu_noinline BOOL vectorcall __sub_4038A0(
        float* x_out, float* y_out,
        float x1, float y1,
        uint32_t x2, uint32_t y2,
        uint32_t x3, uint32_t y3,
        uint32_t x4, uint32_t y4
    ) asm_symbol_rel(0x4038A0) {
        return Impl::__sub_4038A0(
            x_out, y_out,
            x1, y1,
            bitcast<float>(x2), bitcast<float>(y2),
            bitcast<float>(x3), bitcast<float>(y3),
            bitcast<float>(x4), bitcast<float>(y4)
        );
    }
}
    forceinline BOOL __sub_4038A0(
        float* x_out, float* y_out,
        float x1, float y1,
        float x2, float y2,
        float x3, float y3,
        float x4, float y4
    ) {
        return Impl::__sub_4038A0(
            x_out, y_out,
            x1, y1,
            bitcast<uint32_t>(x2), bitcast<uint32_t>(y2),
            bitcast<uint32_t>(x3), bitcast<uint32_t>(y3),
            bitcast<uint32_t>(x4), bitcast<uint32_t>(y4)
        );
    }

namespace Impl {
    forceinline BOOL __sub_403BC0(
        float* x_out, float* y_out,
        float x1, float y1,
        float rotation1,
        float x2, float y2,
        float rotation2
    ) {
        float angle1 = reduce_angle(rotation1);
        float angle2 = reduce_angle(rotation2);
        float angle_diff1 = reduced_angle_diff(angle1, angle2);
        float reduced_angle_diff1 = reduce_angle(angle_diff1);
        if (
            // Angles are not almost the same
            !(zfabsf(reduced_angle_diff1) < 0.001f)
        ) {
            float angle_diff2 = reduce_angle(__angle_diffB(angle1, angle2, angle_diff1));
            float reduced_angle_diff2 = reduce_angle(reduced_angle_diff(angle_diff2, PI_f));
            if (
                // Angles are not almost opposite?
                !(zfabsf(reduced_angle_diff2) < 0.001f)
            ) {
                Float2 pos;
                pos.make_from_vector(rotation1, 10.0f);

                float A1;
                float B1;
                BOOL C1;
                if (
                    // Rotation1 is almost vertical
                    zfabsf(pos.x) < 0.01f
                ) {
                    A1 = x1;
                    B1 = 0.0f;
                    C1 = true;
                } else {
                    B1 = pos.y / pos.x;
                    A1 = y1 - B1 * x1;
                    C1 = false;
                }

                pos.make_from_vector(rotation2, 10.0f);

                float A2;
                float B2;
                BOOL C2;
                if (
                    // Rotation2 is almost vertical
                    zfabsf(pos.x) < 0.01f
                ) {
                    A2 = x2;
                    B2 = 0.0f;
                    C2 = true;
                } else {
                    B2 = pos.y / pos.x;
                    A2 = y2 - B2 * x2;
                    C2 = false;
                }

                float X;
                float Y;
                if (!C1) {
                    if (!C2) {
                        float A_diff = A2 - A1;
                        float B_diff = B1 - B2;
                        X = A_diff / B_diff;
                        Y = A_diff * B1 / B_diff + A1;
                    }
                    else {
                        X = x2;
                        Y = B1 * x2 + A1;
                    }
                }
                else {
                    if (!C2) {
                        X = x1;
                        Y = B2 * x1 + A2;
                    }
                    else {
                        if (zfabsf(x1 - x2) < 0.001f) {
                            *y_out = y1;
                            *x_out = x1;
                            return true;
                        }
                        else {
                            // Does not write to out?
                            return false;
                        }
                    }
                }
                *x_out = X;
                *y_out = Y;
                return true;
            }
        }
        *y_out = y1;
        *x_out = x1;
        return false;
    }
    // 0x403BC0
    dllexport gnu_noinline BOOL vectorcall __sub_403BC0(
        float, float,
        float* x_out, float* y_out,
        float x1, float y1,
        uint32_t rotation1,
        uint32_t x2, uint32_t y2,
        uint32_t rotation2
    ) asm_symbol_rel(0x403BC0) {
        return Impl::__sub_403BC0(
            x_out, y_out,
            x1, y1,
            bitcast<float>(rotation1),
            bitcast<float>(x2), bitcast<float>(y2),
            bitcast<float>(rotation2)
        );
    }
}
    forceinline BOOL __sub_403BC0(
        float* x_out, float* y_out,
        float x1, float y1,
        float rotation1,
        float x2, float y2,
        float rotation2
    ) {
        return Impl::__sub_403BC0(
            UNUSED_FLOAT, UNUSED_FLOAT,
            x_out, y_out,
            x1, y1,
            bitcast<uint32_t>(rotation1),
            bitcast<uint32_t>(x2), bitcast<uint32_t>(y2),
            bitcast<uint32_t>(rotation2)
        );
    }

namespace Impl {
    forceinline BOOL __sub_404080(
        Float2* pointA, Float2* pointB, // ECX, EDX,        (ESP+10, ESP+14)
        Float2* position1,              // EBP+8,
        float rotation1,                // XMM3,
        float x2, float y2,             // EBP+C,  EBP+10,
        float width2, float height2,    // EBP+14, EBP+18,
        float rotation2                 // EBP+1C
    ) {
        float half_width2 = width2 * 0.5f;
        float half_height2 = height2 * 0.5f;
        float neg_half_width2 = -width2 * 0.5f;
        float neg_half_height2 = -height2 * 0.5f;

        RectPoints rectA; // ESP+24
        rectA.points[0] = { neg_half_width2, neg_half_height2 };
        rectA.points[1] = { neg_half_width2, half_height2 };
        rectA.points[2] = { half_width2, half_height2 };
        rectA.points[3] = { half_width2, neg_half_height2 };

        if (rotation1 != 0.0f) {
            rectA.rotate_around_origin(rotation2);
        }

        rectA.offset(x2, y2);

        constexpr Float2 offset_source = { 1000.0f, 0.0f };
        Float2 offset = offset_source.rotate_around_origin(rotation1);

        float x1 = position1->x;
        float y1 = position1->y;

        Float2 A1; // ESP+18, ESP+C

        float A2x = x1 + offset.x; // ESP+1C
        A1.x = x1 - offset.x; // ESP+18
        float A2y = y1 + offset.y; // ESP+20
        A1.y = y1 - offset.y; // ESP+C

        int32_t successes = 0;

        Float3 points[2]; // ESP+44

        nounroll for (size_t i = 0; i < 4; ++i) {
            int32_t B2 = AWFUL_RECTANGLE_INDEX_TABLE[i * 2 + 1];
            int32_t B1 = AWFUL_RECTANGLE_INDEX_TABLE[i * 2];

            float B2y = rectA.points[B2].y;
            float B2x = rectA.points[B2].x;
            float B1y = rectA.points[B1].y;
            float B1x = rectA.points[B1].x;

            if (__sub_4038A0(
                &points[successes].x, &points[successes].y,
                A1.x, A1.y, A2x, A2y,
                B1x, B1y, B2x, B2y
            )) {
                if (++successes >= countof(points)) {
                    break;
                }
            }
        }

        switch (successes) {
            case 0:
                return FALSE;
            case 2: {
                if (A1.distance_squared(&points[0]) < A1.distance_squared(&points[1])) {
                    *pointA = points[0];
                    *pointB = points[1];
                } else {
                    *pointA = points[1];
                    *pointB = points[0];
                }
                return TRUE;
            }
            default: {
                float X = points[0].x;
                float Y = points[0].y;
                *pointA = { X, Y };
                *pointB = { X, Y };
                return TRUE;
            }
        }
    }
    // 0x404080
    dllexport gnu_noinline BOOL vectorcall __sub_404080(
        float, float, float,
        Float2* pointA, Float2* pointB,
        Float2* position1,
        float rotation1,
        uint32_t x2, uint32_t y2,
        uint32_t width2, uint32_t height2,
        uint32_t rotation2
    ) {
        return Impl::__sub_404080(
            pointA, pointB,
            position1,
            rotation1,
            bitcast<float>(x2), bitcast<float>(y2),
            bitcast<float>(width2), bitcast<float>(height2),
            bitcast<float>(rotation2)
        );
    }
}
    forceinline BOOL __sub_404080(
        Float2* pointA, Float2* pointB,
        Float2* position1,
        float rotation1,
        float x2, float y2,
        float width2, float height2,
        float rotation2
    ) {
        return Impl::__sub_404080(
            UNUSED_FLOAT, UNUSED_FLOAT, UNUSED_FLOAT,
            pointA, pointB,
            position1,
            rotation1,
            bitcast<uint32_t>(x2), bitcast<uint32_t>(y2),
            bitcast<uint32_t>(width2), bitcast<uint32_t>(height2),
            bitcast<uint32_t>(rotation2)
        );
    }

namespace Impl {
    forceinline BOOL collision_rectangle_rectangle(
        float x1, float y1,             // XMM0,   XMM1,    (ESP+C,  ESP+14)
        float width1, float height1,    // XMM2,   XMM3,    (ESP+24, ESP+20)
        float rotation1,                // EBP+8,
        float x2, float y2,             // EBP+C,  EBP+10,
        float width2, float height2,    // EBP+14, EBP+18,
        float rotation2                 // EBP+1C
    ) {
        float half_width1 = width1 * 0.5f; // ESP+2C
        float half_height1 = height1 * 0.5f; // ESP+28
        float half_width2 = width2 * 0.5f; // ESP+30
        float half_height2 = height2 * 0.5f; // ESP+1C

        float distance_val = distance(x1, y1, x2, y2); // ESP+18
        float hypot1 = hypot(half_width1, half_height1); // ESP+10
        float hypot2 = hypot(half_width2, half_height2);

        if (
            !(distance_val >= hypot1 + hypot2)
        ) {
            float neg_half_width1 = -width1 * 0.5f;
            float neg_half_height1 = -height1 * 0.5f;

            RectPoints rectA; // ESP+54
            rectA.points[0] = { neg_half_width1, neg_half_height1 };
            rectA.points[1] = { neg_half_width1, half_height1 };
            rectA.points[2] = { half_width1, half_height1 };
            rectA.points[3] = { half_width1, neg_half_height1 };

            if (rotation1 != 0.0f) {
                rectA.rotate_around_origin(rotation1);
            }

            float neg_half_width2 = -width2 * 0.5f;
            float neg_half_height2 = -height2 * 0.5f;

            RectPoints rectB; // ESP+34
            rectB.points[0] = { neg_half_width2, neg_half_height2 };
            rectB.points[1] = { neg_half_width2, half_height2 };
            rectB.points[2] = { half_width2, half_height2 };
            rectB.points[3] = { half_width2, neg_half_height2 };

            if (rotation2 != 0.0f) {
                rectB.rotate_around_origin(rotation2);
            }

            if (
                rectA.__sub_403660(x1, y1, width1, height1, rotation1) ||
                rectB.__sub_403660(x2, y2, width2, height2, rotation2)
            ) {
                return TRUE;
            }

            nounroll for (size_t i = 0; i < 4; ++i) {
                int32_t A1 = AWFUL_RECTANGLE_INDEX_TABLE[i * 2];
                int32_t A2 = AWFUL_RECTANGLE_INDEX_TABLE[i * 2 + 1];
                nounroll for (size_t j = 0; j < 4; ++j) {
                    int32_t B1 = AWFUL_RECTANGLE_INDEX_TABLE[j * 2];
                    int32_t B2 = AWFUL_RECTANGLE_INDEX_TABLE[j * 2 + 1];

                    float A1x = rectA.points[A1].x;
                    float A2x = rectA.points[A2].x;
                    float A1y = rectA.points[A1].y;
                    float A2y = rectA.points[A2].y;
                    float B1x = rectB.points[B1].x;
                    float B1y = rectB.points[B1].y;
                    float B2x = rectB.points[B2].x;
                    float B2y = rectB.points[B2].y;

                    if (__inline_sub_A(
                        A1x, A1y, A2x, A2y,
                        B1x, B1y, B2x, B2y
                    )) {
                        return TRUE;
                    }
                }
            }
        }

        return FALSE;
    }

    // 0x404440
    dllexport gnu_noinline BOOL vectorcall collision_rectangle_rectangle(
        int, int,
        float x1, float y1,
        float width1, float height1,
        uint32_t rotation1,
        uint32_t x2, uint32_t y2,
        uint32_t width2, uint32_t height2,
        uint32_t rotation2
    ) asm_symbol_rel(0x404440) {
        return Impl::collision_rectangle_rectangle(
            x1, y1,
            width1, height1,
            bitcast<float>(rotation1),
            bitcast<float>(x2), bitcast<float>(y2),
            bitcast<float>(width2), bitcast<float>(height2),
            bitcast<float>(rotation2)
        );
    }
}
    forceinline BOOL collision_rectangle_rectangle(
        float x1, float y1,
        float width1, float height1,
        float rotation1,
        float x2, float y2,
        float width2, float height2,
        float rotation2
    ) {
        return Impl::collision_rectangle_rectangle(
            UNUSED_DWORD, UNUSED_DWORD,
            x1, y1,
            width1, height1,
            bitcast<uint32_t>(rotation1),
            bitcast<uint32_t>(x2), bitcast<uint32_t>(y2),
            bitcast<uint32_t>(width2), bitcast<uint32_t>(height2),
            bitcast<uint32_t>(rotation2)
        );
    }

    forceinline BOOL collision_rectangle_circle(
        float x1, float y1,
        float width1, float height1,
        float rotation1,
        float x2, float y2,
        float radius2
    ) {
        Float2 position;
        position.x = x2 - x1;
        position.y = y2 - y1;
        position = position.rotate_around_origin(-rotation1);

        float half_width1 = width1 * 0.5f;
        float half_height1 = height1 * 0.5f;

        if (
            (!(half_width1 + radius2 >= zfabsf(position.x)) || !(half_height1 >= zfabsf(position.y))) &&
            (!(half_width1 >= zfabsf(position.x)) || !(half_height1 + radius2 >= zfabsf(position.y)))
        ) {
            if (
                !(Impl::hypot_squared(position.y - half_height1, position.x - half_width1) < Impl::squared(radius2)) &&
                !(Impl::hypot_squared(position.y - half_height1, position.x + half_width1) < Impl::squared(radius2)) &&
                !(Impl::hypot_squared(position.y + half_height1, position.x - half_width1) < Impl::squared(radius2)) &&
                !(Impl::hypot_squared(position.y + half_height1, position.x + half_width1) < Impl::squared(radius2))
            ) {
                return FALSE;
            }
        }
        return TRUE;
    }

    forceinline BOOL collision_circle_circle(
        float x1, float y1,
        float radius1,
        float x2, float y2,
        float radius2
    ) {
        float y_diff = y1 - y2;
        float x_diff = x1 - x2;
        float max_distance = radius1 + radius2;

        if (
            !(Impl::hypot_squared(x_diff, y_diff) < Impl::squared(max_distance))
        ) {
            return FALSE;
        }
        return TRUE;
    }

namespace Impl {
    // 0x45F0F0
    dllexport gnu_noinline int32_t vectorcall enm_compute_damage_sources(int32_t, int32_t, float, float, float, Float3* position, Float2* size, float rotation, float radius, int32_t* arg5, Float3* hit_position_out, BOOL arg7, int32_t enemy_id) asm_symbol_rel(0x45F0F0);
}
    forceinline int32_t enm_compute_damage_sources(Float3* position, Float2* size, float rotation, float radius, int32_t* arg5, Float3* hit_position_out, BOOL arg7, int32_t enemy_id) {
        return Impl::enm_compute_damage_sources(UNUSED_DWORD, UNUSED_DWORD, UNUSED_FLOAT, UNUSED_FLOAT, UNUSED_FLOAT, position, size, rotation, radius, arg5, hit_position_out, arg7, enemy_id);
    }

namespace Impl {
    // 0x45CBA0
    dllexport gnu_noinline float vectorcall angle_to_player_from_point(int, int, Float2* position) asm_symbol_rel(0x45CBA0);
}
    inline float angle_to_player_from_point(Float2* position) {
        return Impl::angle_to_player_from_point(UNUSED_DWORD, UNUSED_DWORD, position);
    }
};

// size: 0x9C
struct PlayerDamageSource {
    union {
        uint32_t flags; // 0x0, 0x20574
        struct {
            uint32_t active : 1; // 1
            uint32_t hitbox_type : 1; // 2
            uint32_t __unknown_flag_A : 1; // 3
        };
    };
    float radius; // 0x4
    float radius_delta; // 0x8
    ZUNAngle angle; // 0xC
    ZUNAngle angular_velocity; // 0x10
    Float2 size; // 0x14
    MotionData motion; // 0x1C
    Timer duration; // 0x60
    int32_t __int_74; // 0x74
    int __int_78; // 0x78
    int32_t __int_7C; // 0x7C
    int32_t __hit_frequency; // 0x80
    EnemyID __enemy_id_84; // 0x84
    int32_t __int_88; // 0x88
    int __int_8C; // 0x8C
    int32_t __player_bullet_index; // 0x90
    EnemyID __enemy_id_94; // 0x94
    int32_t __unknown_func_index; // 0x98
    // 0x9C

    inline void on_tick() {
        if (this->active) {
            this->motion.update3();
            this->motion.update();

            this->radius += this->radius_delta;
            this->angle += this->angular_velocity;

            if (--this->duration <= 0) {
                this->active = false;
            }
        }
    }

    inline bool check_collision(Float3* position, Float2* size, float rotation, float radius) {
        switch (this->hitbox_type) {
            default:
                unreachable;
            case RectangleHitbox:
                if (size) {
                    return HitboxManager::collision_rectangle_rectangle(
                        this->motion.position.x, this->motion.position.y,
                        this->size.x, this->size.y,
                        this->angle,
                        position->x, position->y,
                        size->x, size->y,
                        rotation
                    );
                } else {
                    return HitboxManager::collision_rectangle_circle(
                        this->motion.position.x, this->motion.position.y,
                        this->size.x, this->size.y,
                        this->angle,
                        position->x, position->y,
                        radius
                    );
                }
            case CircleHitbox:
                if (size) {
                    return HitboxManager::collision_rectangle_circle(
                        position->x, position->y,
                        size->x, size->y,
                        rotation,
                        this->motion.position.x, this->motion.position.y,
                        this->radius
                    );
                } else {
                    return HitboxManager::collision_circle_circle(
                        this->motion.position.x, this->motion.position.y,
                        this->radius,
                        position->x, position->y,
                        radius
                    );
                }
        }
    }

    // 0x45F6A0
    dllexport gnu_noinline static int32_t fastcall __unknown_func_1(PlayerDamageSource* self, Float3* position, Float2* size, float rotation, float radius) asm_symbol_rel(0x45F6A0);

    // 0x460AB0
    dllexport gnu_noinline static int32_t fastcall __unknown_func_2(PlayerDamageSource* self, Float3* position, Float2* size, float rotation, float radius) asm_symbol_rel(0x460AB0);

    // 0x420BF0
    dllexport gnu_noinline static int32_t fastcall __unknown_func_3(PlayerDamageSource* self, Float3* position, Float2* size, float rotation, float radius) asm_symbol_rel(0x420BF0);
};
#pragma region // PlayerDamageSource Validation
ValidateFieldOffset32(0x0, PlayerDamageSource, flags);
ValidateFieldOffset32(0x4, PlayerDamageSource, radius);
ValidateFieldOffset32(0x8, PlayerDamageSource, radius_delta);
ValidateFieldOffset32(0xC, PlayerDamageSource, angle);
ValidateFieldOffset32(0x10, PlayerDamageSource, angular_velocity);
ValidateFieldOffset32(0x14, PlayerDamageSource, size);
ValidateFieldOffset32(0x1C, PlayerDamageSource, motion);
ValidateFieldOffset32(0x60, PlayerDamageSource, duration);
ValidateFieldOffset32(0x74, PlayerDamageSource, __int_74);
ValidateFieldOffset32(0x78, PlayerDamageSource, __int_78);
ValidateFieldOffset32(0x7C, PlayerDamageSource, __int_7C);
ValidateFieldOffset32(0x80, PlayerDamageSource, __hit_frequency);
ValidateFieldOffset32(0x84, PlayerDamageSource, __enemy_id_84);
ValidateFieldOffset32(0x88, PlayerDamageSource, __int_88);
ValidateFieldOffset32(0x8C, PlayerDamageSource, __int_8C);
ValidateFieldOffset32(0x90, PlayerDamageSource, __player_bullet_index);
ValidateFieldOffset32(0x94, PlayerDamageSource, __enemy_id_94);
ValidateFieldOffset32(0x98, PlayerDamageSource, __unknown_func_index);
ValidateStructSize32(0x9C, PlayerDamageSource);
#pragma endregion

// 0x4B4270
static constexpr DamageSourceFunc *const PLAYER_DAMAGE_SOURCE_UNKNOWN_FUNCS[] = {
    NULL,
    &PlayerDamageSource::__unknown_func_1,
    &PlayerDamageSource::__unknown_func_2,
    &PlayerDamageSource::__unknown_func_3
};

static inline PlayerDamageSource* get_damage_source_by_index(int32_t index);

// size: 0xF0
struct PlayerOption {
    int __int_0; // 0x0
    unknown_fields(0x50); // 0x4
    Int2 position; // 0x54
    Int2 internal_position; // 0x5C
    Int2 __unfocused_offset; // 0x64
    Int2 __focused_offset; // 0x6C
    unknown_fields(0x34); // 0x74
    ZUNAngle __angle_A8; // 0xA8
    float __float_AC; // 0xAC
    AnmID __anm_id_B0; // 0xB0
    AnmID __anm_id_B4; // 0xB4
    unknown_fields(0x18); // 0xB8
    int32_t __option_index; // 0xD0
    int __int_D4; // 0xD4
    union {
        uint32_t flags; // 0xD8
        struct {
            uint32_t : 1; // 1
            uint32_t __unknown_flag_A : 1; // 2
        };
    };
    int __dword_DC; // 0xDC
    unknown_fields(0x10); // 0xE0
    // 0xF0
};
#pragma region // PlayerOption Validation
ValidateFieldOffset32(0x0, PlayerOption, __int_0);
ValidateFieldOffset32(0x54, PlayerOption, position);
ValidateFieldOffset32(0x5C, PlayerOption, internal_position);
ValidateFieldOffset32(0x64, PlayerOption, __unfocused_offset);
ValidateFieldOffset32(0x6C, PlayerOption, __focused_offset);
ValidateFieldOffset32(0xA8, PlayerOption, __angle_A8);
ValidateFieldOffset32(0xAC, PlayerOption, __float_AC);
ValidateFieldOffset32(0xB0, PlayerOption, __anm_id_B0);
ValidateFieldOffset32(0xB4, PlayerOption, __anm_id_B4);
ValidateFieldOffset32(0xD0, PlayerOption, __option_index);
ValidateFieldOffset32(0xD4, PlayerOption, __int_D4);
ValidateFieldOffset32(0xD8, PlayerOption, flags);
ValidateFieldOffset32(0xDC, PlayerOption, __dword_DC);
ValidateStructSize32(0xF0, PlayerOption);
#pragma endregion

static inline PlayerBullet* get_player_bullet_by_index(int32_t index);

using PlayerBulletFuncA = ZUNResult fastcall(PlayerBullet* bullet);

// size: 0xF8
struct PlayerBullet {
    union {
        uint32_t flags; // 0x0
        struct {
            uint32_t __unknown_flag_A : 1; // 1
            uint32_t __focused : 1; // 2
        };
    };
    int32_t __bullet_index; // 0x4
    AnmID __vm_id_8; // 0x8
    Timer __timer_C; // 0xC
    unknown_fields(0x28);// 0x20
    MotionData motion; // 0x48
    int state; // 0x8C
    unknown_fields(0xC); // 0x90
    int __int_9C; // 0x9C
    Float2 size; // 0xA0
    unknown_fields(0x4); // 0xA8
    union {
        int32_t __sht_unknownA_index; // 0xAC
        struct {
            uint32_t __sht_unknownA_index2 : 8;
            int32_t __sht_unknownA_index1 : 24;
        };
    };
    int32_t damage_source_index; // 0xB0
    unknown_fields(0x24); // 0xB4
    PlayerBulletFuncA* __func_ptr_D8; // 0xD8
    unknown_fields(0x4); // 0xDC
    AnmLoaded* bullet_anm; // 0xE0
    PlayerOption* option; // 0xE4
    BulletInitFunc* __init_func; // 0xE8
    void* __func_ptr_EC; // 0xEC
    void* __func_ptr_F0; // 0xF0
    BulletDamageFunc* __damage_func; // 0xF4
    // 0xF8

    inline void on_tick();

    // 0x45E320
    dllexport gnu_noinline ZUNResult thiscall shoot(int32_t unknownA_index, int32_t time, Float3* position, PlayerOption* option) asm_symbol_rel(0x45E320);

    // 0x45F6F0
    dllexport gnu_noinline int32_t thiscall __sub_45F6F0() asm_symbol_rel(0x45F6F0) {
        AnmVM* vm = this->__vm_id_8.get_vm_ptr();
        this->motion.position.z = 0.1f;
        vm->interrupt(1);
        this->motion.speed *= 0.125f;
        this->state = 2;
        vm->controller.position = this->motion.position;

        if (PlayerDamageSource* damage_source = get_damage_source_by_index(this->damage_source_index)) {
            damage_source->active = false;
        }

        int32_t ret = this->__int_9C;
        this->damage_source_index = 0;
        return ret;
    }
};
#pragma region // PlayerBullet Validation
ValidateFieldOffset32(0x0, PlayerBullet, flags);
ValidateFieldOffset32(0x4, PlayerBullet, __bullet_index);
ValidateFieldOffset32(0x8, PlayerBullet, __vm_id_8);
ValidateFieldOffset32(0xC, PlayerBullet, __timer_C);
ValidateFieldOffset32(0x48, PlayerBullet, motion);
ValidateFieldOffset32(0x8C, PlayerBullet, state);
ValidateFieldOffset32(0x9C, PlayerBullet, __int_9C);
ValidateFieldOffset32(0xA0, PlayerBullet, size);
ValidateFieldOffset32(0xAC, PlayerBullet, __sht_unknownA_index);
ValidateFieldOffset32(0xB0, PlayerBullet, damage_source_index);
ValidateFieldOffset32(0xD8, PlayerBullet, __func_ptr_D8);
ValidateFieldOffset32(0xE0, PlayerBullet, bullet_anm);
ValidateFieldOffset32(0xE4, PlayerBullet, option);
ValidateFieldOffset32(0xE8, PlayerBullet, __init_func);
ValidateFieldOffset32(0xEC, PlayerBullet, __func_ptr_EC);
ValidateFieldOffset32(0xF0, PlayerBullet, __func_ptr_F0);
ValidateFieldOffset32(0xF4, PlayerBullet, __damage_func);
ValidateStructSize32(0xF8, PlayerBullet);
#pragma endregion

static inline constexpr size_t PLAYER_OPTION_COUNT = 4;
static inline constexpr size_t PLAYER_EQUIPMENT_OPTION_COUNT = 12;

static inline constexpr size_t PLAYER_TOTAL_OPTION_COUNT = PLAYER_OPTION_COUNT + PLAYER_EQUIPMENT_OPTION_COUNT;
static inline constexpr size_t PLAYER_TOTAL_OPTION_COUNT_BIT_WIDTH = std::bit_width(PLAYER_TOTAL_OPTION_COUNT - 1);

static inline constexpr size_t PLAYER_BULLET_COUNT = 0x200;
static inline constexpr size_t PLAYER_DAMAGE_SOURCE_COUNT = 0x400;

// size: 0x47308
struct PlayerData {
    Float3 position; // 0x0, 0x620
    Int2 internal_position; // 0xC, 0x62C
    Timer __death_timer; // 0x14, 0x634
    Timer __timer_28; // 0x28, 0x648
    Timer __timer_3C; // 0x3C, 0x65C
    PlayerOption options[PLAYER_OPTION_COUNT]; // 0x50, 0x670
    PlayerOption equipment[PLAYER_EQUIPMENT_OPTION_COUNT]; // 0x410, 0xA30
    PlayerBullet bullets[PLAYER_BULLET_COUNT]; // 0xF50, 0x1570
    int32_t last_created_damage_source_index; // 0x1FF50, 0x20570
    PlayerDamageSource damage_sources[PLAYER_DAMAGE_SOURCE_COUNT + 1]; // 0x1FF54, 0x20574
    PlayerDamageSource __dummy_damage_source; // 0x46FF0, 0x47610
    int32_t state; // 0x4708C, 0x476AC
    AnmID __vm_id_47090; // 0x47090, 0x476B0
    AnmID __vm_id_47094; // 0x47094, 0x476B4
    Timer __timer_47098; // 0x47098, 0x476B8
    BOOL focused; // 0x470AC, 0x476CC
    Timer shoot_key_short_timer; // 0x470B0, 0x476D0
    Timer shoot_key_long_timer; // 0x470C4, 0x476E4
    int __option_count; // 0x470D8, 0x476F8
    int32_t __level_array_470DC[30]; // 0x470DC, 0x476FC
    Timer __timer_47154; // 0x47154, 0x47774
    Timer __timer_47168; // 0x47168, 0x47788
    union {
        uint32_t flags; // 0x4717C, 0x4779C
        struct {
            uint32_t __unknown_flag_A : 1; // 1
            uint32_t __unknown_flag_C : 1; // 2
            uint32_t __unknown_flag_H : 1; // 3
            uint32_t __unknown_flag_B : 1; // 4
            uint32_t scale_enabled : 1; // 5
            uint32_t __unknown_flag_E : 1; // 6
            uint32_t __unknown_flag_G : 1; // 7
            uint32_t __unknown_field_A : 2; // 8-9
            uint32_t __unknown_flag_D : 1; // 10
        };
    };
    Timer __timer_47180; // 0x47180, 0x477A0
    int32_t __unfocused_linear_speed; // 0x47194, 0x477B4
    int32_t __focused_linear_speed; // 0x47198, 0x477B8
    int32_t __unfocused_diagonal_speed; // 0x4719C, 0x477BC
    int32_t __focused_diagonal_speed; // 0x471A0, 0x477C0
    Float3 velocity; // 0x471A4, 0x477C4
    Float3 __last_movement_velocity; // 0x471B0, 0x477D0
    Int2 __internal_velocity; // 0x471BC, 0x477DC
    int32_t __int_471C4; // 0x471C4, 0x477E4
    int32_t __int_471C8; // 0x471C8, 0x477E8
    float __speed_modifier; // 0x471CC, 0x477EC
    Float3 __base_axis_speed; // 0x471D0, 0x477F0
    int32_t power_level; // 0x471DC, 0x477FC
    Int2 previous_positions[33]; // 0x471E0, 0x47800
    int32_t num_deathbomb_frames; // 0x472E8, 0x47908
    ZUNAngle __shot_tilt_angle; // 0x472EC, 0x4790C
    float __shot_spread; // 0x472F0, 0x47910
    Timer __timer_472F4; // 0x472F4, 0x47914
    // 0x47308, 0x47928

    // 0x45A690
    dllexport gnu_noinline PlayerData() = default;

    // 0x45D5E0
    dllexport gnu_noinline void thiscall __update_option_power_levels(int = UNUSED_DWORD) asm_symbol_rel(0x45D5E0);
};
#pragma region // PlayerData Validation
ValidateFieldOffset32(0x0, PlayerData, position);
ValidateFieldOffset32(0xC, PlayerData, internal_position);
ValidateFieldOffset32(0x14, PlayerData, __death_timer);
ValidateFieldOffset32(0x28, PlayerData, __timer_28);
ValidateFieldOffset32(0x3C, PlayerData, __timer_3C);
ValidateFieldOffset32(0x50, PlayerData, options);
ValidateFieldOffset32(0x410, PlayerData, equipment);
ValidateFieldOffset32(0xF50, PlayerData, bullets);
ValidateFieldOffset32(0x1FF50, PlayerData, last_created_damage_source_index);
ValidateFieldOffset32(0x1FF54, PlayerData, damage_sources);
ValidateFieldOffset32(0x46FF0, PlayerData, __dummy_damage_source);
ValidateFieldOffset32(0x4708C, PlayerData, state);
ValidateFieldOffset32(0x47090, PlayerData, __vm_id_47090);
ValidateFieldOffset32(0x47094, PlayerData, __vm_id_47094);
ValidateFieldOffset32(0x47098, PlayerData, __timer_47098);
ValidateFieldOffset32(0x470AC, PlayerData, focused);
ValidateFieldOffset32(0x470B0, PlayerData, shoot_key_short_timer);
ValidateFieldOffset32(0x470C4, PlayerData, shoot_key_long_timer);
ValidateFieldOffset32(0x470D8, PlayerData, __option_count);
ValidateFieldOffset32(0x470DC, PlayerData, __level_array_470DC);
ValidateFieldOffset32(0x47154, PlayerData, __timer_47154);
ValidateFieldOffset32(0x47168, PlayerData, __timer_47168);
ValidateFieldOffset32(0x4717C, PlayerData, flags);
ValidateFieldOffset32(0x47180, PlayerData, __timer_47180);
ValidateFieldOffset32(0x47194, PlayerData, __unfocused_linear_speed);
ValidateFieldOffset32(0x47198, PlayerData, __focused_linear_speed);
ValidateFieldOffset32(0x4719C, PlayerData, __unfocused_diagonal_speed);
ValidateFieldOffset32(0x471A0, PlayerData, __focused_diagonal_speed);
ValidateFieldOffset32(0x471A4, PlayerData, velocity);
ValidateFieldOffset32(0x471B0, PlayerData, __last_movement_velocity);
ValidateFieldOffset32(0x471BC, PlayerData, __internal_velocity);
ValidateFieldOffset32(0x471C4, PlayerData, __int_471C4);
ValidateFieldOffset32(0x471C8, PlayerData, __int_471C8);
ValidateFieldOffset32(0x471CC, PlayerData, __speed_modifier);
ValidateFieldOffset32(0x471D0, PlayerData, __base_axis_speed);
ValidateFieldOffset32(0x471DC, PlayerData, power_level);
ValidateFieldOffset32(0x471E0, PlayerData, previous_positions);
ValidateFieldOffset32(0x472E8, PlayerData, num_deathbomb_frames);
ValidateFieldOffset32(0x472EC, PlayerData, __shot_tilt_angle);
ValidateFieldOffset32(0x472F0, PlayerData, __shot_spread);
ValidateFieldOffset32(0x472F4, PlayerData, __timer_472F4);
ValidateStructSize32(0x47308, PlayerData);
#pragma endregion

// 0x4B7088
static inline constexpr const char *const PLAYER_SHT_FILENAMES[] = {
    "pl00.sht",
    "pl01.sht",
    "pl02.sht",
    "pl03.sht"
};
// 0x4B7098
static inline constexpr const char *const PLAYER_ANM_FILENAMES[] = {
    "pl00.anm",
    "pl01.anm",
    "pl02.anm",
    "pl03.anm"
};

// size: 0x479D4
struct Player : ZUNTask {
    // ZUNTask base; // 0x0
    AnmLoaded* player_anm; // 0xC
    AnmLoaded* bullet_anm; // 0x10
    AnmVM __vm_14; // 0x14
    PlayerData data; // 0x620
    Float3 __float3_47928; // 0x47928
    Int2 __base_movement_velocity; // 0x47934
    MovementDirection movement_direction; // 0x4793C
    ShtFile* sht_file; // 0x47940
    int __dword_47944; // 0x47944
    char __byte_47948; // 0x47948
    unknown_fields(0x3); // 0x47949
    ZUNInterp<float> scale_interp; // 0x4794C
    float scale; // 0x4797C
    float damage_multiplier; // 0x47980
    int __int_47984; // 0x47984
    float __item_attract_speed; // 0x47988
    float item_collect_radius; // 0x4798C
    float item_attract_radius_focused; // 0x47990
    float item_attract_radius_unfocused; // 0x47994
    float poc_height; // 0x47998
    float __hitbox_radius_unfocused; // 0x4799C
    float __hitbox_radius_focused; // 0x479A0
    Float2 __hitbox_size_unfocused; // 0x479A4 Float3?
    float __float_479AC; // 0x479AC
    Float2 __hitbox_size_focused; // 0x479B0 Float3?
    float __float_479B8; // 0x479B8
    unknown_fields(0x10); // 0x479BC
    float __float_479CC; // 0x479CC
    // 0x479D0

    inline void zero_contents() {
        zero_this();
    }

    inline Player() {
        this->zero_contents();
    }

    // 0x45B020
    dllexport gnu_noinline ~Player() {
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);

        PLAYER_PTR = NULL;

        AnmManager* anm_manager = ANM_MANAGER_PTR;
        if (GAME_MANAGER.__unknown_flag_A) {
            anm_manager->mark_all_vms_from_loaded_slot_for_delete(9);
            CACHED_SHT_FILE_PTR = this->sht_file;
        } else {
            anm_manager->unload_anm(9);
            SAFE_FREE(this->sht_file);
            CACHED_SHT_FILE_PTR = NULL;
        }
    }

    // 0x407D50
    dllexport gnu_noinline Float3* thiscall get_position() asm_symbol_rel(0x407D50) {
        return &this->data.position;
    }

    inline void set_position_internal(int32_t x, int32_t y) {
        this->data.internal_position.x = x;
        this->data.internal_position.y = y;
        this->data.position.x = x * (1.0f / INTERNAL_POSITION_RATIO);
        this->data.position.y = y * (1.0f / INTERNAL_POSITION_RATIO);
    }

    inline void set_x_position_internal(int32_t x) {
        this->data.internal_position.x = x;
        this->data.position.x = x * (1.0f / INTERNAL_POSITION_RATIO);
    }

    inline void set_y_position_internal(int32_t y) {
        this->data.internal_position.y = y;
        this->data.position.y = y * (1.0f / INTERNAL_POSITION_RATIO);
    }

    inline void set_position(float x, float y) {
        return this->set_position_internal(x * INTERNAL_POSITION_RATIO, y * INTERNAL_POSITION_RATIO);
    }

    inline void set_x_position(float x) {
        return this->set_x_position_internal(x * INTERNAL_POSITION_RATIO);
    }

    inline void set_y_position(float y) {
        return this->set_y_position_internal(y * INTERNAL_POSITION_RATIO);
    }

    inline void reset_previous_positions() {
        nounroll for (size_t i = 0; i < countof(this->data.previous_positions); ++i) {
            this->data.previous_positions[i] = this->data.internal_position;
        }
    }

    // 0x4099D0
    dllexport static gnu_noinline void stdcall __set_data_timer_47154(int32_t time) asm_symbol_rel(0x4099D0) {
        PLAYER_PTR->data.__timer_47154.initialize_and_set(time);
    }

    // 0x416D50
    dllexport gnu_noinline void thiscall __sub_416D50() asm_symbol_rel(0x416D50) {
        this->data.__unknown_flag_C = false;
        nounroll for (size_t i = 0; i < PLAYER_OPTION_COUNT; ++i) {
            this->data.options[i].__anm_id_B0.interrupt_tree(2);
            this->data.options[i].__anm_id_B4.interrupt_tree(2);
        }
        nounroll for (size_t i = 0; i < PLAYER_EQUIPMENT_OPTION_COUNT; ++i) {
            this->data.equipment[i].__anm_id_B0.interrupt_tree(2);
            this->data.equipment[i].__anm_id_B4.interrupt_tree(2);
        }
        this->data.__int_471C8 = 0;
    }

    // 0x45B170
    dllexport gnu_noinline void thiscall __sub_45B170() asm_symbol_rel(0x45B170) {
        // TODO: the entire player movement code
    }

private:
    // 0x45CB20
    dllexport float vectorcall angle_from_point(int, Float2* position) asm_symbol_rel(0x45CB20) {
        float y = this->data.position.y - position->y;
        float x = this->data.position.x - position->x;
        if (y == 0.0f && x == 0.0f) {
            return HALF_PI_f;
        } else {
            clang_forceinline return zatan2f(y, x);
        }
    }
public:
    inline float angle_from_point(Float2* position) {
        return this->angle_from_point(UNUSED_DWORD, position);
    }

    // 0x45D090
    dllexport gnu_noinline void thiscall death() asm_symbol_rel(0x45D090);

    // 0x45D590
    dllexport gnu_noinline void thiscall cancel_impending_death() asm_symbol_rel(0x45D590) {
        this->data.__death_timer.set(60);
        this->data.state = 1;
    }

    // 0x45D3A0
    dllexport gnu_noinline void thiscall start_dying() asm_symbol_rel(0x45D3A0);

    inline void __reset_damage_multiplier() {
        if (this->damage_multiplier < 1.01f) {
            this->data.__unknown_flag_E = true;
        } else {
            this->data.__unknown_flag_E = false;
        }
        this->damage_multiplier = 1.0f;
    }

private:
    inline void do_graze_impl(Float2* position) {
        GAME_MANAGER.globals.add_graze();

        Float3 graze_position = *position + this->data.position * 0.5f;

        EFFECT_MANAGER_PTR->effect_anm->instantiate_vm_to_world_list_back(24, &graze_position);

        SOUND_MANAGER.play_sound_positioned(42, position->x);
    }
public:
    // 0x45E160
    dllexport gnu_noinline static void do_graze(Float2* position) asm_symbol_rel(0x45E160) {
        return PLAYER_PTR->do_graze_impl(position);
    }

private:
    // 0x45A5A0
    dllexport gnu_noinline void vectorcall __set_position_and_all_option_D4_to_1(float, float x, float y) asm_symbol_rel(0x45A5A0) {
        this->set_position(x, y);
        this->__set_all_option_D4_to_1();
    }
public:
    inline void __set_position_and_all_option_D4_to_1(float x, float y) {
        return this->__set_position_and_all_option_D4_to_1(UNUSED_FLOAT, x, y);
    }

    // 0x45A600
    dllexport gnu_noinline void thiscall __set_all_option_D4_to_1(int32_t value = UNUSED_DWORD) asm_symbol_rel(0x45A600) {
        for (size_t i = 0; i < PLAYER_OPTION_COUNT; ++i) {
            this->data.options[i].__int_D4 = 1;
        }
        nounroll for (size_t i = 0; i < PLAYER_EQUIPMENT_OPTION_COUNT; ++i) {
            this->data.equipment[i].__int_D4 = 1;
        }
    }

    // 0x45E930
    dllexport gnu_noinline ZUNResult thiscall shoot_one_bullet(int32_t unknownA_index, int32_t time, Float3* position, PlayerOption* option) asm_symbol_rel(0x45E930) {
        uint8_t index2 = unknownA_index;
        int32_t index1 = unknownA_index >> 8;
        ShtFileUnknownA* unknownA_ptr = &this->sht_file->__unknownA_ptr_array_E0[index1][index2];

        if (unknownA_ptr->__byte_21 == 2) {
            int32_t option_index = unknownA_ptr->__option_index;
            
            int32_t option_index_low = option_index % PLAYER_TOTAL_OPTION_COUNT;
            int32_t option_index_high = option_index >> PLAYER_TOTAL_OPTION_COUNT_BIT_WIDTH;

            int32_t index = option_index < PLAYER_TOTAL_OPTION_COUNT ? option_index_low : option_index_high;

            if (this->data.__level_array_470DC[index] != 0) {
                return ZUN_SUCCESS;
            }
        }

        for (int32_t i = 0; i < PLAYER_BULLET_COUNT; ++i) {
            PlayerBullet* bullet = &this->data.bullets[i];
            if (bullet->state == 0) {
                if (ZUN_FAILED(bullet->shoot(unknownA_index, time, position, option))) {
                    return ZUN_ERROR;
                }
                break;
            }
        }
        return ZUN_SUCCESS;
    }

    // 0x45EA00
    dllexport gnu_noinline int thiscall tick_shooting_state() asm_symbol_rel(0x45EA00);

    // 0x45EDB0
    dllexport gnu_noinline int thiscall tick_bullets() asm_symbol_rel(0x45EDB0) {
        for (size_t i = 0; i < PLAYER_BULLET_COUNT; ++i) {
            this->data.bullets[i].on_tick();
        }
        PLAYER_PTR->data.__unknown_flag_G = false;
        return 0;
    }

    // 0x45BE90
    dllexport gnu_noinline UpdateFuncRet thiscall on_tick() asm_symbol_rel(0x45BE90);

    // 0x45CAA0
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_tick(void* ptr) asm_symbol_rel(0x45CAA0) {
        if (ABILITY_SHOP_PTR) {
            return UpdateFuncNext;
        }
        return ((Player*)ptr)->on_tick();
    }

    // 0x45CAC0
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw(void* ptr) asm_symbol_rel(0x45CAC0) {
        Player* self = (Player*)ptr;
        if (self->data.state != 2) {
            self->__vm_14.controller.position = self->data.position;
            self->__vm_14.data.origin_mode = 1;
            ANM_MANAGER_PTR->draw_vm(&self->__vm_14);
        }
        return UpdateFuncNext;
    }

    // 0x45A7A0
    dllexport gnu_noinline ZUNResult thiscall initialize() {
        
        AnmLoaded* player_anm = ANM_MANAGER_PTR->preload_anm(9, PLAYER_ANM_FILENAMES[GAME_MANAGER.globals.character]);
        this->player_anm = player_anm;
        if (player_anm) {
            this->bullet_anm = player_anm;

            if (ShtFile* cached_sht_file = CACHED_SHT_FILE_PTR) {
                this->sht_file = cached_sht_file;
                CACHED_SHT_FILE_PTR = NULL;
            }
            else {
                ShtFile* sht_file = (ShtFile*)read_file_to_buffer(PLAYER_SHT_FILENAMES[GAME_MANAGER.globals.shottype_index()], NULL, false);
                this->sht_file = sht_file;
                if (!sht_file) {
                    goto error;
                }

                int32_t i = 0;
                if ((uint32_t)i < sht_file->__unknownA_count) {
                    do {
                        sht_file = this->sht_file;

                        sht_file->__unknownA_ptr_array_E0[i] = pointer_raw_offset(sht_file->__unknownA_ptr_array_E0[i], &sht_file->__unknownA_array_180[0]);

                        for (
                            ShtFileUnknownA* unknownA_ptr = sht_file->__unknownA_ptr_array_E0[i];
                            unknownA_ptr->__int_0 >= 0;
                            ++unknownA_ptr
                        ) {
                            unknownA_ptr->__init_func = PLAYER_BULLET_INIT_FUNCS[unknownA_ptr->__init_func_index];
                            unknownA_ptr->__unknown_func_B = PLAYER_FUNC_TABLE_B[unknownA_ptr->__unknown_func_B_index];
                            unknownA_ptr->__unknown_func_C = PLAYER_FUNC_TABLE_C[unknownA_ptr->__unknown_func_C_index];
                            unknownA_ptr->__damage_func = PLAYER_BULLET_DAMAGE_FUNCS[unknownA_ptr->__damage_func_index];
                        }

                        sht_file = this->sht_file;
                    } while (++i < sht_file->__unknownA_count);
                }
            }

            UpdateFunc* update_func = new UpdateFunc(&on_tick, false, this);
            UpdateFuncRegistry::register_on_tick(update_func, 23);
            this->on_tick_func = update_func;
            update_func = new UpdateFunc(&on_draw, false, this);
            UpdateFuncRegistry::register_on_draw(update_func, 29);
            this->on_draw_func = update_func;

            this->player_anm->__copy_data_to_vm_and_run(&this->__vm_14, 0);

            this->data.internal_position.x = 0;
            this->data.internal_position.y = 51200;
            this->data.position.x = 0.0f;
            this->data.position.y = 400.0f;

            this->__set_all_option_D4_to_1();

            for (int32_t i = 0; i < 4; ++i) {
                ((int32_t*)&this->data.__unfocused_linear_speed)[i] = this->sht_file->movement_speeds[i] * INTERNAL_POSITION_RATIO;
            }

            this->sht_file->power_per_level = DEFAULT_POWER_PER_LEVEL;

            GAME_MANAGER.globals.max_power = this->sht_file->power_per_level * this->sht_file->max_level;
            GAME_MANAGER.globals.power_per_level = this->sht_file->power_per_level;

            this->data.shoot_key_short_timer.set(-1);
            this->data.shoot_key_long_timer.set(-1);
            this->data.__death_timer.reset();
            this->data.__timer_3C.reset();
            this->data.__timer_47154.reset();
            this->data.__timer_47168.reset();

            this->data.__int_471C4 = 30;
            this->data.__option_count = 0;
            this->data.__speed_modifier = 1.0f;

            for (size_t i = 0; i < PLAYER_OPTION_COUNT; ++i) {
                this->data.options[i].internal_position.y = -51200;
            }
            nounroll for (size_t i = 0; i < PLAYER_EQUIPMENT_OPTION_COUNT; ++i) {
                this->data.equipment[i].internal_position.y = -51200;
            }

            this->data.__unknown_flag_H = false;

            this->scale_interp.end_time = 0;
            this->scale = 1.0f;

            // BUG: This overflows the bullet array and writes over
            // random following memory. The effects of this are currently
            // unknown, but it's *probably* fine since it'll just write
            // into the damage sources array and that won't explode.
            nounroll for (int32_t i = 0; i < PLAYER_BULLET_COUNT * 2; ++i) {
                this->data.bullets[i].__bullet_index = i;
            }

            return ZUN_SUCCESS;
        }
    error:
        LOG_BUFFER.write(JpEnStr("", "Machine data not found. data is corrupted\r\n"));
        return ZUN_ERROR;
    }

    // 0x45AF20
    dllexport gnu_noinline static Player* allocate() {
        Player* player = new Player();
        PLAYER_PTR = player;
        if (ZUN_FAILED(player->initialize())) {
            delete player;
            return NULL;
        }
        return player;
    }

private:
    inline CollisionResult __check_collision_rectangle_impl(Float2* position, Float2* size, CollisionTestType test_type) {
        Float2 A = this->data.position;
        Float2 B;
        if (this->data.focused) {
            B = this->__hitbox_size_focused;
        } else {
            B = this->__hitbox_size_unfocused;
        }
        Float2 min = A - B;
        Float2 max = A + B;
        // TODO: Verify this math isn't complete BS
        Float2 test_size = *size * 0.5f;
        Float2 test_pos = *position;
        Float2 test_min = test_pos - test_size;
        Float2 test_max = test_pos + test_size;
        if (
            !(min.x > test_max.x) &&
            !(min.y > test_max.y) &&
            !(max.x > test_min.x) &&
            !(max.y > test_min.y)
        ) {
            if (!Gui::msg_is_active()) {
                if (test_type != LethalCollisionTest) {
                    return GrazeCollision;
                }
                switch (this->data.state) {
                    case 2: case 3: case 4:
                        return NoCollision;
                }
                if (this->data.__timer_47154 <= 0) {
                    this->start_dying();
                }
                return DeathCollision;
            }
        }
        else {
            test_max -= 24.0f;
            test_min += 24.0f;
            if (
                !(min.x > test_max.x) &&
                !(min.y > test_max.y) &&
                !(max.x > test_min.x) &&
                !(max.y > test_min.y)
            ) {
                return GrazeCollision;
            }
        }
        return NoCollision;
    }
public:
    // 0x45CC20
    dllexport gnu_noinline static CollisionResult __check_collision_rectangle(Float2* position, Float2* size, CollisionTestType test_type) asm_symbol_rel(0x45CC20) {
        return PLAYER_PTR->__check_collision_rectangle_impl(position, size, test_type);
    }

private:
    // Implementation may not actually use Float2 judging by how the compiler is using the stack
    inline CollisionResult __check_collision_rotated_rectangle_impl(Float2* position, float angle, float width, float length, CollisionTestType test_type) {
        Float2 A = (this->data.position - *position).rotate_around_origin(-angle);
        BOOL focused = this->data.focused;
        Float2 B;
        if (focused) {
            B = this->__hitbox_size_focused;
        } else {
            B = this->__hitbox_size_unfocused;
        }
        B *= 16.0f;
        Float2 min = A - B;
        Float2 max = A + B;
        if (
            !(min.x > length) &&
            !(min.y > width * 0.5f) &&
            !(max.x > 0.0f) &&
            !(max.y > -width * 0.5f)
        ) {
            if (focused) {
                B = this->__hitbox_size_focused;
            } else {
                B = this->__hitbox_size_unfocused;
            }
            min = A - B;
            max = A + B;
            if (
                !(min.x > length) &&
                !(min.y > width * 0.5f) &&
                !(max.x > 0.0f) &&
                !(max.y > -width * 0.5f)
            ) {
                if (!Gui::msg_is_active()) {
                    if (test_type != LethalCollisionTest) {
                        return GrazeCollision;
                    }
                    switch (this->data.state) {
                        case 2: case 3: case 4:
                            return NoCollision;
                    }
                    if (this->data.__timer_47154 > 0) {
                        return NoCollision; // Bug? Inconsistent with other types
                    }
                    this->start_dying();
                    return DeathCollision;
                }
            } else {
                return GrazeCollision;
            }
        }
        return NoCollision;
    }

    /*
    inline CollisionResult __check_collision_rotated_rectangle_impl(Float2* position, float angle, float width, float length, CollisionTestType test_type) {
        angle = -angle;
        float x = this->data.position.x - position->x;
        float y = this->data.position.y - position->y;
        float y_unit = zsinf(angle);
        float x_unit = zcosf(angle);
        BOOL focused = this->data.focused;
        float AX = (x_unit * x) - (y_unit * y);
        float AY = (x_unit * y) + (y_unit * x);
        float BX;
        float BY;
        if (focused) {
            BX = this->__hitbox_size_focused.x;
            BY = this->__hitbox_size_focused.y;
        } else {
            BX = this->__hitbox_size_unfocused.x;
            BY = this->__hitbox_size_unfocused.y;
        }
        BX *= 16.0f;
        BY *= 16.0f;
        float x_min = AX - BX;
        float x_max = AX + BX;
        float y_min = AY - BY;
        float y_max = AY + BY;
        if (
            !(x_min > length) &&
            !(y_min > width * 0.5f) &&
            !(x_max > 0.0f) &&
            !(y_max > -width * 0.5f)
        ) {
            if (focused) {
                BX = this->__hitbox_size_focused.x;
                BY = this->__hitbox_size_focused.y;
            } else {
                BX = this->__hitbox_size_unfocused.x;
                BY = this->__hitbox_size_unfocused.y;
            }
            x_min = AX - BX;
            x_max = AX + BX;
            y_min = AY - BY;
            y_max = AY + BY;
            if (
                !(x_min > length) &&
                !(y_min > width * 0.5f) &&
                !(x_max > 0.0f) &&
                !(y_max > -width * 0.5f)
            ) {
                if (!Gui::msg_is_active()) {
                    if (test_type != LethalCollisionTest) {
                        return GrazeCollision;
                    }
                    switch (this->data.state) {
                        case 2: case 3: case 4:
                            return NoCollision;
                    }
                    if (this->data.__timer_47154 > 0) {
                        return NoCollision;
                    }
                    this->start_dying();
                    return DeathCollision;
                }
            } else {
                return GrazeCollision;
            }
        }
        return NoCollision;
    }
    */

    // 0x45CEA0
    dllexport gnu_noinline static CollisionResult vectorcall __check_collision_rotated_rectangle(int, int, float, float, Float2* position, float angle, float width, float length, CollisionTestType test_type) asm_symbol_rel(0x45CEA0) {
        return PLAYER_PTR->__check_collision_rotated_rectangle_impl(position, angle, width, length, test_type);
    }
public:
    static inline CollisionResult __check_collision_rotated_rectangle(Float2* position, float angle, float width, float length, CollisionTestType test_type) {
        return Player::__check_collision_rotated_rectangle(UNUSED_DWORD, UNUSED_DWORD, UNUSED_FLOAT, UNUSED_FLOAT, position, angle, width, length, test_type);
    }

private:
    inline CollisionResult check_collision_circle_impl(Float2* position, float radius, CollisionTestType test_type) {
        float distance_squared = this->data.position.distance_squared(position);
        float player_radius;
        if (this->data.focused) {
            player_radius = this->__hitbox_radius_focused;
        } else {
            player_radius = this->__hitbox_radius_unfocused;
        }
        if (this->data.scale_enabled) {
            player_radius *= this->scale * 3.6f;
        }
        float radius_squared = radius * radius;
        if (player_radius * player_radius + radius_squared <= distance_squared) {
            radius /= 2.5f;
            float A = __max(radius, 40.0f) + player_radius;
            if (A * A + radius_squared <= distance_squared) {
                return NoCollision;
            }
            return GrazeCollision;
        }
        if (Gui::msg_is_active()) {
            return NoCollision;
        }
        if (test_type != LethalCollisionTest) {
            return GrazeCollision;
        }
        switch (this->data.state) {
            case 2: case 3: case 4:
                return NoCollision;
        }
        if (this->data.__timer_47154 <= 0) {
            this->start_dying();
        }
        return DeathCollision;
    }

    // 0x45CD90
    dllexport static gnu_noinline CollisionResult vectorcall check_collision_circle(int, int, float, float, Float2* position, float radius, CollisionTestType test_type) asm_symbol_rel(0x45CD90) {
        return PLAYER_PTR->check_collision_circle_impl(position, radius, test_type);
    }

public:
    static inline CollisionResult check_collision_circle(Float2* position, float radius, CollisionTestType test_type) {
        return check_collision_circle(UNUSED_DWORD, UNUSED_DWORD, UNUSED_FLOAT, UNUSED_FLOAT, position, radius, test_type);
    }

private:
    // 0x45DE40
    dllexport gnu_noinline int32_t vectorcall create_damage_source_circle(int, float, float, Float3* position, float radius, float radius_delta, int32_t duration, int32_t arg5) {
        int32_t index = this->data.last_created_damage_source_index;

        for (int32_t i = 0; i < PLAYER_DAMAGE_SOURCE_COUNT; ++i) {
            ++index;
            if (index > PLAYER_DAMAGE_SOURCE_COUNT) {
                index = 0;
            }

            PlayerDamageSource* damage_source = &this->data.damage_sources[index];
            if (!damage_source->active) {
                damage_source->active = true;
                damage_source->hitbox_type = CircleHitbox;
                damage_source->__unknown_flag_A = false;

                damage_source->motion.zero_contents();
                damage_source->motion.position = *position;
                damage_source->radius = radius;
                damage_source->radius_delta = radius_delta;
                damage_source->duration.set(duration);
                damage_source->__int_74 = arg5;
                damage_source->__int_78 = 0;
                damage_source->__int_7C = 9999999;
                damage_source->__hit_frequency = 1;
                damage_source->__unknown_func_index = 0;
                damage_source->__enemy_id_84 = 0;
                damage_source->__int_88 = 0;
                damage_source->__int_8C = 0;
                break;
            }
        }

        this->data.last_created_damage_source_index = index;
        return index + 1;
    }
public:
    inline int32_t create_damage_source_circle(Float3* position, float radius, float radius_delta, int32_t duration, int32_t arg5) {
        return this->create_damage_source_circle(UNUSED_DWORD, UNUSED_FLOAT, UNUSED_FLOAT, position, radius, radius_delta, duration, arg5);
    }

private:
    inline int32_t create_damage_source_rotated_rectangle_impl(
        Float3* position,
        float width, float height,
        float rotation,
        int32_t duration, int32_t arg6
    ) {
        int32_t index = this->data.last_created_damage_source_index;

        for (int32_t i = 0; i < PLAYER_DAMAGE_SOURCE_COUNT; ++i) {
            ++index;
            if (index > PLAYER_DAMAGE_SOURCE_COUNT) {
                index = 0;
            }

            PlayerDamageSource* damage_source = &this->data.damage_sources[index];
            if (!damage_source->active) {
                damage_source->active = true;
                damage_source->hitbox_type = RectangleHitbox;
                damage_source->__unknown_flag_A = false;

                damage_source->motion.zero_contents();
                damage_source->motion.position = *position;
                damage_source->size.x = width;
                damage_source->size.y = height;
                damage_source->angle = rotation;
                damage_source->angular_velocity.value = 0.0f;
                damage_source->duration.set(duration);
                damage_source->__int_74 = arg6;
                damage_source->__int_78 = 0;
                damage_source->__int_7C = 9999999;
                damage_source->__hit_frequency = 1;
                damage_source->__unknown_func_index = 0;
                damage_source->__enemy_id_84 = 0;
                damage_source->__int_88 = 0;
                damage_source->__int_8C = 0;
                break;
            }
        }

        this->data.last_created_damage_source_index = index;
        return index + 1;
    }
    // 0x45DFA0
    static dllexport gnu_noinline int32_t vectorcall create_damage_source_rotated_rectangle(
        int, int, float, float,
        Float3* position,
        float width, float height,
        uint32_t rotation,
        int32_t duration, int32_t arg6
    ) asm_symbol_rel(0x45DFA0) {
        return PLAYER_PTR->create_damage_source_rotated_rectangle_impl(
            position,
            width, height,
            bitcast<float>(rotation),
            duration, arg6
        );
    }
public:
    static inline int32_t create_damage_source_rotated_rectangle(
        Float3* position,
        float width, float height,
        float rotation,
        int32_t duration, int32_t arg6
    ) {
        return create_damage_source_rotated_rectangle(
            UNUSED_DWORD, UNUSED_DWORD, UNUSED_FLOAT, UNUSED_FLOAT,
            position,
            width, height,
            bitcast<uint32_t>(rotation),
            duration, arg6
        );
    }

    inline int32_t compute_damage_sources(Float3* position, Float2* size, float rotation, float radius, int32_t* arg5, Float3* hit_position_out, BOOL arg7, int32_t enemy_id) {
        if (this->data.__death_timer.__is_paused()) {
            return 0;
        }

        int32_t A; // LOCAL 17

        BombBase* bomb = BOMB_PTR;
        if (!bomb->active) {
            A = 0;
        } else {
            // Nothing uses this... >_>
            A = bomb->__method_10(position, size);
        }

        if (arg5) {
            *arg5 = __min(A, 1);
        }

        BOOL B[4] = {};
        int32_t C[4] = {};
        int32_t D[4] = {};

        PlayerDamageSource* damage_source_ptr = &this->data.damage_sources[0]; // LOCAL 16
        for (
            size_t i = 0;
            i < PLAYER_DAMAGE_SOURCE_COUNT;
            ++i, ++damage_source_ptr
        ) {
            if (
                damage_source_ptr->active &&
                damage_source_ptr->duration.__is_multiple_of_not_paused(damage_source_ptr->__hit_frequency) &&
                damage_source_ptr->__int_88 <= 0
            ) {
                if (damage_source_ptr->check_collision(position, size, rotation, radius)) {
                    switch (int32_t index = damage_source_ptr->__int_8C - 1) {
                        case 0: case 1: case 2: case 3:
                            if (B[index] && C[index] > damage_source_ptr->__int_74) {
                                continue;
                            }
                            A -= D[index];
                            B[index] = true;
                            C[index] = damage_source_ptr->__int_74;
                    }
                    if (enemy_id) {
                        if (damage_source_ptr->__enemy_id_84 == enemy_id) {
                            continue;
                        }
                        damage_source_ptr->__enemy_id_84 = enemy_id;
                    }
                    if (arg5 && damage_source_ptr->__unknown_flag_A) {
                        *arg5 = 1;
                    }
                    int32_t E = damage_source_ptr->__int_74;
                    if (!arg7) {
                        if (damage_source_ptr->__unknown_func_index) {
                            damage_source_ptr->__enemy_id_94 = enemy_id;
                            int32_t F = PLAYER_DAMAGE_SOURCE_UNKNOWN_FUNCS[damage_source_ptr->__unknown_func_index](damage_source_ptr, position, size, rotation, radius);
                            if (F >= 0) {
                                E = F;
                            }
                        }
                        damage_source_ptr->__int_78 += damage_source_ptr->__int_74;
                    }
                    switch (int32_t index = damage_source_ptr->__int_8C - 1) {
                        case 0: case 1: case 2: case 3:
                            D[index] = E;
                    }
                    A += E;
                    if (hit_position_out) {
                        *hit_position_out = damage_source_ptr->motion.position;
                    }
                    int32_t G = damage_source_ptr->__int_7C;
                    if (
                        G < 9999999 &&
                        G <= damage_source_ptr->__int_78
                    ) {
                        damage_source_ptr->active = false;
                        damage_source_ptr->__int_74 = 0;
                    }
                }
            }
        }

        A = __min(A, this->__int_47984);

        if (
            !arg7 &&
            A != 0
        ) {
            GAME_MANAGER.add_to_score(A / 10 + 10);
        }

        return A;
    }
};
#pragma region // Player Validation
ValidateFieldOffset32(0x0, Player, task_flags);
ValidateFieldOffset32(0x4, Player, on_tick_func);
ValidateFieldOffset32(0x8, Player, on_draw_func);
ValidateFieldOffset32(0xC, Player, player_anm);
ValidateFieldOffset32(0x10, Player, bullet_anm);
ValidateFieldOffset32(0x14, Player, __vm_14);
ValidateFieldOffset32(0x620, Player, data);
ValidateFieldOffset32(0x47928, Player, __float3_47928);
ValidateFieldOffset32(0x47934, Player, __base_movement_velocity);
ValidateFieldOffset32(0x4793C, Player, movement_direction);
ValidateFieldOffset32(0x47940, Player, sht_file);
ValidateFieldOffset32(0x47944, Player, __dword_47944);
ValidateFieldOffset32(0x47948, Player, __byte_47948);
ValidateFieldOffset32(0x4794C, Player, scale_interp);
ValidateFieldOffset32(0x4797C, Player, scale);
ValidateFieldOffset32(0x47980, Player, damage_multiplier);
ValidateFieldOffset32(0x47984, Player, __int_47984);
ValidateFieldOffset32(0x47988, Player, __item_attract_speed);
ValidateFieldOffset32(0x4798C, Player, item_collect_radius);
ValidateFieldOffset32(0x47990, Player, item_attract_radius_focused);
ValidateFieldOffset32(0x47994, Player, item_attract_radius_unfocused);
ValidateFieldOffset32(0x47998, Player, poc_height);
ValidateFieldOffset32(0x4799C, Player, __hitbox_radius_unfocused);
ValidateFieldOffset32(0x479A0, Player, __hitbox_radius_focused);
ValidateFieldOffset32(0x479A4, Player, __hitbox_size_unfocused);
ValidateFieldOffset32(0x479AC, Player, __float_479AC);
ValidateFieldOffset32(0x479B0, Player, __hitbox_size_focused);
ValidateFieldOffset32(0x479B8, Player, __float_479B8);
ValidateFieldOffset32(0x479CC, Player, __float_479CC);
ValidateStructSize32(0x479D0, Player);
#pragma endregion

// 0x45F0F0
dllexport gnu_noinline int32_t vectorcall HitboxManager::Impl::enm_compute_damage_sources(int32_t, int32_t, float, float, float, Float3* position, Float2* size, float rotation, float radius, int32_t* arg5, Float3* hit_position_out, BOOL arg7, int32_t enemy_id) {
    return PLAYER_PTR->compute_damage_sources(position, size, rotation, radius, arg5, hit_position_out, arg7, enemy_id);
}

// 0x45CBA0
dllexport gnu_noinline float vectorcall HitboxManager::Impl::angle_to_player_from_point(int, int, Float2* position) {
    clang_forceinline return PLAYER_PTR->angle_from_point(position);
}

static inline PlayerDamageSource* get_damage_source_by_index(int32_t index) {
    if (!index) {
        return &PLAYER_PTR->data.__dummy_damage_source;
    }
    else {
        return &PLAYER_PTR->data.damage_sources[index - 1];
    }
}

static inline PlayerBullet* get_player_bullet_by_index(int32_t index) {
    return &PLAYER_PTR->data.bullets[index];
}

// 0x45F6A0
dllexport gnu_noinline int32_t fastcall PlayerDamageSource::__unknown_func_1(PlayerDamageSource* self, Float3* position, Float2* size, float rotation, float radius) {
    PlayerBullet* bullet = get_player_bullet_by_index(self->__player_bullet_index);
    if (auto* damage_func = bullet->__damage_func) {
        return damage_func(bullet, position, size, rotation, radius);
    } else {
        return bullet->__sub_45F6F0();
    }
}

// 0x460AB0
dllexport gnu_noinline int32_t fastcall PlayerDamageSource::__unknown_func_2(PlayerDamageSource* self, Float3* position, Float2* size, float rotation, float radius) {
    PlayerBullet* bullet = get_player_bullet_by_index(self->__player_bullet_index);
    int32_t ret = bullet->__int_9C;
    bullet->__int_9C = 1;
    return ret;
}

// 0x420BF0
dllexport gnu_noinline int32_t fastcall PlayerDamageSource::__unknown_func_3(PlayerDamageSource* self, Float3* position, Float2* size, float rotation, float radius) {
    AnmVM* vm;
    PLAYER_PTR->player_anm->instantiate_vm_to_world_list_back(20, position, &vm);

    float A = BOMB_PTR->__float3_24.z;

    Float2 idk;
    idk.make_from_vector(A, 6.5f);

    vm->data.current_context.__float3_20.x = idk.x;
    vm->data.current_context.__float3_20.y = idk.y;

    return -1;
}

inline void PlayerBullet::on_tick() {
    if (this->state) {

        ShtFileUnknownA* unknownA_ptr = &PLAYER_PTR->sht_file->__unknownA_ptr_array_E0[this->__sht_unknownA_index1][this->__sht_unknownA_index2];

        if (auto func_ptr = this->__func_ptr_D8) {
            if (ZUN_FAILED(func_ptr(this))) {
                return;
            }
        }

        this->motion.update3();
        this->motion.update();

        AnmVM* vm = this->__vm_id_8.get_vm_ptr();
        if (!vm) {
            this->__int_9C = 0;
            if (int32_t damage_source_index = this->damage_source_index) {
                PLAYER_PTR->data.damage_sources[damage_source_index - 1].active = false;
            }
            return;
        }

        if (unknownA_ptr->__byte_21 != 2) {
            Float3 vertex_positions[4];
            vm->__get_vertex_quad(vertex_positions);
            if (this->__timer_C >= 15) {
                // TODO: probably check for offscreen position
            }
        }

        if (int32_t damage_source_index = this->damage_source_index) {
            PlayerDamageSource* damage_source = &PLAYER_PTR->data.damage_sources[damage_source_index - 1];

            damage_source->motion.position = this->motion.position;
            damage_source->angle = this->motion.angle;
            damage_source->size = this->size;
            damage_source->__int_74 = this->__int_9C;
        }

        vm->controller.position = this->motion.position;
        if (vm->data.auto_rotate) {
            vm->set_z_rotation(this->motion.angle);
        }

        this->__timer_C++;
    }
}

typedef struct PopupManager PopupManager;
extern "C" {
    // 0x4CF420
    externcg PopupManager* POPUP_MANAGER_PTR cgasm("_POPUP_MANAGER_PTR");
}

// size: 0x48
struct Popup {
    uint8_t digits[12]; // 0x0
    Float3 position; // 0xC
    float __speed; // 0x18
    D3DCOLOR color; // 0x1C
    Timer __timer_20; // 0x20
    unknown_fields(0x8); // 0x34
    bool alive; // 0x3C
    uint8_t digit_count; // 0x3D
    unknown_fields(0xA); // 0x3E
    // 0x48

    inline bool on_tick() {
        if (this->alive) {
            float position = this->position.y;
            float speed = this->__speed;
            this->position.y -= speed * GAME_SPEED;
            this->__speed = speed * 0.95f;
            if (++this->__timer_20 <= 60) {
                return true;
            }
            this->alive = false;
        }
        return false;
    }
};
#pragma region // Popup Validation

#pragma endregion

// size: 0x1044
struct PopupManager : ZUNTask {
    // ZUNTask base; // 0x0
    AnmLoaded* ascii_anm; // 0xC
    int32_t __index_10; // 0x10
    unknown_fields(0x4); // 0x14
    AnmVM __vm_18; // 0x18
    Popup popups[18]; // 0x624
    // 0xCE4

    inline void zero_contents() {
        zero_this();
    }

    inline PopupManager() {
        this->zero_contents();
        this->__unknown_task_flag_A = true;
    }

    // 0x463F50
    dllexport gnu_noinline ~PopupManager() {
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);

        POPUP_MANAGER_PTR = NULL;
    }

    // 0x464020
    dllexport gnu_noinline UpdateFuncRet thiscall on_tick() asm_symbol_rel(0x464020) {

        for (size_t i = 0; i < 13; ++i) {
            this->popups[i].on_tick();
        }
        for (size_t i = 0; i < 5; ++i) {
            Popup* popup = &this->popups[i + 13];
            if (popup->on_tick()) {
                D3DCOLOR color = popup->color;
                int32_t alpha = color >> 18;
                alpha -= 4;
                if (alpha <= 0) {
                    popup->alive = false;
                } else {
                    popup->color = (color & 0xFFFFFF) | alpha << 18;
                }
            }
        }

        return UpdateFuncNext;
    }

    // 0x464180
    dllexport gnu_noinline UpdateFuncRet thiscall on_draw() asm_symbol_rel(0x464180) {
        Popup* popup = this->popups;
        SUPERVISOR.d3d_disable_fog();

        for (size_t i = 0; i < 13; ++i) {

        }

        return UpdateFuncNext;
    }

    // 0x4645D0
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_tick(void* ptr) asm_symbol_rel(0x4645D0) {
        return ((PopupManager*)ptr)->on_tick();
    }

    // 0x4645E0
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw(void* ptr) asm_symbol_rel(0x4645E0) {
        return ((PopupManager*)ptr)->on_draw();
    }

    // 0x4645F0
    dllexport gnu_noinline static void stdcall create_popup(Float3* position, int32_t value, D3DCOLOR color) {
        PopupManager* popup_manager = POPUP_MANAGER_PTR;

        int32_t index = popup_manager->__index_10;
        if (index >= 10) {
            popup_manager->__index_10 = 0;
            index = 0;
        }

        Popup* popup = &popup_manager->popups[index];

        popup->alive = true;

        int32_t digit_count = 0;
        if (value >= 0) {
            while (value > 0) {
                int32_t next_value = value / 10;
                uint8_t digit = next_value;
                popup->digits[digit_count++] = value - digit * 10;
                value = next_value;
            }
            if (!digit_count) {
                popup->digits[digit_count++] = 0;
            }
        }
        else {
            popup->digits[digit_count++] = 10; // ???
        }
        popup->digit_count = digit_count;
        popup->color = color;
        popup->__timer_20.reset();
        popup->position = *position;
        popup->__speed = 1.0f;

        ++popup_manager->__index_10;
    }

    inline ZUNResult initialize() {
        this->ascii_anm = ASCII_MANAGER_PTR->ascii_anm;

        UpdateFunc* update_func = new UpdateFunc(&on_tick, false, this);
        UpdateFuncRegistry::register_on_tick(update_func, 21);
        this->on_tick_func = update_func;
        update_func = new UpdateFunc(&on_draw, false, this);
        UpdateFuncRegistry::register_on_draw(update_func, 48);
        this->on_draw_func = update_func;

        AnmLoaded* ascii_anm = this->ascii_anm;
        this->__vm_18.reset();
        this->__vm_18.data.slot2 = ascii_anm->slot_index;
        ascii_anm->set_sprite(&this->__vm_18, 289);

        this->__vm_18.data.origin_mode = 2;
        this->__vm_18.data.resolution_mode = 3;

        return ZUN_SUCCESS;
    }

    // 0x463DD0
    dllexport gnu_noinline static PopupManager* allocate() asm_symbol_rel(0x463DD0) {
        PopupManager* popup_manager = new PopupManager();
        POPUP_MANAGER_PTR = popup_manager;
        if (ZUN_FAILED(popup_manager->initialize())) {
            delete popup_manager;
            return NULL;
        }
        return popup_manager;
    }
};
#pragma region // PopupManager Validation

#pragma endregion

typedef struct AbilityManager AbilityManager;
typedef struct AbilityTextData AbilityTextData;
typedef struct AbilityMenu AbilityMenu;

extern "C" {
    // 0x4CF298
    externcg AbilityManager* ABILITY_MANAGER_PTR cgasm("_ABILITY_MANAGER_PTR");
    // 0x4CF29C
    externcg AbilityTextData* ABILITY_TEXT_DATA_PTR cgasm("_ABILITY_TEXT_DATA_PTR");
    // 0x4CF2A0
    externcg AbilityMenu* ABILITY_MENU_PTR cgasm("_ABILITY_MENU_PTR");
    // 0x4CF2D4
    externcg int32_t UNKNOWN_COUNTER_A cgasm("_UNKNOWN_COUNTER_A");
}

static inline bool enemies_are_alive();
static inline float ability_manager_get_float_C58();
static inline AnmLoaded* ability_manager_get_ability_anm();

// size: 0x54
struct CardBase {
    // void* vtable; // 0x0
    int32_t id; // 0x4
    int32_t __array_index; // 0x8
    ZUNList<CardBase> list_node; // 0xC
    AnmID effect_vm_id; // 0x1C
    Timer __timer_20; // 0x20
    Timer __timer_34; // 0x34
    int32_t recharge_time; // 0x48
    const CardData* data; // 0x4C
    union {
        uint32_t flags; // 0x50
        struct {
            uint32_t __unknown_flag_F : 1; // 1
            uint32_t __unknown_flag_B : 1; // 2
            uint32_t __unknown_flag_C : 1; // 3
            uint32_t __is_active_card : 1; // 4
            uint32_t : 1; // 5
            uint32_t __unknown_flag_A : 1; // 6
            uint32_t __is_equipment_card : 1; // 7
            uint32_t : 1; // 8
        };
    };
    // 0x54

    inline void zero_contents() {
        zero_this();
    }

    inline CardBase() {
        this->zero_contents();
        this->id = -1;
        this->list_node.initialize_with(this);
    }

    // Method 0
    // 0x413010
    dllexport gnu_noinline virtual ZUNResult thiscall initializeA() {
        return ZUN_SUCCESS;
    }
    // Method 4
    // 0x413020
    dllexport gnu_noinline virtual ZUNResult thiscall initializeB() {
        return ZUN_SUCCESS;
    }
    // Method 8
    // 0x413030
    dllexport gnu_noinline virtual int thiscall on_activate() {
        return 0;
    }
    // Method C
    // 0x413040
    dllexport gnu_noinline virtual BOOL thiscall on_player_death(BOOL already_prevented_death) {
        return FALSE;
    }
    // Method 10
    // 0x413050
    dllexport gnu_noinline virtual int thiscall on_player_start_dying() {
        return 0;
    }
    // Method 14
    // 0x413060
    dllexport gnu_noinline virtual int thiscall on_player_death_power_loss() {
        return 0;
    }
    // Method 18
    // 0x413070
    dllexport gnu_noinline virtual int thiscall on_power_level_change() {
        return 0;
    }
    // Method 1C
    // 0x413080
    dllexport gnu_noinline virtual int thiscall on_shoot(int32_t short_time, int32_t long_time) {
        return 0;
    }
    // Method 20
    // 0x413090
    dllexport gnu_noinline virtual int thiscall on_load() {
        return 0;
    }
    // Method 24
    // 0x4130A0
    dllexport gnu_noinline virtual int thiscall on_tick() {
        return 0;
    }
    // Method 28
    // 0x4130B0
    dllexport gnu_noinline virtual int thiscall __on_bullet_init(PlayerBullet* bullet) {
        return 0;
    }
    // Method 2C
    // 0x4130C0
    dllexport gnu_noinline virtual int thiscall __on_tick_2() {
        return 0;
    }
    // Method 30
    // 0x4130D0
    dllexport gnu_noinline virtual int thiscall recharge(int, int) {
        return 0;
    }
    // Method 34
    // 0x4130E0
    dllexport gnu_noinline virtual void thiscall __on_load_2() {
    }
    // Method 38
    // 0x4130F0
    dllexport gnu_noinline virtual int thiscall __set_replay_state(int32_t value) {
        this->__timer_34.set(value);
        return 0;
    }
    // Method 3C
    // 0x413130
    dllexport gnu_noinline virtual int32_t thiscall __get_replay_state() {
        return this->__timer_34.current;
    }
    // Method 40
    // 0x413140
    dllexport gnu_noinline virtual bool thiscall __get_unknown_flag_A() {
        return this->__unknown_flag_A;
    }
    // Method 44
    // 0x413050
    dllexport gnu_noinline virtual int thiscall on_anm_id_assigned_to_hud(AnmID id) {
        return 0;
    }
    // Method 48
    // 0x413060
    dllexport gnu_noinline virtual int thiscall on_draw() {
        return 0;
    }
    // Method 4C
    // 0x413070
    dllexport gnu_noinline virtual void thiscall __method_4C() {
    }
    // Method 50
    // 0x412ED0
    virtual ~CardBase() {
        this->list_node.unlink();
    }

    // 0x408BF0
    dllexport int thiscall __dec_timer_34_during_gameplay() asm_symbol_rel(0x408BF0) {
        if (!GUI_PTR->msg_is_active() && enemies_are_alive()) {
            if (this->__timer_34 > 0) {
                this->__timer_34--;
            }
        }
        return 0;
    }

    inline void __inc_timer_20_during_gameplay() {
        if (!GUI_PTR->msg_is_active() && enemies_are_alive()) {
            ++this->__timer_20;
        }
    }
};

// size: 0x58
struct CardKoishi : CardBase {
    // CardBase base; // 0x0
    int32_t power; // 0x54
    // 0x58

    static inline constexpr CardId ID = KOISHI_CARD; // 27

    inline CardKoishi() {
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = true;
        this->__is_active_card = false;
        this->__is_equipment_card = false;
    }

    // Method C
    // 0x40D4E0
    dllexport gnu_noinline virtual BOOL thiscall on_player_death(BOOL already_prevented_death) {
        this->power = GAME_MANAGER.globals.current_power;
        return FALSE;
    }
    // Method 14
    // 0x40D4F0
    dllexport gnu_noinline virtual int thiscall on_player_death_power_loss() {
        this->power -= 50;
        int32_t new_power = this->power;
        if (new_power < DEFAULT_POWER_PER_LEVEL) {
            this->power = DEFAULT_POWER_PER_LEVEL;
            new_power = DEFAULT_POWER_PER_LEVEL;
        }
        clang_forceinline GAME_MANAGER.globals.set_power(new_power);
        return 0;
    }
    // Method 2C
    // 0x40D4C0
    dllexport gnu_noinline virtual int thiscall __on_tick_2() {
        /*
        if (EnemyManager* enemy_manager = ENEMY_MANAGER_PTR) {
            enemy_manager->__int_164 = 1;
        }
        */
        return 0;
    }
    // Method 34
    // 0x40D4A0
    dllexport gnu_noinline virtual void thiscall __on_load_2() {
        this->__method_4C();
    }
    // Method 4C
    // 0x40D4B0
    dllexport gnu_noinline virtual void thiscall __method_4C() {
        this->__unknown_flag_B = false;
    }
};

struct CardKaguya : CardBase {
    static inline constexpr CardId ID = DEAD_SPELL_CARD; // 31

    inline CardKaguya() {
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = true;
        this->__is_active_card = false;
        this->__is_equipment_card = false;
    }

    // Method 14
    // 0x40D2E0
    dllexport gnu_noinline virtual int thiscall on_player_death_power_loss() {
        spawn_item(BombItem, &PLAYER_PTR->data.position, -HALF_PI_f, 3.2f, 3);
        return 0;
    }
};

// size: 0x58
struct CardMamizou : CardBase {
    // CardBase base; // 0x0
    int32_t power; // 0x54
    // 0x58

    static inline constexpr CardId ID = POWERMAX_CARD; // 32

    inline CardMamizou() {
        this->__unknown_flag_B = true;
        this->__unknown_flag_C = true;
        this->__is_active_card = false;
        this->__is_equipment_card = false;
    }

    // Method 4
    // 0x40D390
    dllexport gnu_noinline virtual int thiscall __method_4() {
        if (GAME_THREAD_PTR && this->__unknown_flag_B) {
            BOOL A = GAME_MANAGER.globals.add_power(DEFAULT_POWER_PER_LEVEL);
            this->__unknown_flag_B = false;
            if (A) {
                if (Player* player = PLAYER_PTR) {
                    player->data.__update_option_power_levels();
                    POPUP_MANAGER_PTR->create_popup(&PLAYER_PTR->data.position, -1, PackD3DCOLOR(64, 255, 255, 255));
                    SOUND_MANAGER.play_sound_positioned(13, PLAYER_PTR->data.position.x);
                }
            }
        }
        return 0;
    }
    // Method C
    // 0x40D400
    dllexport gnu_noinline virtual BOOL thiscall on_player_death(BOOL already_prevented_death) {
        this->power = GAME_MANAGER.globals.current_power;
        return FALSE;
    }
    // Method 14
    // 0x40D410
    dllexport gnu_noinline virtual int thiscall on_player_death_power_loss() {
        int32_t A = GAME_MANAGER.globals.power_per_level;
        int32_t new_power = this->power;
        
        int32_t B = A * 3;
        if (new_power > B) {
            this->power = B;
            new_power = B;
            A = GAME_MANAGER.globals.power_per_level;
        }

        int32_t max_power = GAME_MANAGER.globals.max_power;
        if (new_power > max_power) {
            GAME_MANAGER.globals.current_power = max_power;
        } else {
            if (new_power < A) {
                new_power = A;
            }
            GAME_MANAGER.globals.current_power = new_power;
        }
        return 0;
    }
    // Method 34
    // 0x40D380
    dllexport gnu_noinline virtual void thiscall __on_load_2() {
        if (SUPERVISOR.__int_804) {
            this->__method_4();
        }
    }
    // Method 4C
    // 0x40D370
    dllexport gnu_noinline virtual void thiscall __method_4C() {
        this->__unknown_flag_B = true;
    }
};

struct CardYuyuko : CardBase {
    static inline constexpr CardId ID = YUYUKO_CARD; // 33

    inline CardYuyuko() {
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = true;
        this->__is_active_card = false;
        this->__is_equipment_card = false;
    }

    // Method 2C
    // 0x40D5A0
    dllexport gnu_noinline virtual int thiscall __on_tick_2() {
        /*
        if (BulletManager* bullet_manager = BULLET_MANAGER_PTR) {
            bullet_manager->__unknown_counter_flag = 1;
        }
        */
        return 0;
    }
    // Method 34
    // 0x40D580
    dllexport gnu_noinline virtual void thiscall __on_load_2() {
        this->__method_4C();
    }
    // Method 4C
    // 0x40D590
    dllexport gnu_noinline virtual void thiscall __method_4C() {
        this->__unknown_flag_B = false;
    }
};
struct CardYachie : CardBase {
    static inline constexpr CardId ID = MONEY_CARD; // 34

    inline CardYachie() {
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = true;
        this->__is_active_card = false;
        this->__is_equipment_card = false;
    }

    // Method 30
    // 0x40D630
    dllexport gnu_noinline virtual int thiscall recharge(int, int) {
        float A = REPLAY_RNG.rand_angle();
        // TODO
        return 0;
    }
    // Method 34
    // 0x40D610
    dllexport gnu_noinline virtual void thiscall __on_load_2() {
        this->__method_4C();
    }
    // Method 4C
    // 0x40D620
    dllexport gnu_noinline virtual void thiscall __method_4C() {
        this->__unknown_flag_B = false;
    }
};

// size: 0x64
struct CardShikiEiki : CardBase {
    // CardBase base; // 0x0
    int __int_54; // 0x54
    AnmID __vm_id_58; // 0x58
    void* __ptr_5C; // 0x5C PlayerDamageSource*?
    unknown_fields(0x4); // 0x60
    // 0x64

    static inline constexpr CardId ID = ROKUMON_CARD; // 35

    inline CardShikiEiki() {
        this->__vm_id_58 = NULL;
        this->__ptr_5C = NULL;
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = true;
        this->__is_active_card = false;
        this->__is_equipment_card = false;
    }

    // 0x40D840
    dllexport gnu_noinline int thiscall __sub_40D840() asm_symbol_rel(0x40D840) {
        ability_manager_get_ability_anm()->instantiate_vm_to_world_list_back(41, &PLAYER_PTR->data.position);
        SOUND_MANAGER.play_sound(44);
        // TODO
        //SPELLCARD_PTR->__sub_409AD0();
        GAME_MANAGER.globals.current_money -= 200;
        PLAYER_PTR->data.__timer_47154.set(60);
        // ++ENEMY_MANAGER_PTR->player_bomb_count;
        // ENEMY_MANAGER_PTR->can_capture_spell = FALSE;
        // TODO
        this->__timer_20.reset();
        this->__int_54 = 1;
        return 0;
    }
    // Method C
    // 0x40DA10
    dllexport gnu_noinline virtual BOOL thiscall on_player_death(BOOL already_prevented_death) {
        if (GAME_MANAGER.globals.current_money >= 200) {
            this->__sub_40D840();

            // This is an inlined version of cancel_impending_death
            PLAYER_PTR->data.__death_timer.set(60);
            PLAYER_PTR->data.state = 1;
            return TRUE;
        }
        return FALSE;
    }
    // Method 24
    // 0x40DA80
    dllexport gnu_noinline virtual int thiscall on_tick() {
        switch (this->__int_54) {
            case 1:
                // TODO
                if (this->__timer_20 >= 60) {
                    this->__int_54 = 0;
                    BOMB_PTR->__dword_A0 = 0;
                }
                break;
        }
        ++this->__timer_20;
        return 0;
    }
    // Method 34
    // 0x40D800
    dllexport gnu_noinline virtual void thiscall __on_load_2() {
        this->__method_4C();
    }
    // Method 4C
    // 0x40D810
    dllexport gnu_noinline virtual void thiscall __method_4C() {
        this->__unknown_flag_B = false;
        this->__vm_id_58.mark_tree_for_delete();
        this->__int_54 = 0;
        this->__ptr_5C = NULL;
    }
};


struct CardMike : CardBase {
    static inline constexpr CardId ID = MANEKI_CARD; // 38

    inline CardMike() {
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = true;
        this->__is_active_card = false;
        this->__is_equipment_card = false;
    }
};
struct CardTakane : CardBase {
    static inline constexpr CardId ID = YAMAWARO_CARD; // 39

    inline CardTakane() {
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = true;
        this->__is_active_card = false;
        this->__is_equipment_card = false;
    }
};
struct CardSannyo : CardBase {
    static inline constexpr CardId ID = KISERU_CARD; // 40

    inline CardSannyo() {
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = true;
        this->__is_active_card = false;
        this->__is_equipment_card = false;
    }
};

// size: 0x68
struct CardShinmyoumaru : CardBase {
    // CardBase base; // 0x0
    int __int_54; // 0x54
    Float3 position; // 0x58
    int __dword_64; // 0x64
    // 0x68

    static inline constexpr CardId ID = KOZUCHI_CARD; // 42

    inline CardShinmyoumaru() {
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = false;
        this->__is_active_card = true;
        this->__is_equipment_card = false;
        this->__timer_20.reset();
        this->recharge_time = 2400;
        this->__int_54 = 0;
        this->__timer_34.reset();
    }

    // Method 8
    // 0x40F0F0
    dllexport gnu_noinline virtual int thiscall on_activate() {
        if (!this->__int_54 && this->recharge_time <= 0) {
            this->position = PLAYER_PTR->data.position;
            this->effect_vm_id = ability_manager_get_ability_anm()->instantiate_vm_to_world_list_back(30, &this->position, 13);
            this->__int_54 = 1;
            this->__timer_20.reset();
            SOUND_MANAGER.play_sound_positioned(30, this->position.x);
            this->__timer_34.set(this->recharge_time * ability_manager_get_float_C58());
            this->__dword_64 = 0;
        }
        return 0;
    }
    // Method C
    // 0x40F0D0
    dllexport gnu_noinline virtual BOOL thiscall on_player_death(BOOL already_prevented_death) {
        this->__int_54 = 0;
        this->effect_vm_id.mark_tree_for_delete();
        return FALSE;
    }
    // Method 2C
    // 0x40EED0
    dllexport gnu_noinline virtual int thiscall __on_tick_2() {
        switch (this->__int_54) {
            case 3:
                this->__unknown_flag_A = true;
                if (this->__timer_20 < 10) {
                    float A = (float)this->__timer_20 * 4.0f + 30.0f;
                    // TODO
                }
                if (this->__timer_20 > 40) {
                    this->__int_54 = 0;
                    this->effect_vm_id.mark_tree_for_delete();
                }
                break;
            case 2:
                this->__unknown_flag_A = true;
                if (this->__timer_20 > 10) {
                    this->__int_54 = 3;
                    // TODO, something inlined from sound manager
                    SOUND_MANAGER.play_sound_positioned(41, this->position.x);
                    this->__timer_20.reset();
                    this->position.y -= 84.0f;
                }
                break;
            case 1:
                this->position = PLAYER_PTR->data.position;
                this->position.y -= 16.0f;
                this->effect_vm_id.set_controller_position(&this->position);
                if (this->__timer_20 > 20) {
                    this->__int_54 = 2;
                    this->__timer_20.reset();
                }
                break;
            case 0:
                this->__unknown_flag_A = false;
                this->__dec_timer_34_during_gameplay();
                break;
        }
        ++this->__timer_20;
        return 0;
    }
    // Method 34
    // 0x40EE00
    dllexport gnu_noinline virtual void thiscall __on_load_2() {
        this->__unknown_flag_B = false;
        this->__timer_20.reset();
        this->__int_54 = 0;
        this->effect_vm_id.mark_tree_for_delete();
    }
    // Method 4C
    // 0x40EE50
    dllexport gnu_noinline virtual void thiscall __method_4C() {
        this->__unknown_flag_B = false;
        this->__timer_20.reset();
        this->__int_54 = 0;
        this->__timer_34.reset();
        this->effect_vm_id.mark_tree_for_delete();
    }
};

// size: 0x74
struct CardTenshi : CardBase {
    // CardBase base; // 0x0
    int __int_54; // 0x54
    Float3 position; // 0x58
    Float3 __float3_64; // 0x64
    int __dword_70; // 0x70
    // 0x74

    static inline constexpr CardId ID = KANAME_CARD; // 43

    inline CardTenshi() {
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = false;
        this->__is_active_card = true;
        this->__is_equipment_card = false;
        this->__timer_20.reset();
        this->recharge_time = 3600;
        this->__int_54 = 0;
        this->__timer_34.reset();
    }

    // Method 8
    // 0x40EBF0
    dllexport gnu_noinline virtual int thiscall on_activate() {
        if (!this->__int_54 && this->recharge_time <= 0) {
            this->position = PLAYER_PTR->data.position;
            this->position.y -= 100.0f;
            this->__float3_64 = this->position;
            this->effect_vm_id = ability_manager_get_ability_anm()->instantiate_vm_to_world_list_back(28, &this->position, 13);
            this->__int_54 = 1;
            this->__timer_20.reset();
            SOUND_MANAGER.play_sound_positioned(77, this->position.x);
            this->__timer_34.set(this->recharge_time * ability_manager_get_float_C58());
            this->__unknown_flag_A = true;
            this->__dword_70 = 0;
        }
        return 0;
    }
    // Method 2C
    // 0x40E8C0
    dllexport gnu_noinline virtual int thiscall __on_tick_2() {
        switch (this->__int_54) {
            case 2:
                this->__unknown_flag_A = false;
                if (this->__timer_20 > 8) {
                    this->__int_54 = 0;
                    this->effect_vm_id.mark_tree_for_delete();
                }
                break;
            case 1:
                if (this->__timer_20 >= 30) {
                    this->__unknown_flag_A = false;
                }
                this->__float3_64 = PLAYER_PTR->data.position;
                this->__float3_64.y -= 80.0f;
                static constexpr float scale = 1.0f / 25.0f;
                this->position += (this->__float3_64 - this->position) * scale;
                this->effect_vm_id.set_controller_position(&this->position);
                if (this->__timer_20 > 1800) {
                    this->effect_vm_id.interrupt_tree(1);
                    this->__int_54 = 2;
                    this->__timer_20.reset();
                    SOUND_MANAGER.play_sound_positioned(41, this->position.x);
                }
                break;
            case 0:
                this->__unknown_flag_A = false;
                this->__dec_timer_34_during_gameplay();
                break;
        }
        if (this->__int_54 == 1) {
            // TODO
        }
        this->__inc_timer_20_during_gameplay();
        return 0;
    }
    // Method 34
    // 0x40E7F0
    dllexport gnu_noinline virtual void thiscall __on_load_2() {
        this->__unknown_flag_B = false;
        this->__timer_20.reset();
        this->__int_54 = 0;
        this->effect_vm_id.mark_tree_for_delete();
    }
    // Method 4C
    // 0x40E840
    dllexport gnu_noinline virtual void thiscall __method_4C() {
        this->__unknown_flag_B = false;
        this->__timer_20.reset();
        this->__int_54 = 0;
        this->__timer_34.reset();
        this->effect_vm_id.mark_tree_for_delete();
    }
};

// size: 0xC4
struct CardClownpiece : CardBase {
    // CardBase base; // 0x0
    int __int_54; // 0x54
    Float3 position; // 0x58
    ZUNInterp<Float3> position_interp; // 0x64
    void* __ptr_BC; // 0xBC PlayerDamageSource*?
    float __float_C0; // 0xC0
    // 0xC4

    static inline constexpr CardId ID = MOON_CARD; // 44

    inline CardClownpiece() {
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = false;
        this->__is_active_card = true;
        this->__is_equipment_card = false;
        this->__timer_20.reset();
        this->recharge_time = 2700;
        this->__int_54 = 0;
        this->__timer_34.reset();
    }

    // Method 8
    // 0x40E040
    dllexport gnu_noinline virtual int thiscall on_activate() {
        if (!this->__int_54 && this->recharge_time <= 0) {
            Float3 A = this->position_interp.initial_value = this->position = PLAYER_PTR->data.position;
            A.y -= 400.0f;
            this->position_interp.mode = 1;
            this->position_interp.end_time = 120;
            this->position_interp.final_value = A;
            this->position_interp.time.reset();
            // TODO
            this->effect_vm_id = ability_manager_get_ability_anm()->instantiate_vm_to_world_list_back(45, &this->position, 13);
            this->__int_54 = 1;
            this->__timer_20.reset();
            this->__float_C0 = 0;
            SOUND_MANAGER.play_sound_positioned(77, this->position.x);
            this->__timer_34.set(this->recharge_time * ability_manager_get_float_C58());
        }
        return 0;
    }
    // Method 2C
    // 0x40DCE0
    dllexport gnu_noinline virtual int thiscall __on_tick_2() {
        switch (this->__int_54) {
            case 2:
                this->__unknown_flag_A = true;
                this->position = this->position_interp.step();
                this->position.y += this->__float_C0;
                this->effect_vm_id.set_controller_position(&this->position);
                if (this->__timer_20 > 40) {
                    this->__int_54 = 0;
                    this->effect_vm_id.mark_tree_for_delete();
                }
                break;
            case 1:
                this->__unknown_flag_A = true;
                this->position = this->position_interp.step();
                this->position.y += this->__float_C0;
                this->effect_vm_id.set_controller_position(&this->position);
                if (this->__timer_20 > 80) {
                    this->__int_54 = 2;
                    this->effect_vm_id.interrupt_tree(1);
                    this->__timer_20.reset();

                }
                break;
            case 0:
                this->__unknown_flag_A = false;
                this->__dec_timer_34_during_gameplay();
                break;
        }
        if (this->__int_54) {
            // TODO
        }
        ++this->__timer_20;
        return 0;
    }
    // Method 34
    // 0x40DC10
    dllexport gnu_noinline virtual void thiscall __on_load_2() {
        this->__unknown_flag_B = false;
        this->__timer_20.reset();
        this->__int_54 = 0;
        this->effect_vm_id.mark_tree_for_delete();
    }
    // Method 4C
    // 0x40DC60
    dllexport gnu_noinline virtual void thiscall __method_4C() {
        this->__unknown_flag_B = false;
        this->__timer_20.reset();
        this->__int_54 = 0;
        this->__timer_34.reset();
        this->effect_vm_id.mark_tree_for_delete();
    }
};

// size: 0x68
struct CardMiko : CardBase {
    // CardBase base; // 0x0
    int __int_54; // 0x54
    Float3 position; // 0x58
    void* __ptr_64; // 0x64 PlayerDamageSource*?
    // 0x68

    static inline constexpr CardId ID = MIKOFLASH_CARD; // 45

    inline CardMiko() {
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = false;
        this->__is_active_card = true;
        this->__is_equipment_card = false;
        this->__timer_20.reset();
        this->recharge_time = 1800;
        this->__int_54 = 0;
        this->__timer_34.reset();
    }

    // Method 8
    // 0x40E5C0
    dllexport gnu_noinline virtual int thiscall on_activate() {
        if (!this->__int_54 && this->recharge_time <= 0) {
            this->position = PLAYER_PTR->data.position;
            // TODO
            this->effect_vm_id = ability_manager_get_ability_anm()->instantiate_vm_to_world_list_back(47, &this->position, 13);
            this->__int_54 = 1;
            this->__timer_20.reset();
            SOUND_MANAGER.play_sound_positioned(77, this->position.x);
            this->__timer_34.set(this->recharge_time * ability_manager_get_float_C58());
        }
        return 0;
    }
    // Method 2C
    // 0x40E3D0
    dllexport gnu_noinline virtual int thiscall __on_tick_2() {
        switch (this->__int_54) {
            case 1:
                this->__unknown_flag_A = true;
                this->position = PLAYER_PTR->data.position;
                this->effect_vm_id.set_controller_position(&PLAYER_PTR->data.position);
                if (this->__timer_20 > 130) {
                    this->__int_54 = 0;
                    this->effect_vm_id.mark_tree_for_delete();
                }
                if (
                    (uint32_t)this->__timer_20.current - 40 <= 79 &&
                    this->__timer_20.is_multiple_of(8)
                ) {
                    // TODO
                }
                break;
            case 0:
                this->__unknown_flag_A = false;
                this->__dec_timer_34_during_gameplay();
                break;
        }
        ++this->__timer_20;
        return 0;
    }
    // Method 34
    // 0x40E300
    dllexport gnu_noinline virtual void thiscall __on_load_2() {
        this->__unknown_flag_B = false;
        this->__timer_20.reset();
        this->__int_54 = 0;
        this->effect_vm_id.mark_tree_for_delete();
    }
    // Method 4C
    // 0x40E350
    dllexport gnu_noinline virtual void thiscall __method_4C() {
        this->__unknown_flag_B = false;
        this->__timer_20.reset();
        this->__int_54 = 0;
        this->__timer_34.reset();
        this->effect_vm_id.mark_tree_for_delete();
    }
};

// size: 0x68
struct CardRemilia : CardBase {
    // CardBase base; // 0x0
    int __int_54; // 0x54
    Float3 position; // 0x58
    int __dword_64; // 0x64
    // 0x68

    static inline constexpr CardId ID = VAMPIRE_CARD; // 46

    inline CardRemilia() {
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = false;
        this->__is_active_card = true;
        this->__is_equipment_card = false;
        this->__timer_20.reset();
        this->recharge_time = 1200;
        this->__int_54 = 0;
        this->__timer_34.reset();
    }

    // Method 8
    // 0x40F670
    dllexport gnu_noinline virtual int thiscall on_activate() {
        if (!this->__int_54 && this->recharge_time <= 0) {
            this->position = PLAYER_PTR->data.position;
            this->effect_vm_id = ability_manager_get_ability_anm()->instantiate_vm_to_world_list_back(38, &this->position, 13);
            this->__int_54 = 1;
            this->__timer_20.reset();
            SOUND_MANAGER.play_sound_positioned(30, this->position.x);
            this->__timer_34.set(this->recharge_time * ability_manager_get_float_C58());
            this->__dword_64 = 0;
        }
        return 0;
    }
    // Method C
    // 0x40F650
    dllexport gnu_noinline virtual BOOL thiscall on_player_death(BOOL already_prevented_death) {
        this->__int_54 = 0;
        this->effect_vm_id.mark_tree_for_delete();
        return FALSE;
    }
    // Method 2C
    // 0x40F3A0
    dllexport gnu_noinline virtual int thiscall __on_tick_2() {
        switch (this->__int_54) {
            case 2:
                this->position = PLAYER_PTR->data.position;
                this->effect_vm_id.set_controller_position(&PLAYER_PTR->data.position);
                if (this->__timer_20 < 50) {
                    Float3 A = this->position;
                    float B;
                    if (this->__timer_20 < 10) {
                        B = (float)this->__timer_20 * 90.0f / 10.0f;
                    } else {
                        B = 90.0f;
                    }
                    A.y -= B * 0.5f;
                    // TODO
                }
                if (this->__timer_20 > 60) {
                    this->__int_54 = 0;
                    this->effect_vm_id.mark_tree_for_delete();
                }
                break;
            case 1:
                this->position = PLAYER_PTR->data.position;
                this->effect_vm_id.set_controller_position(&PLAYER_PTR->data.position);
                if (this->__timer_20 > 30) {
                    this->__int_54 = 2;
                    this->__timer_20.reset();
                    SOUND_MANAGER.play_sound_positioned(27, this->position.x);
                }
                break;
            case 0:
                this->__unknown_flag_A = false;
                this->__dec_timer_34_during_gameplay();
                break;
        }
        ++this->__timer_20;
        return 0;
    }
    // Method 34
    // 0x40F2D0
    dllexport gnu_noinline virtual void thiscall __on_load_2() {
        this->__unknown_flag_B = false;
        this->__timer_20.reset();
        this->__int_54 = 0;
        this->effect_vm_id.mark_tree_for_delete();
    }
    // Method 4C
    // 0x40F320
    dllexport gnu_noinline virtual void thiscall __method_4C() {
        this->__unknown_flag_B = false;
        this->__timer_20.reset();
        this->__int_54 = 0;
        this->__timer_34.reset();
        this->effect_vm_id.mark_tree_for_delete();
    }
};

// size: 0x6C
struct CardUtsuho : CardBase {
    // CardBase base; // 0x0
    int __int_54; // 0x54
    Float3 position; // 0x58
    int __dword_64; // 0x64
    void* __ptr_68; // 0x68 PlayerDamageSource*?
    // 0x6C

    static inline constexpr CardId ID = SUN_CARD; // 47

    inline CardUtsuho() {
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = false;
        this->__is_active_card = true;
        this->__is_equipment_card = false;
        this->__timer_20.reset();
        this->recharge_time = 18000;
        this->__int_54 = 0;
        this->__timer_34.reset();
    }

    // Method 8
    // 0x40FB60
    dllexport gnu_noinline virtual int thiscall on_activate() {
        if (!this->__int_54 && this->recharge_time <= 0) {
            //SPELLCARD_PTR->__sub_409AD0();
            // TODO
            this->position = PLAYER_PTR->data.position;
            // TODO
            this->effect_vm_id = ability_manager_get_ability_anm()->instantiate_vm_to_world_list_back(50, &this->position, 13);
            this->__int_54 = 1;
            this->__timer_20.reset();
            SOUND_MANAGER.play_sound_positioned(49, this->position.x);
            this->__timer_34.set(this->recharge_time * ability_manager_get_float_C58());
            this->__dword_64 = 0;
        }
        return 0;
    }
    // Method C
    // 0x40FB40
    dllexport gnu_noinline virtual BOOL thiscall on_player_death(BOOL already_prevented_death) {
        this->__int_54 = 0;
        this->effect_vm_id.mark_tree_for_delete();
        return FALSE;
    }
    // Method 2C
    // 0x40F920
    dllexport gnu_noinline virtual int thiscall __on_tick_2() {
        switch (this->__int_54) {
            case 2:
                this->__unknown_flag_A = true;
                if (this->__timer_20 > 60) {
                    this->__int_54 = 0;
                    this->effect_vm_id.mark_tree_for_delete();
                }
                break;
            case 1: {
                this->__unknown_flag_A = true;
                /*
                if (SPELLCARD_PTR) {
                    Spellcard::__sub_409AD0();
                }
                */
                if (GUI_PTR->msg_vm) {
                    this->__int_54 = 2;
                    this->__timer_20.reset();
                    this->effect_vm_id.interrupt_tree(1);
                }
                // TODO
                float A = this->effect_vm_id.get_vm_ptr()->data.scale.x * 96.0f;
                if (this->__timer_20 > 600) {
                    this->__int_54 = 2;
                    this->__timer_20.reset();
                    SOUND_MANAGER.play_sound_positioned(27, this->position.x);
                }
                if (
                    this->__timer_20.is_multiple_of(6) &&
                    GAME_MANAGER.globals.subtract_power(1)
                ) {
                    PLAYER_PTR->data.__update_option_power_levels();
                }
                break;
            }
            case 0:
                this->__unknown_flag_A = false;
                this->__dec_timer_34_during_gameplay();
                break;
        }
        ++this->__timer_20;
        return 0;
    }
    // Method 34
    // 0x40F850
    dllexport gnu_noinline virtual void thiscall __on_load_2() {
        this->__unknown_flag_B = false;
        this->__timer_20.reset();
        this->__int_54 = 0;
        this->effect_vm_id.mark_tree_for_delete();
    }
    // Method 4C
    // 0x40F8A0
    dllexport gnu_noinline virtual void thiscall __method_4C() {
        this->__unknown_flag_B = false;
        this->__timer_20.reset();
        this->__int_54 = 0;
        this->__timer_34.reset();
        this->effect_vm_id.mark_tree_for_delete();
    }
};

// size: 0x58
struct CardLilyWhite : CardBase {
    // CardBase base; // 0x0
    int32_t __int_54; // 0x54
    // 0x58

    static inline constexpr CardId ID = LILY_CARD; // 48

    inline CardLilyWhite() {
        this->recharge_time = 7200;
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = false;
        this->__is_active_card = true;
        this->__is_equipment_card = false;
        this->__timer_34.reset();
        this->__int_54 = 0;
    }

    // Method 8
    // 0x40FE70
    dllexport gnu_noinline virtual int thiscall on_activate() {
        if (this->recharge_time <= 0) {
            if (EnemyManager* enemy_manager = ENEMY_MANAGER_PTR) {
                // TODO, needs full enemy manager access
                this->__timer_34.set(this->recharge_time * ability_manager_get_float_C58());
                ++this->__int_54;
                this->__unknown_flag_A = true;
            }
        }
        return 0;
    }
    // Method 2C
    // 0x40FE20
    dllexport gnu_noinline virtual int thiscall __on_tick_2() {
        this->__dec_timer_34_during_gameplay();
        if (this->__timer_34 < this->recharge_time - 8) {
            this->__unknown_flag_A = false;
        }
        return 0;
    }
    // Method 34
    // 0x40FDD0
    dllexport gnu_noinline virtual void thiscall __on_load_2() {
        this->__unknown_flag_B = false;
    }
    // Method 38
    // 0x40FFA0
    dllexport gnu_noinline virtual int thiscall __set_replay_state(int32_t value) {
        this->__timer_34.set((uint16_t)value);
        this->__int_54 = value >> 16;
        return 0;
    }
    // Method 3C
    // 0x40FFE0
    dllexport gnu_noinline virtual int32_t thiscall __get_replay_state() {
        return (uint16_t)this->__timer_34.current | this->__int_54 << 16;
    }
    // Method 4C
    // 0x40FDE0
    dllexport gnu_noinline virtual void thiscall __method_4C() {
        this->__unknown_flag_B = false;
        this->__timer_34.reset();
        this->__int_54 = 0;
    }
};

// size: 0x68
struct CardRaiko : CardBase {
    // CardBase base; // 0x0
    int __int_54; // 0x54
    Float3 position; // 0x58
    int __dword_64; // 0x64
    // 0x68

    static inline constexpr CardId ID = BASSDRUM_CARD; // 49

    inline CardRaiko() {
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = false;
        this->__is_active_card = true;
        this->__is_equipment_card = false;
        this->__timer_20.reset();
        this->recharge_time = 600;
        this->__int_54 = 0;
        this->__timer_34.reset();
    }

    // Method 8
    // 0x410250
    dllexport gnu_noinline virtual int thiscall on_activate() {
        if (!this->__int_54 && this->recharge_time <= 0) {
            this->position = PLAYER_PTR->data.position;
            this->effect_vm_id = ability_manager_get_ability_anm()->instantiate_vm_to_world_list_back(58, &this->position, 13);
            this->__int_54 = 1;
            this->__timer_20.reset();
            SOUND_MANAGER.play_sound_positioned(51, this->position.x);
            this->__timer_34.set(this->recharge_time * ability_manager_get_float_C58());
            this->__dword_64 = 0;
        }
        return 0;
    }
    // Method 2C
    // 0x410110
    dllexport gnu_noinline virtual int thiscall __on_tick_2() {
        switch (this->__int_54) {
            case 1:
                this->__unknown_flag_A = true;
                // TODO
                if (this->__timer_20 >= 30) {
                    this->__int_54 = 0;
                    this->__timer_20.reset();
                    this->effect_vm_id.mark_tree_for_delete();
                }
                break;
            case 0:
                this->__unknown_flag_A = false;
                this->__dec_timer_34_during_gameplay();
                break;
        }
        ++this->__timer_20;
        return 0;
    }
    // Method 34
    // 0x410040
    dllexport gnu_noinline virtual void thiscall __on_load_2() {
        this->__unknown_flag_B = false;
        this->__timer_20.reset();
        this->__int_54 = 0;
        this->effect_vm_id.mark_tree_for_delete();
    }
    // Method 4C
    // 0x410090
    dllexport gnu_noinline virtual void thiscall __method_4C() {
        this->__unknown_flag_B = false;
        this->__timer_20.reset();
        this->__int_54 = 0;
        this->__timer_34.reset();
        this->effect_vm_id.mark_tree_for_delete();
    }
};

// size: 0x68
struct CardSumireko : CardBase {
    // CardBase base; // 0x0
    int __int_54; // 0x54
    Float3 position; // 0x58
    int __dword_64; // 0x64
    // 0x68

    static inline constexpr CardId ID = PSYCHO_CARD; // 50

    inline CardSumireko() {
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = false;
        this->__is_active_card = true;
        this->__is_equipment_card = false;
        this->__timer_20.reset();
        this->recharge_time = 1500;
        this->__int_54 = 0;
        this->__timer_34.reset();
    }

    // Method 8
    // 0x410780
    dllexport gnu_noinline virtual int thiscall on_activate() {
        if (!this->__int_54 && this->recharge_time <= 0) {
            this->position = PLAYER_PTR->data.position;
            this->effect_vm_id = ability_manager_get_ability_anm()->instantiate_vm_to_world_list_back(60, &this->position, 13);
            this->__int_54 = 1;
            this->__timer_20.reset();
            SOUND_MANAGER.play_sound_positioned(51, this->position.x);
            this->__timer_34.set(this->recharge_time * ability_manager_get_float_C58());
            this->__dword_64 = 0;
        }
        return 0;
    }
    // Method 2C
    // 0x410500
    dllexport gnu_noinline virtual int thiscall __on_tick_2() {
        switch (this->__int_54) {
            case 1:
                this->effect_vm_id.set_controller_position(&this->position);
                this->__unknown_flag_A = true;
                // TODO
                if (this->__timer_20 >= 120) {
                    this->__int_54 = 0;
                    this->__timer_20.reset();
                    this->effect_vm_id.mark_tree_for_delete();
                }
                break;
            case 0: 
                this->__unknown_flag_A = false;
                this->__dec_timer_34_during_gameplay();
                break;
        }
        ++this->__timer_20;
        return 0;
    }
    // Method 34
    // 0x410430
    dllexport gnu_noinline virtual void thiscall __on_load_2() {
        this->__unknown_flag_B = false;
        this->__timer_20.reset();
        this->__int_54 = 0;
        this->effect_vm_id.mark_tree_for_delete();
    }
    // Method 4C
    // 0x410480
    dllexport gnu_noinline virtual void thiscall __method_4C() {
        this->__unknown_flag_B = false;
        this->__timer_20.reset();
        this->__int_54 = 0;
        this->__timer_34.reset();
        this->effect_vm_id.mark_tree_for_delete();
    }
};


struct CardMagtama : CardBase {
    static inline constexpr CardId ID = MAGATAMA_CARD; // 51

    inline CardMagtama() {
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = true;
        this->__is_active_card = false;
        this->__is_equipment_card = false;
    }
};
struct CardTsukasa : CardBase {
    static inline constexpr CardId ID = CYLINDER_CARD; // 52

    inline CardTsukasa() {
        this->recharge_time = 1200;
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = false;
        this->__is_active_card = true;
        this->__is_equipment_card = false;
        this->__timer_34.reset();
    }

    // Method 8
    // 0x410E60
    dllexport gnu_noinline virtual int thiscall on_activate() {
        if (this->__timer_34 <= 0) {
            if (GAME_MANAGER.globals.current_power < GAME_MANAGER.globals.power_per_level * 2) {
                SOUND_MANAGER.play_sound(16);
                return 0;
            }
            BombBase* bomb = BOMB_PTR;
            if (!bomb->active && !bomb->__dword_A0) {
                bomb->active = TRUE;
                bomb->__timer_34.reset();
                // TODO
                SOUND_MANAGER.play_sound_positioned(44, PLAYER_PTR->data.position.x);
                bomb->activate();
                UNKNOWN_COUNTER_A = 0;
                // ENEMY_MANAGER_PTR->can_capture_spell = FALSE;
                GAME_MANAGER.globals.subtract_power(GAME_MANAGER.globals.power_per_level);
                PLAYER_PTR->data.__update_option_power_levels();
                this->__timer_34.set(this->recharge_time * ability_manager_get_float_C58());
            }
        }
        return 0;
    }
    // Method 2C
    // 0x410E10
    dllexport gnu_noinline virtual int thiscall __on_tick_2() {
        this->__dec_timer_34_during_gameplay();
        if (this->__timer_34 < this->recharge_time - 8) {
            this->__unknown_flag_A = false;
        }
        return 0;
    }
    // Method 34
    // 0x410DD0
    dllexport gnu_noinline virtual void thiscall __on_load_2() {
        this->__unknown_flag_B = false;
    }
    // Method 4C
    // 0x410DE0
    dllexport gnu_noinline virtual void thiscall __method_4C() {
        this->__unknown_flag_B = false;
        this->__timer_34.reset();
    }
};
struct CardMegumu : CardBase {
    static inline constexpr CardId ID = RICEBALL_CARD; // 53

    inline CardMegumu() {
        this->recharge_time = 5400;
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = false;
        this->__is_active_card = true;
        this->__is_equipment_card = false;
        this->__timer_34.reset();
    }

    // Method 8
    // 0x410BD0
    dllexport gnu_noinline virtual int thiscall on_activate() {
        if (this->__timer_34 < 0) {
            if (GAME_MANAGER.globals.current_power >= GAME_MANAGER.globals.max_power) {
                GAME_MANAGER.globals.add_bomb_fragment();
                SOUND_MANAGER.play_sound_positioned(13, PLAYER_PTR->data.position.x);
            }
            else {
                if (GAME_MANAGER.globals.add_power(DEFAULT_POWER_PER_LEVEL)) {
                    PLAYER_PTR->data.__update_option_power_levels();
                    POPUP_MANAGER_PTR->create_popup(&PLAYER_PTR->data.position, -1, PackD3DCOLOR(64, 255, 255, 255));
                    SOUND_MANAGER.play_sound_positioned(13, PLAYER_PTR->data.position.x);
                }
            }
            this->__timer_34.set(this->recharge_time * ability_manager_get_float_C58());
            this->effect_vm_id = ability_manager_get_ability_anm()->instantiate_vm_to_world_list_back(66, &PLAYER_PTR->data.position, 13);
        }
        return 0;
    }
    // Method 2C
    // 0x410A90
    dllexport gnu_noinline virtual int thiscall __on_tick_2() {
        this->__dec_timer_34_during_gameplay();
        if (this->__timer_34 < this->recharge_time - 8) {
            this->__unknown_flag_A = false;
        }
        this->effect_vm_id.set_controller_position(&PLAYER_PTR->data.position);
        // TODO
        return 0;
    }
    // Method 34
    // 0x410A50
    dllexport gnu_noinline virtual void thiscall __on_load_2() {
        this->__unknown_flag_B = false;
    }
    // Method 4C
    // 0x410A60
    dllexport gnu_noinline virtual void thiscall __method_4C() {
        this->__unknown_flag_B = false;
        this->__timer_34.reset();
    }
};

// size: 0x5C
struct CardMomoyo : CardBase {
    // CardBase base; // 0x0
    int32_t __int_54; // 0x54
    AnmID __vm_id_58; // 0x58
    // 0x5C

    static inline constexpr CardId ID = MUKADE_CARD; // 54

    inline CardMomoyo() {
        this->__int_54 = 0;
        UNKNOWN_COUNTER_A = 0;
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = true;
        this->__is_active_card = false;
        this->__is_equipment_card = false;
    }

    // Method 28
    // 0x411010
    dllexport gnu_noinline virtual int thiscall __on_bullet_init(PlayerBullet* bullet) {
        // TODO
    }
    // Method 2C
    // 0x411000
    dllexport gnu_noinline virtual int thiscall __on_tick_2() { // pointless override
        return 0;
    }
    // Method 34
    // 0x410FE0
    dllexport gnu_noinline virtual void thiscall __on_load_2() {
        this->__method_4C();
    }
    // Method 38
    // 0x411350
    dllexport gnu_noinline virtual int thiscall __set_replay_state(int32_t value) {
        this->__int_54 = value;
        return 0;
    }
    // Method 3C
    // 0x411360
    dllexport gnu_noinline virtual int32_t thiscall __get_replay_state() {
        return this->__int_54;
    }
    // Method 44
    // 0x413050
    dllexport gnu_noinline virtual int thiscall on_anm_id_assigned_to_hud(AnmID id) {
        this->__vm_id_58 = id;
        return 0;
    }
    // Method 48
    // 0x4110A0
    dllexport gnu_noinline virtual int thiscall on_draw() {
        // TODO
        return 0;
    }
    // Method 4C
    // 0x410FF0
    dllexport gnu_noinline virtual void thiscall __method_4C() {
        this->__unknown_flag_B = false;
        this->__int_54 = 0;
    }
};

struct CardNull : CardBase {
    static inline constexpr CardId ID = NULL_CARD; // 56

    inline CardNull() {
        this->__unknown_flag_B = false;
        this->__unknown_flag_C = true;
        this->__is_active_card = false;
        this->__is_equipment_card = false;
    }
};

// size: 0x1C0
struct CardText {
    char lines[7][64]; // 0x0
    // 0x1C0
};

// size: 0x63E0
struct AbilityTextData {
    CardText description_text[CARD_COUNT]; // 0x0
    AnmID __vm_id_array_63C0[7]; // 0x63C0
    AnmID __vm_id_63DC; // 0x63DC
    // 0x63E0

    inline void zero_contents() {
        zero_this();
    }

    // 0x4132B0
    dllexport static void delete_vms() asm_symbol_rel(0x4132B0) {
        AnmManager* anm_manager = ANM_MANAGER_PTR;
        AbilityTextData* ability_text_data = ABILITY_TEXT_DATA_PTR;
        size_t i = countof(ability_text_data->__vm_id_array_63C0);
        AnmID* current_vm_id = ability_text_data->__vm_id_array_63C0;
        do {
            current_vm_id++->mark_tree_for_delete(anm_manager);
        } while (--i);
        ability_text_data->__vm_id_63DC.mark_tree_for_delete(anm_manager);
    }

    // 0x416940
    dllexport void thiscall __sub_416940(int arg1, int arg2) asm_symbol_rel(0x416940) {

    }

    // 0x416C10
    dllexport static void stdcall __sub_416C10(int arg1) asm_symbol_rel(0x416C10) {
        AnmManager* anm_manager = ANM_MANAGER_PTR;
        AbilityTextData* ability_text_data = ABILITY_TEXT_DATA_PTR;
        size_t i = countof(ability_text_data->__vm_id_array_63C0);
        AnmID* current_vm_id = ability_text_data->__vm_id_array_63C0;
        do {
            current_vm_id++->__tree_set_visible2(anm_manager);
        } while (--i);
        ability_text_data->__sub_416940(arg1, 0);
    }

    static forceinline char* ability_txt_skip_to_end_of_line(const char* str, int32_t& count) {
        char c = *str;
        while (
            c != '\n' && c != '\r' && c != '\f'
        ) {
            c = *str++;
            --count;
        }
        return (char*)str;
    }
    static forceinline char* ability_txt_skip_end_of_line_chars(const char* str, int32_t& count) {
        char c;
        while (
            ((c = *str) == '\n' || c == '\r' || c == '\f') &&
            count != 0
        ) {
            ++str;
            --count;
        }
        return (char*)str;
    }

    // 0x413580
    dllexport static gnu_noinline char* fastcall ability_txt_skip_to_next_line(const char* str, int32_t& count) asm_symbol_rel(0x413580) {
        str = ability_txt_skip_to_end_of_line(str, count);
        if (count != 0) {
            str = ability_txt_skip_end_of_line_chars(str, count);
        }
        return (char*)str;
    }

    // 0x4135D0
    dllexport static gnu_noinline char* fastcall ability_txt_copy_rest_of_line_to_buffer(char* out_str, char* str, int32_t& count) asm_symbol_rel(0x4135D0) {
        out_str[0] = '\0';
        char* end_of_line = str;
        if (*str != '\n') {
            end_of_line = ability_txt_skip_to_end_of_line(str, count);
        }
        if (count != 0) {
            *end_of_line = '\0';
            byteloop_strcpy(out_str, str);
            end_of_line = ability_txt_skip_end_of_line_chars(++end_of_line, count);
        }
        return end_of_line;
    }

    // 0x4160B0
    dllexport gnu_noinline void thiscall initialize() asm_symbol_rel(0x4160B0) {
        return;
        char buffer[0x100];
        int32_t ability_txt_count;
        void* ability_txt_file = read_file_to_buffer("ability.txt", &ability_txt_count, false);
        char* ability_txt = (char*)ability_txt_file;
        while (ability_txt_count > 0) {
            switch (char c = *ability_txt++) {
                case '\\':
                    goto break_all;
                case '@': stupid_label: {
                    --ability_txt_count;
                    ability_txt = ability_txt_copy_rest_of_line_to_buffer(buffer, ability_txt, ability_txt_count);
                    auto& matched_card = find_in_card_data([=](const CardData& card) {
                        return !strcmp_asm(card.name, buffer);
                    });
                    const CardId& matched_id = matched_card.id;
                    if (ability_txt_count > 0) {
                        for (int32_t i = 0; i < countof(CardText::lines); ++i) {
                            while ((c = *ability_txt) == '#') {
                                clang_forceinline ability_txt = ability_txt_skip_to_next_line(ability_txt, ability_txt_count);
                                if (ability_txt_count <= 0) {
                                    goto break_all;
                                }
                            }
                            if (c == '@') {
                                goto stupid_label;
                            }
                            ability_txt = ability_txt_copy_rest_of_line_to_buffer(buffer, ability_txt, ability_txt_count);
                            byteloop_strcpy(this->description_text[matched_id].lines[i], buffer);
                            if (ability_txt_count <= 0) {
                                goto break_all;
                            }
                        }
                    }
                    break;
                }
                case '#': default:
                    ability_txt = ability_txt_skip_to_next_line(ability_txt, ability_txt_count);
                    break;
            }
        }
    break_all:
        SAFE_FREE(ability_txt_file);
    }

    inline AbilityTextData() {
        this->zero_contents();
        this->initialize();
    }
};
#pragma region // AbilityTextData Validation
ValidateFieldOffset32(0x0, AbilityTextData, description_text);
ValidateFieldOffset32(0x63C0, AbilityTextData, __vm_id_array_63C0);
ValidateFieldOffset32(0x63DC, AbilityTextData, __vm_id_63DC);
ValidateStructSize32(0x63E0, AbilityTextData);
#pragma endregion

// 0xD70
struct AbilityManager : ZUNTask {
    // ZUNTask base; // 0x0
    AnmLoaded* ability_anm; // 0xC
    AnmLoaded* abcard_anm; // 0x10
    AnmLoaded* abmenu_anm; // 0x14
    ZUNListHead<CardBase> card_list; // 0x18
    int32_t card_count; // 0x28
    int32_t active_card_count; // 0x2C
    int32_t equipment_card_count; // 0x30
    int32_t passive_card_count; // 0x34
    CardBase* selected_active_card; // 0x38
    AnmID __anm_id_3C; // 0x3C
    BOOL __selected_card_hidden; // 0x40
    Timer __timer_44; // 0x44
    AnmID __anm_id_array_58[0x100]; // 0x58
    AnmID __anm_id_array_458[0x100]; // 0x458
    CardBase* __card_array_858[0x100]; // 0x858
    float __float_C58; // 0xC58
    int32_t __int_C5C; // 0xC5C
    BOOL __ability_data_loaded; // 0xC60
    BOOL __created_ability_data; // 0xC64
    ZUNThread __thread_C68; // 0xC68
    int __int_array_C84[CARD_COUNT - 1]; // 0xC84
    unknown_fields(0xC); // 0xD64
    // 0xD70

    inline void zero_contents() {
        zero_this();
    }

    inline AbilityManager() {
        this->zero_contents();
        this->__unknown_task_flag_A = true;
    }
    
    // 0x4084C0
    dllexport gnu_noinline ~AbilityManager() {
        this->__thread_C68.stop_and_cleanup();
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);
        this->__sub_407DA0(0);
        ANM_MANAGER_PTR->unload_anm(30);
        ANM_MANAGER_PTR->unload_anm(31);
        ANM_MANAGER_PTR->unload_anm(32);

        ABILITY_MANAGER_PTR = NULL;

        if (this->__created_ability_data) {
            SAFE_DELETE(ABILITY_TEXT_DATA_PTR);
        }
    }

    inline void load_files() {
        if (
            (this->ability_anm = AnmManager::preload_anm(ABILITY_ANM_INDEX, "ability.anm")) &&
            (this->abcard_anm = AnmManager::preload_anm(ABCARD_ANM_INDEX, "abcard.anm")) &&
            (this->abmenu_anm = AnmManager::preload_anm(ABMENU_ANM_INDEX, "abmenu.anm"))
        ) {
            this->__created_ability_data = false;
            if (!ABILITY_TEXT_DATA_PTR) {
                this->__created_ability_data = true;
                ABILITY_TEXT_DATA_PTR = new AbilityTextData();
            }
            this->__ability_data_loaded = true;
        }
        LOG_BUFFER.write(JpEnStr("", "data is corrupted\r\n"));
    }

    // 0x408020
    dllexport gnu_noinline static void __cleanup_all_anms() asm_symbol_rel(0x408020) {
        AbilityManager* ability_manager = ABILITY_MANAGER_PTR;

        ability_manager->__anm_id_3C.mark_tree_for_delete();

        nounroll for (size_t i = 0; i < countof(ability_manager->__anm_id_array_58); ++i) {
            ability_manager->__anm_id_array_58[i].mark_tree_for_delete();
        }

        ANM_MANAGER_PTR->mark_all_vms_from_loaded_slot_for_delete(30);
        ANM_MANAGER_PTR->mark_all_vms_from_loaded_slot_for_delete(31);
        ANM_MANAGER_PTR->mark_all_vms_from_loaded_slot_for_delete(32);
    }

    // 0x4080E0
    dllexport gnu_noinline static void __sub_4080E0() asm_symbol_rel(0x4080E0) {
        AbilityManager* ability_manager = ABILITY_MANAGER_PTR;

        ability_manager->active_card_count = 0;
        ability_manager->equipment_card_count = 0;
        ability_manager->passive_card_count = 0;

        ability_manager->card_list.for_each_safeB([=](CardBase* card) {
            if (card->__unknown_flag_F) {
                card->list_node.unlink();
                delete card;
                --ability_manager->card_count;
            } else {
                card->__method_4C();
                if (card->__is_active_card) {
                    ++ability_manager->active_card_count;
                } else if (card->__is_equipment_card) {
                    ++ability_manager->equipment_card_count;
                } else {
                    ++ability_manager->passive_card_count;
                }
            }
        });

        ANM_MANAGER_PTR->mark_all_vms_from_loaded_slot_for_delete(30);
        ANM_MANAGER_PTR->mark_all_vms_from_loaded_slot_for_delete(31);

        ability_manager->selected_active_card = NULL;

        ZUNList<CardBase>* end_node = ability_manager->card_list.find_end_node();
        for (
            size_t card_count = ability_manager->card_count;
            card_count;
            --card_count
        ) {
            // wtf is this
            if (
                !end_node || end_node == &ability_manager->card_list
            ) {
                end_node = ability_manager->card_list.find_end_node();
            }
            CardBase* card = end_node->data;
            if (card->__is_active_card) {
                if (card) {
                    ability_manager->selected_active_card = card;
                    const CardData* card_data = card->data;

                    ability_manager->__anm_id_3C.__tree_set_visible2();
                    if (AnmVM* vm = ability_manager->__anm_id_3C.__wtf_child_list_jank_A(4, 0)) {
                        vm->set_sprite(card_data->sprite_small);
                    }
                    if (AnmVM* vm = ability_manager->__anm_id_3C.__wtf_child_list_jank_A(3, 0)) {
                        vm->set_sprite(card_data->sprite_small);
                    }
                }
                break;
            }
        }

        zero_array(ability_manager->__anm_id_array_58);
    }

    inline void wait_for_ability_data_to_load() {
        while (!this->__ability_data_loaded) {
            Sleep(1);
        }
    }

    // 0x408DE0
    dllexport gnu_noinline void thiscall create_card_list_for_hud(Float3* position_ptr, int32_t count, int card_type, BOOL arg4) {
        Float3 position = *position_ptr;
        ZUNList<CardBase>* node = this->card_list.next;
        float offset_per_card = 80.0f; // LOCAL 1
        if (count) {
            float count_f = count;
            float offset = count_f * offset_per_card; // EBP+C
            if (offset > 304.0f) {
                offset = 304.0f;
                offset_per_card = 304.0f / count_f;
            }
            offset *= 0.5f;
            offset += position.x;
            position.x = offset;
            if (node) {
                size_t i = 0;
                size_t j = 0;
                node->for_each([&](CardBase* card) {
                    const CardData* data = card->data;
                    switch (card_type) {
                        case 0:
                            if (!card->__is_active_card) {
                                goto skip_card;
                            }
                            break;
                        case 1:
                            if (!card->__is_equipment_card) {
                                goto skip_card;
                            }
                            break;
                        default:
                            if (
                                (card->__is_active_card | card->__is_equipment_card) ||
                                !data->__render_passive_in_hud
                            ) {
                                goto skip_card;
                            }
                            break;
                    }
                    AnmID anm_id = this->abcard_anm->instantiate_vm_to_ui_list_back(5, &position);
                    this->__anm_id_array_58[i] = anm_id;
                    anm_id.run_vm();

                    this->__anm_id_array_58[i].__wtf_child_list_jank_A(6, 0)->set_sprite(data->sprite_small);
                    this->__anm_id_array_58[i].__wtf_child_list_jank_A(7, 0)->set_sprite(data->sprite_small);

                    card->on_anm_id_assigned_to_hud(this->__anm_id_array_58[i]);

                    if (arg4) {
                        this->__anm_id_array_58[i].interrupt_tree(4);
                    }

                    if (card_type == 0) {
                        this->__anm_id_array_458[j] = this->__anm_id_array_58[i];
                        this->__card_array_858[j] = card;
                        ++j;
                    }

                    offset -= offset_per_card;
                    position.x = offset;

                skip_card:
                    ++i;
                });
            }
        }
    }

    // 0x408D00
    dllexport gnu_noinline void thiscall create_all_card_lists_for_hud(BOOL arg1) {
        for (size_t i = 0; i < countof(this->__anm_id_array_58); ++i) {
            this->__anm_id_array_58[i].mark_tree_for_delete();
        }
        if (GAME_THREAD_PTR) {
            Float3 position = {};
            this->create_card_list_for_hud(&position, this->active_card_count, 0, arg1);
            position.y = 130.0f;
            this->create_card_list_for_hud(&position, this->equipment_card_count, 1, arg1);
            position.z = 260.0f;
            this->create_card_list_for_hud(&position, this->passive_card_count, 2, arg1);
        }
    }

    inline ZUNResult initialize_new_card(CardBase* card, int32_t id, uint32_t flags) {
        card->id = id;
        card->__array_index = this->card_count + 1;
        BOOL flagF = flags & 1;
        card->__unknown_flag_F = flagF;
        if (!flagF) {
            if (ZUN_FAILED(card->initializeA())) {
                return ZUN_ERROR;
            }
        }
        if (flags & 2) {
            if (ZUN_FAILED(card->initializeB())) {
                return ZUN_ERROR;
            }
        }
        this->__int_array_C84[id] = 1;
        this->card_list.append_to_list_end(&card->list_node);
        if (card->__is_active_card) {
            this->selected_active_card = card;
        }
        if (card->__is_active_card) {
            ++this->active_card_count;
        } else if (card->__is_equipment_card) {
            ++this->equipment_card_count;
        } else {
            ++this->passive_card_count;
        }
        card->data = &find_id_in_card_data(card->id);

        if (flags != 1) {
            this->create_all_card_lists_for_hud(false);
        }

        ++this->card_count;

        return ZUN_SUCCESS;
    }

    // 0x411460
    dllexport gnu_noinline int32_t thiscall allocate_new_card(int32_t id, uint32_t flags) {
        if (this->card_count < 0x100) {
            CardBase* card;
            switch (id) {
                case NULL_CARD: // 56
                    card = new CardNull();
                    break;
                // TODO
                default:
                    return -1;
            }
            if (card) {
                if (ZUN_FAILED(this->initialize_new_card(card, id, flags))) {
                    delete card;
                }
                return this->card_count;
            }
        }
        return -1;
    }

    // 0x416F50
    dllexport gnu_noinline static uint32_t fastcall __pick_random_cardA(const CardData*& out, int32_t search_type_low, int32_t search_type_high, const CardData* card_data[], int32_t card_data_count) asm_symbol_rel(0x416F50) {
        const CardData* weighted_array[countof(AbilityManager::__int_array_C84) * 10] = {};
        uint32_t weighted_array_size = 0;

        for (int32_t i = 0; i < countof(AbilityManager::__int_array_C84); ++i) {
            if (ABILITY_MANAGER_PTR->__int_array_C84[i]) {
                if (!find_id_in_card_data(i).__allow_duplicates) {
                    continue;
                }
            }
            if (
                find_id_in_card_data(i).__check_availability() == 1 &&
                find_id_in_card_data(i).__type >= search_type_low &&
                find_id_in_card_data(i).__type <= search_type_high &&
                find_id_in_card_data(i).__weight != 0 &&
                find_id_in_card_data(i).__weight != 6
            ) {
                for (int32_t j = 0; j < card_data_count; ++j) {
                    if (card_data[j]->id == i) {
                        goto continue_outer;
                    }
                }
                const CardData* card = &find_id_in_card_data(i);
                int32_t weight = card->__weight;
                for (int32_t j = 0; j < weight; ++j) {
                    weighted_array[weighted_array_size + j] = card;
                }
                weighted_array_size += weight;
                if (!SCOREFILE_MANAGER_PTR->primary_file.__sectionA.__byte_array_D0[i]) {
                    for (int32_t j = 0; j < 5; ++j) {
                        weighted_array[weighted_array_size + j] = card;
                    }
                    weighted_array_size += 5;
                }
            }
        continue_outer:;
        }

        if (weighted_array_size) {
            out = weighted_array[RNG.rand_uint_range(weighted_array_size)];
        }

        return weighted_array_size;
    }

    // 0x407DA0
    dllexport gnu_noinline void thiscall __sub_407DA0(BOOL arg1) {
        this->card_list.delete_each_data();
        this->card_list.initialize_with((CardBase*)this);
        this->card_count = 0;
        this->active_card_count = 0;
        this->equipment_card_count = 0;
        this->passive_card_count = 0;
        this->__float_C58 = 1.0f;
        this->selected_active_card = NULL;
        ANM_MANAGER_PTR->mark_all_vms_from_loaded_slot_for_delete(30);
        this->__anm_id_3C.mark_tree_for_delete();
        ANM_MANAGER_PTR->mark_all_vms_from_loaded_slot_for_delete(31);

        nounroll for (size_t i = 0; i < countof(this->__anm_id_array_58); ++i) {
            this->__anm_id_array_58[i].mark_tree_for_delete();
        }

        if (arg1) {
            // Do these REP STOS memsets correspond to std::array = {}?
            zero_array(this->__int_array_C84);

            ScorefileManager* scorefile_manager = SCOREFILE_MANAGER_PTR;
            for (
                int32_t i = 0;
                i < scorefile_manager->primary_file.__sectionA.__int_array_1C0[this->__int_C5C];
                ++i, scorefile_manager = SCOREFILE_MANAGER_PTR
            ) {
                int32_t card_id = scorefile_manager->primary_file.__sectionA.__card_ids_150[this->__int_C5C][i];
                this->allocate_new_card(card_id, 1);
            }
        }
    }

    inline void check_for_card_activation() {
        Gui* gui = GUI_PTR;
        if (gui && !gui->msg_vm) {
            if (enemies_are_alive()) {
                if (INPUT_STATES[0].check_inputs_no_repeat(BUTTON_USE_CARD)) {
                    if (CardBase* selected_card = this->selected_active_card) {
                        selected_card->on_activate();
                    }
                }
            }
        }
    }

    static inline void check_for_card_switch() {
        if (INPUT_STATES[0].check_inputs_no_repeat(BUTTON_SWITCH_CARD)) {
            if (ABILITY_MANAGER_PTR->__sub_408B00(-1)) {
                SOUND_MANAGER.play_sound(78);
            }
        }
    }

    // 0x408890
    dllexport gnu_noinline void thiscall __sub_408890(AnmID id, int32_t scriptA, int32_t scriptB, CardBase* card, int arg5) asm_symbol_rel(0x408890) {
        AnmVM* vmA = id.__wtf_child_list_jank_A(scriptA, 0);
        AnmVM* vmB = id.__wtf_child_list_jank_A(scriptB, 0);

        // TODO

        if (card->__get_unknown_flag_A()) {

        }
        else if (!this->selected_active_card) {

        }
        else {

        }

    }

    // 0x408640
    dllexport gnu_noinline UpdateFuncRet thiscall on_tick() asm_symbol_rel(0x408640) {
        GameThread* game_thread = GAME_THREAD_PTR;
        if (
            game_thread &&
            game_thread->on_tick_enabled() && // ???
            this->__ability_data_loaded
        ) {
            this->card_list.for_each([](CardBase* card) {
                card->__on_tick_2();
            });
            this->__anm_id_3C.get_vm_ptr();
            if (
                this->__anm_id_3C &&
                this->selected_active_card
            ) {
                Player* player = PLAYER_PTR;
                if (!this->__selected_card_hidden) {
                    if (
                        player &&
                        player->data.position.y > 368.0f &&
                        player->data.position.x < -64.0f
                    ) {
                        this->__anm_id_3C.interrupt_and_run_tree(5);
                        this->__selected_card_hidden = true;
                    }
                } else {
                    if (
                        player && (
                            player->data.position.y < 352.0f ||
                            player->data.position.x > -48.0f
                        )
                    ) {
                        this->__anm_id_3C.interrupt_and_run_tree(4);
                        this->__selected_card_hidden = false;
                    }
                }

                Float3 position = { 0.0f, -4.0f, 0.0f };

                this->__sub_408890(this->__anm_id_3C, 2, 3, this->selected_active_card, false);

                for (int32_t i = 0; i < this->active_card_count; ++i) {
                    if (CardBase* card = this->__card_array_858[i]) {
                        this->__sub_408890(this->__anm_id_array_458[i], 9, 7, card, true);
                        this->__anm_id_array_458[i].get_vm_ptr()->data.__position_2 = UNKNOWN_FLOAT3_A;
                        if (
                            this->selected_active_card == this->__card_array_858[i] &&
                            this->__timer_44 >= 80
                        ) {
                            AnmVM* vmA = this->__anm_id_array_458[i].get_vm_ptr();
                            vmA->data.__position_2 = position;
                            vmA->__wtf_child_list_jank_A(11, 0)->data.color1 = PackD3DCOLOR(208, 128, 192, 128);
                            AnmVM* vmB = vmA->__wtf_child_list_jank_A(6, 0);
                            AnmVM* vmC = vmA->__wtf_child_list_jank_A(11, 0);
                            vmC->set_alpha(vmB->get_alpha());
                        }
                    }
                }
            }
            this->__timer_44++;
        }
        return UpdateFuncNext;
    }

    // 0x408A90
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC on_tick(void* self) asm_symbol_rel(0x408A90) {
        if (ABILITY_SHOP_PTR) {
            return UpdateFuncNext;
        }
        return ((AbilityManager*)self)->on_tick();
    }

    // 0x408AB0
    dllexport static gnu_noinline UpdateFuncRet UpdateFuncCC on_draw(void* self) asm_symbol_rel(0x408AB0) {
        ((AbilityManager*)self)->card_list.for_each([](CardBase* card) static_lambda {

        });
        return UpdateFuncNext;
    }

    inline ZUNResult initialize() {
        this->card_list.initialize_with((CardBase*)this);
        this->load_files();
        UpdateFunc* update_func = new UpdateFunc(&on_tick, false, this);
        UpdateFuncRegistry::register_on_tick(update_func, 22);
        this->on_tick_func = update_func;
        update_func = new UpdateFunc(&on_draw, false, this);
        UpdateFuncRegistry::register_on_draw(update_func, 51);
        this->on_draw_func = update_func;

        return ZUN_SUCCESS;
    }

    // 0x4082B0
    dllexport static gnu_noinline AbilityManager* allocate() asm_symbol_rel(0x4082B0) {
        AbilityManager* ability_manager = new AbilityManager();
        ABILITY_MANAGER_PTR = ability_manager;
        if (ZUN_FAILED(ability_manager->initialize())) {
            delete ability_manager;
            return NULL;
        }
        return ability_manager;
    }

    // 0x408BA0
    dllexport static gnu_noinline int __sub_408BA0(int32_t* ptr) asm_symbol_rel(0x408BA0) {

    }

    // 0x408C30
    dllexport gnu_noinline void thiscall __sub_408C30() asm_symbol_rel(0x408C30) {
        CardBase* card = this->selected_active_card;
        if (!card) {
            this->__anm_id_3C.__tree_clear_visible2();
        }
        else {
            const CardData* card_data = card->data;

            this->__anm_id_3C.__tree_set_visible2();

            if (AnmVM* vm = this->__anm_id_3C.__wtf_child_list_jank_A(4, 0)) {
                vm->set_sprite(card_data->sprite_small);
            }
            if (AnmVM* vm = this->__anm_id_3C.__wtf_child_list_jank_A(3, 0)) {
                vm->set_sprite(card_data->sprite_small);
            }
        }
    }

    // 0x408B00
    dllexport gnu_noinline int thiscall __sub_408B00(int32_t card_id) asm_symbol_rel(0x408B00) {
        ZUNList<CardBase>* list_node;
        if (card_id == -1) {
            CardBase* card = this->selected_active_card;
            if (!card) {
                list_node = this->card_list.find_end_node();
            }
            else {
                list_node = card->list_node.prev;
            }
        }
        else {
            list_node = this->card_list.next;
        }

        for (
            size_t card_count = this->card_count;
            card_count;
            --card_count
        ) {
            if (
                !list_node || list_node == &this->card_list
            ) {
                list_node = this->card_list.find_end_node();
            }
            CardBase* card = list_node->data;

            // TODO: untangle mess
            if (card_id < 0) {
                if (card->__is_active_card) {
                    if (this->selected_active_card == card) {
                        break;
                    }
            idk:
                    this->selected_active_card = card;
                    this->__sub_408C30();
                    return 1;
                }
            }
            else if (card->id == card_id) {
                goto idk;
            }

            list_node = list_node->prev;
        }


        return 0;
    }

#if INCLUDE_PATCH_CODE
    size_t vectorcall dont_worry_bravi_it_only_took_me_a_year(const char *restrict count_name) {
        const CardData *restrict card_data_ptr = CARD_DATA_TABLE;
        do {
            if (byteloop_strmatch(card_data_ptr->name, count_name)) {
                CardId count_id = card_data_ptr->id;
                return this->card_list.count_if([=](CardBase* card) {
                    return card->id == count_id;
                });
            }
        } while (++card_data_ptr != array_end_addr(CARD_DATA_TABLE));
        return 0;
    }
#endif

    // 0x412FE0
    inline static BOOL card_equipped_inline(int32_t id) {
        return (bool)ABILITY_MANAGER_PTR->card_list.find_if([=](CardBase* card) {
            return card->id == id;
        });
    }

    // 0x412FE0
    dllexport gnu_noinline static BOOL stdcall card_equipped(int32_t id) asm_symbol_rel(0x412FE0) {
        return card_equipped_inline(id);
    }

private:
    inline int32_t equipped_cards_get_ids_impl(int32_t* card_ids_out) {
        memset(card_ids_out, 0, sizeof(int32_t[256]));
        int32_t card_count = 0;
        this->card_list.do_while([&](CardBase* card) {
            ++card_count;
            *card_ids_out++ = card->id;
            return card_count < 255;
        });
        *card_ids_out = -1;
        CardBase* active_card = this->selected_active_card;
        if (!active_card) {
            return -1;
        }
        return active_card->id;
    }

    inline int __equipped_cards_get_replay_states_impl(int32_t* times_out) {
        this->card_list.for_each([&](CardBase* card) {
            *times_out++ = card->__get_replay_state();
        });
        *times_out = -1;
        return 0;
    }

    inline int equipped_cards_run_on_load_impl() {
        int ret = 0;
        this->card_list.for_each([&](CardBase* card) {
            ret |= card->on_load();
        });
        return ret;
    }
public:

    // 0x418C70
    dllexport gnu_noinline static int32_t stdcall equipped_cards_get_ids(int32_t* card_ids_out, int = UNUSED_DWORD) {
        return ABILITY_MANAGER_PTR->equipped_cards_get_ids_impl(card_ids_out);
    }

    // 0x408BA0
    dllexport gnu_noinline static int stdcall __equipped_cards_get_replay_states(int32_t* times_out) {
        return ABILITY_MANAGER_PTR->__equipped_cards_get_replay_states_impl(times_out);
    }

    // 0x408AD0
    dllexport gnu_noinline static int equipped_cards_run_on_load() {
        return ABILITY_MANAGER_PTR->equipped_cards_run_on_load_impl();
    }
};
#pragma region // AbilityManager Validation
ValidateFieldOffset32(0x0, AbilityManager, task_flags);
ValidateFieldOffset32(0x4, AbilityManager, on_tick_func);
ValidateFieldOffset32(0x8, AbilityManager, on_draw_func);
ValidateFieldOffset32(0xC, AbilityManager, ability_anm);
ValidateFieldOffset32(0x10, AbilityManager, abcard_anm);
ValidateFieldOffset32(0x14, AbilityManager, abmenu_anm);
ValidateFieldOffset32(0x18, AbilityManager, card_list);
ValidateFieldOffset32(0x28, AbilityManager, card_count);
ValidateFieldOffset32(0x2C, AbilityManager, active_card_count);
ValidateFieldOffset32(0x30, AbilityManager, equipment_card_count);
ValidateFieldOffset32(0x34, AbilityManager, passive_card_count);
ValidateFieldOffset32(0x38, AbilityManager, selected_active_card);
ValidateFieldOffset32(0x3C, AbilityManager, __anm_id_3C);
ValidateFieldOffset32(0x40, AbilityManager, __selected_card_hidden);
ValidateFieldOffset32(0x44, AbilityManager, __timer_44);
ValidateFieldOffset32(0x58, AbilityManager, __anm_id_array_58);
ValidateFieldOffset32(0x458, AbilityManager, __anm_id_array_458);
ValidateFieldOffset32(0x858, AbilityManager, __card_array_858);
ValidateFieldOffset32(0xC58, AbilityManager, __float_C58);
ValidateFieldOffset32(0xC5C, AbilityManager, __int_C5C);
ValidateFieldOffset32(0xC60, AbilityManager, __ability_data_loaded);
ValidateFieldOffset32(0xC64, AbilityManager, __created_ability_data);
ValidateFieldOffset32(0xC68, AbilityManager, __thread_C68);
ValidateFieldOffset32(0xC84, AbilityManager, __int_array_C84);
ValidateStructSize32(0xD70, AbilityManager);
#pragma endregion

static inline float ability_manager_get_float_C58() {
    return ABILITY_MANAGER_PTR->__float_C58;
}
static inline AnmLoaded* ability_manager_get_ability_anm() {
    return ABILITY_MANAGER_PTR->ability_anm;
}

// 0x452F80
dllexport gnu_noinline LoadingThread::~LoadingThread() {
    this->__thread_C.stop_and_cleanup();
    UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
    UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);

    delete ABILITY_MANAGER_PTR;
    UNKNOWN_THREAD_A.stop_and_cleanup();
    ANM_MANAGER_PTR->unload_anm(5);
    SAFE_DELETE(EFFECT_MANAGER_PTR);
    // delete TROPHY_MANAGER_B_PTR;
    ANM_MANAGER_PTR->unload_anm(27);
    ANM_MANAGER_PTR->unload_anm(1);

    LOADING_THREAD_PTR = NULL;

    delete ASCII_MANAGER_PTR;
    ANM_MANAGER_PTR->unload_anm(0);

    SCOREFILE_MANAGER_PTR->save_files();
    SAFE_DELETE(SCOREFILE_MANAGER_PTR);
}

// 0x452CB0
dllexport gnu_noinline unsigned cdecl LoadingThread::thread_func_A(void* arg) {
    LoadingThread* loading_thread = LOADING_THREAD_PTR;
    AnmLoaded* anm_loaded = ANM_MANAGER_PTR->preload_anm(1, "sig.anm");
    loading_thread->sig_anm = anm_loaded;
    if (anm_loaded) {
        loading_thread->enable_draw_unsafe();
        ScorefileManager::allocate();
        loading_thread->sig_loaded = 1;
        if (AsciiManager::allocate()) {
            loading_thread->__ascii_manager_loaded = 1;
            anm_loaded = ANM_MANAGER_PTR->preload_anm(0, "text.anm");
            SUPERVISOR.text_anm = anm_loaded;
            if (anm_loaded) {
                void* bgm_format = read_file_to_buffer("../../bgm/thbgm.fmt", NULL, false);
                SOUND_MANAGER.bgm_format_file = bgm_format;
                if (!bgm_format) {
                    LOG_BUFFER.write(JpEnStr("", "error : BGM initialization failed\r\n"));
                }
                for (size_t i = 0; i < MAX_ACTIVE_SOUNDS; ++i) {
                    SOUND_MANAGER.active_sound_ids[i] = -1;
                }
                SOUND_MANAGER.__wait_and_close_handles();
                if (
                    SOUND_MANAGER.csound_manager_ptr &&
                    SOUND_MANAGER.dsound
                ) {
                    int32_t A = SUPERVISOR.config.__sbyte_4B;
                    int32_t B = SUPERVISOR.config.__sbyte_4A;
                    SOUND_MANAGER.__int_5730 = B;
                    SOUND_MANAGER.__int_5734 = A;
                    // TODO
                }
                if (zun_file_exists("thbgm.dat")) {
                    // TODO
                }
                UNKNOWN_THREAD_A.start(thread_func_load_front_anm, NULL);
                if (
                    AbilityManager::allocate() &&
                    EffectManager::allocate()
                ) {
                    // TrophyManager::allocate();
                    loading_thread->enable_tick_unsafe();
                    return 0;
                }
            }
        }
        LOG_BUFFER.write(JpEnStr("", "error : failed to initialize character\r\n"));
    }
    SUPERVISOR.gamemode_switch = 3;
end:
    loading_thread->enable_tick_unsafe();
    return 0;
}

// 0x45E320
dllexport gnu_noinline ZUNResult thiscall PlayerBullet::shoot(int32_t unknownA_index, int32_t time, Float3* position, PlayerOption* option) {
    uint8_t index2 = unknownA_index;
    int32_t index1 = unknownA_index >> 8;
    ShtFileUnknownA* unknownA_ptr = &PLAYER_PTR->sht_file->__unknownA_ptr_array_E0[index1][index2];

    this->state = 1;
    this->__sht_unknownA_index = unknownA_index;
    this->__timer_C.reset();
    this->__int_9C = unknownA_ptr->__anm_script;
    this->size = unknownA_ptr->size;
    this->option = option;
    this->__focused = PLAYER_PTR->data.focused;
    this->__init_func = unknownA_ptr->__init_func;
    this->__func_ptr_EC = unknownA_ptr->__unknown_func_B;
    this->__func_ptr_F0 = unknownA_ptr->__unknown_func_C;
    this->__damage_func = unknownA_ptr->__damage_func;
    this->motion.zero_contents();

    int8_t option_index = unknownA_ptr->__option_index % PLAYER_TOTAL_OPTION_COUNT;
    if (!option_index) {
        this->motion.position = *position;
    } else {
        PlayerOption* option = &PLAYER_PTR->data.options[option_index - 1];
        this->motion.position = {
            option->internal_position.x * (1.0f / INTERNAL_POSITION_RATIO),
            option->internal_position.y * (1.0f / INTERNAL_POSITION_RATIO),
            0.0f
        };
    }

    if (unknownA_ptr->__byte_21 == 2) {

        int32_t level = GAME_MANAGER.globals.power_level();

        int32_t option_index = unknownA_ptr->__option_index;
        int32_t option_index_low = option_index % PLAYER_TOTAL_OPTION_COUNT;
        int32_t option_index_high = option_index >> PLAYER_TOTAL_OPTION_COUNT_BIT_WIDTH;

        int32_t index = option_index < PLAYER_TOTAL_OPTION_COUNT ? option_index_low : option_index_high;

        PLAYER_PTR->data.__level_array_470DC[index] = level;
    }

    this->motion.speed = unknownA_ptr->speed;

    float angle = unknownA_ptr->angle;
    if (angle >= 1000.0f) {
        // TODO: RNG
    }
    else if (angle >= 995.0f) {
        // TODO: RNG
    }
    else {
        this->motion.angle = angle;
    }

    this->motion.update3();

    switch (unknownA_ptr->__byte_21) {
        default:
            this->motion.position.as2() += unknownA_ptr->position - this->motion.misc_float3.as2();
            break;
        case 4: case 5: case 6:
            this->motion.position.as2() += unknownA_ptr->position;
            break;
    }


    AnmLoaded* bullet_anm = PLAYER_PTR->bullet_anm;
    this->bullet_anm = bullet_anm;

    Float3 zero = {};

    this->__vm_id_8 = bullet_anm->instantiate_vm_to_world_list_back(unknownA_ptr->__anm_script, &zero);

    ABILITY_MANAGER_PTR->card_list.for_each([=](CardBase* card) {
        card->__on_bullet_init(this);
    });

    AnmVM* vm = this->__vm_id_8.get_vm_ptr();

    if (vm->data.auto_rotate) {
        // BUG:
        // this doesn't account for the RNG
        // special cases of the angle value
        vm->set_z_rotation(unknownA_ptr->angle);
    }

    int32_t damage_source_index = PLAYER_PTR->create_damage_source_rotated_rectangle(&this->motion.position, this->size.x, this->size.y, this->motion.angle, 9999999, this->__int_9C);
    this->damage_source_index = damage_source_index;

    PlayerDamageSource* damage_source = get_damage_source_by_index(damage_source_index);
    damage_source->__unknown_func_index = 1;
    damage_source->__int_7C = 10000000;
    damage_source->__player_bullet_index = this->__bullet_index;

    this->__unknown_flag_A = true;

    auto* init_func = this->__init_func;
    if (
        init_func &&
        ZUN_FAILED(init_func(this, damage_source))
    ) {
        this->state = 0;
        this->__vm_id_8.mark_tree_for_delete();
        this->__unknown_flag_A = false;
        return ZUN_ERROR;
    }

    SOUND_MANAGER.play_sound_positioned_validate(unknownA_ptr->sound_id, this->motion.position.x);

    vm->controller.position = this->motion.position;

    return ZUN_SUCCESS;
}

extern "C" {
    // 0x4CDB60
    // For all characters: 0, 1, 3, 6, 10, 11, 13, 16
    externcg int32_t UNKNOWN_W[SHOTTYPE_COUNT][MAX_ALLOWED_POWER_LEVEL] cgasm("_UNKNOWN_W")
#if !USE_EXTERN_FOR_CODEGEN
    = {
        { 0, 1, 3, 6, 10, 11, 13, 16 },
        { 0, 1, 3, 6, 10, 11, 13, 16 },
        { 0, 1, 3, 6, 10, 11, 13, 16 },
        { 0, 1, 3, 6, 10, 11, 13, 16 }
    }
#endif
    ;
}

// 0x4B7020
static inline constexpr int32_t PLAYER_OPTION_ANM_SCRIPTS_B[CHARACTER_COUNT] = {
    15, 17, 12, 10
};
// 0x4B7030
static inline constexpr int32_t PLAYER_OPTION_ANM_SCRIPTS_A[CHARACTER_COUNT] = {
    16, 18, 13, 12
};

// 0x45D5E0
dllexport gnu_noinline void thiscall PlayerData::__update_option_power_levels(int) {
    // this; // ESP+24
    int32_t* unknownW_ptr = UNKNOWN_W[GAME_MANAGER.globals.shottype_index()]; // ESP+18

    int32_t power_level = GAME_MANAGER.globals.power_level(); // ESP+10
    this->power_level = power_level;

    PlayerOption* options = this->options; // ESP+14

    // this feels a bit backwards...?
    if (GAME_MANAGER.globals.current_power >= GAME_MANAGER.globals.max_power) {
        PlayerOption* option_iter = options;
        for (
            int32_t i = power_level;
            i;
            --i, ++option_iter
        ) {
            option_iter->__anm_id_B4.mark_tree_for_delete();
            option_iter->__anm_id_B4 = PLAYER_PTR->player_anm->instantiate_vm_to_world_list_front(PLAYER_OPTION_ANM_SCRIPTS_A[GAME_MANAGER.globals.character]);
            option_iter->__anm_id_B4.get_vm_ptr()->controller.position.y = -999.0f;
        }
    }
    else {
        PlayerOption* option_iter = options;
        for (size_t i = 0; i < PLAYER_OPTION_COUNT; ++i, ++option_iter) {
            option_iter->__anm_id_B4.interrupt_and_orphan_tree(1);
        }
    }

    Player* player = PLAYER_PTR;
    if (player->data.__option_count != power_level) {
        PlayerOption* option_iter = options;
        int32_t i = 0; // ESP+1C
        if (power_level > 0) {
            do {
                option_iter->__anm_id_B0.mark_tree_for_delete();
                option_iter->__option_index = i;

                ShtFile* sht_file;
                int32_t sht_index;

                sht_file = player->sht_file;
                sht_index = i + unknownW_ptr[power_level - 1];
                option_iter->__unfocused_offset = (Int2)(sht_file->__float2_array_40[sht_index] * INTERNAL_POSITION_RATIO);

                sht_file = player->sht_file;
                sht_index = i + unknownW_ptr[power_level - 1];
                option_iter->__focused_offset = (Int2)(sht_file->__float2_array_90[sht_index] * INTERNAL_POSITION_RATIO);

                option_iter->internal_position = option_iter->position = player->data.internal_position + (player->data.focused ? option_iter->__focused_offset : option_iter->__unfocused_offset);

                option_iter->__anm_id_B0 = player->player_anm->instantiate_vm_to_world_list_back(PLAYER_OPTION_ANM_SCRIPTS_B[GAME_MANAGER.globals.character], 15);
                option_iter->__anm_id_B0.get_vm_ptr()->controller.position.y = -999.0f;

                option_iter->__unknown_flag_A = false;
                option_iter->__int_0 = 2;
                option_iter->__dword_DC = 0;
                player = PLAYER_PTR;

                if (GAME_MANAGER.globals.character == Sakuya) {
                    sht_file = player->sht_file;
                    sht_index = i + unknownW_ptr[power_level - 1];
                    option_iter->__angle_A8 = sht_file->__float2_array_40[sht_index].x;

                    sht_file = player->sht_file;
                    sht_index = i + unknownW_ptr[power_level - 1];
                    option_iter->__float_AC = sht_file->__float2_array_40[sht_index].y;
                }
                ++option_iter;
            } while (++i < power_level);
        }

        if (i < PLAYER_OPTION_COUNT) {
            for (
                size_t j = PLAYER_OPTION_COUNT - i;
                j;
                --j, ++option_iter
            ) {
                option_iter->__int_0 = 0;
                option_iter->__dword_DC = 0;
                option_iter->__anm_id_B0.interrupt_tree(1);
            }
            player = PLAYER_PTR;
        }

        player->data.__option_count = power_level;
        player->__set_all_option_D4_to_1();
    }

    for (size_t i = 0; i < PLAYER_EQUIPMENT_OPTION_COUNT; ++i) {
        PlayerOption* equipment = &this->equipment[i];
        equipment->__unknown_flag_A = false;
        equipment->__int_0 = 0;
        equipment->__dword_DC = 0;
    }

    ABILITY_MANAGER_PTR->card_list.for_each([](CardBase* card) {
        card->on_power_level_change();
    });
}

// 0x45EA00
dllexport gnu_noinline int thiscall Player::tick_shooting_state() {
    if (INPUT_STATES[0].check_inputs(BUTTON_SHOOT)) {
        this->data.__unknown_flag_D = true;
    }
    if (!this->data.focused) {
        if (INPUT_STATES[0].check_inputs(BUTTON_LEFT)) {
            float angle = this->data.__shot_tilt_angle;
            if (
                angle > DEGREES(-135.0f)
            ) {
                this->data.__shot_tilt_angle += (DEGREES(-135.0f) - angle) * 0.08f;
            }
        }
        else if (INPUT_STATES[0].check_inputs(BUTTON_RIGHT)) {
            float angle = this->data.__shot_tilt_angle;
            if (
                angle < -QUARTER_PI_f
            ) {
                this->data.__shot_tilt_angle += (-QUARTER_PI_f - angle) * 0.08f;
            }
        }
        else if (INPUT_STATES[0].check_inputs(BUTTON_DOWN)) {
            float angle = this->data.__shot_tilt_angle;
            this->data.__shot_tilt_angle += (-HALF_PI_f - angle) * 0.08f;

            if (this->data.__shot_spread < 1.0f) {
                this->data.__shot_spread += 0.05f;
            }
        }
        else if (INPUT_STATES[0].check_inputs(BUTTON_UP)) {
            float angle = this->data.__shot_tilt_angle;
            this->data.__shot_tilt_angle += (-HALF_PI_f - angle) * 0.08f;

            if (this->data.__shot_spread > 0.3f) {
                this->data.__shot_spread -= 0.05f;
            }
        }
        else {
            float angle = this->data.__shot_tilt_angle;
            this->data.__shot_tilt_angle += (-HALF_PI_f - angle) * 0.05f;
        }

        if (INPUT_STATES[0].check_inputs(BUTTON_UP | BUTTON_DOWN)) {
            this->data.__shot_spread *= 0.9f;
        }
    }

    if (this->data.state == 1) {
        if (this->data.shoot_key_short_timer < 0) {
            if (!INPUT_STATES[0].check_inputs(BUTTON_SHOOT)) {
                // TODO
            }

            if (this->data.shoot_key_long_timer < 0) {
                this->data.shoot_key_long_timer.reset();
            }
            this->data.shoot_key_short_timer.reset(); // technically this is its own function, but screw that
        }

        if (!this->data.shoot_key_short_timer.__is_paused()) {

            int32_t A = this->data.shoot_key_long_timer;
            int32_t B = this->data.shoot_key_short_timer;

            int32_t sht_index = GAME_MANAGER.globals.power_level();

            ShtFile* sht_file = this->sht_file;

            uint32_t i = 0;
            if (this->data.focused) {
                sht_index += sht_file->max_level + 1;
            }

            ShtFileUnknownA* unknownA_ptr = sht_file->__unknownA_ptr_array_E0[sht_index];

            int8_t C = unknownA_ptr->__byte_0;
            if (C >= 0) {
                do {
                    if (C) {
                        int32_t D = unknownA_ptr->__sbyte_2A;
                        int32_t E;
                        int32_t F;
                        if (!D) {
                            E = B % C;
                            F = unknownA_ptr->__sbyte_1;
                        } else {
                            E = A % D;
                            F = unknownA_ptr->__sbyte_2B;
                        }
                        if (E != F) {
                            continue;
                        }
                    }

                    PlayerOption* option = NULL;
                    if (int8_t option_index = unknownA_ptr->__option_index) {
                        int32_t index = option_index % PLAYER_TOTAL_OPTION_COUNT;
                        option = &this->data.options[index - 1];
                    }

                    int32_t unknownA_index = i | sht_index << 8;
                    this->shoot_one_bullet(unknownA_index, B, &this->data.position, option);
                        
                } while (
                    // This was probably a for loop,
                    // but whatever I wanted to use continue
                    ++i,
                    (C = ++unknownA_ptr->__byte_0) >= 0
                );
                // this is probably just spilled values
                A = this->data.shoot_key_long_timer;
                B = this->data.shoot_key_short_timer;
            }

            ABILITY_MANAGER_PTR->card_list.for_each([=](CardBase* card) {
                card->on_shoot(B, A);
            });
        }


        if (this->data.shoot_key_short_timer >= 15) {
            if (INPUT_STATES[0].check_inputs(BUTTON_SHOOT)) {
                this->data.shoot_key_short_timer -= 15;
            } else {
                this->data.shoot_key_short_timer.set(-1);
            }
        } else {
            this->data.shoot_key_short_timer++;
            int32_t long_timer = this->data.shoot_key_long_timer;
            if (long_timer < 0) {
                return 0;
            }
            if (long_timer >= 119) {
                if (INPUT_STATES[0].check_inputs(BUTTON_SHOOT)) {
                    this->data.shoot_key_long_timer -= 119;
                } else {
                    this->data.shoot_key_long_timer.set(-1);
                }
            }
            return 0;
        }
    }

    this->__dword_47944 = 0;
    this->__byte_47948 = 0;
    return 0;
}

// size: 0xE3C
struct AbilityShop : ZUNTask {
    // ZUNTask base; // 0x0
    MenuSelect __menu_select_C; // 0xC
    MenuSelect __menu_select_E4; // 0xE4
    Timer __timer_1BC; // 0x1BC
    Float3 __float3_1D0; // 0x1D0
    unknown_fields(0x18); // 0x1DC
    Timer __timer_1F4; // 0x1F4
    Timer __timer_208; // 0x208
    unknown_fields(0xC); // 0x21C
    AnmID __anm_id_228; // 0x228
    AnmID __anm_id_array_22C[256]; // 0x22C
    AnmID __anm_id_array_62C[256]; // 0x62C
    int32_t card_count; // 0xA2C
    const CardData* card_array[256]; // 0xA30
    unknown_fields(0x4); // 0xE30
    BOOL __has_blank_card_already; // 0xE34
    unknown_fields(0x4); // 0xE38
    // 0xE3C

    inline void zero_contents() {
        zero_this();
    }

    inline AbilityShop() {
        this->zero_contents();
        ABILITY_SHOP_PTR = this;
        this->__unknown_task_flag_A = true;
    }

    // 0x4176E0
    dllexport gnu_noinline ~AbilityShop() {
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);

        if (ANM_MANAGER_PTR) {
            ANM_MANAGER_PTR->mark_all_vms_from_loaded_slot_for_delete(32);
        }

        this->__anm_id_228.mark_tree_for_delete();

        nounroll for (size_t i = 0; i < countof(__anm_id_array_22C); ++i) {
            this->__anm_id_array_22C[i].mark_tree_for_delete();
        }

        ABILITY_SHOP_PTR = NULL;
    }

    // 0x417880
    dllexport gnu_noinline void thiscall cleanup() asm_symbol_rel(0x417880);

    // 0x417CC0
    dllexport gnu_noinline UpdateFuncRet thiscall on_tick() asm_symbol_rel(0x417CC0) {
        // TODO
    }

    // 0x418990
    dllexport gnu_noinline UpdateFuncRet thiscall on_draw() asm_symbol_rel(0x418990) {
        // TODO
    }

    // 0x418C20
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_tick(void* ptr) asm_symbol_rel(0x418C20) {
        return ((AbilityShop*)ptr)->on_tick();
    }

    // 0x418C30
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw(void* ptr) asm_symbol_rel(0x418C30) {
        return ((AbilityShop*)ptr)->on_draw();
    }

    // 0x4171B0
    dllexport gnu_noinline ZUNResult thiscall initialize(Float3* arg1) asm_symbol_rel(0x4171B0) {
        UpdateFunc* update_func = new UpdateFunc(&on_tick, true, this);
        UpdateFuncRegistry::register_on_tick(update_func, 12);
        this->on_tick_func = update_func;
        update_func = new UpdateFunc(&on_draw, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 81);
        this->on_draw_func = update_func;

        this->enable_funcs_unsafe();

        this->__timer_1BC.reset();
        this->__timer_1F4.reset();
        this->__timer_208.reset();

        this->__float3_1D0 = *arg1;

        //this->__menu_select_C.__sub_416BA0(0);
        this->__menu_select_C.enable_wrap = true;

        int32_t& card_array_size = this->card_count;

        const CardData* new_card_array[countof(AbilityManager::__int_array_C84)];
        card_array_size = 0;
        if (ABILITY_MANAGER_PTR->__pick_random_cardA(new_card_array[0], 10, 15, new_card_array, 0)) {
            ++card_array_size;
        }

        if (ABILITY_MANAGER_PTR->card_equipped_inline(MANEKI_CARD)) {
            if (ABILITY_MANAGER_PTR->__pick_random_cardA(new_card_array[card_array_size], 1, 15, new_card_array, card_array_size)) {
                ++card_array_size;
            }
        }
        if (ABILITY_MANAGER_PTR->__pick_random_cardA(new_card_array[card_array_size], 7, 9, new_card_array, card_array_size)) {
            ++card_array_size;
        }

        if (ABILITY_MANAGER_PTR->card_equipped_inline(MANEKI_CARD)) {
            if (ABILITY_MANAGER_PTR->__pick_random_cardA(new_card_array[card_array_size], 1, 15, new_card_array, card_array_size)) {
                ++card_array_size;
            }
        }
        if (ABILITY_MANAGER_PTR->__pick_random_cardA(new_card_array[card_array_size], 1, 6, new_card_array, card_array_size)) {
            ++card_array_size;
        }

        if (ABILITY_MANAGER_PTR->card_equipped_inline(MANEKI_CARD)) {
            if (ABILITY_MANAGER_PTR->__pick_random_cardA(new_card_array[card_array_size], 1, 15, new_card_array, card_array_size)) {
                ++card_array_size;
            }
        }
        for (int32_t i = 0; i < countof(AbilityManager::__int_array_C84); ++i) {
            if (ABILITY_MANAGER_PTR->__int_array_C84[i]) {
                if (!find_id_in_card_data(i).__allow_duplicates) {
                    continue;
                }
            }
            if (
                find_id_in_card_data(i).__check_availability() == 1 &&
                find_id_in_card_data(i).__weight == 0
            ) {
                new_card_array[card_array_size++] = &find_id_in_card_data(i);
            }
        }

        for (int32_t i = 0; i < countof(AbilityManager::__int_array_C84); ++i) {
            if (ABILITY_MANAGER_PTR->__int_array_C84[i]) {
                if (!find_id_in_card_data(i).__allow_duplicates) {
                    continue;
                }
            }
            if (
                find_id_in_card_data(i).__check_availability() == 2
            ) {
                new_card_array[card_array_size++] = &find_id_in_card_data(i);
            }
        }

        int32_t total_cards = 0;
        for (int32_t i = 0; i < card_array_size; ++i) {
            const CardData* new_card = new_card_array[i];
            if (i > 0) {
                const CardData* current = this->card_array[i];
                for (int32_t j = 0; j < i; ++j) { // yes this is a pointless loop
                    if (current == new_card) {
                        goto skip_adding_card;
                    }
                }
            }
            ++total_cards;
            this->card_array[i] = new_card;
    skip_adding_card:;
        }

        this->card_count = total_cards;
        this->__menu_select_E4.menu_length = total_cards;
        //this->__menu_select_E4.__sub_416BA0(0);
        this->__menu_select_E4.enable_wrap = false;

        if (!ABILITY_MANAGER_PTR->card_equipped(BLANK_CARD)) {
            this->__has_blank_card_already = FALSE;
        } else {
            this->__has_blank_card_already = TRUE;
        }
        
        return ZUN_SUCCESS;
    }

    inline static AbilityShop* allocate(Float3* arg1) {
        AbilityShop* ability_shop = new AbilityShop();
        if (Player* player = PLAYER_PTR) {
            // player->__sub_416CD0();
        }
        if (ZUN_FAILED(ability_shop->initialize(arg1))) {
            delete ability_shop;
            return NULL;
        }
        return ability_shop;
    }
};
#pragma region // AbilityShop Validation
ValidateFieldOffset32(0x0, AbilityShop, task_flags);
ValidateFieldOffset32(0x4, AbilityShop, on_tick_func);
ValidateFieldOffset32(0x8, AbilityShop, on_draw_func);
ValidateFieldOffset32(0xC, AbilityShop, __menu_select_C);
ValidateFieldOffset32(0xE4, AbilityShop, __menu_select_E4);
ValidateFieldOffset32(0x1BC, AbilityShop, __timer_1BC);
ValidateFieldOffset32(0x1D0, AbilityShop, __float3_1D0);
ValidateFieldOffset32(0x1F4, AbilityShop, __timer_1F4);
ValidateFieldOffset32(0x208, AbilityShop, __timer_208);
ValidateFieldOffset32(0x228, AbilityShop, __anm_id_228);
ValidateFieldOffset32(0x22C, AbilityShop, __anm_id_array_22C);
ValidateFieldOffset32(0x62C, AbilityShop, __anm_id_array_62C);
ValidateFieldOffset32(0xA2C, AbilityShop, card_count);
ValidateFieldOffset32(0xA30, AbilityShop, card_array);
ValidateFieldOffset32(0xE34, AbilityShop, __has_blank_card_already);
ValidateStructSize32(0xE3C, AbilityShop);
#pragma endregion

// size: 0x13FC
struct AbilityMenu : ZUNTask {
    // ZUNTask base; // 0x0
    MenuSelect __menu_select_C; // 0xC
    MenuSelect __menu_select_E4; // 0xE4
    MenuSelect __menu_select_1BC; // 0x1BC
    Timer __timer_294; // 0x294
    Float3 __float3_2A8; // 0x2A8
    unknown_fields(0x18); // 0x2B4
    Timer __timer_2CC; // 0x2CC
    Timer __timer_2E0; // 0x2E0
    unknown_fields(0xF0); // 0x2F4
    int32_t __int_3E4; // 0x3E4
    unknown_fields(0x4); // 0x3E8
    AnmID __anm_id_array_3EC[256]; // 0x3EC
    AnmID __anm_id_array_7EC[256]; // 0x7EC
    AnmID __anm_id_array_BEC[256]; // 0xBEC
    unknown_fields(0x400); // 0xFEC
    int __int_13EC; // 0x13EC
    int __int_13F0; // 0x13F0
    int __int_13F4; // 0x13F4
    unknown_fields(0x4); // 0x13F8
    // 0x13FC

    inline void zero_contents() {
        zero_this();
    }

    inline AbilityMenu() {
        this->zero_contents();
        ABILITY_MENU_PTR = this;
        this->__unknown_task_flag_A = true;
    }

    // 0x413950
    dllexport gnu_noinline ~AbilityMenu() {
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);

        if (ABILITY_MANAGER_PTR) {
            ANM_MANAGER_PTR->mark_all_vms_from_loaded_slot_for_delete(32);
        }

        nounroll for (size_t i = 0; i < countof(this->__anm_id_array_3EC); ++i) {
            this->__anm_id_array_3EC[i].mark_tree_for_delete();
        }

        ABILITY_MENU_PTR = NULL;

        if (SCOREFILE_MANAGER_PTR) {
            SCOREFILE_MANAGER_PTR->save_files();
        }
    }

    // 0x413AF0
    dllexport gnu_noinline UpdateFuncRet thiscall on_tick() asm_symbol_rel(0x413AF0) {
        // TODO
    }

    // 0x415E00
    dllexport gnu_noinline UpdateFuncRet thiscall on_draw() asm_symbol_rel(0x415E00) {
        // TODO
    }

    // 0x416090
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_tick(void* ptr) asm_symbol_rel(0x416090) {
        return ((AbilityMenu*)ptr)->on_tick();
    }

    // 0x4160A0
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw(void* ptr) asm_symbol_rel(0x4160A0) {
        return ((AbilityMenu*)ptr)->on_draw();
    }

    // 0x413650
    dllexport gnu_noinline ZUNResult thiscall initialize(Float3* arg1, int arg2) asm_symbol_rel(0x413650) {
        UpdateFunc* update_func = new UpdateFunc(&on_tick, true, this);
        UpdateFuncRegistry::register_on_tick(update_func, 7);
        this->on_tick_func = update_func;
        update_func = new UpdateFunc(&on_draw, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 80);
        this->on_draw_func = update_func;

        this->enable_funcs_unsafe();

        this->__timer_294.reset();
        this->__timer_2CC.reset();
        this->__timer_2E0.reset();

        this->__float3_2A8 = *arg1;

        this->__int_13EC = arg2;
        // TODO

        arg2 = this->__int_13EC;

        this->__int_13F0 = !arg2;
        this->__int_13F4 = arg2 == 2 ? 0 : 11;

        return ZUN_SUCCESS;
    }

    // 0x413810
    dllexport gnu_noinline static AbilityMenu* fastcall allocate(Float3* arg1, int arg2) asm_symbol_rel(0x413810) {
        AbilityMenu* ability_menu = new AbilityMenu();
        if (ZUN_FAILED(ability_menu->initialize(arg1, arg2))) {
            delete ability_menu;
            return NULL;
        }
        return ability_menu;
    }
};
#pragma region // AbilityMenu Validation
ValidateFieldOffset32(0x0, AbilityMenu, task_flags);
ValidateFieldOffset32(0x4, AbilityMenu, on_tick_func);
ValidateFieldOffset32(0x8, AbilityMenu, on_draw_func);
ValidateFieldOffset32(0xC, AbilityMenu, __menu_select_C);
ValidateFieldOffset32(0xE4, AbilityMenu, __menu_select_E4);
ValidateFieldOffset32(0x1BC, AbilityMenu, __menu_select_1BC);
ValidateFieldOffset32(0x294, AbilityMenu, __timer_294);
ValidateFieldOffset32(0x2A8, AbilityMenu, __float3_2A8);
ValidateFieldOffset32(0x2CC, AbilityMenu, __timer_2CC);
ValidateFieldOffset32(0x2E0, AbilityMenu, __timer_2E0);
ValidateFieldOffset32(0x3E4, AbilityMenu, __int_3E4);
ValidateFieldOffset32(0x3EC, AbilityMenu, __anm_id_array_3EC);
ValidateFieldOffset32(0x7EC, AbilityMenu, __anm_id_array_7EC);
ValidateFieldOffset32(0xBEC, AbilityMenu, __anm_id_array_BEC);
ValidateFieldOffset32(0x13EC, AbilityMenu, __int_13EC);
ValidateFieldOffset32(0x13F0, AbilityMenu, __int_13F0);
ValidateFieldOffset32(0x13F4, AbilityMenu, __int_13F4);
ValidateStructSize32(0x13FC, AbilityMenu);
#pragma endregion

#if INCLUDE_PATCH_CODE
dllexport gnu_noinline void count_cards_of_type(EnemyData* self) {
    int32_t* out;
    clang_forceinline out = self->get_int_ptr_arg();
    EclInstruction* current_instruction;
    __asm__(
        "movl -0x57C(%%ebp), %[current_instruction]"
        : asm_arg("=r", current_instruction)
    );
    *out = ABILITY_MANAGER_PTR->dont_worry_bravi_it_only_took_me_a_year(StringArg(4));
}

dllexport gnu_noinline void count_cards_of_type2(EnemyData* self) {
    EclInstruction* current_instruction;
    __asm__(
        "movl -0x57C(%%ebp), %[current_instruction]"
        : asm_arg("=r", current_instruction)
    );
    const char* count_name = StringArg(4);
    
    int32_t count = 0;
    for (
        const CardData *restrict card_data_ptr = CARD_DATA_TABLE;
        card_data_ptr != array_end_addr(CARD_DATA_TABLE);
        ++card_data_ptr
    ) {
        if (byteloop_strmatch(card_data_ptr->name, count_name)) {
            CardId count_id = card_data_ptr->id;
            count = ABILITY_MANAGER_PTR->card_list.count_if([=](CardBase* card) {
                return card->id == count_id;
            });
            break;
        }
    }
    clang_forceinline *self->get_int_ptr_arg() = count;
}

dllexport gnu_noinline void stdcall log_vprintf(const char* format, va_list va) {
    vprintf(format, va);
}

dllexport gnu_noinline void fastcall thcrap_print(EclContext* self_in, int, const EclInstruction* current_instruction) {
    EclContext* self;
    __asm__(
        ""
        : "=D"(self)
        : "0"(self_in)
    );
    
    const EclValue* call_arg_formats = based_pointer<EclValue>(StringArg(4), IntArg(0));
    size_t param_count = current_instruction->param_count;
    //uint8_t* print_args = (uint8_t*)__builtin_alloca(sizeof(double[param_count - 1]));
    //uint8_t* print_args_write = print_args;
    double print_args_mem[bitsof(current_instruction->param_mask)];
    uint8_t* print_args = (uint8_t*)print_args_mem;
    for (size_t i = 1; i < param_count; ++i) {
        const EclValue& call_arg = call_arg_formats[i - 1];
        switch (call_arg.type) {
            case 'f': case 'g':
                *(double*)print_args = (long double)self->parse_float_as_arg_pop(i, call_arg.value.real, (EclInstruction*)current_instruction);
                print_args += sizeof(double);
                //*(double*)print_args_write = (long double)context->parse_float_as_arg_pop(i, call_arg.value.real, (EclInstruction*)current_instruction);
                //print_args_write += sizeof(double);
                break;
            default:
                *(int32_t*)print_args = self->parse_int_as_arg_pop(i, call_arg.value.integer, (EclInstruction*)current_instruction);
                print_args += sizeof(int32_t);
                //*(int32_t*)print_args_write = context->parse_int_as_arg_pop(i, call_arg.value.integer, (EclInstruction*)current_instruction);
                //print_args_write += sizeof(int32_t);
                break;
        }
    }
    log_vprintf(StringArg(4), (va_list)print_args_mem);
    //free(print_args);
}
#endif

// 0x425B40
dllexport gnu_noinline float vectorcall Float3::__bullet_effect_angle_jank(float angle, float arg2, float arg3) {
    if (!(arg2 <= -999990.0f)) {
        if (arg2 >= 999990.0f && arg2 < 1999990.0f) {
            return arg3 + angle_to_player_from_point(this);
        }
        if (arg2 >= 2999990.0f && arg2 < 3999990.0f) {
            return REPLAY_RNG.rand_float_signed_range(arg3) + angle_to_player_from_point(this);
        }
        if (arg2 >= 3999990.0f && arg2 < 4999990.0f) {
            return REPLAY_RNG.rand_float_signed_range(arg3) + angle;
        }
        if (arg2 >= 4999990.0f) {
            return get_boss_by_index(0)->data.current_motion.position.angle_to(this);
        }
        return arg2;
    }
    return angle;
}

static inline constexpr size_t MAX_BOSS_COUNT = 16; // I'm just guessing here

// size: 0x1A0
struct EnemyManager : ZUNTask {
    // ZUNTask base; // 0x0
    int32_t int_vars[4]; // 0xC
    float float_vars[8]; // 0x1C
    int32_t player_death_count; // 0x3C
    int32_t player_bomb_count; // 0x40
    int32_t can_capture_spell; // 0x44
    int32_t boss_ids[MAX_BOSS_COUNT]; // 0x48
    union {
        uint32_t flags; // 0x88
        struct {
            uint32_t __unknown_flag_A : 1; // 1
        };
    };
    int32_t enemy_limit; // 0x8C
    int32_t next_enemy_id; // 0x90
    int32_t prev_enemy_id; // 0x94
    Timer __timer_98; // 0x98
    int32_t __int_AC; // 0xAC
    int32_t __int_B0; // 0xB0
    unknown_fields(0xB0); // 0xB4
    int __int_164; // 0x164
    AnmLoaded* enemy_anms[MAX_ECL_ANM_FILES]; // 0x168
    EclManager* ecl_manager; // 0x188
    ZUNListEnds<Enemy> enemy_list; // 0x18C
    ZUNList<Enemy>* __unknown_enemy_list; // 0x194
    int32_t enemy_count; // 0x198
    ZUNAngle __angle_19C; // 0x19C
    // 0x1A0

    inline void zero_contents() {
        zero_this();
    }

    inline EnemyManager() {
        this->zero_contents();
        this->__unknown_task_flag_A = true;
    }

    // 0x42DDC0
    dllexport gnu_noinline ~EnemyManager() {
        this->destroy_all();

        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);

        SAFE_DELETE(this->ecl_manager);

        nounroll for (size_t i = 0; i < MAX_ECL_ANM_FILES; ++i) {
            ANM_MANAGER_PTR->unload_anm(i + 10);
        }

        ENEMY_MANAGER_PTR = NULL;
    }

    inline void reset() {
        this->__timer_98.reset();
        this->enemy_list.head = NULL;
        this->enemy_list.tail = NULL;
    }

    // 0x42AB40
    dllexport gnu_noinline void thiscall destroy_all() asm_symbol_rel(0x42AB40) {
        AnmManager* anm_manager = ANM_MANAGER_PTR;
        for (size_t i = 0; i < 10; ++i) {
            anm_manager->mark_all_vms_from_loaded_slot_for_delete(i + 10);
        }

        this->enemy_list.delete_each_data();

        zero_array_inline(this->boss_ids);
        
        this->disable_funcs();
    }

    forceinline bool is_below_enemy_limit() {
        return this->enemy_count < this->enemy_limit;
    }

    inline void index_next_enemy_id() {
        int32_t id = this->next_enemy_id;
        this->prev_enemy_id = id;
        this->next_enemy_id = ++id;
        if (!id) {
            this->next_enemy_id = ++id;
        }
    }

    inline int32_t get_next_enemy_id() {
        int32_t id = this->next_enemy_id;
        this->index_next_enemy_id();
        return id;
    }

    // 0x42D7D0
    dllexport gnu_noinline Enemy* allocate_new_enemy(const char* sub_name, EnemyInitData* data, int32_t = UNUSED_DWORD) asm_symbol_rel(0x42D7D0) {
        Enemy* enemy = new Enemy(sub_name);
        enemy->data.motion.absolute.position = data->position;
        enemy->data.score = data->score;
        enemy->data.life.current = data->life;
        enemy->data.life.maximum = data->life;
        enemy->data.life.remaining_current_attack = data->life;
        enemy->data.drops.main_id = data->item_drop;
        enemy->data.mirrored = data->mirrored;
        enemy->context.difficulty_mask = 1 << GAME_MANAGER.globals.difficulty;
        __builtin_memcpy(enemy->data.int_vars, data->int_vars, sizeof(enemy->data.int_vars));
        __builtin_memcpy(enemy->data.float_vars, data->float_vars, sizeof(enemy->data.float_vars));
        enemy->data.invulnerable_timer.set(1);
        enemy->data.__basic_anm_update = data->__basic_anm_update;
        enemy->data.kill_id = 0;
        enemy->parent_id = data->parent_id;
        if (data->life >= 1000) {
            enemy->data.__unknown_flag_O = true;
        }
        enemy->data.chapter = GAME_MANAGER.globals.chapter;

        // Nothing checks the result here...?
        enemy->on_tick();

        // Presumably this is supposed to be a slight randomization
        enemy->data.death_sound = 3 + (enemy->id & 1);

        if (!enemy->data.death_anm_script) {
            enemy->data.death_anm_script = 44;
            if (
                enemy->data.anm_slot_0_source_index == 2
            ) {
                switch (enemy->data.anm_slot_0_script) {
                    case 5: case 25: case 53: case 91:
                        enemy->data.death_anm_script = 40;
                        break;
                    case 15: case 103:
                        enemy->data.death_anm_script = 52;
                        break;
                    case 10: case 56: case 95:
                        enemy->data.death_anm_script = 48;
                        break;
                    case 30:
                        enemy->data.death_anm_script = 58;
                        break;
                    case 35:
                        enemy->data.death_anm_script = 57;
                        break;
                    case 40:
                        enemy->data.death_anm_script = 56;
                        break;
                }
            }
            enemy->data.death_anm_index = 1;
        }

        this->enemy_list.append(&enemy->data.global_list_node);

        ++this->enemy_count;

        return enemy;
    }

    // 0x42D440
    dllexport static gnu_noinline int32_t count_killable_enemies() asm_symbol_rel(0x42D440) {
        return ENEMY_MANAGER_PTR->enemy_list.count_if_not([](Enemy* enemy) {
            return !enemy->data.has_active_hitbox() || enemy->data.is_invulnerable();
            //return enemy->data.disable_hitbox || enemy->data.invincible || enemy->data.intangible || enemy->data.invulnerable_timer > 0;
        });
    }

    // 0x42D490
    dllexport gnu_noinline void set_boss(int32_t index, Enemy* enemy) asm_symbol_rel(0x42D490) {
        EnemyManager* enemy_manager = ENEMY_MANAGER_PTR;
        if (enemy) {
            enemy_manager->boss_ids[index] = enemy->id;
        } else {
            enemy_manager->boss_ids[index] = 0;
        }
    }

    // 0x42D4D0
    dllexport gnu_noinline void __set_unkown_flag_A(bool value) asm_symbol_rel(0x42D4D0) {
        ENEMY_MANAGER_PTR->__unknown_flag_A = value;
    }

    forceinline Enemy* get_enemy_by_id_impl(int32_t enemy_id) {
        if (!enemy_id) {
            return NULL;
        } else {
            return this->enemy_list.find_if([=](Enemy* enemy) {
                return enemy->id == enemy_id;
            });
        }
    }

    // 0x42D500
    dllexport gnu_noinline Enemy* get_enemy_by_id(int32_t enemy_id) asm_symbol_rel(0x42D500) {
        return ENEMY_MANAGER_PTR->get_enemy_by_id_impl(enemy_id);
    }

    forceinline Enemy* get_boss_by_index(int32_t index) {
        return ::get_boss_by_index(index);
    }

    // 0x409990
    dllexport gnu_noinline BOOL enemy_exists_with_id(int32_t enemy_id) asm_symbol_rel(0x409990) {
        if (enemy_id) {
            return (bool)ENEMY_MANAGER_PTR->enemy_list.find_if([=](Enemy* enemy) {
                return enemy->id == enemy_id;
            });
        }
        return false;
    }

    // 0x42D540
    dllexport gnu_noinline void set_enemy_limit(int32_t limit) asm_symbol_rel(0x42D540) {
        ENEMY_MANAGER_PTR->enemy_limit = limit;
    }

    inline AnmLoaded* anm_file_lookup(int32_t file_index) asm_symbol_rel(0x438D40);

private:
    inline EnemyID& __get_id_of_nearest_enemy_in_radius(EnemyID& out, Float2* position, float radius) {
        Enemy* found = NULL;
        float radius_squared = radius * radius;
        this->enemy_list.for_each_safe([&](Enemy* enemy) {
            if (!(
                enemy->data.disable_hitbox | enemy->data.intangible |
                enemy->data.__basic_anm_update | enemy->data.homing_disable
            )) {
                float distance_squared = position->distance_squared(&enemy->data.current_motion.position);
                if (distance_squared < radius_squared) {
                    found = enemy;
                    radius_squared = distance_squared;
                }
            }
        });
        if (found) {
            out = found->id;
            return out;
        }
        out = 0;
        return out;
    }
    // 0x438CB0
    dllexport gnu_noinline static EnemyID& vectorcall __get_id_of_nearest_enemy_in_radius(int, int, EnemyID& out, Float2* position, float, float, float, float radius) {
        return ENEMY_MANAGER_PTR->__get_id_of_nearest_enemy_in_radius(out, position, radius);
    }
public:
    inline static EnemyID __get_id_of_nearest_enemy_in_radius(Float2* position, float radius) {
        EnemyID temp;
        return __get_id_of_nearest_enemy_in_radius(UNUSED_DWORD, UNUSED_DWORD, temp, position, UNUSED_FLOAT, UNUSED_FLOAT, UNUSED_FLOAT, radius);
    }

    // 0x430710
    dllexport gnu_noinline static void kill_all() {
        EnemyManager* enemy_manager = ENEMY_MANAGER_PTR;
        enemy_manager->enemy_list.for_each_safe([=](Enemy* enemy) {
            enemy->try_kill();
        });
        enemy_manager->__timer_98++;
    }

    // 0x430B20
    dllexport gnu_noinline static void kill_all_no_callbacks() {
        EnemyManager* enemy_manager = ENEMY_MANAGER_PTR;
        enemy_manager->enemy_list.for_each_safe([=](Enemy* enemy) {
            enemy->try_kill<true>();
        });
        enemy_manager->__timer_98++;
    }

    // 0x430910
    dllexport gnu_noinline static void stdcall kill_all_by_kill_id(int32_t kill_id) {
        EnemyManager* enemy_manager = ENEMY_MANAGER_PTR;
        enemy_manager->enemy_list.for_each_safe([=](Enemy* enemy) {
            enemy->try_kill_by_kill_id(kill_id);
        });
        enemy_manager->__timer_98++;
    }

    inline UpdateFuncRet thiscall on_tick_impl() {
        this->__int_AC = 0;
        this->__int_B0 = 0;

        this->enemy_list.for_each_safeB([](Enemy* enemy, ZUNList<Enemy>* node) {
            if (
                !enemy->data.__unknown_flag_B &&
                ZUN_SUCCEEDED(enemy->on_tick())
            ) {
                enemy = node->data;
                enemy->data.__unknown_flag_A = false;
            }
            else {
                enemy = node->data;
                if (enemy) {
                    delete enemy;
                }
            }
        });

        PLAYER_PTR->__reset_damage_multiplier();

        this->__timer_98++;

        return UpdateFuncNext;
    }

    // 0x42DF50
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_tick(void* ptr) {
        GameThread* game_thread_ptr = GAME_THREAD_PTR;
        if (
            game_thread_ptr &&
            !(game_thread_ptr->__unknown_flag_A | game_thread_ptr->skip_flag) &&
            !game_thread_ptr->__unknown_flag_C &&
            !game_thread_ptr->__unknown_flag_B &&
            !ABILITY_SHOP_PTR
        ) {
            return ((EnemyManager*)ptr)->on_tick_impl();
        }
        return UpdateFuncNext;
    }

    // 0x42E0B0
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw(void* ptr) {
        return UpdateFuncNext;
    }

    // 0x42DC20
    dllexport gnu_noinline static EnemyManager* fastcall allocate(const char* ecl_filename) asm_symbol_rel(0x42DC20) {
        EnemyManager* enemy_manager = new EnemyManager();
        enemy_manager->index_next_enemy_id();
        ENEMY_MANAGER_PTR = enemy_manager;

        EclManager* ecl_manager = new EclManager();
        enemy_manager->ecl_manager = ecl_manager;

        ecl_manager->add_ecl_file(ecl_filename);

        UpdateFunc* update_func = new UpdateFunc(&on_tick, false, enemy_manager);
        UpdateFuncRegistry::register_on_tick(update_func, 27);
        update_func = new UpdateFunc(&on_draw, false, enemy_manager);
        UpdateFuncRegistry::register_on_draw(update_func, 23);

        enemy_manager->__timer_98.initialize_and_reset();
        enemy_manager->enemy_limit = 99999;
        enemy_manager->__int_164 = 0;

        return enemy_manager;
    }
};
#pragma region // EnemyManager Validation
ValidateFieldOffset32(0x0, EnemyManager, task_flags);
ValidateFieldOffset32(0x4, EnemyManager, on_tick_func);
ValidateFieldOffset32(0x8, EnemyManager, on_draw_func);
ValidateFieldOffset32(0xC, EnemyManager, int_vars);
ValidateFieldOffset32(0x1C, EnemyManager, float_vars);
ValidateFieldOffset32(0x3C, EnemyManager, player_death_count);
ValidateFieldOffset32(0x40, EnemyManager, player_bomb_count);
ValidateFieldOffset32(0x44, EnemyManager, can_capture_spell);
ValidateFieldOffset32(0x48, EnemyManager, boss_ids);
ValidateFieldOffset32(0x88, EnemyManager, flags);
ValidateFieldOffset32(0x8C, EnemyManager, enemy_limit);
ValidateFieldOffset32(0x90, EnemyManager, next_enemy_id);
ValidateFieldOffset32(0x94, EnemyManager, prev_enemy_id);
ValidateFieldOffset32(0x98, EnemyManager, __timer_98);
ValidateFieldOffset32(0xAC, EnemyManager, __int_AC);
ValidateFieldOffset32(0xB0, EnemyManager, __int_B0);
ValidateFieldOffset32(0x164, EnemyManager, __int_164);
ValidateFieldOffset32(0x168, EnemyManager, enemy_anms);
ValidateFieldOffset32(0x188, EnemyManager, ecl_manager);
ValidateFieldOffset32(0x18C, EnemyManager, enemy_list);
ValidateFieldOffset32(0x194, EnemyManager, __unknown_enemy_list);
ValidateFieldOffset32(0x198, EnemyManager, enemy_count);
ValidateFieldOffset32(0x19C, EnemyManager, __angle_19C);
ValidateStructSize32(0x1A0, EnemyManager);
#pragma endregion

static inline bool enemies_are_alive() {
    if (EnemyManager* enemy_manager = ENEMY_MANAGER_PTR) {
        return enemy_manager->enemy_count != 0;
    }
    return false;
}

// 0x42DA90
// Method 4
dllexport gnu_noinline ZUNResult thiscall EclManager::load_imports(EclIncludes* includes) {
    if (
        includes->magic.as_uint == ANM_INCLUDE_MAGIC
    ) {
        const char* anm_names = (const char*)includes->data;
        uint32_t i = 0;
        if (includes->count > i) {
            EnemyManager* enemy_manager = ENEMY_MANAGER_PTR;
            do {
                AnmLoaded* anm_loaded;
                clang_forceinline anm_loaded = ANM_MANAGER_PTR->preload_anm(i + 10, anm_names);
                enemy_manager->enemy_anms[i] = anm_loaded;
                if (!anm_loaded) {
                    LOG_BUFFER.write(JpEnStr("", "data is corrupted\r\n"));
                    return ZUN_ERROR;
                }
                anm_names += byteloop_strlen(anm_names) + 1;
            } while (++i < includes->count);
        }

        int32_t includes_align = (anm_names - (char*)includes) % 4;
        if (!includes_align) {
            anm_names += 4 - includes_align;
        }

        includes = (EclIncludes*)anm_names;

        if (
            includes->magic.as_uint == ECL_INCLUDE_MAGIC
        ) {
            const char* ecl_names = (const char*)includes->data;
            for (uint32_t i = 0; i < includes->count; ++i) {
                this->add_ecl_file(ecl_names);
                ecl_names += byteloop_strlen(ecl_names) + 1;
            }
        }
    }
    return ZUN_SUCCESS;
}

// 0x42E0C0
dllexport gnu_noinline Enemy* thiscall EnemyID::get_enemy_ptr() {
    int32_t raw_id = this->raw;
    if (!raw_id) {
        return NULL;
    }
    return ENEMY_MANAGER_PTR->get_enemy_by_id_impl(raw_id);
}

inline void EnemyData::set_anm_vm_slowdowns(const float& slowdown_value) {
    for (size_t i = 0; i < countof(this->anm_vms); ++i) {
        this->anm_vms[i].get_vm_ptr()->set_custom_slowdown(slowdown_value);
    }
}

inline void EnemyData::initialize(Enemy* enemy) {
    this->vm = enemy;
    this->position_interp.absolute.end_time = 0;
    this->position_interp.relative.end_time = 0;
    this->angle_interp_absolute.end_time = 0;
    this->angle_interp_relative.end_time = 0;
    this->speed_interp_absolute.end_time = 0;
    this->speed_interp_relative.end_time = 0;
    this->orbit_radius_interp.absolute.end_time = 0;
    this->orbit_radius_interp.relative.end_time = 0;
    this->ellipse_interp.absolute.end_time = 0;
    this->ellipse_interp.relative.end_time = 0;
    this->hit_sound = -1;
    this->death_anm_script = 0;
    this->current_motion.zero_contents();
    this->motion.absolute.zero_contents();
    this->motion.relative.zero_contents();
    this->hitbox_size = { 24.0f, 24.0f };
    this->collision_size = { 24.0f, 24.0f };
    this->hitbox_rotation = 0.0f;
    this->boss_id = -1;
    this->global_list_node.initialize_with(enemy);
    this->drops.initialize();
    this->ecl_time.initialize_and_reset();
    this->boss_timer.initialize_and_reset();
    this->invulnerable_timer.initialize_and_reset();
    this->no_collision_timer.initialize_and_reset();
    this->anm_base_layer = 1;
}

// 0x42E100
dllexport gnu_noinline Enemy::Enemy(const char* sub_name) {
    this->initialize_vm();
    this->data.initialize(this);
    EnemyManager* enemy_manager = ENEMY_MANAGER_PTR;
    this->__on_kill_func = NULL;
    this->data.death_callback_sub[0] = '\0';
    this->id = enemy_manager->get_next_enemy_id();
    this->data.slowdown = 0.0f;
    this->controller = enemy_manager->ecl_manager;
    this->locate_sub((char*)sub_name);
    this->current_context->location.instruction_offset = 0;
    this->current_context->time = 0.0f;
    this->data.life.initialize();
    this->data.initialize_callbacks();
    this->data.initialize_anm_vm_slots();
    this->data.bomb_damage_multiplier = 1.0f;
    this->data.chapter_spawn_weight = 0;
}

// 0x4237F0
dllexport gnu_noinline Enemy* get_boss_by_index(int32_t boss_index) {
    EnemyManager* enemy_manager = ENEMY_MANAGER_PTR;
    return enemy_manager->get_enemy_by_id_impl(enemy_manager->boss_ids[boss_index]);
}

// 0x42D220
dllexport gnu_noinline Enemy::~Enemy() {
    EnemyManager* enemy_manager = ENEMY_MANAGER_PTR;
    this->data.global_list_node.unlink_from_head(enemy_manager->enemy_list.head);
    this->data.global_list_node.unlink_from_tail(enemy_manager->enemy_list.tail);
    this->data.global_list_node.unlink_from_head(enemy_manager->__unknown_enemy_list);
    this->data.global_list_node.unlink();
    if (!this->data.__unknown_flag_P) {
        --enemy_manager->enemy_count;
        // Probably a nested function here...
        if (!this->data.__unknown_flag_P) {
            if (this->data.is_boss) {
                enemy_manager->boss_ids[this->data.boss_id] = 0;
            }
            AnmManager* anm_manager = ANM_MANAGER_PTR;
            for (size_t i = 0; i < countof(this->data.anm_vms); ++i) {
                anm_manager->mark_tree_id_for_delete(this->data.anm_vms[i]);
                this->data.anm_vms[i] = 0;
            }
        }
    }
    if (void* fog_ptr = this->data.fog.fog_ptr) {
        // __sub_41BE50(fog_ptr);
    }
    this->data.fog.fog_ptr = NULL;
}

// 0x430240
dllexport gnu_noinline int thiscall Enemy::kill() {

    ENEMY_MANAGER_PTR->__angle_19C = this->data.kill_effects<true>();

    this->data.drops.spawn_items(&this->data.current_motion.position);

    char* death_callback_sub = this->data.death_callback_sub;
    if (death_callback_sub[0]) {
        this->reinitialize_vm_with_sub(death_callback_sub);
        this->run_ecl(0.0f);
        death_callback_sub[0] = '\0';
    }

    if (auto* on_kill_func = this->__on_kill_func) {
        on_kill_func(this);
    }

    return 1;
}



// size: 0x1E48
struct AnmVMSpecialDataA {
    AnmVM __vm_array_0[4]; // 0x0
    AnmVM __anm_vm_1830; // 0x1830
    int __int_1E3C; // 0x1E3C
    int __int_1E40; // 0x1E40
    int32_t __int_1E44; // 0x1E44
    // 0x1E48
};
#pragma region // AnmVMSpecialDataA Validation
ValidateFieldOffset32(0x0, AnmVMSpecialDataA, __vm_array_0);
ValidateFieldOffset32(0x1830, AnmVMSpecialDataA, __anm_vm_1830);
ValidateFieldOffset32(0x1E3C, AnmVMSpecialDataA, __int_1E3C);
ValidateFieldOffset32(0x1E40, AnmVMSpecialDataA, __int_1E40);
ValidateFieldOffset32(0x1E44, AnmVMSpecialDataA, __int_1E44);
ValidateStructSize32(0x1E48, AnmVMSpecialDataA);
#pragma endregion

// 0x406AD0
dllexport gnu_noinline int fastcall AnmVM::on_create_special_dataA(AnmVM* vm, void* arg) {
    vm->controller.special_data_size = sizeof(AnmVMSpecialDataA);
    AnmVMSpecialDataA* special_data = (AnmVMSpecialDataA*)malloc(sizeof(AnmVMSpecialDataA));
    vm->controller.special_data = special_data;
    memset(special_data, 0, sizeof(AnmVMSpecialDataA));

    vm->data.origin_mode = 0;
    vm->data.layer = 0;

    Float3 position;
    position.x = 320.0f;
    position.y = 240.0f;
    position.z = 0.0f;

    nounroll for (int32_t i = 0; i < countof(special_data->__vm_array_0); ++i) {
        AnmVM* vm = &special_data->__vm_array_0[i];

        clang_forceinline EFFECT_MANAGER_PTR->effect_anm->__copy_data_to_vm_and_run(vm, i + 3);
        vm->controller.position = position;
    }

    special_data->__int_1E3C = 0;
    vm->data.layer = 43;
    vm->data.origin_mode = 0;
    vm->data.resolution_mode = 1;

    for (size_t i = 0; i < countof(special_data->__vm_array_0); ++i) {
        special_data->__vm_array_0[i].controller.position = { 320.0f, 240.0f, 0.0f };
    }

    clang_forceinline EFFECT_MANAGER_PTR->effect_anm->__copy_data_to_vm_and_run(&special_data->__anm_vm_1830, 194);

    return 0;
}

// 0x406C80
dllexport gnu_noinline int fastcall AnmVM::on_tick_special_dataA(AnmVM* vm) {
    AnmVMSpecialDataA* special_data = (AnmVMSpecialDataA*)vm->controller.special_data;

    int32_t total = 0;
    for (size_t i = 0; i < countof(special_data->__vm_array_0); ++i) {
        if (special_data->__vm_array_0[i].run_anm()) {
            ++total;
        }
    }

    if (total < 4) {
        special_data->__anm_vm_1830.run_anm();
        int32_t A = special_data->__int_1E40++;
        if (
            !special_data->__int_1E44 ||
            A < 60
        ) {
            return 0;
        }
    }
    return 1;
}

// 0x406D00
dllexport gnu_noinline int fastcall AnmVM::on_draw_special_dataA(AnmVM* vm) {
    // TODO
}

// 0x4072A0
dllexport gnu_noinline int fastcall AnmVM::on_destroy_special_dataA(AnmVM* vm) {
    return 0;
}

// 0x4072B0
dllexport gnu_noinline int fastcall AnmVM::on_interrupt_special_dataA(AnmVM* vm, int32_t interrupt) {
    AnmVMSpecialDataA* special_data = (AnmVMSpecialDataA*)vm->controller.special_data;
    switch (interrupt) {
        case 1:
            nounroll for (int32_t i = 0; i < countof(special_data->__vm_array_0); ++i) {
                clang_forceinline EFFECT_MANAGER_PTR->effect_anm->__copy_data_to_vm_and_run(&special_data->__vm_array_0[i], i + 7);
            }
            special_data->__int_1E44 = 1;
            special_data->__int_1E40 = 0;
        default:
            return 0;
        case 7:
            special_data->__int_1E3C = 0;
            break;
        case 8:
            special_data->__int_1E3C = 1;
            vm->data.origin_mode = 1;
            vm->data.resolution_mode = 1;
            break;
        case 9:
            special_data->__int_1E3C = 0;
            vm->data.layer = 37;
            break;
        case 10:
            special_data->__int_1E3C = 3;
            vm->data.layer = 31;
            vm->data.origin_mode = 0;
            vm->data.resolution_mode = 1;
            break;
    }
    for (size_t i = 0; i < countof(special_data->__vm_array_0); ++i) {
        special_data->__vm_array_0[i].controller.position = { 320.0f, 240.0f, 0.0f };
    }
    return 0;
}

// size: 0x193C
struct AnmVMSpecialDataB {
    AnmID __anm_id_array_0[200]; // 0x0
    unknown_fields(0x1608); // 0x320
    Timer __timer_1928; // 0x1928
    // 0x193C
};
#pragma region // AnmVMSpecialDataB Validation
ValidateFieldOffset32(0x0, AnmVMSpecialDataB, __anm_id_array_0);
ValidateFieldOffset32(0x1928, AnmVMSpecialDataB, __timer_1928);
ValidateStructSize32(0x193C, AnmVMSpecialDataB);
#pragma endregion

// 0x404FC0
dllexport gnu_noinline int fastcall AnmVM::on_create_special_dataB(AnmVM* vm, void* arg) {
    vm->controller.special_data_size = sizeof(AnmVMSpecialDataB);
    AnmVMSpecialDataB* special_data = (AnmVMSpecialDataB*)malloc(sizeof(AnmVMSpecialDataB));
    vm->controller.special_data = special_data;
    memset(special_data, 0, sizeof(AnmVMSpecialDataB));

    special_data->__timer_1928.reset();

    return 0;
}

// 0x405030
dllexport gnu_noinline int fastcall AnmVM::on_tick_special_dataB(AnmVM* vm) {
    AnmVMSpecialDataB* special_data = (AnmVMSpecialDataB*)vm->controller.special_data;

    // TODO
}

// 0x4058B0
dllexport gnu_noinline int fastcall AnmVM::on_draw_special_dataB(AnmVM* vm) {
    return 0;
}

// 0x4058C0
dllexport gnu_noinline int fastcall AnmVM::on_destroy_special_dataB(AnmVM* vm) {
    AnmVMSpecialDataB* special_data = (AnmVMSpecialDataB*)vm->controller.special_data;
    nounroll for (size_t i = 0; i < countof(special_data->__anm_id_array_0); ++i) {
        if (AnmVM* vm = special_data->__anm_id_array_0[i].get_vm_ptr()) {
            vm->data.visible = false;
            vm->data.current_instruction_offset = -1;
        }
    }
    return 0;
}

// 0x405910
dllexport gnu_noinline int fastcall AnmVM::on_interrupt_special_dataB(AnmVM* vm, int32_t interrupt) {
    if (interrupt == 1) {
        AnmVMSpecialDataB* special_data = (AnmVMSpecialDataB*)vm->controller.special_data;
        special_data->__timer_1928++;
    }
    return 0;
}

// size: 0x318
struct AnmVMSpecialDataC {
    Float2 position_array[64]; // 0x0
    D3DCOLOR __color_array_200[64]; // 0x200
    float __angle_300; // 0x300
    Timer __timer_304; // 0x304
    // 0x318
};
#pragma region // AnmVMSpecialDataC Validation
ValidateFieldOffset32(0x0, AnmVMSpecialDataC, position_array);
ValidateFieldOffset32(0x200, AnmVMSpecialDataC, __color_array_200);
ValidateFieldOffset32(0x300, AnmVMSpecialDataC, __angle_300);
ValidateFieldOffset32(0x304, AnmVMSpecialDataC, __timer_304);
ValidateStructSize32(0x318, AnmVMSpecialDataC);
#pragma endregion

// 0x405D70
dllexport gnu_noinline int fastcall AnmVM::on_create_special_dataC1(AnmVM* vm, void* arg) {
    vm->controller.special_data_size = sizeof(AnmVMSpecialDataC);
    AnmVMSpecialDataC* special_data = (AnmVMSpecialDataC*)malloc(sizeof(AnmVMSpecialDataC));
    vm->controller.special_data = special_data;
    memset(special_data, 0, sizeof(AnmVMSpecialDataC));

    Float3* position = (Float3*)arg;

    float X = position->x;
    special_data->position_array[0].x = X;
    float Y = position->y;
    X += 320.0f;
    Y += 16.0f;
    special_data->position_array[0].x = X;
    special_data->position_array[0].y = Y;

    special_data->__angle_300 = RNG.rand_angle();
    special_data->__timer_304.set(1);

    uint32_t j = 0;
    for (int32_t i = 0; i < countof(special_data->__color_array_200); ++i) {
        special_data->__color_array_200[i] = PackD3DCOLOR(255, 0, 128, 255);
        if (i < 8u) {
            RED(special_data->__color_array_200[i]) = ~(i << 5);
        }
        else if (i >= 32u) {
            ALPHA(special_data->__color_array_200[i]) = ~(j++ << 4);
        }
    }

    vm->controller.position = *position;
    vm->data.layer = 15;
    vm->data.origin_mode = 1;
    vm->data.blend_mode = 1;

    vm->initialize_alpha_interp(64, 0, 255, 0);

    return 0;
}

// 0x405ED0
dllexport gnu_noinline int fastcall AnmVM::on_tick_special_dataC(AnmVM* vm) {
    AnmVMSpecialDataC* special_data = (AnmVMSpecialDataC*)vm->controller.special_data;

    int32_t time = special_data->__timer_304;
    if (time < 64) {
        if (time != special_data->__timer_304.previous) {
            for (int32_t i = time; i > 0; --i) {
                uint8_t alpha = ALPHA(special_data->__color_array_200[i]);
                ALPHA(special_data->__color_array_200[i]) = alpha >= 16 ? alpha - 16 : 0;
            }

            Float2* position = &special_data->position_array[time];

            position[0].make_from_vector(special_data->__angle_300, RNG.rand_float() * 5.0f + 4.0f);
            position[0] += position[-1];

            float angle = special_data->__angle_300 + RNG.rand_angle() / 5.0f;
            special_data->__angle_300 = reduce_angle(angle);
        }
        special_data->__timer_304++;
        return 0;
    }
    return 1;
}

// 0x406090
dllexport gnu_noinline int fastcall AnmVM::on_draw_special_dataC(AnmVM* vm) {
    // TODO
}

// 0x406290
dllexport gnu_noinline int fastcall AnmVM::on_destroy_special_dataC(AnmVM* vm) {
    return 0;
}

// 0x4062A0
dllexport gnu_noinline int fastcall AnmVM::on_interrupt_special_dataC(AnmVM* vm, int32_t interrupt) {
    return 0;
}

// 0x4062B0
dllexport gnu_noinline int fastcall AnmVM::on_create_special_dataC2(AnmVM* vm, void* arg) {
    vm->controller.special_data_size = sizeof(AnmVMSpecialDataC);
    AnmVMSpecialDataC* special_data = (AnmVMSpecialDataC*)malloc(sizeof(AnmVMSpecialDataC));
    vm->controller.special_data = special_data;
    memset(special_data, 0, sizeof(AnmVMSpecialDataC));

    special_data->__angle_300 = RNG.rand_angle();
    special_data->__timer_304.set(1);

    uint32_t j = 0;
    for (int32_t i = 0; i < countof(special_data->__color_array_200); ++i) {
        special_data->__color_array_200[i] = PackD3DCOLOR(255, 80, 80, 80);
        if (i < 8u) {
            RED(special_data->__color_array_200[i]) = ~(i << 5);
        } else if (i >= 32u) {
            ALPHA(special_data->__color_array_200[i]) = ~(j++ << 4);
        }
    }

    vm->controller.position = *(Float3*)arg;
    vm->data.blend_mode = 0;
    vm->data.layer = 19;
    vm->data.origin_mode = 1;

    return 0;
}

// size: 0x97C
struct AnmVMSpecialDataD {
    unknown_fields(0x900); // 0x0
    ZUNInterp<Float3> __float3_interp_900; // 0x900
    unknown_fields(0x10); // 0x10
    Timer __timer_968; // 0x968
    // 0x97C
};
#pragma region // AnmVMSpecialDataD Validation
ValidateFieldOffset32(0x900, AnmVMSpecialDataD, __float3_interp_900);
ValidateFieldOffset32(0x968, AnmVMSpecialDataD, __timer_968);
ValidateStructSize32(0x97C, AnmVMSpecialDataD);
#pragma endregion

// 0x407590
dllexport gnu_noinline int fastcall AnmVM::on_create_special_dataD(AnmVM* vm, void* arg) {

    
    AnmLoaded* anm_loaded = ENEMY_MANAGER_PTR->enemy_anms[3];
    anm_loaded->__copy_data_to_vm_unknown_A(vm);

    vm->data.slot = anm_loaded->slot_index;
    vm->data.slot2 = anm_loaded->slot_index;

    vm->controller.special_data_size = sizeof(AnmVMSpecialDataD);
    AnmVMSpecialDataD* special_data = (AnmVMSpecialDataD*)malloc(sizeof(AnmVMSpecialDataD));
    vm->controller.special_data = special_data;
    memset(special_data, 0, sizeof(AnmVMSpecialDataD));

    special_data->__timer_968.set(1);

    // TODO

    return 0;
}

// 0x4078D0
dllexport gnu_noinline int fastcall AnmVM::on_tick_special_dataD(AnmVM* vm) {
    // TODO
}

// 0x407C90
dllexport gnu_noinline int fastcall AnmVM::on_draw_special_dataD(AnmVM* vm) {
    // TODO
}

// 0x407D30
dllexport gnu_noinline int fastcall AnmVM::on_destroy_special_dataD(AnmVM* vm) {
    return 0;
}

// 0x407D40
dllexport gnu_noinline int fastcall AnmVM::on_interrupt_special_dataD(AnmVM* vm, int32_t interrupt) {
    return 0;
}

typedef struct Stage Stage;
extern "C" {
    // 0x4CF2B4
    externcg Stage* STAGE_PTR cgasm("_STAGE_PTR");
    // 0x4CF2B8
    externcg Stage* STAGE_B_PTR cgasm("_STAGE_B_PTR");
}

// size: 0x30
struct StdDistortion {
    EnemyFogImpl* fog_ptr; // 0x0
    unknown_fields(0x28); // 0x4
    int32_t enabled; // 0x2C
    // 0x30
};

// size: 0x1C
struct StdQuad {
    int16_t type; // 0x0
    int16_t offset_to_next; // 0x2
    uint16_t anm_script; // 0x4
    int16_t face_vm_index; // 0x6
    Float3 position; // 0x8
    Float2 size; // 0x14
    // 0x1C
};

// size: 0x1C+
struct StdEntry {
    int16_t id; // 0x0
    int8_t layer; // 0x2
    union {
        uint8_t flags; // 0x3
        struct {
            uint8_t __unknown_flag_A : 1; // 1
        };
    };
    Float3 position; // 0x4
    Float3 size; // 0x10
    StdQuad quads[0]; // 0x1C

    // 0x41CA90
    dllexport gnu_noinline int thiscall __sub_41CA90(Float3* arg1, StageCamera* camera) asm_symbol_rel(0x41CA90) {
        // TODO
    }
};

// size: 0x90
struct StdHeader {
    int16_t entry_count; // 0x0
    int16_t face_count; // 0x2
    uint32_t faces_offset; // 0x4
    uint32_t script_offset; // 0x8
    unknown_fields(0x4); // 0xC
    char anm_name[128]; // 0x10
    StdEntry* entries[]; // 0x90 stored as offsets
};
#pragma region // StdHeader Validation
ValidateFieldOffset32(0x0, StdHeader, entry_count);
ValidateFieldOffset32(0x2, StdHeader, face_count);
ValidateFieldOffset32(0x4, StdHeader, faces_offset);
ValidateFieldOffset32(0x8, StdHeader, script_offset);
ValidateFieldOffset32(0x10, StdHeader, anm_name);
ValidateFieldOffset32(0x90, StdHeader, entries);
ValidateStructSize32(0x90, StdHeader);
#pragma endregion

// size: 0x10
struct StdFace {
    int16_t entry_id; // 0x0
    union {
        uint16_t flags; // 0x2
        struct {

        };
    };
    Float3 position; // 0x4
    // 0x10
};
#pragma region // StdFace Validation
ValidateFieldOffset32(0x0, StdFace, entry_id);
ValidateFieldOffset32(0x2, StdFace, flags);
ValidateFieldOffset32(0x4, StdFace, position);
ValidateStructSize32(0x10, StdFace);
#pragma endregion

// size: 0x8+
struct StdInstruction {
    int32_t time; // 0x0
    int16_t opcode; // 0x4
    int16_t size; // 0x6
    unsigned char args[]; // 0x8
};

// size: 0x3444
struct StdVM {
    Timer script_time; // 0x0, 0xC
    int32_t current_instruction_offset; // 0x14, 0x20
    int32_t shaking_mode; // 0x18, 0x24
    Timer shaking_timer; // 0x1C, 0x28
    Timer __shaking_6_timer; // 0x30, 0x3C
    ZUNInterp<Float3> camera_facing_interp; // 0x44, 0x50
    ZUNInterp<Float3> camera_position_interp; // 0x9C, 0xA8
    ZUNInterp<Float3> camera_rotation_interp; // 0xF4, 0x100
    ZUNInterp<StageSky> sky_data_interp; // 0x14C, 0x158
    ZUNInterp<float> camera_fov_interp; // 0x1F4, 0x200
    StageCamera camera; // 0x224, 0x230
    Stage* full_stage; // 0x388, 0x394
    AnmVM slot_vms[8]; // 0x38C, 0x398
    int32_t slot_layers[8]; // 0x33EC, 0x33F8
    float draw_distance_squared; // 0x340C, 0x3418
    StdDistortion distortion; // 0x3410, 0x341C
    D3DCOLOR __color_3440; // 0x3440, 0x344C
    // 0x3444

    // 0x41D260
    dllexport gnu_noinline ZUNResult thiscall run_std() asm_symbol_rel(0x41D260) {
        // TODO
    }
};
#pragma region // StdVM Validation
ValidateFieldOffset32(0x0, StdVM, script_time);
ValidateFieldOffset32(0x14, StdVM, current_instruction_offset);
ValidateFieldOffset32(0x18, StdVM, shaking_mode);
ValidateFieldOffset32(0x1C, StdVM, shaking_timer);
ValidateFieldOffset32(0x30, StdVM, __shaking_6_timer);
ValidateFieldOffset32(0x44, StdVM, camera_facing_interp);
ValidateFieldOffset32(0x9C, StdVM, camera_position_interp);
ValidateFieldOffset32(0xF4, StdVM, camera_rotation_interp);
ValidateFieldOffset32(0x14C, StdVM, sky_data_interp);
ValidateFieldOffset32(0x1F4, StdVM, camera_fov_interp);
ValidateFieldOffset32(0x224, StdVM, camera);
ValidateFieldOffset32(0x388, StdVM, full_stage);
ValidateFieldOffset32(0x38C, StdVM, slot_vms);
ValidateFieldOffset32(0x33EC, StdVM, slot_layers);
ValidateFieldOffset32(0x340C, StdVM, draw_distance_squared);
ValidateFieldOffset32(0x3410, StdVM, distortion);
ValidateFieldOffset32(0x3440, StdVM, __color_3440);
ValidateStructSize32(0x3444, StdVM);
#pragma endregion

// size: 0x34A0
struct Stage : ZUNTask {
    // ZUNTask base; // 0x0
    StdVM std_vm; // 0xC
    AnmVM* face_vms; // 0x3450
    StdHeader* std_file; // 0x3454
    StdEntry** entries; // 0x3458
    StdFace* faces; // 0x345C
    StdInstruction* script; // 0x3460
    AnmLoaded* stage_anm; // 0x3464
    unknown_fields(0xC); // 0x3468
    union {
        uint32_t flags; // 0x3474
        struct {
            uint32_t __unknown_flag_C : 1; // 1
            uint32_t : 1; // 2
            uint32_t __unknown_flag_B : 1; // 3
            uint32_t __unknown_flag_A : 1; // 4
        };
    };
    Timer __timer_3478; // 0x3478
    int32_t stage_number; // 0x348C
    int __int_3490; // 0x3490
    void* std_file_buffer; // 0x3494
    int32_t std_file_size; // 0x3498
    UpdateFunc* on_draw_func_B; // 0x349C
    // 0x34A0

    inline void zero_contents() {
        zero_this();
    }

    inline Stage() {
        this->zero_contents();
        this->__unknown_task_flag_A = true;
    }

    // 0x41BB50
    dllexport gnu_noinline ~Stage() {
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func_B);

        if (AnmVM* face_vms = this->face_vms) {
            for (int32_t i = 0; i < this->std_file->face_count; ++i) {
                face_vms[i].cleanup();
            }
            SAFE_FREE(this->face_vms);
        }

        for (int32_t i = 0; i < countof(this->std_vm.slot_vms); ++i) {
            this->std_vm.slot_vms[i].cleanup();
        }

        SAFE_FREE(this->std_file);
        SAFE_FREE(this->std_file_buffer);

        SAFE_DELETE(this->std_vm.distortion.fog_ptr);

        if (!GAME_MANAGER.__unknown_flag_A) {
            ANM_MANAGER_PTR->unload_anm(3 + (this->stage_number & 1));
        }

        if (STAGE_PTR == this) {
            STAGE_PTR = NULL;
        }
        if (STAGE_B_PTR == this) {
            STAGE_B_PTR = NULL;
        }
    }

    // 0x41C0A0
    dllexport gnu_noinline UpdateFuncRet thiscall on_tick() asm_symbol_rel(0x41C0A0) {
        if (
            !this->__unknown_flag_A &&
            (!this->__unknown_flag_B || this->__timer_3478 < 60)
        ) {
            this->std_vm.camera.__float2_FC = {};
            this->std_vm.camera.__float3_13C = {};

            Float3 A = this->std_vm.camera.facing + this->std_vm.camera.__shaking_float3_B;
            D3DXVec3Normalize(&this->std_vm.camera.facing_normalized.D3DX(), &A.D3DX());

            this->std_vm.__color_3440 = PackD3DCOLOR(0, 128, 128, 128);

            if (!this->__unknown_flag_B || this->__timer_3478 < 30) {
                for (int32_t i = 0; i < this->std_file->entry_count; ++i) {
                    StdEntry* entry = this->entries[i];
                    if (entry->__unknown_flag_A) {
                        uint32_t vms_alive = 0;
                        for (
                            StdQuad* quad = entry->quads;
                            quad->type >= 0;
                            quad = pointer_raw_offset(quad, quad->offset_to_next)
                        ) {
                            AnmVM* vm = &this->face_vms[quad->face_vm_index];
                            vm->run_anm();
                            vms_alive += vm->data.current_instruction_offset >= 0;
                        }
                        if (!vms_alive) {
                            entry->__unknown_flag_A = false;
                        }
                    }
                }
                this->std_vm.run_std();
            }
            SUPERVISOR.cameras[3] = this->std_vm.camera;
            nounroll for (size_t i = 0; i < countof(this->std_vm.slot_vms); ++i) {
                this->std_vm.slot_vms[i].run_anm();
            }
            this->__on_tick_B();
            ++this->__int_3490;
        }
        return UpdateFuncNext;
    }

    // 0x41E760
    dllexport gnu_noinline void thiscall __on_tick_B() asm_symbol_rel(0x41E760) {

    }

    // 0x41C290
    dllexport gnu_noinline UpdateFuncRet thiscall on_draw() asm_symbol_rel(0x41C290) {
        // TODO
    }

    // 0x41C700
    dllexport gnu_noinline UpdateFuncRet thiscall on_draw_B() asm_symbol_rel(0x41C700) {
        // TODO
    }

    // 0x41CA60
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_tick(void* ptr) asm_symbol_rel(0x41CA60) {
        return ((Stage*)ptr)->on_tick();
    }

    // 0x41CA70
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw(void* ptr) asm_symbol_rel(0x41CA70) {
        return ((Stage*)ptr)->on_draw();
    }

    // 0x41CA80
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw_B(void* ptr) asm_symbol_rel(0x41CA80) {
        return ((Stage*)ptr)->on_draw_B();
    }

    // 0x41B850
    dllexport gnu_noinline ZUNResult thiscall initialize(const char* std_filename) asm_symbol_rel(0x41B850) {
        STAGE_PTR = this;
        this->stage_number = GAME_MANAGER.globals.current_stage;

        if (!this->std_file_buffer) {
            void* file_buffer = read_file_from_dat(std_filename, &this->std_file_size);
            this->std_file_buffer = file_buffer;
            if (!file_buffer) {
                goto corrupted_data;
            }
        }
        StdHeader* std_file = (StdHeader*)malloc(this->std_file_size);
        this->std_file = std_file;
        memcpy(std_file, this->std_file_buffer, this->std_file_size);

        AnmLoaded* stage_anm = ANM_MANAGER_PTR->preload_anm(3 + (this->stage_number & 1), this->std_file->anm_name);
        this->stage_anm = stage_anm;
        if (!stage_anm) {
            LOG_BUFFER.write(JpEnStr("", "No stage data found. data is corrupted\r\n"));
corrupted_data:
            LOG_BUFFER.write_error(JpEnStr("", "Unable to read stage data. data is corrupted\r\n"));
            return ZUN_ERROR;
        }

        std_file = this->std_file;

        this->entries = std_file->entries;
        this->faces = based_pointer<StdFace>(std_file, std_file->faces_offset);
        this->script = based_pointer<StdInstruction>(std_file, std_file->script_offset);

        // Adjust the entry offsets
        for (
            int32_t i = 0;
            i < std_file->entry_count;
            ++i, std_file = this->std_file
        ) {
            this->entries[i] = based_pointer<StdEntry>(this->entries[i], this->std_file);
        }

        AnmVM* face_vms = (AnmVM*)malloc(sizeof(AnmVM) * std_file->face_count);
        this->face_vms = face_vms;
        memset(face_vms, 0, sizeof(AnmVM) * std_file->face_count);

        this->std_vm.full_stage = this;

        this->std_vm.camera = SUPERVISOR.cameras[3];

        this->std_vm.camera.position = { 0.0f, 0.0f, -600.0f };
        this->std_vm.camera.facing = { 0.0f, 300.0f, 600.0f };
        this->std_vm.camera.rotation = { 0.0f, 1.0f, 0.0f };
        this->std_vm.camera.__shaking_float3_A = { 0.0f, 0.0f, 0.0f };
        this->std_vm.camera.__shaking_float3_B = { 0.0f, 0.0f, 0.0f };
        this->std_vm.draw_distance_squared = 9610000.0f; // 3100 squared

        UpdateFunc* update_func = new UpdateFunc(&on_tick, false, this);
        UpdateFuncRegistry::register_on_tick(update_func, 18);
        this->on_tick_func = update_func;
        update_func = new UpdateFunc(&on_draw, false, this);
        UpdateFuncRegistry::register_on_draw(update_func, 3);
        this->on_draw_func = update_func;
        update_func = new UpdateFunc(&on_draw_B, false, this);
        UpdateFuncRegistry::register_on_draw(update_func, 6);
        this->on_draw_func_B = update_func;

        this->__int_3490 = 0;
        this->std_vm.script_time.reset();
        this->__unknown_flag_C = true;
        this->std_vm.camera_facing_interp.end_time = 0;
        this->std_vm.camera_position_interp.end_time = 0;

        return ZUN_SUCCESS;
    }

    // 0x41BF90
    dllexport gnu_noinline static Stage* fastcall allocate(const char* std_filename) asm_symbol_rel(0x41BF90) {
        Stage* stage = new Stage();
        if (ZUN_FAILED(stage->initialize(std_filename))) {
            delete stage;
            return NULL;
        }
        return stage;
    }
};
#pragma region // Stage Validation
ValidateFieldOffset32(0x0, Stage, task_flags);
ValidateFieldOffset32(0x4, Stage, on_tick_func);
ValidateFieldOffset32(0x8, Stage, on_draw_func);
ValidateFieldOffset32(0xC, Stage, std_vm);
ValidateFieldOffset32(0x3450, Stage, face_vms);
ValidateFieldOffset32(0x3454, Stage, std_file);
ValidateFieldOffset32(0x3458, Stage, entries);
ValidateFieldOffset32(0x345C, Stage, faces);
ValidateFieldOffset32(0x3460, Stage, script);
ValidateFieldOffset32(0x3464, Stage, stage_anm);
ValidateFieldOffset32(0x3474, Stage, flags);
ValidateFieldOffset32(0x3478, Stage, __timer_3478);
ValidateFieldOffset32(0x348C, Stage, stage_number);
ValidateFieldOffset32(0x3490, Stage, __int_3490);
ValidateFieldOffset32(0x3494, Stage, std_file_buffer);
ValidateFieldOffset32(0x3498, Stage, std_file_size);
ValidateFieldOffset32(0x349C, Stage, on_draw_func_B);
ValidateStructSize32(0x34A0, Stage);
#pragma endregion

typedef struct Spellcard Spellcard;
extern "C" {
    // 0x4CF2C0
    externcg Spellcard* SPELLCARD_PTR cgasm("_SPELLCARD_PTR");
}

// size: 0xC0
struct Spellcard : ZUNTask {
    // ZUNTask base; // 0x0
    AnmID __vm_id_C; // 0xC
    AnmID __vm_id_10; // 0x10
    AnmID __vm_id_14; // 0x14
    AnmID __vm_id_18; // 0x18
    AnmID __vm_id_1C; // 0x1C
    Timer __timer_20; // 0x20
    char name[64]; // 0x34
    int32_t id; // 0x74
    union {
        uint32_t flags; // 0x78
        struct {
            uint32_t __unknown_flag_A : 1; // 1
            uint32_t __unknown_flag_B : 1; // 2
            uint32_t : 1; // 3
            uint32_t __timeout_spell : 1; // 4
            uint32_t __unknown_flag_C : 1; // 5
            uint32_t __unknown_flag_E : 1; // 6
            uint32_t __unknown_flag_F : 1; // 7
            uint32_t __unknown_flag_D : 1; // 8
            uint32_t __unknown_flag_H: 1; // 9
            uint32_t __unknown_flag_G : 1; // 10
        };
    };
    int32_t __bonus_A; // 0x7C
    int32_t __bonus_B; // 0x80
    int32_t time; // 0x84
    unknown_fields(0x4); // 0x88
    int __int_8C; // 0x8C
    int32_t __int_90; // 0x90
    unknown_fields(0x14); // 0x94
    int32_t __int_A8; // 0xA8
    Float3 __float3_AC; // 0xAC
    unknown_fields(0x8); // 0xB8
    // 0xC0

    inline void zero_contents() {
        zero_this();
    }

    inline Spellcard() {
        this->zero_contents();
        this->__unknown_task_flag_A = true;
    }

    // 0x429D80
    dllexport gnu_noinline ~Spellcard() {
        this->__vm_id_10.mark_tree_for_delete();
        this->__vm_id_14.mark_tree_for_delete();
        this->__vm_id_18.mark_tree_for_delete();

        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);

        SPELLCARD_PTR = NULL;
    }

    // 0x409B10
    dllexport gnu_noinline BOOL thiscall __get_flag_A() asm_symbol_rel(0x409B10) {
        return this->__unknown_flag_A;
    }

    // 0x42D640
    dllexport gnu_noinline BOOL thiscall __get_flag_B() asm_symbol_rel(0x42D640) {
        return this->__unknown_flag_B;
    }

    // 0x42D650
    dllexport gnu_noinline void thiscall __set_timeout_flag() asm_symbol_rel(0x42D650) {
        SPELLCARD_PTR->__timeout_spell = true;
    }

    // 0x42D610
    dllexport gnu_noinline void thiscall __set_flag_H(int32_t state) asm_symbol_rel(0x42D610) {
        SPELLCARD_PTR->__unknown_flag_H = state;
    }

    inline bool __inline_sub_A() {
        return this->__unknown_flag_A && this->__timer_20 >= 60;
    }

    inline bool __inline_sub_B() {
        return this->__unknown_flag_A & this->__timeout_spell;
    }

    inline bool __inline_sub_C() {
        return this->__unknown_flag_A & this->__unknown_flag_E;
    }

    // 0x42D670
    dllexport gnu_noinline void thiscall __sub_42D670() asm_symbol_rel(0x42D670) {
        Spellcard* spellcard = SPELLCARD_PTR;
        spellcard->__unknown_flag_C = true;
        spellcard->__vm_id_1C.mark_tree_for_delete();
    }

    inline void __inline_sub_409AD0() {
        if (this->__unknown_flag_A) {
            if (this->__timer_20 >= 60) {
                this->__bonus_A = 0;
                this->__unknown_flag_B = false;
                this->__unknown_flag_E = false;
            } else if (BOMB_PTR->is_active()) {
                this->__unknown_flag_E = true;
            }
        }
    }

    // 0x409AD0
    static dllexport gnu_noinline void __sub_409AD0() asm_symbol_rel(0x409AD0) {
        SPELLCARD_PTR->__inline_sub_409AD0();
    }

    // 0x42A320
    dllexport gnu_noinline void thiscall start_spell(int32_t id, const char* name, int32_t time, int32_t mode) asm_symbol_rel(0x42A320) {
        __asm FINIT

        this->__timer_20.reset();
        this->id = id;
        byteloop_strcpy(this->name, name);
        this->__unknown_flag_A = true;
        this->__unknown_flag_B = true;
        this->__timeout_spell = false;
        this->__unknown_flag_C = false;
        this->__unknown_flag_D = false;
        if (!is_replay()) {
            byteloop_strcpy(SCOREFILE_MANAGER_PTR->primary_file.shottypes[GAME_MANAGER.globals.shottype_index()].spells[id].name, name);

        }
        Gui* gui = GUI_PTR;
        gui->__anm_vm_84->interrupt_and_run(2);
        gui->__anm_vm_88->interrupt_and_run(2);

        this->__int_8C = 1;
        this->__unknown_flag_E = false;
        this->__unknown_flag_F = false;

        this->__vm_id_10 = ASCII_MANAGER_PTR->ascii_anm->instantiate_vm_to_world_list_back(0);
        this->__vm_id_14 = SUPERVISOR.text_anm->instantiate_vm_to_world_list_back(2);
        this->__vm_id_18 = ASCII_MANAGER_PTR->ascii_anm->instantiate_vm_to_world_list_back(1);
        AnmVM* vm = this->__vm_id_14.get_vm_ptr();
        // TODO

        SOUND_MANAGER.play_sound(33);
        this->__vm_id_1C = EFFECT_MANAGER_PTR->effect_anm->instantiate_vm_to_world_list_back(13);

        Enemy* boss;
        clang_forceinline boss = ENEMY_MANAGER_PTR->get_boss_by_index(0);
        this->__float3_AC = boss->data.current_motion.position;
        this->__vm_id_1C.set_controller_position(&boss->data.current_motion.position);

        this->__vm_id_1C.__wtf_child_list_jank_A(11, 0)->data.current_context.int_vars[2] = time;
        this->__vm_id_1C.__wtf_child_list_jank_A(13, 0)->data.current_context.int_vars[2] = time;

        this->time = time;

        // ZUN didn't mark this as const,
        // so it gets written onto the
        // stack for no good reason.
        // 
        // Trying to run this code on overdrive
        // will end up reading the stack cookie
        // as the bonus.
        int32_t bonus_table[] = {
            500000,
            1000000,
            1500000,
            2000000,
            1000000
        };

        int32_t bonus = bonus_table[GAME_MANAGER.globals.difficulty] * GAME_MANAGER.globals.current_stage;
        this->__bonus_A = bonus;
        this->__bonus_B = bonus;
        if (bonus >= 1000000000) {
            this->__bonus_B = 1000000000;
        }

        EFFECT_MANAGER_PTR->effect_anm->instantiate_vm_to_world_list_back(20);

        auto& anm_sourceA = STAGE_DATA_PTR->innner[mode];
        anm_file_lookup(anm_sourceA.__spell_anm_indexA)->instantiate_vm_to_world_list_back(anm_sourceA.__spell_anm_scriptA);
        auto& anm_sourceB = STAGE_DATA_PTR->innner[mode];
        this->__unknown_flag_G = anm_sourceB.__spell_flag_state;
        anm_file_lookup(anm_sourceB.__spell_anm_indexB)->instantiate_vm_to_world_list_back(anm_sourceB.__spell_anm_scriptB);
        
        GAME_MANAGER.globals.__unknown_flag_A = false;
    }

    // 0x42A780
    dllexport gnu_noinline void thiscall end_spell() {
        if (this->__unknown_flag_A) {
            // TODO, sets some stage flag
            this->__vm_id_10.interrupt_tree(1);
            this->__vm_id_14.interrupt_tree(1);
            this->__vm_id_18.interrupt_tree(1);
            this->__unknown_flag_A = false;
            this->__vm_id_C.mark_tree_for_delete();
            this->__unknown_flag_E = false;
            //GUI_PTR->__sub_429C30();
            this->__vm_id_1C.mark_tree_for_delete();

            if (this->__unknown_flag_B) {
                GAME_MANAGER.add_to_score(this->__bonus_A);
                //GUI_PTR->__sub_441A50(0, this->__bonus_A);
                if (!is_replay()) {
                    // TODO: update scorefile
                }
                SOUND_MANAGER.play_sound(46);
            }
            else {
                Gui* gui = GUI_PTR;
                gui->__anm_id_B8.mark_tree_for_delete();
                gui->__anm_id_B8 = gui->__anm_loaded_2C0->instantiate_vm_to_world_list_back(50);
                gui->__int_134 = 1;
                gui->__anm_id_110 = gui->__anm_loaded_2C0->instantiate_vm_to_world_list_back(84);
            }

            if (this->__timeout_spell) {
                SOUND_MANAGER.play_sound(69);
            }
        }
    }

    // this probably actually takes an Enemy*, but
    // the memory access pattern when recompiling
    // would be wrong for that.
    inline bool __enemy_is_low_health(EnemyData* enemy_data, int32_t threshold_low, int32_t threshold_high) {
        if (this->__inline_sub_C()) {
            return false;
        }
        int32_t life_remaining = enemy_data->enemy()->data.life.remaining_current_attack;

        if (this->__unknown_flag_A) {
            return life_remaining < threshold_low;
        } else {
            return life_remaining < threshold_high;
        }
    }

    // 0x429EB0
    dllexport gnu_noinline UpdateFuncRet thiscall on_tick() asm_symbol_rel(0x429EB0) {

    }

    inline UpdateFuncRet thiscall on_draw() {

    }

    // 0x42A160
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_tick(void* ptr) asm_symbol_rel(0x42A160) {
        return ((Spellcard*)ptr)->on_tick();
    }

    // 0x42A170
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw(void* ptr) asm_symbol_rel(0x42A170) {
        return ((Spellcard*)ptr)->on_draw();
    }

    inline ZUNResult initialize() {
        UpdateFunc* update_func = new UpdateFunc(&on_tick, false, this);
        UpdateFuncRegistry::register_on_tick(update_func, 31);
        this->on_tick_func = update_func;
        update_func = new UpdateFunc(&on_draw, false, this);
        UpdateFuncRegistry::register_on_draw(update_func, 12);
        this->on_draw_func = update_func;

        this->__timer_20.reset();
        
        return ZUN_SUCCESS;
    }

    static inline Spellcard* allocate() {
        Spellcard* spellcard = new Spellcard();
        SPELLCARD_PTR = spellcard;
        if (ZUN_FAILED(spellcard->initialize())) {
            delete spellcard;
            return NULL;
        }
        return spellcard;
    }
};
#pragma region // Spellcard Validation
ValidateFieldOffset32(0x0, Spellcard, task_flags);
ValidateFieldOffset32(0x4, Spellcard, on_tick_func);
ValidateFieldOffset32(0x8, Spellcard, on_draw_func);
ValidateFieldOffset32(0xC, Spellcard, __vm_id_C);
ValidateFieldOffset32(0x10, Spellcard, __vm_id_10);
ValidateFieldOffset32(0x14, Spellcard, __vm_id_14);
ValidateFieldOffset32(0x18, Spellcard, __vm_id_18);
ValidateFieldOffset32(0x1C, Spellcard, __vm_id_1C);
ValidateFieldOffset32(0x20, Spellcard, __timer_20);
ValidateFieldOffset32(0x34, Spellcard, name);
ValidateFieldOffset32(0x74, Spellcard, id);
ValidateFieldOffset32(0x78, Spellcard, flags);
ValidateFieldOffset32(0x7C, Spellcard, __bonus_A);
ValidateFieldOffset32(0x80, Spellcard, __bonus_B);
ValidateFieldOffset32(0x84, Spellcard, time);
ValidateFieldOffset32(0x8C, Spellcard, __int_8C);
ValidateFieldOffset32(0x90, Spellcard, __int_90);
ValidateFieldOffset32(0xA8, Spellcard, __int_A8);
ValidateFieldOffset32(0xAC, Spellcard, __float3_AC);
ValidateStructSize32(0xC0, Spellcard);
#pragma endregion

// 0x420360
dllexport gnu_noinline ZUNResult BombBase::start_bomb() {
    BombBase* bomb = BOMB_PTR;
    if (
        !bomb->active && !bomb->__dword_A0
    ) {
        bomb->active = TRUE;
        bomb->__timer_34.reset();
        GAME_MANAGER.globals.subtract_bomb();

        Spellcard* spellcard = SPELLCARD_PTR;
        if (
            spellcard->__unknown_flag_A &&
            spellcard->__timer_20 >= 60
        ) {
            bomb->__int_68 = 1;
        }

        SOUND_MANAGER.play_sound_positioned(44, PLAYER_PTR->data.position.x);

        bomb->activate();

        UNKNOWN_COUNTER_A = 0;

        ENEMY_MANAGER_PTR->can_capture_spell = false;

        return ZUN_SUCCESS;
    }
    return ZUN_ERROR;
}

// 0x420420
dllexport gnu_noinline BOOL BombBase::bomb_allowed() {
    if (GAME_MANAGER.globals.bomb_stocks > 0) {
        BombBase* bomb = BOMB_PTR;
        if (
            (bomb && bomb->active != TRUE) &&
            GUI_PTR->msg_is_inactive() &&
            enemies_are_alive()
        ) {
            return TRUE;
        }
    }
    return FALSE;
}

// 0x45BE90
dllexport gnu_noinline UpdateFuncRet thiscall Player::on_tick() {
    switch (this->data.state) {
        case 0: { // Respawning?
            int32_t A = 61440 - this->data.__death_timer * 10240 / 60;
            this->data.__death_timer.previous = A;
            this->set_y_position_internal(A);
            this->__set_all_option_D4_to_1();
            this->reset_previous_positions();
            int32_t B = this->data.__death_timer;
            float radius;
            if (B >= 30) {
                Spellcard* spellcard = SPELLCARD_PTR;
                if (
                    spellcard->__unknown_flag_A &&
                    spellcard->id == 96
                ) {
                    bullet_cancel_radius(&this->data.position, 128.0f, CancelType0);
                }
                bullet_cancel_radius_as_bomb(&this->data.position, 640.0f, CancelType0, 99999, 0);
                radius = 640.0f;
            } else {
                radius = (float)B * 512.0f / 30.f + 64.0f;
                laser_cancel_radius(&this->data.position, radius, 0, 1);
                radius *= 0.25f;
            }
            laser_cancel_radius(&this->data.position, radius, 0, 0);

            if (this->data.__death_timer < 60) {
                break;
            }

            this->data.__death_timer.reset();
        }
        case 1: // Normal
            BOMB_PTR->check_for_bomb();
            ABILITY_MANAGER_PTR->check_for_card_activation();
            ABILITY_MANAGER_PTR->check_for_card_switch();
            if (!ABILITY_SHOP_PTR) {
                this->__sub_45B170();
            }
            ABILITY_MANAGER_PTR->card_list.for_each([](CardBase* card) {
                card->on_tick();
            });
            break;
        case 4: // Dying?
            if (this->data.__death_timer >= this->data.num_deathbomb_frames) {
                BOOL prevent_death = FALSE;
                ABILITY_MANAGER_PTR->card_list.for_each([&](CardBase* card) {
                    prevent_death |= card->on_player_death(prevent_death);
                });
                if (prevent_death) {
                    break;
                }
                this->death();
            } else {
                if (BOMB_PTR->check_for_deathbomb()) {
                    this->cancel_impending_death();
                }
                break;
            }
        case 2: {
            int32_t current_death_timer = this->data.__death_timer;
            if (current_death_timer == 3) {
                GAME_MANAGER.globals.subtract_power(GAME_MANAGER.globals.power_per_level);
                
                Float3 position = { 0.0f, this->data.position.y - 224.0f, 0.0f };
                float base_angle = this->angle_from_point(&position);

                // Gotta love old code that does literally nothing
                int32_t item_ids[] = {
                    PowerItem, PowerItem, PowerItem, PowerItem, PowerItem, PowerItem, PowerItem
                };

                nounroll for (int32_t i = 0; i < 7; ++i) {
                    float angle = base_angle + (float)i * PI_f / 28.0f - EIGHTH_PI_f;
                    spawn_item(item_ids[i], &this->data.position, angle, 3.0f, 0);
                }

                int32_t current_money = GAME_MANAGER.globals.current_money;
                int32_t money_loss = current_money / 3;
                money_loss = __min(money_loss, 100);

                ABILITY_MANAGER_PTR->card_list.for_each([](CardBase* card) {
                    card->on_player_death_power_loss();
                });

                this->data.__update_option_power_levels();

                current_death_timer = this->data.__death_timer;
            }
            if (current_death_timer < 60) {
                break;
            }

            if (
                GAME_MANAGER.globals.life_stocks < 0 &&
                current_death_timer == 60
            ) {
                if (!is_replay()) {
                    //PAUSE_MENU_PTR->__sub_458A30();
                }
                this->data.__death_timer++;
            }
            else {
                this->data.state = 0;
                GAME_SPEED.value = 1.0f;
                this->create_damage_source_circle(&this->data.position, 32.0f, 16.0f, 30, 150);
                this->__float3_47928 = this->data.position;
                this->__set_position_and_all_option_D4_to_1(0.0f, SCREEN_HEIGHT + 38.0f);
                this->data.__timer_47154.set(280);
                this->data.__death_timer.reset();
            }
            break;
        }
        case 3: {
            int32_t A = this->data.__death_timer;
            if (A != 4 && A == 15) {
                //LASER_MANAGER_PTR->cancel_all(1);
            }
            break;
        }
    }

    for (size_t i = 0; i < PLAYER_DAMAGE_SOURCE_COUNT; ++i) {
        this->data.damage_sources[i].on_tick();
    }

    this->data.__timer_47168--;

    if (this->data.__timer_47154 > 0) {
        this->data.__timer_47154--;

        if (this->data.__death_timer.__is_multiple_of_not_paused(3)) {
            this->__vm_14.data.color2 = PackD3DCOLOR(255, 0, 0, 255);
            this->__vm_14.data.color_mode = 1;
        } else {
            this->__vm_14.data.color_mode = 0;
        }
    }
    else {
        this->__vm_14.data.color_mode = 0;

        if (this->data.__unknown_flag_E) {
            if (this->data.__death_timer % 8 < 4) {
                this->__vm_14.data.color2 = PackD3DCOLOR(255, 255, 0, 0);
                this->__vm_14.data.color_mode = 1;
            }
        }
        else {
            if (
                this->data.__speed_modifier > 1.01f &&
                this->data.__death_timer % 8 < 4
            ) {
                this->__vm_14.set_alpha2(0);
                this->__vm_14.data.color_mode = 1;
            }
        }
    }

    this->data.__speed_modifier = 1.0f;
    this->data.__base_axis_speed = UNKNOWN_FLOAT3_A;

    this->__vm_14.run_anm();

    if (this->data.scale_enabled) {
        float scale = this->scale;
        if (this->scale_interp.end_time) {
            scale = this->scale_interp.step();
            this->scale = scale;
            if (
                !this->scale_interp.end_time ||
                !this->data.__death_timer.is_multiple_of(3)
            ) {
                scale = 1.0f;
            }
        }
        this->__vm_14.set_scale(scale);
    }
    else {
        this->__vm_14.set_scale(1.0f);
    }

    this->data.__death_timer++;
    this->data.__timer_28++;
    this->data.__timer_3C++;

    this->data.__unknown_flag_D = false;

    if (
        !GUI_PTR->msg_vm &&
        enemies_are_alive() &&
        !GAME_THREAD_PTR->__unknown_flag_C &&
        this->data.__timer_3C >= 20 &&
        !this->data.__unknown_flag_H &&
        this->data.__unknown_field_A &&
        !this->data.scale_enabled
    ) {
        this->tick_shooting_state();
    }
    else {
        this->data.shoot_key_short_timer.set(-1);
        this->data.shoot_key_long_timer.set(-1);
        SOUND_MANAGER.stop_sound(30);
        SOUND_MANAGER.stop_sound(55);
    }

    this->tick_bullets();

    return UpdateFuncNext;
}

// 0x45D090
dllexport gnu_noinline void thiscall Player::death() {
    EFFECT_MANAGER_PTR->instantiate_effect_vm_to_world_list_back(28, &this->data.position);

    // probably an inlined subtract_life function here
    int32_t life_count = --GAME_MANAGER.globals.life_stocks;
    if (life_count >= 0) {
        GUI_PTR->__update_life_ui(life_count, GAME_MANAGER.globals.life_fragments, GAME_MANAGER.globals.life_stock_max);
        life_count = GAME_MANAGER.globals.life_stocks;
    }
    if (life_count >= 0) {
        GAME_MANAGER.globals.set_bombs(GAME_MANAGER.globals.bomb_stocks_for_new_life);
        __update_bomb_ui();
    }

    this->data.__death_timer.reset();
    this->data.__timer_47154.set(180);

    this->player_anm->__copy_data_to_vm_and_run(&this->__vm_14, 0);

    nounroll for (size_t i = 0; i < PLAYER_OPTION_COUNT; ++i) {
        PlayerOption* option = &this->data.options[i];
        option->__int_0 = 0;
        option->__anm_id_B0.interrupt_tree(1);
        option->__anm_id_B4.interrupt_tree(1);
    }

    this->data.__option_count = 0;

    nounroll for (size_t i = 0; i < PLAYER_EQUIPMENT_OPTION_COUNT; ++i) {
        PlayerOption* option = &this->data.equipment[i];
        option->__int_0 = 0;
        option->__anm_id_B0.interrupt_tree(1);
        option->__anm_id_B4.interrupt_tree(1);
    }

    Spellcard* spellcard = SPELLCARD_PTR;
    if (spellcard->__unknown_flag_A) {
        if (spellcard->__timer_20 >= 60) {
            spellcard->__unknown_flag_B = false;
            spellcard->__unknown_flag_E = false;
        }
        else if (BOMB_PTR->is_active()) {
            spellcard->__unknown_flag_E = true;
        }
    }

    UNKNOWN_COUNTER_A = 0;

    EnemyManager* enemy_manager = ENEMY_MANAGER_PTR;
    ++enemy_manager->player_death_count;
    enemy_manager->can_capture_spell = FALSE;

    GAME_MANAGER.globals.add_death();
}

// 0x45D3A0
dllexport gnu_noinline void thiscall Player::start_dying() {
    if (!this->data.__unknown_flag_B) {
        SOUND_MANAGER.play_sound(2);
    }
    
    EFFECT_MANAGER_PTR->effect_anm->instantiate_vm_to_world_list_back(29, &this->data.position);

    SPELLCARD_PTR->__inline_sub_409AD0();

    this->data.__death_timer.reset();
    this->data.state = 4;
    this->data.__timer_47154.set(6);

    this->player_anm->__copy_data_to_vm_and_run(&this->__vm_14, 0);

    ABILITY_MANAGER_PTR->card_list.for_each([](CardBase* card) {
        card->on_player_start_dying();
    });
}

// size: 0x8
struct ItemSpriteData {
    int32_t __id_0; // 0x0
    int32_t __id_4; // 0x4
    // 0x8
};

// size: 0xC94
struct Item {
    ZUNList<Item> __list_node_0; // 0x0
    AnmVM __vm_10; // 0x10
    AnmVM __vm_61C; // 0x61C
    AnmID __vm_id_C28; // 0xC28
    Float3 position; // 0xC2C
    Float3 velocity; // 0xC38
    float speed; // 0xC44
    ZUNAngle angle; // 0xC48
    Timer __timer_C4C; // 0xC4C
    unknown_fields(0x14); // 0xC60
    uint32_t state; // 0xC74
    ItemID id; // 0xC78
    int __dword_C7C; // 0xC7C
    float __float_C80; // 0xC80
    int32_t __int_C84; // 0xC84
    unknown_fields(0x4); // 0xC88
    int __dword_C8C; // 0xC8C
    int32_t sound_id; // 0xC90
    // 0xC94

    // 0x4456B0
    dllexport Item() = default;

    // 0x445800
    dllexport ~Item() = default;

    // 0x4472B0
    dllexport gnu_noinline int thiscall __sub_4472B0() asm_symbol_rel(0x4472B0) {
        switch (this->id) {
            case LifeFragmentItem: // 4
            case BombFragmentItem: // 6
            case Item15: // 15
            case LifeItem: // 5
            case BombItem: // 7
            case Item16: // 16
            case Item17: // 17
            case Item19: // 19
            case Item18: // 18

            case PointItem: // 2
                break;
        }
        return 0;
    }
};
#pragma region // Item Validation
ValidateFieldOffset32(0x0, Item, __list_node_0);
ValidateFieldOffset32(0x10, Item, __vm_10);
ValidateFieldOffset32(0x61C, Item, __vm_61C);
ValidateFieldOffset32(0xC28, Item, __vm_id_C28);
ValidateFieldOffset32(0xC2C, Item, position);
ValidateFieldOffset32(0xC38, Item, velocity);
ValidateFieldOffset32(0xC44, Item, speed);
ValidateFieldOffset32(0xC48, Item, angle);
ValidateFieldOffset32(0xC4C, Item, __timer_C4C);
ValidateFieldOffset32(0xC74, Item, state);
ValidateFieldOffset32(0xC78, Item, id);
ValidateFieldOffset32(0xC7C, Item, __dword_C7C);
ValidateFieldOffset32(0xC80, Item, __float_C80);
ValidateFieldOffset32(0xC84, Item, __int_C84);
ValidateFieldOffset32(0xC8C, Item, __dword_C8C);
ValidateFieldOffset32(0xC90, Item, sound_id);
ValidateStructSize32(0xC94, Item);
#pragma endregion

typedef struct ItemManager ItemManager;
extern "C" {
    // 0x4CF2EC
    externcg ItemManager* ITEM_MANAGER_PTR cgasm("_ITEM_MANAGER_PTR");
}

static inline constexpr size_t MAX_ITEM_COUNT = 600;
static inline constexpr size_t MAX_CANCEL_ITEM_COUNT = 0x1000;

static inline constexpr size_t TOTAL_ITEM_COUNT = MAX_ITEM_COUNT + MAX_CANCEL_ITEM_COUNT;

// size: 0xE6BB28
struct ItemManager : ZUNTask {
    //ZUNTask base; // 0x0
    unknown_fields(0x4); // 0xC
    UpdateFunc* on_draw_func_B; // 0x10
    Item items[MAX_ITEM_COUNT]; // 0x14
    Item cancel_items[MAX_CANCEL_ITEM_COUNT]; // 0x1D7AF4
    ZUNListHead<Item> items_freelist; // 0xE6BAF4
    ZUNListHead<Item> cancel_items_freelist; // 0xE6BB04
    float slowdown_factor; // 0xE6BB14
    int32_t items_onscreen; // 0xE6BB18
    int32_t item_count; // 0xE6BB1C
    unknown_fields(0x8); // 0xE6BB20
    // 0xE6BB28

    inline void zero_contents() {
        zero_this();
    }

    inline ItemManager() {
        this->zero_contents();
        this->__unknown_task_flag_A = true;
    }

    // 0x445920
    dllexport gnu_noinline ~ItemManager() {
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func_B);
        ITEM_MANAGER_PTR = NULL;
    }

    // 0x42AA30
    dllexport gnu_noinline void thiscall destroy_all() {
        memset(&this->items, 0, sizeof(Item[MAX_ITEM_COUNT + MAX_CANCEL_ITEM_COUNT]));

        this->items_freelist.initialize_with(NULL);

        for (size_t i = 0; i < MAX_ITEM_COUNT; ++i) {
            Item* item = &this->items[i];
            item->__list_node_0.initialize_with(item);
            this->items_freelist.append(&item->__list_node_0);
        }

        this->cancel_items_freelist.initialize_with(NULL);

        for (size_t i = 0; i < MAX_CANCEL_ITEM_COUNT; ++i) {
            Item* item = &this->cancel_items[i];
            item->__list_node_0.initialize_with(item);
            this->cancel_items_freelist.append(&item->__list_node_0);
        }

        this->slowdown_factor = 1.0f;
    }

private:
    // 0x446F40
    dllexport gnu_noinline Item* thiscall spawn_item(int32_t item_id, Float3* position, float, float angle, float speed, int32_t arg6, int, int) asm_symbol_rel(0x446F40) {
        if (item_id > 20) {
            return NULL;
        }
        ++this->item_count;
        switch (item_id) {
            default: // normal items

            case Piv5Item: // 9
            case Piv10Item: // 10
            case Piv20Item: // 11
            case Piv30Item: // 12
            case Piv40Item: // 13
            case Piv50Item: // 14

        }
        use_var(item_id);
        use_var(position);
        use_var(angle);
        use_var(speed);
        return (Item*)(position + (intptr_t)(item_id + angle + speed));
    }
public:
    inline Item* spawn_item(int32_t item_id, Float3* position, float angle, float speed, int32_t arg6) {
        return this->spawn_item(item_id, position, UNUSED_FLOAT, angle, speed, arg6, UNUSED_DWORD, UNUSED_DWORD);
    }

    // 0x445A80
    dllexport gnu_noinline UpdateFuncRet thiscall on_tick() asm_symbol_rel(0x445A80) {
        // TODO
        return UpdateFuncNext;
    }

    // 0x446D60
    dllexport gnu_noinline UpdateFuncRet thiscall on_draw(BOOL arg1) asm_symbol_rel(0x446D60) {
        Item* item = this->items;
        for (size_t i = 0; i < TOTAL_ITEM_COUNT; ++i, ++item) {
            if (
                item->state != 0 &&
                (item->__vm_10.controller.fast_id & 1) && // this has to be wrong...
                item->__int_C84 <= 0 &&
                arg1
            ) {

            }
        }
        return UpdateFuncNext;
    }

    // 0x446EC0
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_tick(void* ptr) asm_symbol_rel(0x446EC0) {
        GameThread* game_thread = GAME_THREAD_PTR;
        if (
            (game_thread && ((game_thread->__unknown_flag_A | game_thread->skip_flag) || game_thread->__unknown_flag_C)) ||
            ABILITY_SHOP_PTR
        ) {
            return UpdateFuncNext;
        }
        return ((ItemManager*)ptr)->on_tick();
    }

    // 0x446F00
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw_A(void* ptr) asm_symbol_rel(0x446F00) {
        GameThread* game_thread = GAME_THREAD_PTR;
        if (
            (game_thread && game_thread->skip_flag)
        ) {
            return UpdateFuncNext;
        }
        return ((ItemManager*)ptr)->on_draw(true);
    }

    // 0x446F20
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw_B(void* ptr) asm_symbol_rel(0x446F20) {
        GameThread* game_thread = GAME_THREAD_PTR;
        if (
            (game_thread && game_thread->skip_flag)
        ) {
            return UpdateFuncNext;
        }
        return ((ItemManager*)ptr)->on_draw(false);
    }

    inline ZUNResult initialize() {
        UpdateFunc* update_func = new UpdateFunc(&on_tick, false, this);
        UpdateFuncRegistry::register_on_tick(update_func, 30);
        this->on_tick_func = update_func;
        update_func = new UpdateFunc(&on_draw_A, false, this);
        UpdateFuncRegistry::register_on_draw(update_func, 33);
        this->on_draw_func = update_func;
        update_func = new UpdateFunc(&on_draw_B, false, this);
        UpdateFuncRegistry::register_on_draw(update_func, 19);
        this->on_draw_func_B = update_func;

        this->destroy_all();

        return ZUN_SUCCESS;
    }

    // 0x445820
    dllexport gnu_noinline static ItemManager* allocate() asm_symbol_rel(0x445820) {
        ItemManager* item_manager = new ItemManager();
        ITEM_MANAGER_PTR = item_manager;
        if (ZUN_FAILED(item_manager->initialize())) {
            delete item_manager;
            return NULL;
        }
        return item_manager;
    }
};
#pragma region // ItemManager Validation
ValidateFieldOffset32(0x0, ItemManager, task_flags);
ValidateFieldOffset32(0x4, ItemManager, on_tick_func);
ValidateFieldOffset32(0x8, ItemManager, on_draw_func);
ValidateFieldOffset32(0x10, ItemManager, on_draw_func_B);
ValidateFieldOffset32(0x14, ItemManager, items);
ValidateFieldOffset32(0x1D7AF4, ItemManager, cancel_items);
ValidateFieldOffset32(0xE6BAF4, ItemManager, items_freelist);
ValidateFieldOffset32(0xE6BB04, ItemManager, cancel_items_freelist);
ValidateFieldOffset32(0xE6BB14, ItemManager, slowdown_factor);
ValidateFieldOffset32(0xE6BB18, ItemManager, items_onscreen);
ValidateFieldOffset32(0xE6BB1C, ItemManager, item_count);
ValidateStructSize32(0xE6BB28, ItemManager);
#pragma endregion

static inline Item* spawn_item(int32_t item_id, Float3* position, float angle, float speed, int32_t arg6) {
    return ITEM_MANAGER_PTR->spawn_item(item_id, position, angle, speed, arg6);
}

// size: 0x10
struct BulletSpriteColorData {
    int32_t sprite_id; // 0x0
    int32_t spawn_effect_id; // 0x4
    int32_t cancel_effect_id; // 0x8
    int32_t cancel_script; // 0xC
    // 0x10
};
// size: 0x118
struct BulletSpriteData {
    int32_t anm_script; // 0x0
    BulletSpriteColorData color_data[16]; // 0x4
    float hitbox_size; // 0x104
    int32_t layer; // 0x108
    int __int_10C; // 0x10C
    int __int_110; // 0x110
    int32_t __anm_script_114; // 0x114
    // 0x118
};

extern "C" {
    // 0x4C5F90
    externcg BulletSpriteData BULLET_SPRITE_DATA[48] cgasm("_BULLET_SPRITE_DATA");
    // 0x4B36F0
    externcg int32_t BULLET_IDK_DATA[8] cgasm("_BULLET_IDK_DATA");
}


typedef struct BulletManager BulletManager;
typedef struct LaserManager LaserManager;
extern "C" {
    // 0x4CF2BC
    externcg BulletManager* BULLET_MANAGER_PTR cgasm("_BULLET_MANAGER_PTR");
    // 0x4CF3F4
    externcg LaserManager* LASER_MANAGER_PTR cgasm("_LASER_MANAGER_PTR");
}

enum BulletEffectType : uint32_t {
    EX_NONE         = 0x00000000, // 0      0
    EX_DIST         = 0x00000001, // 1      1
    EX_ANIM         = 0x00000002, // 2      2
    EX_ACCEL        = 0x00000004, // 3      4
    EX_ANGLE_ACCEL  = 0x00000008, // 4      8
    EX_ANGLE        = 0x00000010, // 5      16
    // EX_NOP_A     = 0x00000020, // 6      32
    EX_BOUNCE       = 0x00000040, // 7      64
    EX_INVULN       = 0x00000080, // 8      128
    EX_OFFSCREEN    = 0x00000100, // 9      256
    EX_SETSPRITE    = 0x00000200, // 10     512
    EX_DELETE       = 0x00000400, // 11     1024
    EX_PLAYSOUND    = 0x00000800, // 12     2048
    EX_WRAP         = 0x00001000, // 13     4096
    EX_SHOOT        = 0x00002000, // 14     8192
    // EX_NOP_B     = 0x00004000, // 15     16384
    EX_REACT        = 0x00008000, // 16     32768
    EX_LOOP         = 0x00010000, // 17     65536
    EX_MOVE         = 0x00020000, // 18     131072
    EX_VEL          = 0x00040000, // 19     262144
    EX_VELADD       = 0x00080000, // 20     524288
    EX_BRIGHT       = 0x00100000, // 21     1048576
    EX_VELTIME      = 0x00200000, // 22     2097152
    EX_SIZE         = 0x00400000, // 23     4194304
    EX_SAVEANGLE    = 0x00800000, // 24     8388608
    EX_ENEMY        = 0x01000000, // 25     16777216
    EX_LAYER        = 0x02000000, // 26     33554432
    EX_DELAY        = 0x04000000, // 27     67108864
    EX_LASER        = 0x08000000, // 28     134217728
    // EX_NOP_C     = 0x10000000, // 29     268435456
    EX_HITBOX       = 0x20000000, // 30     536870912
    EX_HOMING       = 0x40000000, // 31     1073741824
    EX_WAIT         = 0x80000000, // 32     -2147483648
};

// size: 0x48
struct BulletEffectData {
    Timer timer; // 0x0
    union { // 0x14
        float speed;
        float acceleration;
    };
    union { // 0x18
        float angle;
        float angular_velocity;
    };
    union { // 0x1C
        Float3 position;
        Float3 size;
    };
    union { // 0x28
        Float3 velocity;
        Float3 acceleration_vec;
        Float3 target;
    };
    union { // 0x34
        int32_t duration;
        int32_t __offscreen_unknown;
        int32_t wrap_count;
    };
    union { // 0x38
        int32_t max_count;
        int32_t mode;
    };
    union { // 0x3C
        int32_t count;
        int32_t flags;
    };
    int32_t type; // 0x40
    int32_t __int_44; // 0x44
    // 0x48

    inline BulletEffectData() {}
};

enum BulletState {
    BulletState0,
    BulletState1,
    BulletState2,
    BulletState3,
    CanceledBullet = 4
};

// size: 0xFA0
struct Bullet {
    ZUNList<Bullet> free_list_node; // 0x0
    ZUNList<Bullet> tick_list_node; // 0x10
    union {
        uint32_t flags; // 0x20
        struct {
            uint32_t __unknown_flag_E : 1; // 1
            uint32_t __unknown_flag_F : 1; // 2
            uint32_t grazed : 1; // 3
            uint32_t __unknown_flag_D : 1; // 4
            uint32_t __circular_hitbox : 1; // 5
            uint32_t : 1; // 6
            uint32_t __scale_enabled : 1; // 7
            uint32_t : 1; // 8
            uint32_t __unknown_flag_C : 1; // 9
            uint32_t __delay_flag : 1; // 10
        };
    };
    int32_t invulnerable_time; // 0x24
    AnmVM vm; // 0x28
    AnmID __anm_tree_id; // 0x634
    Float3 position; // 0x638
    Float3 velocity; // 0x644
    float speed; // 0x650
    ZUNAngle angle; // 0x654
    union {
        float hitbox_radius; // 0x658
        Float2 hitbox_size; // 0x658
    };
    int32_t bullet_manager_index; // 0x660
    int32_t __ex_func_a; // 0x664
    unknown_fields(0x8); // 0x668
    int32_t offscreen_time; // 0x670
    int32_t cancel_script_id; // 0x674
    int __int_678; // 0x678
    int32_t effect_index; // 0x67C
    int32_t effect_loop_index; // 0x680
    uint32_t active_effects; // 0x684
    uint32_t initial_effects; // 0x688
    Bullet* next_in_layer; // 0x68C
    int __dword_690; // 0x690
    int32_t transform_sound; // 0x694
    int32_t layer; // 0x698
    BulletEffectArgs effects[BULLET_EFFECT_MAX]; // 0x69C
    BulletEffectData effect_speedup; // 0xABC
    BulletEffectData effect_accel; // 0xB04
    BulletEffectData effect_angle_accel; // 0xB4C
    BulletEffectData effect_angle; // 0xB94
    BulletEffectData effect_bounce; // 0xBDC
    BulletEffectData effect_wait; // 0xC24
    BulletEffectData effect_wrap; // 0xC6C
    BulletEffectData effect_homing; // 0xCB4
    BulletEffectData effect_move; // 0xCFC
    BulletEffectData effect_veladd; // 0xD44
    BulletEffectData effect_veltime; // 0xD8C
    BulletEffectData effect_offscreen; // 0xDD4
    BulletEffectData effect_saveangle; // 0xE1C
    BulletEffectData effect_delay; // 0xE64
    unknown_fields(0x4); // 0xEAC
    ZUNInterp<Float3> effect_move_interp; // 0xEB0
    ZUNInterp<float> scale_interp; // 0xF08
    float scale; // 0xF38
    Timer __timer_F3C; // 0xF3C
    Timer __timer_F50; // 0xF50
    int __int_F64; // 0xF64
    uint16_t state; // 0xF68
    probably_padding_bytes(0x2); // 0xF6A
    Timer __timer_F6C; // 0xF6C
    Timer __timer_F80; // 0xF80
    BulletSpriteData* sprite_data; // 0xF94
    int16_t sprite; // 0xF98
    int16_t color; // 0xF9A
    unknown_fields(0x4); // 0xF9C
    // 0xFA0

    // 0x423880
    dllexport Bullet() = default;

    // 0x423970
    dllexport ~Bullet() = default;

    inline bool effects_active(uint32_t mask) {
        return this->active_effects & mask;
    }

    inline void enable_effects(uint32_t mask) {
        this->active_effects |= mask;
    }

    inline void toggle_effects(uint32_t mask) {
        this->active_effects ^= mask;
    }

    inline void disable_effects(uint32_t mask) {
        this->active_effects &= ~mask;
    }

    // 0x424AD0
    dllexport gnu_noinline void cleanup() asm_symbol_rel(0x424AD0);

    // 0x428E90
    dllexport gnu_noinline int32_t thiscall cancel(CancelType cancel_type) asm_symbol_rel(0x428E90);

    inline AnmSprite* get_sprite() {
        return &ANM_MANAGER_PTR->loaded_anm_files[this->vm.data.slot2]->sprites[this->vm.data.sprite_id];
    }

    inline bool is_offscreen() {
        float scale = this->scale;
        
        float X = this->position.x;

        float sprite_width = this->get_sprite()->__size_x * scale;
        float half_width = sprite_width * 0.5f;

        if (
            (X + half_width <= SCREEN_LEFT_EDGE) ||
            (X - half_width >= SCREEN_RIGHT_EDGE)
        ) {
            return true;
        }

        float Y = this->position.y;

        float sprite_height = this->get_sprite()->__size_y * scale;
        float half_height = sprite_height * 0.5f;

        if (
            (Y + half_height <= -64.0f) || // bit of extra tolerance off the bottom I guess
            (Y - half_height >= SCREEN_TOP_EDGE)
        ) {
            return true;
        }

        return false;
    }

    // 0x4248A0
    dllexport gnu_noinline CollisionResult thiscall __check_collision(CollisionTestType test_type) asm_symbol_rel(0x4248A0);

    // 0x425C60
    dllexport void run_effects() asm_symbol_rel(0x425C60);

    inline int thiscall run_effect_speedup() {
        if (this->effect_speedup.timer <= 16) {

            float A = 5.0f - (float)this->effect_speedup.timer * 5.0f * (1.0f / 16.0f);

            this->velocity.make_from_vector(this->angle, this->speed + A);

            this->effect_speedup.timer++;
            return 0;
        }
        else {
            this->disable_effects(EX_DIST);
            return 1;
        }
    }

    // 0x427930
    dllexport gnu_noinline int thiscall run_effect_accel() asm_symbol_rel(0x427930) {
        if (this->effect_accel.timer >= this->effect_accel.duration) {
            this->disable_effects(EX_ACCEL);
            return 1;
        }

        this->speed += this->effect_accel.acceleration * GAME_SPEED;
        this->velocity += this->effect_accel.acceleration_vec * GAME_SPEED;

        if (
            zfabsf(this->velocity.x) > 0.0001f ||
            zfabsf(this->velocity.y) > 0.0001f
        ) {
            this->angle = this->velocity.as2().direction();
        }
        this->speed = this->velocity.as2().length();

        this->effect_accel.timer++;
        return 0;
    }

    // are these literally the same or am I blind

    // 0x427B60
    dllexport gnu_noinline int thiscall run_effect_veltime() asm_symbol_rel(0x427B60) {
        if (this->effect_veltime.timer >= this->effect_veltime.duration) {
            this->disable_effects(EX_VELTIME);
            return 1;
        }

        this->speed += this->effect_veltime.acceleration * GAME_SPEED;
        this->velocity += this->effect_veltime.acceleration_vec * GAME_SPEED;

        if (
            zfabsf(this->velocity.x) > 0.0001f ||
            zfabsf(this->velocity.y) > 0.0001f
        ) {
            this->angle = this->velocity.as2().direction();
        }
        this->speed = this->velocity.as2().length();

        this->effect_veltime.timer++;
        return 0;
    }

    inline int thiscall run_effect_angle_accel() {
        if (this->effect_angle_accel.timer >= this->effect_angle_accel.duration) {
            this->disable_effects(EX_ANGLE_ACCEL);
            return 1;
        }
        
        this->angle += this->effect_angle_accel.angular_velocity * GAME_SPEED;
        this->speed += this->effect_angle_accel.acceleration * GAME_SPEED;

        this->velocity.make_from_vector(this->angle, this->speed);

        this->effect_angle_accel.timer++;
        return 0;
    }

    // 0x427D50
    dllexport gnu_noinline int thiscall run_effect_angle() asm_symbol_rel(0x427D50) {
        float speed;
        
        int32_t end_time = this->effect_angle.duration;
        if (this->effect_angle.timer >= end_time) {
            SOUND_MANAGER.play_sound_validate(this->transform_sound);

            ++this->effect_angle.count;

            switch (this->effect_angle.type) {
                case 0: case 5:
                    this->angle += this->effect_angle.angle;
                    break;
                case 1: case 6:
                    this->angle += this->effect_angle.angle + angle_to_player_from_point(&this->position);
                    break;
                case 2: case 3: case 4:
                    this->angle = this->effect_angle.angle;
                    break;
            }
            speed = this->effect_angle.speed;
            this->speed = speed;

            this->effect_angle.timer.reset();

            if (this->effect_angle.count >= this->effect_angle.max_count) {
                this->velocity.make_from_vector(this->angle, speed);
                this->disable_effects(EX_ANGLE);
                return 1;
            }
        }
        else {
            speed = this->speed - ((float)this->effect_angle.timer * this->speed / (float)end_time);
        }
        this->velocity.make_from_vector(this->angle, speed);

        this->effect_angle.timer++;
        return 0;
    }

    // 0x427F40
    dllexport gnu_noinline int thiscall run_effect_bounce() asm_symbol_rel(0x427F40) {
        // uuuuuuugh

        return 0;
    }

    // 0x428460
    dllexport gnu_noinline int thiscall run_effect_homing() asm_symbol_rel(0x428460) {
        if (this->effect_homing.timer >= this->effect_homing.duration) {
            this->disable_effects(EX_HOMING);
            return 1;
        }

        Float2 A = PLAYER_PTR->data.position.as2() - this->position.as2();

        float angle;
        if (A.y == 0.0f && A.x == 0.0f) {
            angle = HALF_PI_f;
        } else {
            angle = A.direction();
        }

        A.make_from_vector(reduce_angle(angle + this->effect_homing.angle), this->effect_homing.speed);

        this->velocity += (A - this->velocity) * this->effect_homing.target.x;

        this->speed = this->velocity.as2().length();

        this->angle = this->velocity.as2().direction();

        this->effect_homing.timer++;
        return 0;
    }

    // 0x428710
    dllexport gnu_noinline int thiscall run_effect_move() asm_symbol_rel(0x428710) {
        int32_t effect_time = this->effect_move.timer;
        if (effect_time >= this->effect_move.duration) {
            this->disable_effects(EX_MOVE);

            this->position = this->effect_move.position;
            float speed = this->effect_move.speed;
            this->speed = speed;
            this->velocity.make_from_vector3(this->angle, speed);
            return 1;
        }

        if (!effect_time) {
            this->effect_move_interp.initial_value = this->position;
        }
        this->velocity = this->effect_move_interp.step() - this->position;
        if (
            zfabsf(this->velocity.x) > 0.0001f ||
            zfabsf(this->velocity.y) > 0.0001f
        ) {
            this->angle = this->velocity.as2().direction();
        }
        this->velocity.z = 0.0f;

        this->effect_move.timer++;
        return 0;
    }

    inline int thiscall run_effect_veladd() {
        if (this->effect_veladd.timer >= this->effect_veladd.duration) {
            this->disable_effects(EX_VELADD);
            return 1;
        }

        this->position += this->effect_veladd.velocity;

        this->effect_veladd.timer.reset(); // is this bugged?
        return 0;
    }

    // 0x428970
    dllexport gnu_noinline int thiscall run_effect_offscreen() asm_symbol_rel(0x428970) {
        this->effect_offscreen.timer--;

        if (this->effect_offscreen.__offscreen_unknown) {
            // TODO: nastiness
        }
        if (this->effect_offscreen.timer <= 0) {
            this->toggle_effects(EX_OFFSCREEN);
            return 1;
        }
        return 0;
    }

    inline int thiscall run_effect_wait() {
        if (this->effect_wait.timer <= 0) {
            this->disable_effects(EX_WAIT);
            return 1;
        }

        this->effect_wait.timer--;
        return 0;
    }

    inline int thiscall run_effect_delay() {
        if (this->effect_delay.timer <= 0) {
            this->disable_effects(EX_DELAY);
            this->__delay_flag = false;
            return 1;
        }

        this->__delay_flag = true;
        this->effect_delay.timer--;
        return 0;
    }

    inline void thiscall run_effect_wrap(float sprite_width, float sprite_height) {
        float X = this->position.x;
        float half_width = sprite_width * 0.5f;
        if (
            !(X + half_width <= SCREEN_LEFT_EDGE) &&
            !(X - half_width >= SCREEN_RIGHT_EDGE)
        ) {
            float Y = this->position.y;
            float half_height = sprite_height * 0.5f;
            if (
                !(Y + half_height <= SCREEN_BOTTOM_EDGE) &&
                !(Y - half_height >= SCREEN_TOP_EDGE)
            ) {
                return;
            }
        }

        if (
            (this->effect_wrap.flags & 0b0001) &&
            this->position.y < SCREEN_BOTTOM_EDGE
        ) {
            this->position.y += sprite_height + SCREEN_HEIGHT;
        }
        else if (
            (this->effect_wrap.flags & 0b0010) &&
            this->position.y > SCREEN_TOP_EDGE
        ) {
            this->position.y -= sprite_height + SCREEN_HEIGHT;
        }
        else if (
            (this->effect_wrap.flags & 0b0100) &&
            X < SCREEN_LEFT_EDGE
        ) {
            X += sprite_width + SCREEN_WIDTH;
            this->position.x = X;
        }
        else if (
            (this->effect_wrap.flags & 0b1000) &&
            X > SCREEN_RIGHT_EDGE
        ) {
            X -= sprite_width + SCREEN_WIDTH;
            this->position.x = X;
        }
        else {
            return;
        }

        ++this->effect_wrap.wrap_count;

        SOUND_MANAGER.play_sound_validate(this->transform_sound);

        if (this->effect_wrap.wrap_count >= this->effect_wrap.max_count) {
            this->disable_effects(EX_WRAP);
        }
    }

    // 0x423E10
    dllexport gnu_noinline ZUNResult thiscall on_tick() asm_symbol_rel(0x423E10) {
        this->__timer_F80++;

        if (!this->__unknown_flag_D) {

            if (this->effects_active(EX_SIZE)) {
                float scale = this->scale_interp.step();
                this->scale = scale;
                if (!this->scale_interp.end_time) {
                    this->disable_effects(EX_SIZE);
                    if (scale == 1.0f) {
                        this->__scale_enabled = false;
                    }
                }
            }

            switch (this->state) {
                case 3:
                    this->position += (this->velocity * GAME_SPEED) * 0.5f;
                    break;
                case 2:
                    this->position += (this->velocity * GAME_SPEED) * 0.5f;
                    if (this->__timer_F6C >= 8) {
                        if (
                            this->__check_collision(LethalCollisionTest) == DeathCollision
                        ) {
                            break;
                        }
                    }
                    // wtf is this ZUN
                    if (this->vm.data.current_context.int_vars[0]) {
                        this->state = 1;
                case 1:
                    rerun_effects:
                        if (!this->effects_active(EX_DELAY)) {
                            this->run_effects();
                        }

                        if (this->active_effects) {
                            int32_t disabled_effects = 0;

                            if (this->effects_active(EX_DIST)) {
                                disabled_effects += this->run_effect_speedup();
                            }
                            if (this->effects_active(EX_ACCEL)) {
                                disabled_effects += this->run_effect_accel();
                            }
                            if (this->effects_active(EX_VELTIME)) {
                                disabled_effects += this->run_effect_veltime();
                            }
                            if (this->effects_active(EX_ANGLE_ACCEL)) {
                                disabled_effects += this->run_effect_angle_accel();
                            }
                            if (this->effects_active(EX_ANGLE)) {
                                disabled_effects += this->run_effect_angle();
                            }
                            if (this->effects_active(EX_BOUNCE)) {
                                disabled_effects += this->run_effect_bounce();
                            }
                            if (this->effects_active(EX_HOMING)) {
                                disabled_effects += this->run_effect_homing();
                            }
                            if (this->effects_active(EX_MOVE)) {
                                disabled_effects += this->run_effect_move();
                            }
                            if (this->effects_active(EX_VELADD)) {
                                disabled_effects += this->run_effect_veladd();
                            }
                            if (this->effects_active(EX_OFFSCREEN)) {
                                disabled_effects += this->run_effect_offscreen();
                            }
                            if (this->effects_active(EX_WAIT)) {
                                disabled_effects += this->run_effect_wait();
                            }
                            if (this->effects_active(EX_DELAY)) {
                                disabled_effects += this->run_effect_delay();
                            }
                            if (disabled_effects) {
                                goto rerun_effects;
                            }
                        }

                        if (!this->__delay_flag) {
                            this->position += this->velocity * GAME_SPEED;
                            this->__check_collision(LethalCollisionTest);
                        }
                    }
                    break;
            }

            // this condition can't fail because of how the sprite
            // is actually obtained from the anm manager.
            if (AnmSprite* sprite = this->get_sprite()) {
                if (this->effects_active(EX_WRAP)) {
                    this->run_effect_wrap(sprite->__size_x, sprite->__size_y);
                }
                if (
                    !this->effects_active(EX_OFFSCREEN) &&
                    this->offscreen_time < 1
                ) {
                    if (this->is_offscreen()) {
                        goto cleanup_bullet;
                    }
                }
            }

            if (this->invulnerable_time) {
                this->invulnerable_time--;
            }
            if (this->offscreen_time > 0) {
                this->offscreen_time--;
            }
            if (!this->__delay_flag) {
                if (ZUN_FAILED(this->vm.run_anm())) {
                    goto cleanup_bullet;
                }
            }
            return ZUN_SUCCESS;
        }
    cleanup_bullet:
        this->cleanup();
        return ZUN_ERROR;
    }

    inline void on_draw() {
        this->vm.controller.position = this->position;
        if (this->vm.data.auto_rotate) {
            this->vm.set_z_rotation(reduce_angle_add(this->angle, HALF_PI_f));
        }
        if (this->__scale_enabled) {
            this->vm.set_scale2(this->scale);
        }
        ANM_MANAGER_PTR->draw_vm(&this->vm);
    }
};
#pragma region // Bullet Validation
ValidateFieldOffset32(0x0, Bullet, free_list_node);
ValidateFieldOffset32(0x10, Bullet, tick_list_node);
ValidateFieldOffset32(0x20, Bullet, flags);
ValidateFieldOffset32(0x24, Bullet, invulnerable_time);
ValidateFieldOffset32(0x28, Bullet, vm);
ValidateFieldOffset32(0x634, Bullet, __anm_tree_id);
ValidateFieldOffset32(0x638, Bullet, position);
ValidateFieldOffset32(0x644, Bullet, velocity);
ValidateFieldOffset32(0x650, Bullet, speed);
ValidateFieldOffset32(0x654, Bullet, angle);
ValidateFieldOffset32(0x658, Bullet, hitbox_size);
ValidateFieldOffset32(0x660, Bullet, bullet_manager_index);
ValidateFieldOffset32(0x664, Bullet, __ex_func_a);
ValidateFieldOffset32(0x670, Bullet, offscreen_time);
ValidateFieldOffset32(0x674, Bullet, cancel_script_id);
ValidateFieldOffset32(0x678, Bullet, __int_678);
ValidateFieldOffset32(0x67C, Bullet, effect_index);
ValidateFieldOffset32(0x680, Bullet, effect_loop_index);
ValidateFieldOffset32(0x684, Bullet, active_effects);
ValidateFieldOffset32(0x688, Bullet, initial_effects);
ValidateFieldOffset32(0x68C, Bullet, next_in_layer);
ValidateFieldOffset32(0x690, Bullet, __dword_690);
ValidateFieldOffset32(0x694, Bullet, transform_sound);
ValidateFieldOffset32(0x698, Bullet, layer);
ValidateFieldOffset32(0x69C, Bullet, effects);
ValidateFieldOffset32(0xABC, Bullet, effect_speedup);
ValidateFieldOffset32(0xB04, Bullet, effect_accel);
ValidateFieldOffset32(0xB4C, Bullet, effect_angle_accel);
ValidateFieldOffset32(0xB94, Bullet, effect_angle);
ValidateFieldOffset32(0xBDC, Bullet, effect_bounce);
ValidateFieldOffset32(0xC24, Bullet, effect_wait);
ValidateFieldOffset32(0xC6C, Bullet, effect_wrap);
ValidateFieldOffset32(0xCB4, Bullet, effect_homing);
ValidateFieldOffset32(0xCFC, Bullet, effect_move);
ValidateFieldOffset32(0xD44, Bullet, effect_veladd);
ValidateFieldOffset32(0xD8C, Bullet, effect_veltime);
ValidateFieldOffset32(0xDD4, Bullet, effect_offscreen);
ValidateFieldOffset32(0xE1C, Bullet, effect_saveangle);
ValidateFieldOffset32(0xE64, Bullet, effect_delay);
ValidateFieldOffset32(0xEB0, Bullet, effect_move_interp);
ValidateFieldOffset32(0xF08, Bullet, scale_interp);
ValidateFieldOffset32(0xF38, Bullet, scale);
ValidateFieldOffset32(0xF3C, Bullet, __timer_F3C);
ValidateFieldOffset32(0xF50, Bullet, __timer_F50);
ValidateFieldOffset32(0xF64, Bullet, __int_F64);
ValidateFieldOffset32(0xF68, Bullet, state);
ValidateFieldOffset32(0xF6C, Bullet, __timer_F6C);
ValidateFieldOffset32(0xF80, Bullet, __timer_F80);
ValidateFieldOffset32(0xF94, Bullet, sprite_data);
ValidateFieldOffset32(0xF98, Bullet, sprite);
ValidateFieldOffset32(0xF9A, Bullet, color);
ValidateStructSize32(0xFA0, Bullet);
#pragma endregion

enum LaserType {
    LineLaser = 0,
    InfiniteLaser = 1,
    CurvyLaser = 2,
    BeamLaser = 3
};

typedef struct LaserData LaserData;
// size: 0x788
struct LaserData {
    // void* vtable; // 0x0
    ZUNEmbeddedListR<LaserData> embedded_node; // 0x4
    union {
        uint32_t __flags_C; // 0xC
        struct {
            uint32_t __unknown_flag_A : 1;
            uint32_t __unknown_field_A : 2;
            uint32_t __unknown_flag_B : 1;
        };
    };
    int32_t state; // 0x10
    int32_t type; // 0x14
    Timer __timer_18; // 0x18
    Timer graze_timer; // 0x2C
    Timer __timer_40; // 0x40
    Float3 position; // 0x54
    Float3 velocity; // 0x60
    float angle; // 0x6C
    float length; // 0x70
    float width; // 0x74
    float speed; // 0x78
    float __float_7C; // 0x7C
    int32_t id; // 0x80
    BulletEffectData effect_speedup; // 0x84
    BulletEffectData effect_accel; // 0xCC
    BulletEffectData effect_angle_accel; // 0x114
    BulletEffectData effect_angle; // 0x15C
    BulletEffectData effect_bounce; // 0x1A4
    BulletEffectData effect_wait; // 0x1EC
    BulletEffectData effect_wrap; // 0x234
    BulletEffectData effect_unused[17]; // 0x27C
    int32_t effect_index; // 0x744
    uint32_t active_effects; // 0x748
    unknown_fields(0x8); // 0x74C
    Timer __timer_754; // 0x754
    Timer offscreen_timer; // 0x768
    int32_t invulnerable_time; // 0x77C
    int32_t sprite; // 0x780
    int32_t color; // 0x784
    uint8_t derived_class[0]; // 0x788

    inline void zero_contents() {
        zero_this();
    }

    // 0x448170
    dllexport gnu_noinline LaserData() {
        this->zero_contents();
        this->__timer_18.reset();
    }

private:
    // 0x42D6A0
    dllexport gnu_noinline void vectorcall set_angle(float, float angle) asm_symbol_rel(0x42D6A0) {
        this->angle = angle;
    }
public:
    inline void set_angle(float angle) {
        return this->set_angle(UNUSED_FLOAT, angle);
    }

private:
    // 0x42D6B0
    dllexport gnu_noinline void vectorcall set_width(float, float width) asm_symbol_rel(0x42D6B0) {
        this->width = width;
    }
public:
    inline void set_width(float width) {
        return this->set_width(UNUSED_FLOAT, width);
    }

private:
    // 0x42D6C0
    dllexport gnu_noinline void vectorcall set_speed(float, float speed) asm_symbol_rel(0x42D6C0) {
        this->speed = speed;
    }
public:
    inline void set_speed(float speed) {
        return this->set_speed(UNUSED_FLOAT, speed);
    }

    // 0x42D6D0
    dllexport gnu_noinline void thiscall set_id(int32_t id = 0) asm_symbol_rel(0x42D6D0) {
        this->id = 0;
    }

    // 0x42D700
    dllexport gnu_noinline void thiscall set_position(Float3* position) asm_symbol_rel(0x42D700) {
        // why zun, don't do this
        *(Float3*)&this->derived_class[0] = this->position = *position;
    }

    // 0x42D730
    // Line:        __angle_C, __length_related, length
    // Infinite:    velocity
    // Curve:       __angle_C, width, __speed1
    // Beam:        velocity
    dllexport gnu_noinline void thiscall set_velocity(Float3* set_velocity) asm_symbol_rel(0x42D730) {
        *(Float3*)&this->derived_class[0xC] = *set_velocity;
    }

private:
    // 0x42D750
    dllexport gnu_noinline void vectorcall set_angular_velocity(float, float angular_velocity) {
        *(float*)&this->derived_class[0x1C] = angular_velocity;
    }
public:
    // Line:        width
    // Infinite:    angular_velocity
    // Curve:       color (incorrect type)
    // Beam:        angular_velocity
    inline void set_angular_velocity(float angular_velocity) {
        return this->set_angular_velocity(UNUSED_FLOAT, angular_velocity);
    }

#pragma region // LaserData method stubs

    // 0x447FC0
    // Method 0x0
    dllexport virtual gnu_noinline void thiscall __method_0(float magnitude, Float3* arg2) asm_symbol_rel(0x447FC0) {}
    // 0x447FD0
    // Method 0x4
    dllexport virtual gnu_noinline void thiscall run_effects() asm_symbol_rel(0x447FD0) {}
    // 0x447FE0
    // Method 0x8
    dllexport virtual gnu_noinline void thiscall __method_8(int) asm_symbol_rel(0x447FE0) {}
    // 0x447FF0
    // Method 0xC
    dllexport virtual gnu_noinline int thiscall initialize(void*) asm_symbol_rel(0x447FF0) {
        return 0;
    }
    // 0x448000
    // Method 0x10
    dllexport virtual gnu_noinline int thiscall on_tick() asm_symbol_rel(0x448000) {
        return 0;
    }
    // 0x448010
    // Method 0x14
    dllexport virtual gnu_noinline int thiscall on_draw() asm_symbol_rel(0x448010) {
        return 0;
    }
    // 0x448020
    // Method 0x18
    dllexport virtual gnu_noinline int thiscall __method_18() asm_symbol_rel(0x448020) {
        this->embedded_node.unlink();
        return 0;
    }
    // 0x448040
    // Method 0x1C
    dllexport virtual gnu_noinline int thiscall __method_1C(int, int, int, int, int, int) asm_symbol_rel(0x448040) {
        return 0;
    }
    // 0x448050
    // Method 0x20
    dllexport virtual gnu_noinline int thiscall cancel_in_rectangle(Float3* position, Float3* size, float rotation, int arg4, int32_t arg5) asm_symbol_rel(0x448050) {
        return 0;
    }
    // 0x448060
    // Method 0x24
    dllexport virtual gnu_noinline int thiscall cancel_in_radius(Float3* position, float radius, int arg3, int arg4) asm_symbol_rel(0x448060) {
        return 0;
    }
    // 0x448070
    // Method 0x28
    dllexport virtual gnu_noinline int thiscall cancel(int32_t arg1, int32_t arg2) asm_symbol_rel(0x448070) {
        return 0;
    }
    // 0x448080
    // Method 0x2C
    dllexport virtual gnu_noinline int thiscall __method_2C(int, int, int, int) asm_symbol_rel(0x448080) {
        return 0;
    }
    // 0x448090
    // Method 0x30
    dllexport virtual gnu_noinline int thiscall __method_30(Float2* arg1, float arg2) asm_symbol_rel(0x448090) {
        return 0;
    }
    // 0x4480A0
    // Method 0x34
    dllexport virtual gnu_noinline int thiscall check_collision(CollisionTestType test_type) asm_symbol_rel(0x4480A0) {
        return 0;
    }
    // 0x4480B0
    // Method 0x38
    dllexport virtual gnu_noinline int thiscall __method_38() asm_symbol_rel(0x4480B0) {
        return 0;
    }
    // 0x4480C0
    // Method 0x3C
    dllexport virtual gnu_noinline int thiscall __method_3C() asm_symbol_rel(0x4480C0) {
        return 0;
    }
    // 0x4480D0
    // Method 0x40
    dllexport virtual gnu_noinline int thiscall __method_40() asm_symbol_rel(0x4480D0) {
        return 0;
    }
    // 0x4480E0
    // Method 0x44
    dllexport virtual gnu_noinline int thiscall __method_44() asm_symbol_rel(0x4480E0) {
        return 0;
    }
    // 0x4480F0
    // Method 0x48
    dllexport virtual gnu_noinline int thiscall __method_48() asm_symbol_rel(0x4480F0) {
        return 0;
    }
    // 0x448100
    // Method 0x4C
    dllexport virtual gnu_noinline int thiscall __method_4C() asm_symbol_rel(0x448100) {
        return 0;
    }
    // 0x448110
    // Method 0x50
    dllexport virtual gnu_noinline int thiscall __method_50() asm_symbol_rel(0x448110) {
        return 0;
    }
    // 0x448120
    // Method 0x54
    dllexport virtual gnu_noinline int thiscall __method_54() asm_symbol_rel(0x448120) {
        return 0;
    }
    // 0x448130
    // Method 0x58
    dllexport virtual gnu_noinline int thiscall __method_58() asm_symbol_rel(0x448130) {
        return 0;
    }
    // 0x448140
    // Method 0x5C
    dllexport virtual gnu_noinline int thiscall __method_5C() asm_symbol_rel(0x448140) {
        return 0;
    }
    // 0x448150
    // Method 0x60
    dllexport virtual gnu_noinline int thiscall __method_60() asm_symbol_rel(0x448150) {
        return 0;
    }
    // 0x448160
    // Method 0x64
    dllexport virtual gnu_noinline LaserData* thiscall duplicate() asm_symbol_rel(0x448160) {
        return NULL;
    }
    // 0x4481E0
    // Method 0x68
    virtual ~LaserData() {
    }

#pragma endregion // LaserData method stubs

    inline int on_tick_common() {
        if (this->__unknown_flag_B) {
            this->check_collision(GrazeCollisionTest);
        }
        else {
            if (this->on_tick()) {
                return 1;
            }
            ++this->__timer_18;
            this->__unknown_flag_A = true;
        }
        return 0;
    }
};

// size: 0x460
struct LaserLineParams {
    Float3 position; // 0x0, 0x788
    float __angle_C; // 0xC, 0x794
    float __length_related; // 0x10, 0x798 (max length?)
    float length; // 0x14, 0x79C
    float __float_18; // 0x18, 0x7A0
    float width; // 0x1C, 0x7A4
    float __speed_1; // 0x20, 0x7A8
    int32_t sprite; // 0x24, 0x7AC
    int32_t color; // 0x28, 0x7B0
    float distance; // 0x2C, 0x7B4
    int32_t effect_index; // 0x30, 0x7B8
    union {
        uint32_t flags; // 0x34, 0x7BC
        struct {
            uint32_t __unknown_flag_A : 1; // 1
            uint32_t __unknown_flag_B : 1; // 2
        };
    };
    BulletEffectArgs effects[BULLET_EFFECT_MAX]; // 0x38, 0x7C0
    int32_t shot_sound; // 0x458, 0xBE0
    int32_t transform_sound; // 0x45C, 0xBE4
    // 0x460, 0xBE8

    inline void zero_contents() {
        zero_this();
    }

    inline LaserLineParams() {
        this->zero_contents();
    }

    inline LaserLineParams(int) {
    }
};

// size: 0x1E0C
struct LaserLine : LaserData {
    LaserLineParams params; // 0x788
    AnmVM __vm_BE8; // 0xBE8
    AnmVM __vm_11F4; // 0x11F4
    AnmVM __vm_1800; // 0x1800
    // 0x1E0C

    // 0x4482C0
    dllexport gnu_noinline LaserLine() {
    }

    // 0x448220
    // Method 0x0
    dllexport virtual gnu_noinline void thiscall __method_0(float magnitude, Float3* arg2) override asm_symbol_rel(0x448220) {
        arg2->make_from_vector(this->angle, magnitude);
        *arg2 += this->position;
    }

    // 0x4494F0
    // Method 0x4
    dllexport virtual gnu_noinline void thiscall run_effects() override asm_symbol_rel(0x4494F0);

    // 0x4490D0
    // Method 0xC
    dllexport virtual gnu_noinline int thiscall initialize(void* data) override asm_symbol_rel(0x4490D0);

    // 0x44A4F0
    // Method 0x10
    dllexport virtual gnu_noinline int thiscall on_tick() override asm_symbol_rel(0x44A4F0) {
        return 0;
    }

    // 0x44AB60
    // Method 0x14
    dllexport virtual gnu_noinline int thiscall on_draw() override asm_symbol_rel(0x44AB60) {
        this->__vm_BE8.data.position = this->position;
        this->__vm_BE8.set_z_rotation(reduce_angle_add(this->angle, HALF_PI_f));
        ANM_MANAGER_PTR->draw_vm(&this->__vm_BE8);
        this->__vm_1800.data.position.make_from_vector(this->angle, this->length);
        this->__vm_1800.data.position += this->position.as2();
        ANM_MANAGER_PTR->draw_vm(&this->__vm_1800);
        if (this->__float_7C == 0.0f) {
            this->__vm_11F4.data.position = this->position;
            ANM_MANAGER_PTR->draw_vm(&this->__vm_11F4);
        }
        return 0;
    }

    // 0x44AC90
    // Method 0x18
    dllexport virtual gnu_noinline int thiscall __method_18() override asm_symbol_rel(0x44AC90) {
        return 0;
    }

    // 0x44B5B0
    // Method 0x1C
    dllexport virtual gnu_noinline int thiscall __method_1C(int, int, int, int, int, int) override asm_symbol_rel(0x44B5B0) {
        // TODO
    }

    // 0x44ACA0
    // Method 0x20
    dllexport virtual gnu_noinline int thiscall cancel_in_rectangle(Float3* position, Float3* size, float rotation, int arg4, int32_t arg5) override asm_symbol_rel(0x44ACA0) {
        // TODO
    }

    // 0x44BD00
    // Method 0x24
    dllexport virtual gnu_noinline int thiscall cancel_in_radius(Float3* position, float radius, int arg3, int arg4) override asm_symbol_rel(0x44BD00) {
        // TODO
    }

    // 0x44C420
    // Method 0x28
    dllexport virtual gnu_noinline int thiscall cancel(int, int) override asm_symbol_rel(0x44C420) {
        // TODO
    }

    // 0x448210
    // Method 0x2C
    dllexport virtual gnu_noinline int thiscall __method_2C(int, int, int, int) override asm_symbol_rel(0x448210) {
        return 0;
    }

    // 0x44C790
    // Method 0x30
    dllexport virtual gnu_noinline int thiscall __method_30(Float2* arg1, float arg2) override asm_symbol_rel(0x44C790) {
        float x = arg1->x - this->position.x;
        float y = arg1->y - this->position.y;
        float angle = -this->angle;
        float y_unit = zsinf(angle);
        float x_unit = zcosf(angle);
        float A = (x_unit * x) - (y_unit * y);
        float B = (x_unit * y) + (y_unit * x);
        if (
            !(A - arg2 > this->length) &&
            !(B - arg2 > this->width * 0.5) &&
            !(A + arg2 < 0.0f) &&
            !(B + arg2 < -this->width * 0.5)
        ) {
            return 2;
        }
        return 0;
    }

    // 0x44A950
    // Method 0x34
    dllexport virtual gnu_noinline int thiscall check_collision(CollisionTestType test_type) override asm_symbol_rel(0x44A950) {
        float length = this->length;
        if (length > 16.0f) {
            float width = this->width;
            if (width > 3.0f) {
                Float3 position;
                if (!this->params.__unknown_flag_B) {
                    position.make_from_vector(this->angle, length / 10.0f);
                    position += this->position;
                } else {
                    position = this->position;
                }
                if (!this->params.__unknown_flag_B) {
                    length *= 4.0f;
                    length /= 5.0f;
                }
                if (width < 32.0f) {
                    width *= 0.5f;
                } else {
                    width -= (width + 16.0f) * 0.5f;
                }
                CollisionResult result = PLAYER_PTR->__check_collision_rotated_rectangle(&position, this->angle, width, length, test_type);
                if (result == DeathCollision) {
                    Float3 B(32.0f, 32.0f, 0.0f);
                    this->cancel_in_rectangle(&PLAYER_PTR->data.position, &B, UNUSED_FLOAT, 0, result);
                    return 0;
                }
                if (result == GrazeCollision) {
                    if (this->graze_timer.is_multiple_of(3)) {
                        float C = this->angle;
                        float D;
                        float E;
                        __sub_403BC0(&D, &E, position.x, position.y, C, this->position.x, this->position.y, reduce_angle(C + HALF_PI_f));
                        Float2 F(D, E);
                        Player::do_graze(&F);
                        this->graze_timer.increment();
                    }
                }
            }
        }
        return 0;
    }

    // 0x44A370
    // Method 0x3C
    dllexport virtual gnu_noinline int thiscall __method_3C() override asm_symbol_rel(0x44A370) {
        // TODO
    }

    // 0x44A1F0
    // Method 0x44
    dllexport virtual gnu_noinline int thiscall __method_44() override asm_symbol_rel(0x44A1F0) {
        // TODO
    }

    // 0x449E00
    // Method 0x50
    dllexport virtual gnu_noinline int thiscall __method_50() override asm_symbol_rel(0x449E00) {
        // TODO
    }

    // 0x448280
    // Method 0x64
    dllexport virtual gnu_noinline LaserData* thiscall duplicate() override asm_symbol_rel(0x448280) {
        LaserLine* new_laser = new LaserLine();
        memcpy(new_laser, this, sizeof(LaserLine));
        return new_laser;
    }
};

// size: 0x480
struct LaserInfiniteParams {
    Float3 position; // 0x0, 0x788
    Float3 velocity; // 0xC, 0x794
    float __angle_18; // 0x18, 0x7A0
    float angular_velocity; // 0x1C, 0x7A4
    float length; // 0x20, 0x7A8
    float __float_24; // 0x24, 0x7AC
    float width; // 0x28, 0x7B0
    float __speed_1; // 0x2C, 0x7B4
    int32_t start_time; // 0x30, 0x7B8
    int32_t expand_time; // 0x34, 0x7BC
    int32_t duration; // 0x38, 0x7C0
    int32_t stop_time; // 0x3C, 0x7C4
    int32_t shot_sound; // 0x40, 0x7C8
    int32_t transform_sound; // 0x44, 0x7CC
    int32_t laser_id; // 0x48, 0x7D0
    float distance; // 0x4C, 0x7D4
    int32_t __start_ex; // 0x50, 0x7D8
    int32_t sprite; // 0x54, 0x7DC
    int32_t color; // 0x58, 0x7E0
    union {
        uint32_t flags; // 0x5C, 0x7E4
        struct {
            uint32_t : 1; // 1
            uint32_t __unknown_flag_A : 1; // 2
        };
    };
    BulletEffectArgs effects[BULLET_EFFECT_MAX]; // 0x60, 0x7E8
    // 0x480, 0xC08

    inline void zero_contents() {
        zero_this();
    }

    inline LaserInfiniteParams() {
        this->zero_contents();
    }

    inline LaserInfiniteParams(int) {
    }
};

// size: 0x1824
struct LaserInfinite : LaserData {
    LaserInfiniteParams params; // 0x788
    int __dword_C08; // 0xC08
    AnmVM __vm_C0C; // 0xC0C
    AnmVM __vm_1218; // 0x1218
    // 0x1824

    inline LaserInfinite() {
    }
};

// size: 0x460
struct LaserCurveParams {
    Float3 position; // 0x0, 0x788
    float __angle_C; // 0xC, 0x794
    float width; // 0x10, 0x798
    float __speed_1; // 0x14, 0x79C
    int32_t sprite; // 0x18, 0x7A0
    int32_t color; // 0x1C, 0x7A4
    int32_t curve_length; // 0x20, 0x7A8
    float distance; // 0x24, 0x7AC
    union {
        uint32_t flags; // 0x28, 0x7B0
        struct {

        };
    };
    BulletEffectArgs effects[BULLET_EFFECT_MAX]; // 0x2C, 0x7B4
    int32_t shot_sound; // 0x44C, 0xBD4
    int32_t transform_sound; // 0x450, 0xBD8
    unknown_fields(0xC); // 0x454, 0xBDC
    // 0x460, 0xBE8

    inline void zero_contents() {
        zero_this();
    }

    inline LaserCurveParams() {
        this->zero_contents();
    }
};

// size: 0x1844
struct LaserCurve : LaserData {

    // size: 0x20
    struct LaserCurveNode {
        Float3 position; // 0x0
        Float3 velocity; // 0xC
        float angle; // 0x18
        float speed; // 0x1C
        // 0x20
    };

    // size: 0x3C
    struct LaserCurveNodeEx {
        LaserCurveNodeEx* next; // 0x0
        LaserCurveNodeEx* prev; // 0x4
        float __float_8; // 0x8
        float __float_C; // 0xC
        int32_t move_type; // 0x10
        Float3 __float3_14; // 0x14
        Float3 __float3_20; // 0x20
        float angle; // 0x2C
        float speed; // 0x30
        float __float_34; // 0x34
        float __float_38; // 0x38
        // 0x3C
    };

    LaserCurveParams params; // 0x788
    AnmVM __vm_BE8; // 0xBE8
    AnmVM __vm_11F4; // 0x11F4
    LaserCurveNode* nodes; // 0x1800
    SpriteVertex* vertices; // 0x1804
    LaserCurveNodeEx node_ex; // 0x1808
    // 0x1844
};

// size: 0x45C
struct LaserBeamParams {
    Float3 position; // 0x0
    Float3 velocity; // 0xC
    float __angle_18; // 0x18
    float angular_velocity; // 0x1C
    float __float_20; // 0x20
    float __float_24; // 0x24
    int32_t laser_id; // 0x28
    int32_t color; // 0x2C
    float distance; // 0x30
    int32_t start_time; // 0x34
    unknown_fields(0x4); // 0x38
    BulletEffectArgs effects[24]; // 0x3C
    // 0x45C

    inline void zero_contents() {
        zero_this();
    }

    inline LaserBeamParams() {
        this->zero_contents();
    }
};

// size: 0x21F4
struct LaserBeam : LaserData {

    LaserBeamParams params; // 0x788
    AnmVM __vm_BE4; // 0xBE4
    unknown_fields(0x1004); // 0x11F0
    // 0x21F4

    inline LaserBeam() {
    }
};

// size: 0x10
struct BulletIters {
    ZUNList<Bullet>* current[2]; // 0x0
    ZUNList<Bullet>* next[2]; // 0x8
    // 0x10
};

enum AimMode : int32_t {
    FanAimedMode = 0,
    FanMode = 1,
    CircleAimedMode = 2,
    CircleMode = 3,
    OffsetCircleAimedMode = 4,
    OffsetCircleMode = 5,
    RandomAngleMode = 6,
    RandomSpeedMode = 7,
    RandomMode = 8,
};

static inline constexpr int32_t MAX_BULLETS = 2000;

// size: 0x7A41F8
struct BulletManager : ZUNTask {
    // ZUNTask base; // 0x0
    Bullet* __bullet_ptr_C; // 0xC
    Bullet* __bullet_cache_A[6]; // 0x10
    Bullet* __bullet_cache_B[6]; // 0x28
    int32_t __int_40; // 0x40 (ECL variable -9898)
    float player_protect_radius_squared; // 0x44
    Float2 __bounce_bounds; // 0x48
    unknown_fields(0x8); // 0x50
    int __graze_array[20]; // 0x58
    int __int_A8; // 0xA8
    ZUNListHead<Bullet> bullet_free_list; // 0xAC
    ZUNListHead<Bullet> bullet_tick_list; // 0xBC
    unknown_fields(0x20); // 0xCC
    Bullet bullets[MAX_BULLETS + 1]; // 0xEC
    AnmID anm_ids[MAX_BULLETS + 1]; // 0x7A228C
    int32_t __cancel_counter; // 0x7A41D0
    int32_t __int_7A41D4; // 0x7A41D4
    BulletIters bullet_iter; // 0x7A41D8
    int32_t __cancel_counter2; // 0x7A41E8
    AnmLoaded* bullet_anm; // 0x7A41EC
    int32_t __unknown_counter_flag; // 0x7A41F0
    int32_t __unknown_counter; // 0x7A41F4
    // 0x7A41F8

    inline void zero_contents() {
        zero_this();
    }

    inline BulletManager() {
        this->zero_contents();
    }

    // 0x423CE0
    dllexport gnu_noinline ~BulletManager() {
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);

        ANM_MANAGER_PTR->mark_all_vms_from_loaded_slot_for_delete(7);

        BULLET_MANAGER_PTR = NULL;
    }
    
    // 0x409940
    dllexport Bullet* thiscall start_bullet_iter(uint32_t index) asm_symbol_rel(0x409940) {
        ZUNList<Bullet>* node = this->bullet_tick_list.next;
        this->bullet_iter.current[index] = node;
        if (node) {
            this->bullet_iter.next[index] = node->next;
            return node->data;
        }
        else {
            this->bullet_iter.next[index] = NULL;
            return NULL;
        }
    }

    inline Bullet* thiscall next_bullet_iter(uint32_t index) {
        ZUNList<Bullet>* node = this->bullet_iter.next[index];
        this->bullet_iter.current[index] = node;
        if (node) {
            this->bullet_iter.next[index] = node->next;
            return node->data;
        }
        else {
            this->bullet_iter.next[index] = NULL;
            return NULL;
        }
    }

    // 0x42CC70
    dllexport gnu_noinline uint32_t thiscall __count_graze_array() asm_symbol_rel(0x42CC70) {
        // MSVC loops this 2 at a time?
        uint32_t count = 0;
        for (size_t i = 0; i < countof(this->__graze_array); ++i) {
            count += this->__graze_array[i];
        }
        return count;
    }

private:
    // 0x42CCA0
    dllexport gnu_noinline void vectorcall set_player_protect_radius_squared(float, float radius) asm_symbol_rel(0x42CCA0) {
        BULLET_MANAGER_PTR->player_protect_radius_squared = radius;
    }
public:
    inline void set_player_protect_radius_squared(float radius) {
        return this->set_player_protect_radius_squared(UNUSED_FLOAT, radius);
    }

private:
    // 0x4237E0
    dllexport gnu_noinline void vectorcall __set_bounce_bounds(float, float width, float height) {
        this->__bounce_bounds.x = width;
        this->__bounce_bounds.y = height;
    }
public:
    inline void __set_bounce_bounds(float width, float height) {
        return this->__set_bounce_bounds(UNUSED_FLOAT, width, height);
    }

    // 0x4297A0
    dllexport gnu_noinline void thiscall cancel_all(int = UNUSED_DWORD) asm_symbol_rel(0x4297A0) {
        for (int32_t i = countof(this->bullets); i; --i) {

        }
    }

    // 0x424FE0
    dllexport gnu_noinline ZUNResult thiscall shoot_one_bullet(ShooterData* shooter, int32_t count1_index, int32_t count2_index, float angle_to_player) asm_symbol_rel(0x424FE0) {
        ZUNList<Bullet>* free_bullet_node = this->bullet_free_list.next;
        if (!free_bullet_node) {
            return ZUN_SUCCESS2;
        }
        free_bullet_node->unlink();
        Bullet* bullet = (Bullet*)free_bullet_node;
        BULLET_MANAGER_PTR->bullet_tick_list.append(&bullet->tick_list_node);

        float zero = 0.0f; // XMM2, ESP+30 wtf is this value for the compiler not to nuke it
        float count2 = count2_index; // XMM7
        float angle = 0.0f; // XMM3

        float speed1 = shooter->speed1; // XMM6
        int32_t count2_max = shooter->count2;

        float speed;
        if (count2_max > 1) {
            speed = speed1 - (speed1 - shooter->speed2) * count2 / (count2_max - 1.0f);
        } else {
            speed = speed1;
        }

        switch (shooter->aim_mode) {
            case FanAimedMode: case FanMode: { // 0, 1
                float angle2 = shooter->angle2;
                if (shooter->count1 & 1) {
                    angle2 = angle2 * ((count1_index + 1) / 2);
                } else {
                    angle2 = angle2 * (count1_index / 2) + (angle2 * 0.5f);
                }
                angle2 += zero;
                if (count1_index & 1) {
                    angle2 *= -1.0f;
                }
                if (shooter->aim_mode == FanAimedMode) { // 0
                    angle2 += angle_to_player;
                }
                angle = shooter->angle1 + angle2;
                break;
            }
            case CircleAimedMode: // 2
                angle = angle_to_player + zero;
            case CircleMode: { // 3
                float angle_between_bullets = count1_index * TWO_PI_f / shooter->count1;
                angle += angle_between_bullets + shooter->angle1 + shooter->angle2 * count2;
                break;
            }
            case OffsetCircleAimedMode: // 4
                angle = angle_to_player + zero;
            case OffsetCircleMode: { // 5
                float count1 = shooter->count1;
                float offset = PI_f / count1;
                float angle_between_bullets = count1_index * TWO_PI_f / count1;
                angle += angle_between_bullets + offset + shooter->angle1 + shooter->angle2 * count2;
                break;
            }
            case RandomAngleMode: // 6
                angle = shooter->angle1 + REPLAY_RNG.rand_float_signed_range(shooter->angle2);
                break;
            case RandomSpeedMode: { // 7
                speed = shooter->speed1 + REPLAY_RNG.rand_float_range(shooter->speed2);

                float angle_between_bullets = count1_index * TWO_PI_f / shooter->count1;
                angle = angle_between_bullets + zero + shooter->angle1 + shooter->angle2 * count2_index;
                break;
            }
            case RandomMode: // 8
                angle = shooter->angle1 + REPLAY_RNG.rand_float_signed_range(shooter->angle2);
                speed = shooter->speed1 + REPLAY_RNG.rand_float_range(shooter->speed2);
                break;
            case 9: case 10: {
                float angle_between_bullets = count1_index * TWO_PI_f / shooter->count1;
                float angle2 = shooter->angle2;
                if (count2_max & 1) {
                    angle2 = angle2 * ((count2_index + 1) / 2) + angle_between_bullets;

                    if (shooter->count2 > 1) {
                        speed = speed1 + (shooter->speed2 - speed1) * (count2_index & (uint16_t)~1) / (count2_max - 1);
                    } else {
                        speed = speed1;
                    }
                } else {
                    angle2 = angle2 * (count1_index / 2) + (angle2 * 0.5f) + angle_between_bullets;

                    if (shooter->count2 > 1) {
                        speed = speed1 + (shooter->speed2 - speed1) * (count2_index & (uint16_t)~1) / (count2_max - 1);
                    } else {
                        speed = speed1;
                    }
                }
                if (count1_index & 1) {
                    angle2 *= -1.0f;
                }
                if (shooter->aim_mode == 9) { // 0
                    angle2 += angle_to_player;
                }
                angle = shooter->angle1 + angle2;
                break;
            }
            case 11: {
                float angle_between_bullets = count1_index * TWO_PI_f / shooter->count1;

                angle = shooter->angle1 + angle_between_bullets + zero;

                speed *= 1.0f - (zfabsf(zsin(angle_between_bullets)) * shooter->speed2);
                break;
            }
            case 12: {
                float count1 = shooter->count1;
                float offset = PI_f / count1;
                float angle_between_bullets = count1_index * TWO_PI_f / count1;
                angle = angle_between_bullets + offset + shooter->angle1 + zero;

                speed *= 1.0f - (zfabsf(zsin(angle_between_bullets + offset)) * shooter->speed2);
                break;
            }
        }

        bullet->speed = speed;
        angle = reduce_angle_add(angle, zero);
        bullet->angle.value = angle;
        bullet->position = shooter->position;

        float distance = shooter->distance;
        if (distance != zero) {
            Float2 offset;
            offset.make_from_vector(angle, distance);
            bullet->position.as2() += offset;
        }
        bullet->position.z = 0.1f;

        bullet->__unknown_flag_E = true;
        bullet->state = BulletState1;
        bullet->__timer_F6C.reset();
        bullet->__timer_F80.reset();
        bullet->invulnerable_time = 0;
        bullet->scale = 1.0f;
        bullet->scale_interp.end_time = 0;

        float player_protect_radius_squared = this->player_protect_radius_squared;
        if (
            player_protect_radius_squared > 0.0f &&
            bullet->position.as2().distance_squared(&PLAYER_PTR->data.position) < player_protect_radius_squared
        ) {
            bullet->cleanup();
            return ZUN_ERROR;
        }

        bullet->velocity.make_from_vector(angle, speed);
        bullet->active_effects = shooter->flags; // WTF?

        bullet->color = shooter->color;
        bullet->sprite = shooter->type;
        bullet->__dword_690 = 0;
        bullet->__int_F64 = 60;
        bullet->__unknown_flag_F = true;
        bullet->grazed = false;
        bullet->__unknown_flag_D = false;
        bullet->__timer_F3C.reset();
        bullet->__timer_F50.reset();
        bullet->vm.reset();

        bullet->vm.controller.on_sprite_lookup_index = 1;
        bullet->vm.controller.associated_entity = bullet;

        this->bullet_anm->__sub_477D60(&bullet->vm, BULLET_SPRITE_DATA[shooter->type].anm_script);

        bullet->__circular_hitbox = true;
        bullet->vm.data.origin_mode = 1;

        if (int32_t script = BULLET_SPRITE_DATA[shooter->type].__anm_script_114) {
            bullet->__anm_tree_id = BULLET_MANAGER_PTR->bullet_anm->instantiate_vm_to_world_list_back(script, &bullet->position);
        }

        bullet->sprite_data = &BULLET_SPRITE_DATA[shooter->type];

        switch (BULLET_SPRITE_DATA[shooter->type].__int_10C) {
            case 0:
                bullet->cancel_script_id = shooter->color * 2 + 4;
                break;
            case 1:
                bullet->cancel_script_id = BULLET_IDK_DATA[shooter->color];
                break;
            case 2:
                bullet->cancel_script_id = -1;
                bullet->__circular_hitbox = true;
                break;
            case 3:
                bullet->cancel_script_id = 16;
                break;
            case 4:
                bullet->cancel_script_id = 6;
                break;
                /*
                Case 5 is missing compared to EX_SETSPRITE
            case 5:
                bullet->cancel_script_id = 12;
                break;
                */
            case 6:
                bullet->cancel_script_id = BULLET_SPRITE_DATA[bullet->sprite].color_data[shooter->color].cancel_script;
                bullet->__circular_hitbox = true;
                break;
            case 7:
                bullet->cancel_script_id = 260;
                bullet->__circular_hitbox = true;
                break;
            case 8:
                bullet->cancel_script_id = 263;
                bullet->__circular_hitbox = true;
                break;
            case 9:
                bullet->cancel_script_id = 266;
                bullet->__circular_hitbox = true;
                break;
            case 10:
                bullet->cancel_script_id = 275;
                bullet->__circular_hitbox = true;
                break;
        }

        bullet->__int_678 = 0;
        bullet->layer = BULLET_SPRITE_DATA[shooter->type].layer;
        bullet->transform_sound = shooter->transform_sound;
        bullet->offscreen_time = 5;

        float hitbox_size = BULLET_SPRITE_DATA[shooter->type].hitbox_size;
        bullet->hitbox_size.y = hitbox_size;
        bullet->hitbox_size.x = hitbox_size;

        bullet->initial_effects = shooter->flags;
        bullet->active_effects = 0;
        bullet->effect_loop_index = 0;
        int32_t effect_index = shooter->start_transform;
        bullet->effect_index = effect_index;

        memcpy(bullet->effects, shooter->effects, sizeof(BulletEffectArgs[BULLET_EFFECT_MAX]));

        if (shooter->effects[effect_index].type == EX_ANIM) {
            int32_t interrupt_index = (uint16_t)shooter->effects[effect_index].int_values[0];
            if (interrupt_index != 1) {
                bullet->vm.interrupt(7 + interrupt_index);
            }
            bullet->state = 2;
            bullet->position -= bullet->velocity * 4.0f;
        }
        else {
            bullet->vm.interrupt(2);
        }
        bullet->run_effects();
        bullet->vm.run_anm();

        return ZUN_SUCCESS;
    }
    
    // 0x427810
    dllexport gnu_noinline int32_t thiscall shoot_bullets(ShooterData* shooter) asm_symbol_rel(0x427810) {
        BulletManager* bullet_manager = BULLET_MANAGER_PTR;
        float angle_to_player = angle_to_player_from_point(&shooter->position);
        for (int32_t i = 0; i < shooter->count2; ++i) {
            for (int32_t j = 0; j < shooter->count1; ++j) {
                int32_t result = bullet_manager->shoot_one_bullet(shooter, j, i, angle_to_player);
                if (result != 0 && result == 1) goto break_outer;
            }
        }
    break_outer:
        if (shooter->play_sound_on_spawn) {
            SOUND_MANAGER.play_sound_positioned(shooter->shoot_sound, shooter->position.x);
        }
        return 0;
    }

private:
    // 0x429250
    dllexport gnu_noinline int vectorcall cancel_radius(int, float, float, Float2* position, float radius, CancelType cancel_type) asm_symbol_rel(0x429250) {
        BulletManager* bullet_manager = BULLET_MANAGER_PTR;
        for (
            Bullet* bullet = bullet_manager->start_bullet_iter(0);
            bullet;
            bullet = BULLET_MANAGER_PTR->next_bullet_iter(0)
        ) {
            switch (bullet->state) {
                case 2: case 1: {
                    // Yes, this aliases the normal radius field.
                    // But the math is written in a way that makes more sense
                    // for this to be reading the square size.
                    float bullet_radius = bullet->hitbox_size.x * 0.5f;
                    bool in_cancel_radius = bullet->position.distance_squared(position) <= bullet_radius * bullet_radius;
                    if (in_cancel_radius) {
                        bullet->cancel(cancel_type);
                        ++bullet_manager->__cancel_counter2;

                    }
                }
                    
            }
        }
    }
public:
    inline int cancel_radius(Float3* position, float radius, CancelType cancel_type) {
        return this->cancel_radius(UNUSED_DWORD, UNUSED_FLOAT, UNUSED_FLOAT, position, radius, cancel_type);
    }

private:
    // 0x429370
    dllexport gnu_noinline int vectorcall cancel_radius_as_bomb(int, float, float, Float2* position, float radius, CancelType cancel_type, int32_t max_count, int arg5) asm_symbol_rel(0x429370) {
        BulletManager* bullet_manager = BULLET_MANAGER_PTR;
        for (
            Bullet* bullet = bullet_manager->start_bullet_iter(0);
            bullet;
            bullet = BULLET_MANAGER_PTR->next_bullet_iter(0)
        ) {
            switch (bullet->state) {
                case 2: case 1:
                    if (!bullet->invulnerable_time) {
                        // Yes, this aliases the normal radius field.
                        // But the math is written in a way that makes more sense
                        // for this to be reading the square size.
                        float bullet_radius = bullet->hitbox_size.x * 0.5f;
                        bool in_cancel_radius = bullet->position.distance_squared(position) <= bullet_radius * bullet_radius;
                        if (in_cancel_radius) {
                            bullet->__int_678 = arg5;
                            bullet->cancel(cancel_type);
                            ++bullet_manager->__cancel_counter2;
                            if (--max_count <= 0) {
                                goto stop;
                            }
                        }
                    }
            }
        }
    stop:
        return 0;
    }
public:
    inline int cancel_radius_as_bomb(Float2* position, float radius, CancelType cancel_type, int32_t max_count, int arg5) {
        return this->cancel_radius_as_bomb(UNUSED_DWORD, UNUSED_FLOAT, UNUSED_FLOAT, position, radius, cancel_type, max_count, arg5);
    }

private:
    // 0x4294B0
    dllexport gnu_noinline int vectorcall cancel_rotated_rectangle_as_bomb(int, float, float, float, Float2* position, Float2* size, float rotation, CancelType cancel_type, int arg5) asm_symbol_rel(0x4294B0) {
        BulletManager* bullet_manager = BULLET_MANAGER_PTR;
        Bullet* bullet = bullet_manager->bullets;
        for (
            size_t i = 0;
            i < MAX_BULLETS;
            ++i, ++bullet
        ) {
            switch (bullet->state) {
                case 2: case 1:
                    if (!bullet->invulnerable_time) {
                        // TODO
                    }
            }
        }
        return 0;
    }
public:
    inline int cancel_rotated_rectangle_as_bomb(Float2* position, Float2* size, float rotation, CancelType cancel_type, int arg5) {
        return this->cancel_rotated_rectangle_as_bomb(UNUSED_DWORD, UNUSED_FLOAT, UNUSED_FLOAT, UNUSED_FLOAT, position, size, rotation, cancel_type, arg5);
    }
    
    // 0x424C50
    dllexport gnu_noinline UpdateFuncRet thiscall on_tick() asm_symbol_rel(0x424C50) {
        for (size_t i = countof(this->__graze_array) - 1; i; --i) {
            this->__graze_array[i] = this->__graze_array[i - 1];
        }
        this->__graze_array[0] = 0;
        
        Bullet* bullet = this->start_bullet_iter(0);

        this->__int_40 = 0;
        for (int32_t i = countof(this->__bullet_cache_A) - 1; i; --i) {
            this->__bullet_cache_A[i] = NULL;
        }
        for (int32_t i = countof(this->__bullet_cache_B) - 1; i; --i) {
            this->__bullet_cache_B[i] = NULL;
        }

        for (
            ;
            bullet;
            bullet = this->next_bullet_iter(0)
        ) {
            GameThread* game_thread_ptr = GAME_THREAD_PTR;
            if (
                !(game_thread_ptr && game_thread_ptr->__unknown_flag_C)
            ) {
                if (bullet->__unknown_flag_C) {
                    switch (bullet->state) {
                        case 2:
                            if (bullet->__timer_F6C < 8) {
                                break;
                            }
                        case 1:
                            bullet->__check_collision(GrazeCollisionTest);
                            goto idkA;
                    }
                }

                if (ZUN_FAILED(bullet->on_tick())) {
                    continue;
                }
            }
        idkA:

            if (!bullet->__delay_flag) {
                int32_t layer = bullet->layer;
                if (!this->__bullet_cache_A[layer]) {
                    this->__bullet_cache_A[layer] = bullet;
                }
                else if (this->__bullet_cache_B[layer]) {
                    this->__bullet_cache_B[layer]->next_in_layer = bullet;
                }
                this->__bullet_cache_B[layer] = bullet;
                bullet->next_in_layer = NULL;
            }
            
            this->__int_40++;
            bullet->__timer_F6C++;
        }

        return UpdateFuncNext;
    }

    inline UpdateFuncRet thiscall on_draw() {
        Bullet** draw_list = this->__bullet_cache_A;
        size_t i = countof(this->__bullet_cache_A);
        nounroll do {
            for (
                Bullet* bullet = *draw_list;
                bullet != NULL;
                bullet = bullet->next_in_layer
            ) {
                bullet->on_draw();
            }
            ++draw_list;
        } while (--i);
        return UpdateFuncNext;
    }
    
    // 0x424E70
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_tick(void* ptr) asm_symbol_rel(0x424E70) {
        GameThread* game_thread_ptr = GAME_THREAD_PTR;
        if (
            (game_thread_ptr && (game_thread_ptr->__unknown_flag_A | game_thread_ptr->skip_flag)) ||
            ABILITY_SHOP_PTR
        ) {
            return UpdateFuncNext;
        }
        return ((BulletManager*)ptr)->on_tick();
    }

    // 0x424EB0
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw(void* ptr) asm_symbol_rel(0x424EB0) {
        GameThread* game_thread_ptr = GAME_THREAD_PTR;
        if (
            game_thread_ptr && game_thread_ptr->skip_flag
        ) {
            return UpdateFuncNext;
        }
        return ((BulletManager*)ptr)->on_draw();
    }

    inline ZUNResult initialize() {
        AnmLoaded* bullet_anm = ANM_MANAGER_PTR->preload_anm(7, "bullet.anm");
        this->bullet_anm = bullet_anm;
        if (!bullet_anm) {
            LOG_BUFFER.write(JpEnStr("", "Enemy bullet data not found. data is corrupted\r\n"));
            return ZUN_ERROR;
        }

        this->__bullet_ptr_C = this->bullets;
        this->bullets[MAX_BULLETS].state = 5;

        UpdateFunc* update_func = new UpdateFunc(&on_tick, false, this);
        UpdateFuncRegistry::register_on_tick(update_func, 29);
        this->on_tick_func = update_func;
        update_func = new UpdateFunc(&on_draw, false, this);
        UpdateFuncRegistry::register_on_draw(update_func, 38);
        this->on_draw_func = update_func;

        for (int32_t i = 0; i < MAX_BULLETS; ++i) {
            Bullet* bullet = &this->bullets[i];

            bullet->free_list_node.initialize_with(NULL);
            bullet->tick_list_node.initialize_with(bullet);
            bullet->bullet_manager_index = i;

            // This may be the wrong list op, IDK
            this->bullet_free_list.append(&bullet->tick_list_node);
        }

        this->bullet_tick_list.initialize_with(NULL);

        return ZUN_SUCCESS;
    }

    // 0x423AF0
    dllexport gnu_noinline static BulletManager* allocate() asm_symbol_rel(0x423AF0) {
        BulletManager* bullet_manager = new BulletManager();
        BULLET_MANAGER_PTR = bullet_manager;
        if (ZUN_FAILED(bullet_manager->initialize())) {
            delete bullet_manager;
            return NULL;
        }
        return bullet_manager;
    }
};
#pragma region // BulletManager Validation
ValidateFieldOffset32(0x0, BulletManager, task_flags);
ValidateFieldOffset32(0x4, BulletManager, on_tick_func);
ValidateFieldOffset32(0x8, BulletManager, on_draw_func);
ValidateFieldOffset32(0xC, BulletManager, __bullet_ptr_C);
ValidateFieldOffset32(0x10, BulletManager, __bullet_cache_A);
ValidateFieldOffset32(0x28, BulletManager, __bullet_cache_B);
ValidateFieldOffset32(0x40, BulletManager, __int_40);
ValidateFieldOffset32(0x44, BulletManager, player_protect_radius_squared);
ValidateFieldOffset32(0x48, BulletManager, __bounce_bounds);
ValidateFieldOffset32(0x58, BulletManager, __graze_array);
ValidateFieldOffset32(0xA8, BulletManager, __int_A8);
ValidateFieldOffset32(0xAC, BulletManager, bullet_free_list);
ValidateFieldOffset32(0xBC, BulletManager, bullet_tick_list);
ValidateFieldOffset32(0xEC, BulletManager, bullets);
ValidateFieldOffset32(0x7A228C, BulletManager, anm_ids);
ValidateFieldOffset32(0x7A41D0, BulletManager, __cancel_counter);
ValidateFieldOffset32(0x7A41D4, BulletManager, __int_7A41D4);
ValidateFieldOffset32(0x7A41D8, BulletManager, bullet_iter);
ValidateFieldOffset32(0x7A41E8, BulletManager, __cancel_counter2);
ValidateFieldOffset32(0x7A41EC, BulletManager, bullet_anm);
ValidateFieldOffset32(0x7A41F0, BulletManager, __unknown_counter_flag);
ValidateFieldOffset32(0x7A41F4, BulletManager, __unknown_counter);
ValidateStructSize32(0x7A41F8, BulletManager);
#pragma endregion

static inline int bullet_cancel_radius(Float3* position, float radius, CancelType cancel_type) {
    return BULLET_MANAGER_PTR->cancel_radius(position, radius, cancel_type);
}

static inline int bullet_cancel_radius_as_bomb(Float2* position, float radius, CancelType cancel_type, int32_t max_count, int arg5) {
    return BULLET_MANAGER_PTR->cancel_radius_as_bomb(position, radius, cancel_type, max_count, arg5);
}

// 0x424AD0
dllexport gnu_noinline void Bullet::cleanup() {
    if (this->state != 0) {
        this->state = 0;
        this->__timer_F6C.reset();
        this->__timer_F80.reset();
        this->__timer_F3C.reset();
        this->__timer_F50.reset();
        this->__unknown_flag_E = false;
        this->__scale_enabled = false;
        this->__unknown_flag_C = false;
        this->__delay_flag = false;
        this->__dword_690 = 0;
        this->__ex_func_a = 0;
        BULLET_MANAGER_PTR->bullet_free_list.append(&this->free_list_node);
        this->tick_list_node.unlink();
    }
}

// 0x4290E0
dllexport gnu_noinline void fastcall spawn_bullet_cancel_items(Float3* position, CancelType cancel_type) {
    if (cancel_type != CancelType0) {
        float x = position->x;
        if (
            !(x + 32.0f <= SCREEN_LEFT_EDGE) &&
            !(x - 32.0f >= SCREEN_RIGHT_EDGE)
        ) {
            float y = position->y;
            if (
                !(y + 32.0f <= SCREEN_BOTTOM_EDGE) &&
                !(y - 32.0f >= SCREEN_TOP_EDGE)
            ) {
                int32_t cancel_counter = ++BULLET_MANAGER_PTR->__cancel_counter;

                switch (cancel_type) {
                    case CancelType1: cancel_type_1: {
                        float angle = REPLAY_RNG.rand_float_signed_range(DEGREES(10.0f)) - HALF_PI_f;
                        ITEM_MANAGER_PTR->spawn_item(Piv5Item, position, angle, 2.2f, 0);
                        return;
                    }
                    case CancelType4:
                        switch (cancel_counter % 5) {
                            case 2:
                                if (REPLAY_RNG.rand_uint() & 1) {
                            default:
                                    if (
                                        (BULLET_MANAGER_PTR->__cancel_counter % 5) != 4 ||
                                        REPLAY_RNG.rand_uint_range(3) != 0
                                    ) {
                                        goto cancel_type_1;
                                    }
                                }
                            case 0:
                                ITEM_MANAGER_PTR->spawn_item(PointItem, position, -HALF_PI_f, 2.2f, 0);
                        }
                        break;
                }
            }
        }
    }
}

// 0x428E90
dllexport gnu_noinline int32_t thiscall Bullet::cancel(CancelType cancel_type) {
    this->vm.interrupt_and_run(1);
    this->__anm_tree_id.interrupt_tree(1);
    if (!this->__delay_flag) {
        int32_t cancel_script = this->cancel_script_id;
        if (cancel_script >= 0) {
            BULLET_MANAGER_PTR->anm_ids[this->bullet_manager_index] = BULLET_MANAGER_PTR->bullet_anm->instantiate_vm_to_world_list_back(cancel_script, &this->position);
            if (this->__int_678) {
                BULLET_MANAGER_PTR->anm_ids[this->bullet_manager_index].interrupt_tree(3);
            }
        }
        SOUND_MANAGER.play_sound_positioned(71, this->position.x);
        spawn_bullet_cancel_items(&this->position, cancel_type);
    }
    this->state = CanceledBullet;
    this->position += this->velocity * GAME_SPEED * 0.5f;
    this->__timer_F6C.reset();
    return 0;
}

// 0x4248A0
dllexport gnu_noinline CollisionResult thiscall Bullet::__check_collision(CollisionTestType test_type) {
    CollisionResult result = NoCollision;

    this->vm.data.color_mode = 0; // why is this *here* of all places
    this->vm.data.position = UNKNOWN_FLOAT3_A;

    if (
        this->__unknown_flag_F &&
        this->hitbox_radius > 0.0f // aliases hitbox_size.x
    ) {
        if (!this->__scale_enabled) {
            if (!this->__circular_hitbox) {
                result = PLAYER_PTR->__check_collision_rectangle(&this->position, &this->hitbox_size, test_type);
            } else {
                result = PLAYER_PTR->check_collision_circle(&this->position, this->hitbox_radius, test_type);
            }
        } else {
            float scale = this->scale;
            if (!this->__circular_hitbox) {
                Float2 scaled_hitbox = this->hitbox_size * scale;
                result = PLAYER_PTR->__check_collision_rectangle(&this->position, &scaled_hitbox, test_type);
            } else {
                result = PLAYER_PTR->check_collision_circle(&this->position, this->hitbox_radius * scale, test_type);
            }
        }
        switch (result) {
            case DeathCollision:
                if (!this->invulnerable_time) {
                    break;
                }
                goto spawn_graze_effects;
            case GrazeCollision:
                if (!this->grazed) {
                    PLAYER_PTR->do_graze(&this->position);
                    this->grazed = true;

                    BulletManager* bullet_manager = BULLET_MANAGER_PTR;
                    ++bullet_manager->__graze_array[0];
                    if (bullet_manager->__unknown_counter_flag) {
                        ++bullet_manager->__unknown_counter;
                        if (!(bullet_manager->__unknown_counter % 6)) {
            spawn_graze_effects:
                            this->__int_678 = 1;
                            this->state = 3;
                            this->vm.interrupt(1);
                            this->__anm_tree_id.interrupt_tree(1);

                            int32_t script = this->cancel_script_id;
                            if (script >= 0) {
                                AnmID anm_id = BULLET_MANAGER_PTR->bullet_anm->instantiate_vm_to_world_list_back(script, &this->position, 0.0f, -1, NULL);
                                AnmVM* vm = anm_id.get_vm_ptr();
                                if (this->__int_678) {
                                    vm->interrupt(3);
                                }
                                Float3 end = (this->velocity * GAME_SPEED) * 10.0f;
                                vm->initialize_position_interp(30, 6, &UNKNOWN_FLOAT3_A, &end);
                            }
                        }
                    }
                }
                break;
        }
    }
    return result;
}

static inline constexpr int32_t MAX_LASER_COUNT = 512;

// size: 0x7C4
struct LaserManager : ZUNTask {
    // ZUNTask base; // 0x0
    LaserData dummy_laser; // 0xC
    LaserData* list_tail; // 0x794
    int32_t laser_count; // 0x798
    int32_t __prev_laser_id; // 0x79C
    Float3 __float3_7A0; // 0x7A0
    Float3 __float3_7AC; // 0x7AC
    AnmLoaded* bullet_anm; // 0x7B8
    int32_t __int_7BC; // 0x7BC
    LaserData* __current_stupid_iter; // 0x7C0
    // 0x7C4

    inline void zero_contents() {
        zero_this();
    }

    inline LaserManager() {
        this->zero_contents();
        this->__prev_laser_id = 0x10000;
    }

    // 0x448650
    dllexport gnu_noinline ~LaserManager() {
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);

        this->destroy_all();

        LASER_MANAGER_PTR = NULL;
    }

    inline ZUNEmbeddedListRHead<LaserData>& list_head() {
        return *(ZUNEmbeddedListRHead<LaserData>*) & this->dummy_laser.embedded_node;
    }

    inline void __increment_laser_id() {
        ++this->__prev_laser_id;
        this->__prev_laser_id = std::max(this->__prev_laser_id, 0x10000);
    }

    inline void allocate_new_line_laser(LaserLineParams* data) {
        if (this->laser_count < MAX_LASER_COUNT) {
            this->__increment_laser_id();
            LaserLine* laser = new LaserLine();
            laser->id = this->__prev_laser_id;
            this->list_tail->embedded_node.append(laser);
            ++this->laser_count;
            this->list_tail = laser;
            laser->initialize(data);
        }
    }

    // 0x448920
    dllexport gnu_noinline int32_t thiscall allocate_new_laser(int32_t laser_type, void* data) asm_symbol_rel(0x448920) {
        LaserManager* laser_manager = LASER_MANAGER_PTR;
        if (this->laser_count >= MAX_LASER_COUNT) {
            return 0;
        }
        laser_manager->__increment_laser_id();
        switch (laser_type) {
            case LineLaser: {
                LaserLine* laser = new LaserLine();
                laser->id = laser_manager->__prev_laser_id;
                laser_manager->list_tail->embedded_node.append(laser);
                ++laser_manager->laser_count;
                laser_manager->list_tail = laser;
                laser->initialize(data);
                break;
            }
            case InfiniteLaser: {
                LaserInfinite* laser = new LaserInfinite();
                laser->id = laser_manager->__prev_laser_id;
                laser_manager->list_tail->embedded_node.append(laser);
                ++laser_manager->laser_count;
                laser_manager->list_tail = laser;
                laser->initialize(data);
                break;
            }
            case BeamLaser: {
                LaserBeam* laser = new LaserBeam();
                laser->id = laser_manager->__prev_laser_id;
                laser_manager->list_tail->embedded_node.append(laser);
                ++laser_manager->laser_count;
                laser_manager->list_tail = laser;
                laser->initialize(data);
                break;
            }
            case CurvyLaser: {
                LaserCurve* laser = new LaserCurve();
                laser->id = laser_manager->__prev_laser_id;
                laser_manager->list_tail->embedded_node.append(laser);
                ++laser_manager->laser_count;
                laser_manager->list_tail = laser;
                laser->initialize(data);
                break;
            }
        }
        return laser_manager->__prev_laser_id;
    }

    // 0x42D780
    dllexport gnu_noinline LaserData* thiscall get_laser_with_id(int32_t id, int32_t arg2 = 0) {
        LaserManager* laser_manager = LASER_MANAGER_PTR;
        if (id) {
            return laser_manager->list_head().find_if([=](LaserData* laser) {
                return laser->id == id;
            });
        }
        return NULL;
    }

    // 0x442480
    dllexport gnu_noinline void thiscall destroy_all() asm_symbol_rel(0x442480) {
        this->list_head().for_each_safe([](LaserData* laser) {
            laser->__method_18();
            laser->embedded_node.unlink();
            delete laser;
        });
        this->laser_count = 0;
        this->list_tail = &this->dummy_laser;
    }

    // 0x449090
    dllexport gnu_noinline int thiscall cancel_all(int32_t arg1, int32_t arg2 = UNUSED_DWORD) asm_symbol_rel(0x449090) {
        LASER_MANAGER_PTR->list_head().for_each_safe([=](LaserData* laser) {
            if (laser->state != 1) {
                laser->cancel(arg1, 0);
            }
        });
        return 1;
    }

    // 0x448FA0
    dllexport gnu_noinline int thiscall clear_all() asm_symbol_rel(0x448FA0) {
        LASER_MANAGER_PTR->list_head().for_each_safe([](LaserData* laser) {
            laser->__timer_754.reset();
            laser->invulnerable_time = 0;
            laser->cancel(1, 0);
        });
        return 0;
    }

private:
    // 0x448F10
    dllexport gnu_noinline static int vectorcall cancel_in_rectangle(int, int, float, float, float, Float3* position, Float3* size, float rotation, int arg4 = UNUSED_DWORD, int arg5 = 0) {
        LaserManager* laser_manager = LASER_MANAGER_PTR;
        int ret = 0;
        laser_manager->__float3_7A0 = *position;
        laser_manager->__float3_7AC = *size;
        laser_manager->list_head().for_each_safe([&](LaserData* laser) {
            if (
                laser->state != 1 &&
                laser->__unknown_flag_A
            ) {
                ret += laser->cancel_in_rectangle(position, size, rotation, 0, arg5);
            }
        });
        return ret;
    }
public:
    inline static int cancel_in_rectangle(Float3* arg1, Float3* arg2, float arg3, int arg4 = UNUSED_DWORD, int arg5 = 0) {
        return cancel_in_rectangle(UNUSED_DWORD, UNUSED_DWORD, UNUSED_FLOAT, UNUSED_FLOAT, UNUSED_FLOAT, arg1, arg2, arg3, arg4, arg5);
    }

private:
    // 0x449010
    dllexport gnu_noinline static int vectorcall cancel_in_radius(int, int, float, float, Float3* position, float radius, int arg3, int arg4) {
        LaserManager* laser_manager = LASER_MANAGER_PTR;
        int ret = 0;
        laser_manager->__float3_7A0 = *position;
        laser_manager->list_head().for_each_safe([&](LaserData* laser) {
            if (laser->state != 1) {
                ret += laser->cancel_in_radius(position, radius, arg3, arg4);
            }
        });
        return ret;
    }
public:
    inline static int cancel_in_radius(Float3* position, float radius, int arg3, int arg4) {
        return cancel_in_radius(UNUSED_DWORD, UNUSED_DWORD, UNUSED_FLOAT, UNUSED_FLOAT, position, radius, arg3, arg4);
    }

    // 0x448760
    dllexport gnu_noinline UpdateFuncRet thiscall on_tick() {
        this->list_head().for_each_safe([=](LaserData* laser) {
            if (
                (laser->__unknown_field_A != 0 && ++laser->__unknown_field_A >= 2) ||
                laser->state == 1 ||
                laser->on_tick_common() != 0
            ) {
                laser->__method_18();
                --this->laser_count;
                laser->embedded_node.unlink();
                if (this->list_tail == laser) {
                    this->list_tail = laser->embedded_node.prev;
                }
                delete laser;
            }
        });
        return UpdateFuncNext;
    }

    // 0x448870
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_tick(void* ptr) {
        LaserManager* laser_manager = (LaserManager*)ptr;
        if (
            !(GAME_THREAD_PTR->skip_flag | GAME_THREAD_PTR->__unknown_flag_A) &&
            !GAME_THREAD_PTR->__unknown_flag_C
        ) {
            if (GAME_THREAD_PTR->__unknown_flag_B) {
                float prev_game_speed = GAME_SPEED;
                GAME_SPEED.value = 0.0f;
                UpdateFuncRet ret = laser_manager->on_tick();
                GAME_SPEED.value = prev_game_speed;
                return ret;
            }
            else {
                if (!ABILITY_SHOP_PTR) {
                    return laser_manager->on_tick();
                }
            }
        }
        return UpdateFuncNext;
    }

    // 0x4488E0
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw(void* ptr) {
        LaserManager* laser_manager = (LaserManager*)ptr;
        if (!GAME_THREAD_PTR->skip_flag) {
            laser_manager->list_head().for_each_safe([](LaserData* laser) {
                if (laser->state != 1) {
                    laser->on_draw();
                }
            });
        }
        return UpdateFuncNext;
    }

    inline ZUNResult initialize() {
        AnmLoaded* bullet_anm = ANM_MANAGER_PTR->preload_anm(7, "bullet.anm");
        this->bullet_anm = bullet_anm;
        if (!bullet_anm) {
            LOG_BUFFER.write(JpEnStr("", "Enemy bullet data not found. Data is corrupted\r\n"));
            return ZUN_ERROR;
        }

        UpdateFunc* update_func = new UpdateFunc(&on_tick, false, this);
        UpdateFuncRegistry::register_on_tick(update_func, 28);
        this->on_tick_func = update_func;
        update_func = new UpdateFunc(&on_draw, false, this);
        UpdateFuncRegistry::register_on_draw(update_func, 36);
        this->on_draw_func = update_func;

        this->list_tail = &this->dummy_laser;

        return ZUN_SUCCESS;
    }

    static inline LaserManager* allocate() {
        LaserManager* laser_manager = new LaserManager();
        LASER_MANAGER_PTR = laser_manager;
        if (ZUN_FAILED(laser_manager->initialize())) {
            delete laser_manager;
            return NULL;
        }
        return laser_manager;
    }

    template <typename L>
    static inline void for_each_laser_but_stupid(const L& lambda) {
        LaserManager* laser_manager = LASER_MANAGER_PTR;
        LaserData* data = laser_manager->list_head().next;
        laser_manager->__current_stupid_iter = data;
        if (data) {
            do {
                lambda(data);
                laser_manager = LASER_MANAGER_PTR;
                data = laser_manager->__current_stupid_iter;
                if (!data) break;
                data = data->embedded_node.next;
                laser_manager->__current_stupid_iter = data;
            } while (data);
        }
    }

    dllexport static inline void __set_flag_B_on_all_lasers() {
        for_each_laser_but_stupid([](LaserData* laser) {
            laser->__unknown_flag_B = true;
        });
    }

    dllexport static inline void __clear_flag_B_on_all_lasers() {
        for_each_laser_but_stupid([](LaserData* laser) {
            laser->__unknown_flag_B = false;
        });
    }
};

static inline int laser_cancel_radius(Float3* position, float radius, int arg3, int arg4) {

}

// 0x4490D0
// Method 0xC
dllexport gnu_noinline int thiscall LaserLine::initialize(void* data) {
    memcpy(&this->params, data, sizeof(LaserLineParams));
    this->sprite = this->params.sprite;
    this->color = this->params.color;
    this->state = 2;
    this->type = 0;
    AnmVM* vm = &this->__vm_BE8;
    vm->reset();
    LASER_MANAGER_PTR->bullet_anm->__sub_477D60(vm, BULLET_SPRITE_DATA[this->sprite].color_data[0].sprite_id);
    vm->run_on_interrupt(2);
    vm->run_anm();
    vm->data.blend_mode = 1;
    vm->data.x_anchor_mode = 0;
    vm->data.y_anchor_mode = 2;
    vm->data.render_mode = 1;
    vm->data.origin_mode = 1;

    vm = &this->__vm_11F4;
    clang_forceinline LASER_MANAGER_PTR->bullet_anm->__copy_data_to_vm_and_run(vm, this->params.color + 56);
    vm->run_on_interrupt(2);
    vm->run_anm();
    vm->data.blend_mode = 1;
    vm->data.render_mode = 1;
    vm->data.origin_mode = 1;

    if (this->sprite > 17 && this->sprite != 38) {
        vm = &this->__vm_1800;
        clang_forceinline LASER_MANAGER_PTR->bullet_anm->__copy_data_to_vm_and_run(vm, this->params.color + 83);
    } else {
        vm = &this->__vm_1800;
        clang_forceinline LASER_MANAGER_PTR->bullet_anm->__copy_data_to_vm_and_run(vm, this->params.color + 91);
        vm->data.blend_mode = 1;
    }
    vm->data.origin_mode = 1;
    this->__timer_754.set(30);
    this->offscreen_timer.set(3);
    SoundManager::play_sound_positioned_validate(this->params.shot_sound, 0.0f);
    this->graze_timer.reset();
    this->__timer_40.reset();
    // TODO: FINISH THIS
}

// 0x438D90
dllexport gnu_noinline ZUNResult fastcall EnemyData::__func_set_1_6bs(EnemyData* enemy_data) {
    // TODO
}

// 0x439020
dllexport gnu_noinline ZUNResult fastcall EnemyData::__func_call_2_ex(EnemyData* enemy_data) {
    Float3 A; // ESP+1C
    Float3 B; // ESP+28
    Float3 unit_vec; // ESP+34

    LASER_MANAGER_PTR->for_each_laser_but_stupid([&](LaserData* laser) {
        if (HitboxManager::__sub_404080(
            &A, &B,
            &laser->position,
            laser->angle,
            0.0f, 224.0f,
            384.0f, 448.0f,
            0.0f
        )) {
            unit_vec.make_from_vector(laser->angle, 1.0f);

            Float3 C = (A - laser->position) * unit_vec;
            if (C.x + C.y + C.z >= 1.0f) {
                B = A;
            } else {
                A = B;
            }

            EnemyInitData enemy_init = {};
            enemy_init.position = A;
            enemy_init.life = 10000;
            enemy_init.score = 0;
            enemy_init.item_drop = 0;
            ENEMY_MANAGER_PTR->allocate_new_enemy("BossCard6_et", &enemy_init);
        }
    });
    return ZUN_SUCCESS;
}

// 0x4391A0
dllexport gnu_noinline ZUNResult fastcall EnemyData::__func_call_3_ex(EnemyData* enemy_data) {
    Float3 A; // ESP+1C
    Float3 B; // ESP+28
    Float3 unit_vec; // ESP+34
    
    LASER_MANAGER_PTR->for_each_laser_but_stupid([&](LaserData* laser) {
        if (HitboxManager::__sub_404080(
            &A, &B,
            &laser->position,
            laser->angle,
            0.0f, 224.0f,
            384.0f, 448.0f,
            0.0f
        )) {
            unit_vec.make_from_vector(laser->angle, 1.0f);

            Float3 C = (A - laser->position) * unit_vec;
            if (C.x + C.y + C.z >= 1.0f) {
                B = A;
            } else {
                A = B;
            }

            EnemyInitData enemy_init = {};
            enemy_init.position = A;
            enemy_init.life = 10000;
            enemy_init.score = 0;
            enemy_init.item_drop = 0;
            ENEMY_MANAGER_PTR->allocate_new_enemy("BossCard6_et2", &enemy_init);
        }
    });
    return ZUN_SUCCESS;
}

// 0x439320
dllexport gnu_noinline ZUNResult fastcall EnemyData::__func_set_4_ex(EnemyData* enemy_data) {

}

#pragma push_macro("IntArg")
#pragma push_macro("ShortArg")
#pragma push_macro("WordArg")
#pragma push_macro("FloatArg")

#undef IntArg
#undef ShortArg
#undef WordArg
#undef FloatArg
#define IntArg(index) (current_effect.int_values[index])
#define ShortArg(index) (*(int16_t*)&IntArg(index))
#define WordArg(index) (*(uint16_t*)&IntArg(index))
#define FloatArg(index) (current_effect.float_values[index])
#define IntArgEx(index) (((index < 4) + &current_effect)->int_values[(index) % 4])
#define FloatArgEx(index) (((index < 4) + &current_effect)->float_values[(index) % 4])

// 0x4494F0
// Method 0x4
dllexport gnu_noinline void thiscall LaserLine::run_effects() {
    int32_t& effect_index = this->effect_index;
    while (effect_index < countof(this->params.effects)) {
        BulletEffectArgs& current_effect = this->params.effects[effect_index];
        BulletEffectType current_type = current_effect.type;
        if (
            current_type == EX_NONE ||
            !current_effect.async && this->active_effects != EX_NONE
        ) {
            return;
        }
        switch (current_type) {
            case EX_DIST: {
                this->active_effects |= EX_DIST;
                BulletEffectData& effect_data = this->effect_speedup;
                effect_data.timer.reset();
                ++effect_index;
                continue;
            }
            case EX_ACCEL: {
                this->active_effects |= EX_ACCEL;
                BulletEffectData& effect_data = this->effect_accel;
                effect_data.acceleration = FloatArg(0);
                float angle_arg = FloatArg(1);
                if (angle_arg <= -999.0f) {
                    angle_arg = this->angle;
                }
                else if (angle_arg >= 990.0f) {
                    angle_arg = angle_to_player_from_point(&this->position);
                }
                effect_data.angle = angle_arg;
                effect_data.timer.reset();
                effect_data.duration = IntArg(0);
                effect_data.acceleration_vec.make_from_vector(effect_data.angle, effect_data.acceleration);
                if (this->effect_index != 0) {
                    SoundManager::play_sound_validate(this->params.transform_sound);
                }
                break;
            }
            case EX_ANGLE_ACCEL: {
                this->active_effects |= EX_ANGLE_ACCEL;
                BulletEffectData& effect_data = this->effect_angle_accel;
                effect_data.acceleration = FloatArg(0);
                effect_data.angle = FloatArg(1);
                effect_data.timer.reset();
                effect_data.duration = IntArg(0);
                if (this->effect_index != 0) {
                    SoundManager::play_sound_validate(this->params.transform_sound);
                }
                break;
            }
            case EX_ANGLE: {
                this->active_effects |= current_type;
                BulletEffectData& effect_data = this->effect_angle;
                effect_data.angle = FloatArg(0);
                float speed_arg = FloatArg(1);
                if (!(speed_arg > -999990.0f)) {
                    speed_arg = this->speed;
                }
                effect_data.speed = speed_arg;
                effect_data.timer.reset();
                effect_data.duration = IntArg(0);
                effect_data.max_count = IntArg(1);
                effect_data.count = 0;
                effect_data.type = IntArg(2);
                ++effect_index;
                continue;
            }
            case EX_BOUNCE: { // looks more like EX_LOOP...?
                if (IntArg(0) > 0) {
                    this->active_effects |= current_type;
                    BulletEffectData& effect_data = this->effect_bounce;
                    float speed_arg = FloatArg(0);
                    if (!(speed_arg >= 0.0f)) {
                        speed_arg = this->speed;
                    }
                    effect_data.speed = speed_arg;
                    effect_data.max_count = --IntArg(0);
                    effect_data.duration = 0;
                    effect_data.count = IntArg(1);
                    ++effect_index;
                    continue;
                }
                break;
            }
            case EX_SETSPRITE: {
                AnmVM* vm = &this->__vm_BE8;
                int32_t sprite_id = BULLET_SPRITE_DATA[IntArg(0)].color_data[0].sprite_id + IntArg(1);
                clang_forceinline BULLET_MANAGER_PTR->bullet_anm->__copy_data_to_vm_and_run(vm, sprite_id);
                ++effect_index;
                continue;
            }
            case EX_OFFSCREEN: {
                this->offscreen_timer.set(IntArg(0));
                ++effect_index;
                continue;
            }
            case EX_INVULN: {
                this->invulnerable_time = IntArg(0);
                ++effect_index;
                continue;
            }
            case EX_DELETE: {
                this->state = 3;
                ++effect_index;
                continue;
            }
        }
        ++effect_index;
    }
}

// 0x438D40
dllexport AnmLoaded* stdcall anm_file_lookup(int32_t file_index) {
    if (file_index == 7) {
        return STAGE_PTR->stage_anm;
    } else if (file_index == 0) {
        return BULLET_MANAGER_PTR->bullet_anm;
    } else if (file_index == 1) {
        return EFFECT_MANAGER_PTR->effect_anm;
    } else {
        return ENEMY_MANAGER_PTR->enemy_anms[file_index];
    }
}


inline AnmLoaded* EnemyManager::anm_file_lookup(int32_t file_index) {
    return ::anm_file_lookup(file_index);
}

// 0x425C60
dllexport void Bullet::run_effects() {
    int32_t& effect_index = this->effect_index;
    while (effect_index < BULLET_EFFECT_MAX) {
        BulletEffectArgs& current_effect = this->effects[effect_index];
        BulletEffectType current_type = current_effect.type;
        if (
            current_type == EX_NONE ||
            !current_effect.async && (this->active_effects & EX_OFFSCREEN) != EX_NONE ||
            !(this->active_effects & current_type)
        ) {
            return;
        }

        switch (current_type) {
            case EX_ANIM:
                this->vm.interrupt(7 + ShortArg(0));
                this->state = 2;
                this->position -= this->velocity * 4.0f;
                break;
            case EX_DIST: {
                this->active_effects |= EX_DIST;
                BulletEffectData& effect_data = this->effect_speedup;
                effect_data.timer.reset();
                effect_data.velocity.z = 0.0f;
                break;
            }
            case EX_ACCEL: {
                this->active_effects |= EX_ACCEL;
                BulletEffectData& effect_data = this->effect_accel;
                effect_data.acceleration = FloatArg(0);
                effect_data.angle = this->position.__bullet_effect_angle_jank(this->angle, FloatArg(1), FloatArg(2));
                effect_data.timer.reset();
                effect_data.duration = IntArg(0);
                effect_data.acceleration_vec.make_from_vector(effect_data.angle, effect_data.acceleration);
                if (this->effect_index != 0) {
                    SOUND_MANAGER.play_sound_validate(this->transform_sound);
                }
                break;
            }
            case EX_ANGLE_ACCEL: {
                this->active_effects |= EX_ANGLE_ACCEL;
                BulletEffectData& effect_data = this->effect_angle_accel;
                effect_data.acceleration = FloatArg(0);
                effect_data.angle = FloatArg(1);
                effect_data.timer.reset();
                effect_data.duration = IntArg(0);
                if (this->effect_index != 0) {
                    SOUND_MANAGER.play_sound_validate(this->transform_sound);
                }
                break;
            }
            case EX_ANGLE: {
                this->active_effects |= current_type;
                BulletEffectData& effect_data = this->effect_angle;
                float speed_arg = FloatArg(1);
                if (!(speed_arg > -999990.0f)) {
                    speed_arg = this->speed;
                }
                effect_data.speed = speed_arg;
                float angle_arg = this->position.__bullet_effect_angle_jank(this->angle, FloatArg(0), FloatArg(2));
                switch (IntArg(2)) {
                    case 2:
                        effect_data.angle = reduce_angle(angle_arg + angle_to_player_from_point(&this->effect_saveangle.position));
                        break;
                    case 3:
                        effect_data.angle = reduce_angle(this->effect_saveangle.angle + angle_arg);
                        break;
                    case 0: case 1: case 4:
                        effect_data.angle = angle_arg;
                        break;
                    case 5: case 6:
                        effect_data.angle = REPLAY_RNG.rand_float_signed_range(FloatArg(0));
                        break;
                    case 7:
                        angle_arg = FloatArg(0);
                        if (angle_arg <= -999990.0f) {
                            angle_arg = this->angle;
                        }
                        if (angle_arg >= 990.0f) {
                            angle_arg = angle_to_player_from_point(&this->position);
                        }
                        effect_data.angle = reduce_angle(angle_arg);
                        effect_data.speed = this->speed + REPLAY_RNG.rand_float_signed_range(FloatArg(1));
                        break;
                }
                effect_data.timer.reset();
                effect_data.duration = IntArg(0);
                effect_data.max_count = IntArg(1);
                effect_data.count = 0;
                effect_data.type = IntArg(2);
                effect_data.__int_44 = IntArg(3);
                break;
            }
            case EX_BOUNCE: {
                this->active_effects |= current_type;
                BulletEffectData& effect_data = this->effect_bounce;
                effect_data.speed = FloatArg(0);
                if (IntArg(1) & 0x20) {
                    effect_data.size = { FloatArg(1), FloatArg(2) };
                } else {
                    effect_data.size = { 384.0f, 448.0f };
                }
                effect_data.max_count = IntArg(0);
                effect_data.duration = 0;
                effect_data.type = IntArg(1);
                break;
            }
            case EX_INVULN:
                this->invulnerable_time = IntArg(0);
                break;
            case EX_OFFSCREEN: {
                this->active_effects |= EX_OFFSCREEN;
                BulletEffectData& effect_data = this->effect_offscreen;
                effect_data.timer.set(IntArg(0));
                effect_data.__offscreen_unknown = IntArg(1);
                break;
            }
            case EX_PLAYSOUND:
                SOUND_MANAGER.play_sound_positioned(IntArg(0), this->position.x);
                break;
            case EX_DELETE:
                if (IntArg(0) == true) {
                    this->cancel_script_id = -1;
                }
                this->cancel(CancelType0);
                break;
            case EX_SETSPRITE: {
                this->sprite = IntArg(0);
                this->color = WordArg(1) & INT16_MAX;
                BulletSpriteData& bullet_sprite_data = BULLET_SPRITE_DATA[IntArg(0)];
                this->hitbox_size.x = bullet_sprite_data.hitbox_size;
                this->hitbox_size.y = bullet_sprite_data.hitbox_size;
                this->layer = bullet_sprite_data.layer;
                this->vm.reset();
                this->vm.controller.on_sprite_lookup_index = 1;
                this->vm.controller.associated_entity = this;
                BULLET_MANAGER_PTR->bullet_anm->__sub_477D60(&this->vm, BULLET_SPRITE_DATA[IntArg(0)].color_data[0].sprite_id);
                this->vm.data.origin_mode = 1;
                this->__anm_tree_id.mark_tree_for_delete();
                if (int32_t script = BULLET_SPRITE_DATA[IntArg(0)].__anm_script_114) {
                    this->__anm_tree_id = BULLET_MANAGER_PTR->bullet_anm->instantiate_vm_to_world_list_back(script, &this->position);
                }
                switch (BULLET_SPRITE_DATA[this->sprite].__int_10C) {
                    case 0:
                        this->cancel_script_id = this->color * 2 + 4;
                        break;
                    case 1:
                        this->cancel_script_id = BULLET_IDK_DATA[this->color];
                        break;
                    case 2:
                        this->cancel_script_id = -1;
                        this->__circular_hitbox = true;
                        break;
                    case 3:
                        this->cancel_script_id = 16;
                        break;
                    case 4:
                        this->cancel_script_id = 6;
                        break;
                    case 5:
                        this->cancel_script_id = 12;
                        break;
                    case 6:
                        this->cancel_script_id = BULLET_SPRITE_DATA[this->sprite].color_data[this->color].cancel_script;
                        this->__circular_hitbox = true;
                        break;
                    case 7:
                        this->cancel_script_id = 260;
                        this->__circular_hitbox = true;
                        break;
                    case 8:
                        this->cancel_script_id = 263;
                        this->__circular_hitbox = true;
                        break;
                    case 9:
                        this->cancel_script_id = 266;
                        this->__circular_hitbox = true;
                        break;
                    case 10:
                        this->cancel_script_id = 275;
                        this->__circular_hitbox = true;
                        break;
                }
                if (IntArg(2) & 0x8000) {
                    this->vm.interrupt(2);
                }
                break;
            }
            case EX_WRAP: {
                this->active_effects |= EX_WRAP;
                BulletEffectData& effect_data = this->effect_wrap;
                effect_data.max_count = IntArg(0);
                effect_data.wrap_count = 0;
                effect_data.flags = IntArg(1);
                break;
            }
            case EX_REACT:
                this->__ex_func_a = IntArg(0);
                ++effect_index;
                continue;
            case EX_SHOOT: {
                ShooterData bullet_shooter(0);
                bullet_shooter.position = this->position;
                bullet_shooter.aim_mode = WordArg(0);
                bullet_shooter.start_transform = IntArg(1);
                bullet_shooter.count1 = WordArg(2);
                bullet_shooter.transform_sound = -1;
                bullet_shooter.count2 = WordArg(3);
                ZUNAngle angle;
                float angle_arg = FloatArg(0);
                if (angle_arg <= -999990.0f) {
                    angle = this->angle;
                }
                else if (999990.0f < angle_arg && angle_arg < 1999990.0f) {
                    // Somehow this can end up only running half of an angle reduce? WTF?
                    angle = angle_to_player_from_point(&this->position);
                }
                else {
                    angle = angle_arg;
                }
                bullet_shooter.angle1 = angle;
                bullet_shooter.angle2 = FloatArg(1);
                float speed_arg = FloatArg(2);
                if (speed_arg <= -999990.0f) {
                    speed_arg = this->speed;
                }
                bullet_shooter.speed1 = speed_arg;
                BOOL cancel_current_bullet = IntArgEx(6);
                bullet_shooter.type = IntArgEx(4);
                bullet_shooter.color = IntArgEx(5);
                bullet_shooter.speed2 = FloatArg(3);
                bullet_shooter.flags = 0;
                memcpy(bullet_shooter.effects, this->effects, sizeof(bullet_shooter.effects));
                BULLET_MANAGER_PTR->shoot_bullets(&bullet_shooter);
                ++effect_index;
                if (cancel_current_bullet) {
                    this->cancel(CancelType0);
                }
                continue;
            }
            case EX_LOOP: {
                int32_t new_loop_index = IntArg(1);
                int32_t current_loop_index;
                if (new_loop_index <= 0) goto default_loop;
                current_loop_index = this->effect_loop_index;
                switch (current_loop_index) {
                    case 0:
                        this->effect_loop_index = new_loop_index;
                        effect_index = IntArg(0);
                        continue;
                    case 1:
                        this->effect_loop_index = 0;
                        break;
                    default:
                        this->effect_loop_index = --current_loop_index;
                    default_loop:
                        effect_index = IntArg(0);
                        continue;
                }
                break;
            }
            case EX_VELADD: {
                this->active_effects |= EX_VELADD;
                BulletEffectData& effect_data = this->effect_veladd;
                effect_data.velocity.make_from_vector3(FloatArg(0), FloatArg(1));
                effect_data.angle = FloatArg(0);
                effect_data.speed = FloatArg(1);
                effect_data.duration = IntArg(0);
                effect_data.timer.reset();
                break;
            }
            case EX_VEL: {
                float angle_arg = FloatArg(0);
                if (angle_arg >= 990.0f) {
                    angle_arg -= 999.0f;
                    angle_arg += angle_to_player_from_point(&this->position);
                    this->angle = reduce_angle(angle_arg);
                }
                else if (angle_arg >= -990.0f) {
                    this->angle = angle_arg;
                }
                float speed_arg = FloatArg(1);
                if (speed_arg >= -990.0) {
                    this->speed = speed_arg;
                } else {
                    speed_arg = this->speed;
                }
                this->velocity.make_from_vector(this->angle, speed_arg);
                break;
            }
            case EX_MOVE: {
                this->active_effects |= EX_MOVE;
                BulletEffectData& effect_data = this->effect_move;
                effect_data.target = { FloatArg(0), FloatArg(1) };
                if (IntArg(1) & 0x100) {
                    effect_data.target += this->position;
                }
                effect_data.speed = this->speed;
                effect_data.target.z = 0.0f;
                effect_data.duration = IntArg(0);
                effect_data.mode = IntArg(1);
                effect_data.timer.reset();
                this->effect_move_interp.initial_value = this->position;
                this->effect_move_interp.final_value = effect_data.target;
                this->effect_move_interp.bezier1 = UNKNOWN_FLOAT3_A;
                this->effect_move_interp.bezier2 = UNKNOWN_FLOAT3_A;
                this->effect_move_interp.end_time = IntArg(0);
                this->effect_move_interp.mode = IntArg(1);
                this->effect_move_interp.time.reset();
                break;
            }
            case EX_BRIGHT:
                switch (IntArg(0)) {
                    case 2:
                        this->vm.data.blend_mode = 2;
                        break;
                    case 1:
                        this->vm.data.blend_mode = 1;
                        break;
                    default:
                        this->vm.data.blend_mode = 0;
                        break;
                }
                break;
            case EX_SAVEANGLE:
                this->effect_saveangle.position = this->position;
                //this->effect_saveangle.position.copy(this->position);
                this->effect_saveangle.angle = this->angle;
                this->effect_saveangle.speed = this->speed;
                ++effect_index;
                continue;
            case EX_SIZE: {
                this->active_effects |= EX_SIZE;
                this->scale_interp.initial_value = FloatArg(0);
                this->scale_interp.final_value = FloatArg(1);
                this->scale_interp.bezier1 = 0.0f;
                this->scale_interp.bezier2 = 0.0f;
                this->scale_interp.end_time = IntArg(0);
                this->scale_interp.mode = IntArg(1);
                this->scale_interp.time.reset();
                this->__scale_enabled = true;
                break;
            }
            case EX_VELTIME: {
                this->active_effects |= EX_VELTIME;
                BulletEffectData& effect_data = this->effect_veltime;
                effect_data.speed = (FloatArg(0) - this->speed) / IntArg(0);
                effect_data.angle = this->position.__bullet_effect_angle_jank(this->angle, FloatArg(1), FloatArg(2));
                effect_data.timer.reset();
                effect_data.duration = IntArg(0);
                effect_data.velocity.make_from_vector(effect_data.angle, effect_data.speed);
                if (this->effect_index != 0) {
                    SoundManager::play_sound_validate(this->transform_sound);
                }
                break;
            }
            case EX_ENEMY: {
                EnemyInitData enemy_data;
                enemy_data.position = this->position;
                enemy_data.int_vars[0] = IntArg(0); // I0 = etEx a
                enemy_data.int_vars[1] = IntArg(1); // I1 = etEx b
                enemy_data.int_vars[2] = IntArg(2); // I2 = etEx c
                enemy_data.int_vars[3] = IntArg(3); // I3 = etEx d
                enemy_data.mirrored = false;
                enemy_data.__basic_anm_update = false;
                enemy_data.float_vars[4] = 0.0f;
                enemy_data.float_vars[5] = 0.0f;
                enemy_data.float_vars[6] = 0.0f;
                enemy_data.float_vars[7] = 0.0f;
                enemy_data.parent_id = 0;
                enemy_data.life = 10000;
                enemy_data.score = 0;
                enemy_data.item_drop = 0;
                enemy_data.float_vars[0] = FloatArg(0); // F0 = etEx r
                enemy_data.float_vars[1] = FloatArg(1); // F1 = etEx s
                enemy_data.float_vars[2] = FloatArg(2); // F2 = etEx m
                enemy_data.float_vars[3] = FloatArg(3); // F3 = etEx n
                ENEMY_MANAGER_PTR->allocate_new_enemy(current_effect.string, &enemy_data, UNUSED_DWORD);
                break;
            }
            case EX_LASER: {
                switch (IntArg(0)) {
                    case 1: {
                        LaserInfiniteParams laser_params(0); // 0xA8
                        laser_params.__speed_1 = 8.0f;
                        laser_params.velocity.x = 0.0f;
                        laser_params.velocity.y = 0.0f;
                        laser_params.velocity.z = 0.0f;
                        laser_params.__angle_18 = 0.0f;
                        laser_params.angular_velocity = 0.0f;
                        laser_params.length = 0.0f;
                        laser_params.__float_24 = 0.0f;
                        laser_params.width = 0.0f;
                        laser_params.start_time = 0;
                        laser_params.expand_time = 0;
                        laser_params.duration = 0;
                        laser_params.stop_time = 0;
                        laser_params.shot_sound = 0;
                        laser_params.transform_sound = 0;
                        laser_params.laser_id = 0;
                        laser_params.distance = 0.0f;
                        __builtin_memcpy(laser_params.effects, this->effects, sizeof(laser_params.effects));
                        int32_t flags = IntArg(3);
                        laser_params.position = this->position;
                        laser_params.flags = (flags & 0xFD) | 0x2;
                        laser_params.sprite = IntArg(1);
                        laser_params.color = IntArg(2);
                        laser_params.__start_ex = (uint8_t)(flags >> 8);
                        ZUNAngle angle;
                        float angle_arg = FloatArg(0);
                        if (angle_arg <= -999990.0f) {
                            angle = this->angle;
                        } else if (999990.0f < angle_arg && angle_arg < 1999990.0f) {
                            // Somehow this can end up only running half of an angle reduce? WTF?
                            clang_forceinline angle = angle_to_player_from_point(&this->position);
                        } else {
                            angle = angle_arg;
                        }
                        laser_params.__angle_18 = angle;
                        float speed_arg = FloatArg(1);
                        if (speed_arg <= -999990.0f) {
                            speed_arg = this->speed;
                        }
                        ++effect_index;
                        laser_params.__float_24 = FloatArg(2);
                        laser_params.start_time = IntArgEx(4);
                        laser_params.expand_time = IntArgEx(5);
                        laser_params.duration = IntArgEx(6);
                        laser_params.length = FloatArg(3);
                        laser_params.stop_time = IntArgEx(7);
                        laser_params.width = FloatArgEx(4);
                        laser_params.shot_sound = 18;
                        laser_params.transform_sound = -1;
                        laser_params.distance = FloatArgEx(5);
                        LASER_MANAGER_PTR->allocate_new_laser(1, &laser_params);
                        ++effect_index;
                        if (flags & 0x10000) {
                            this->cancel(CancelType0);
                        }
                        continue;
                    }
                    case 0: {
                        LaserLineParams laser_params(0); // 0x528
                        laser_params.flags = 0;
                        laser_params.__angle_C = 0.0f;
                        laser_params.__length_related = 0.0f;
                        laser_params.length = 0.0f;
                        laser_params.__float_18 = 0.0f;
                        laser_params.width = 0.0f;
                        laser_params.__speed_1 = 0.0f;
                        laser_params.distance = 0.0f;
                        laser_params.effect_index = 0;
                        laser_params.shot_sound = 0;
                        laser_params.transform_sound = 0;
                        __builtin_memcpy(laser_params.effects, this->effects, sizeof(laser_params.effects));
                        BOOL cancel_current_bullet = IntArg(3);
                        laser_params.position = this->position;
                        laser_params.sprite = IntArg(1);
                        laser_params.color = IntArg(2);
                        ZUNAngle angle;
                        float angle_arg = FloatArg(0);
                        if (angle_arg <= -999990.0f) {
                            angle = this->angle;
                        } else if (999990.0f < angle_arg && angle_arg < 1999990.0f) {
                            // Somehow this can end up only running half of an angle reduce? WTF?
                            clang_forceinline angle = angle_to_player_from_point(&this->position);
                        } else {
                            angle = angle_arg;
                        }
                        laser_params.__angle_C = angle;
                        float speed_arg = FloatArg(1);
                        if (speed_arg <= -999990.0f) {
                            speed_arg = this->speed;
                        }
                        ++effect_index;
                        laser_params.__unknown_flag_A = true;
                        laser_params.__speed_1 = speed_arg;
                        laser_params.length = FloatArg(2);
                        laser_params.__length_related = FloatArg(3);
                        laser_params.__float_18 = FloatArgEx(4);
                        laser_params.shot_sound = IntArgEx(4);
                        laser_params.width = FloatArgEx(5);
                        laser_params.transform_sound = IntArgEx(5);
                        laser_params.distance = FloatArgEx(6);
                        laser_params.effect_index = IntArgEx(6);
                        LASER_MANAGER_PTR->allocate_new_laser(0, &laser_params);
                        ++effect_index;
                        if (cancel_current_bullet) {
                            this->cancel(CancelType0);
                        }
                        continue;
                    }
                }
                continue;
            }
            case EX_DELAY:
                if (IntArg(0) <= 0) {
                    ++effect_index;
                    continue;
                }
                this->active_effects |= EX_DELAY;
                this->effect_delay.timer.set(IntArg(0));
                break;
            case EX_LAYER:
                this->layer = IntArg(0);
                ++effect_index;
                continue;
            case EX_HITBOX: {
                float hitbox_size = FloatArg(0);
                if (0.0f > hitbox_size) {
                    hitbox_size = BULLET_SPRITE_DATA[this->sprite].hitbox_size;
                }
                this->hitbox_size.y = hitbox_size;
                this->hitbox_size.x = hitbox_size;
                break;
            }
            case EX_WAIT:
                if (IntArg(0) <= 0) {
                    ++effect_index;
                    continue;
                }
                this->active_effects |= EX_WAIT;
                this->effect_wait.timer.set(IntArg(0));
                break;
            case EX_HOMING: {
                this->active_effects |= EX_HOMING;
                BulletEffectData& effect_data = this->effect_homing;
                effect_data.speed = FloatArg(0);
                effect_data.angle = FloatArg(1);
                effect_data.target.x = FloatArg(2);
                effect_data.timer.reset();
                effect_data.duration = IntArg(0);
                break;
            }
            default:
                break;
        }
        ++effect_index;
    }
}

#pragma pop_macro("IntArg")
#pragma pop_macro("ShortArg")
#pragma pop_macro("WordArg")
#pragma pop_macro("FloatArg")

forceinline ZUNResult thiscall EnemyData::update() {
    if (ZUN_FAILED(this->__move())) {
        return ZUN_ERROR;
    }
    if (ZUN_FAILED(this->vm->run_ecl(this->ecl_time.get_scale_unsafe()))) {
        return ZUN_ERROR;
    }
    if (auto func_set_func = this->func_set_func) {
        if (ZUN_FAILED(func_set_func(this))) {
            return ZUN_ERROR;
        }
    }
    return ZUN_SUCCESS;
}

inline const char* Enemy::check_timer_callbacks() {
    for (size_t i = 0; i < MAX_CALLBACKS; ++i) {
        if (this->data.callbacks[i].life >= 0) {
            int32_t time_threshold = this->data.callbacks[i].time;
            if (time_threshold > 0) {
                if (this->data.is_boss) {
                    GUI_PTR->update_spell_timer(time_threshold - this->data.ecl_time);
                }
                if (this->data.ecl_time >= this->data.callbacks[i].time) {
                    this->data.life.current = this->data.callbacks[i].life;
                    this->data.callbacks[i].life = -1;
                    this->data.ecl_time.reset();
                    this->data.__unknown_flag_L = true;

                    Spellcard* spellcard = SPELLCARD_PTR;
                    if (!spellcard->__timeout_spell) {
                        spellcard->__sub_409AD0();
                        ENEMY_MANAGER_PTR->can_capture_spell = false;
                    }
                    else if (spellcard->__inline_sub_B()) {
                        this->data.__unknown_flag_L = false;
                        GAME_MANAGER.globals.__int_90 += this->data.chapter_spawn_weight;
                    }
                    this->data.chapter_spawn_weight = 0;

                    return this->data.callbacks[i].time_sub;
                }
                break;
            }
        }
    }
    return NULL;
}

inline const char* Enemy::check_life_callbacks() {
    int32_t life = this->data.life.current;
    for (size_t i = 0; i < MAX_CALLBACKS; ++i) {
        int32_t life_threshold = this->data.callbacks[i].life;
        if (life_threshold >= 0) {
            this->data.life.remaining_current_attack = life - life_threshold;
            this->data.life.starting_value_for_next_attack = this->data.callbacks[i].life;
            life_threshold = this->data.callbacks[i].life;
            if (life <= life_threshold) {
                this->data.add_spawn_weight_to_chapter_destroy();
                this->data.callbacks[i].life = -1;
                this->data.ecl_time.reset();
                this->data.__unknown_flag_L = false;
                return this->data.callbacks[i].life_sub;
            }
            break;
        }
    }
    return NULL;
}

// 0x42ED40
dllexport gnu_noinline ZUNResult thiscall EnemyData::__update_state() {
    BombBase* bomb = BOMB_PTR;
    if (this->bomb_shield) {
        if (bomb->active && !this->bomb_shield_active) {
            this->anm_vms[0].__sub_488FD0(this->current_anm_script = this->bombshield_on_anm);
            this->disable_hitbox = true;
            this->bomb_shield_active = true;
        } else if (this->bomb_shield_active) {
            this->anm_vms[0].__sub_488FD0(this->current_anm_script = this->bombshield_off_anm);
            this->disable_hitbox = false;
            this->bomb_shield_active = false;
        }
    } else if (this->bomb_shield_active) {
        this->anm_vms[0].__sub_488FD0(this->current_anm_script = this->bombshield_off_anm);
        this->disable_hitbox = false;
        this->bomb_shield_active = false;
    }
    if (this->delete_as_bullet) {
        Float3* damage_pos = &this->position_of_last_damage_source_to_hit;
        int32_t A = 0;
        Float2* hitbox_size = &this->hitbox_size;
        Float3* position = &this->current_motion.position;
        EnemyID id = this->enemy()->id;
        float radius;
        float rotation;
        if (!this->rectangular_hitbox) {
            rotation = 0.0f;
            radius = this->hitbox_size.x * 0.5f;
        } else {
            rotation = this->hitbox_rotation;
            radius = 0.0f;
        }
        if (
            HitboxManager::enm_compute_damage_sources(position, hitbox_size, rotation, radius, &A, damage_pos, true, id) != 0 &&
            A != 0
        ) {
            if (this->enemy()->kill()) {
                return ZUN_SUCCESS2; // triggers the fail condition
            }
        }
    }
    if (const char* timer_callback_to_run = this->enemy()->check_timer_callbacks()) {
        this->ecl_time.reset();
        this->reinitialize_vm_with_sub(timer_callback_to_run);
        if (ZUN_FAILED(this->run_ecl())) {
            return ZUN_ERROR;
        }
    }

    int32_t B = 0;
    this->__damaged_this_frame = false;
    if (this->has_active_hitbox()) {
        float radius = this->hitbox_size.x;
        Float2* hitbox_size = &this->hitbox_size;
        int32_t damage = 0;
        if (radius > 0.0f) {
            Float3* damage_pos = &this->position_of_last_damage_source_to_hit;
            Float3* position = &this->current_motion.position;
            EnemyID id = this->enemy()->id;
            float rotation;
            if (!this->rectangular_hitbox) {
                rotation = 0.0f;
                radius = this->hitbox_size.x * 0.5f;
            } else {
                rotation = this->hitbox_rotation;
                radius = 0.0f;
            }
            damage = HitboxManager::enm_compute_damage_sources(position, hitbox_size, rotation, radius, &B, damage_pos, false, id);
            damage *= PLAYER_PTR->damage_multiplier;
        }
        if (auto* extra_damage_func = this->extra_damage_func) {
            damage += extra_damage_func(this, damage);
        }
        int32_t more_damage = this->__int_50D4;
        if (more_damage > 0) {
            damage += more_damage;
        }
        switch (PLAYER_PTR->data.state) {
            case 0: case 2:
                damage /= 5;
        }
        if (GUI_PTR->msg_vm_active()) {
            damage = 0;
        }
        if (damage > 0) {
            if (B) {
                int32_t life = this->life.current;
                if (damage >= life) {
                    ENEMY_MANAGER_PTR->__int_AC += (damage - life) / 4 + life;
                }
                else {
                    ENEMY_MANAGER_PTR->__int_AC += damage;
                }
            }
            else {
                ENEMY_MANAGER_PTR->__int_B0 += damage;
            }
        }
        if (BOMB_PTR->is_active()) {
            float bomb_multiplier = this->bomb_damage_multiplier;
            if (bomb_multiplier < 1.0f) {
                if (damage && bomb_multiplier <= 0.0f) {
                    SOUND_MANAGER.play_sound_positioned(36, this->current_motion.position.x);
                }
                damage *= bomb_multiplier;
            }
        }
        if (damage) {
            ++UNKNOWN_COUNTER_A;
            if (SPELLCARD_PTR->__inline_sub_C()) {
                damage /= 60;
            }
            this->life.take_damage(damage, this->is_invulnerable());
            this->__timer_5118.set(30);

            if (const char* life_callback_to_run = this->enemy()->check_life_callbacks()) {
                this->ecl_time.set(0);
                this->reinitialize_vm_with_sub(life_callback_to_run);
                if (ZUN_FAILED(this->run_ecl())) {
                    return ZUN_ERROR;
                }
            }

            if (this->life.current <= 0 & ~this->no_delete) {
                if (this->enemy()->kill()) {
                    return ZUN_SUCCESS2; // triggers the fail condition
                }
            }
            this->__damaged_this_frame = true;
        }
    }

    if (
        this->life.__unknown_flag_A &&
        this->enemy()->kill()
    ) {
        return ZUN_SUCCESS2; // triggers the fail condition
    }

    if (
        this->has_active_collision() &&
        this->__basic_anm_update &&
        (!ENEMY_MANAGER_PTR->__int_164 || this->is_boss)
    ) {
        if (auto* extra_hitbox_func = this->extra_hitbox_func) {
            extra_hitbox_func(this);
        }
        else {
            CollisionResult result;
            if (!this->rectangular_hitbox) {
                result = PLAYER_PTR->check_collision_circle(&this->current_motion.position, this->collision_size.x, LethalCollisionTest);
            }
            else {
                AnmVM* main_vm = this->anm_vms[0].get_vm_ptr();
                float X = 0.0f;
                float Y = this->collision_size.y * 0.5f;
                float Z = 0.0f;
                if (main_vm) {
                    float angle = reduce_angle<NoInline>(main_vm->data.rotation.z + HALF_PI_f);
                    // This looks a lot like rotate_around_origin,
                    // but the register usage doesn't look like
                    // it was using actual Float2/Float3
                    float y_unit = zsinf(angle);
                    float x_unit = zcosf(angle);
                    X = (x_unit * X) - (y_unit * Y);
                    Y = (x_unit * Y) + (y_unit * X);
                }
                float rotation = this->hitbox_rotation;
                float width = this->collision_size.y;
                Float3 position;
                position.x = this->current_motion.position.x + X;
                position.y = this->current_motion.position.y + Y;
                position.z = this->current_motion.position.z + Z;
                float length = this->collision_size.x;
                result = PLAYER_PTR->__check_collision_rotated_rectangle(&position, rotation, width, length, LethalCollisionTest);
            }
            if (
                this->grazable &&
                result == GrazeCollision &&
                this->ecl_time.is_multiple_of(6)
            ) {
                PLAYER_PTR->do_graze(&PLAYER_PTR->data.position);
            }
        }
    }

    if (AnmVM* main_vm = this->anm_vms[0].get_vm_ptr()) {
        if (!this->__int_50E4) {
            if (this->__anm_related_flag_A) {
                if (this->ecl_time.is_multiple_of(4)) {
                    main_vm->data.color2 = PackD3DCOLOR(255, 255, 0, 255);
                    main_vm->data.color_mode = 1;
                }
                else {
                    main_vm->data.color_mode = 0;
                }
            }
            if (
                this->__damaged_this_frame &&
                !this->slowdown_immune // ???
            ) {
                main_vm->data.color2 = PackD3DCOLOR(255, 0, 0, 255);
                main_vm->data.color_mode = 1;
                int32_t hit_sound = this->hit_sound;
                this->__int_50E4 = 4;
                if (hit_sound < 0) {
                    int32_t health_remaining;
                    if (
                        !(this->__unknown_flag_O | this->is_boss) || // make this another helper function
                        !SPELLCARD_PTR->__enemy_is_low_health(this, 200, 900)
                    ) {
                        SOUND_MANAGER.play_sound_positioned(34, this->current_motion.position.x);
                    }
                    else {
                        SOUND_MANAGER.play_sound_positioned(35, this->current_motion.position.x);
                    }
                }
                else {
                    SOUND_MANAGER.play_sound_positioned(hit_sound, this->current_motion.position.x);
                }
            }
            else {
                if (this->ecl_time.is_multiple_of(4)) {
                    if (
                        (this->__unknown_flag_O | this->is_boss) &&
                        SPELLCARD_PTR->__enemy_is_low_health(this, 100, 500)
                    ) {
                        main_vm->data.color2 = PackD3DCOLOR(255, 0, 0, 255);
                        main_vm->data.color_mode = 1;
                    }
                }
                else {
                    main_vm->data.color_mode = 0;
                }
            }
        }
        else {
            main_vm->data.color_mode = 0;
            --this->__int_50E4;
        }
    }

    if (this->__timer_5118 > 0) {
        this->__timer_5118--;
    }
    return ZUN_SUCCESS;
}

// 0x42FF80
dllexport gnu_noinline ZUNResult thiscall EnemyData::on_tick() {
    if (!this->__unknown_flag_A) {
        this->__unknown_flag_A = true;
        if (ZUN_FAILED(this->update())) {
            return ZUN_ERROR;
        }
        if (ZUN_FAILED(this->__update_state())) {
            return ZUN_ERROR;
        }
        this->__update_fog();
        if (!this->__basic_anm_update) {
            for (size_t i = 0; i < ENEMY_ANM_SLOTS; ++i) {
                if (AnmVM* vm = this->anm_vms[i].get_vm_ptr()) {
                    Float3 new_position = this->current_motion.position + this->anm_positions[i];
                    int32_t vm_index = this->anm_vm_indices[i];
                    if (vm_index >= 0) {
                        if (AnmVM* vm2 = this->anm_vms[vm_index].get_vm_ptr()) {
                            new_position += vm2->data.position;
                        }
                    }
                    vm->set_controller_position(&new_position);
                    if (vm->data.auto_rotate) {
                        float movement_angle = this->current_motion.axis_velocity.direction();
                        vm->set_z_rotation(movement_angle);
                        this->hitbox_rotation = movement_angle;
                    }
                }
            }
        } else {
            for (size_t i = 0; i < ENEMY_ANM_SLOTS; ++i) {
                this->anm_vms[i].set_controller_position(&this->current_motion.position);
            }
        }
        this->drops.limited_timer++;
        if (this->invulnerable_timer > 0) {
            this->invulnerable_timer--;
        }
        if (this->no_collision_timer > 0) {
            this->no_collision_timer--;
        }
        this->boss_timer++;
        this->ecl_time++;
    }
    return ZUN_SUCCESS;
}

// 0x4394A0
dllexport gnu_noinline int32_t fastcall EnemyData::extra_damage_func2(EnemyData* enemy_data, int32_t prev_damage) {
    Float3 position = enemy_data->current_motion.position;
    int32_t dummy = 0; // 
    int32_t new_damageA = 0; // EBX
    int32_t new_damageB = 0; // EDI
    if (AnmVM* anm_vm = enemy_data->anm_vms[1].get_vm_ptr()) {
        position.y += 24.0f;
        Float2 hurtbox = {
            anm_vm->data.scale.x * 192.0f,
            anm_vm->data.scale.y * 32.0f
        };
        new_damageB = HitboxManager::enm_compute_damage_sources(&position, &hurtbox, anm_vm->data.rotation.z, 0.0f, &dummy, NULL, false, enemy_data->enemy()->id);
        position.y += 32.0f;
        new_damageA = HitboxManager::enm_compute_damage_sources(&position, NULL, 0.0f, 48.0f, &dummy, NULL, false, enemy_data->enemy()->id);
    }
    return new_damageA + new_damageB + prev_damage;
}

inline void EclContext::step_float_interps() {
    nounroll for (size_t i = 0; i < countof(this->float_interps); ++i) {
        if (this->float_interps[i].end_time) {
            EclInstruction* current_instruction = this->get_instruction(this->float_interp_locations[i].sub_index, this->float_interp_locations[i].instruction_offset);
            float* value_write;
            if (current_instruction->param_mask & 2) {
                float value = FloatArg(1);
                int32_t value_as_int = value;
                if (value >= 0.0f) {
                    value_write = &this->stack.ref_offset<float>(this->float_interp_stack_offsets[i]);
                } else {
                    value_write = this->vm->get_float_ptr(value_as_int);
                }
            } else {
                value_write = NULL;
            }
            *value_write = this->float_interps[i].step();
        }
    }
}

// 0x4369E0
dllexport gnu_noinline int32_t thiscall EnemyData::ecl_enm_create() {
    using namespace Ecl;

    if (ENEMY_MANAGER_PTR->is_below_enemy_limit()) {
        EclInstruction* current_instruction = this->vm->current_context->get_current_instruction();
        int32_t sub_name_length = IntArg(0) + sizeof(IntArg(0));
        int32_t enm_args_offset = sub_name_length / sizeof(DWORD);

        EnemyInitData init_data;
        init_data.position = {};
        init_data.mirrored = false;
        init_data.__basic_anm_update = false;
        
        init_data.position.x = this->parse_float_as_arg(1, FloatArg(enm_args_offset));
        init_data.position.y = this->parse_float_as_arg(2, FloatArg(enm_args_offset + 1));

        // This section looks *really* weird...
        uint32_t opcode = current_instruction->opcode;
        if (
            opcode == enemy_create_rel ||
            opcode == enemy_create_rel_stage ||
            opcode == __enemy_create_rel_2 ||
            opcode == enemy_create_rel_stage_mirror ||
            opcode == enemy_create_rel_mirror
        ) {
            init_data.position.x += this->current_motion.position.x;
            init_data.position.y += this->current_motion.position.y;
        }
        if (
            opcode == enemy_create_rel_stage_mirror ||
            opcode == enemy_create_abs_stage_mirror ||
            opcode == enemy_create_rel_mirror ||
            opcode == enemy_create_abs_mirror
        ) {
            init_data.mirrored = true;
        }
        if (this->get_mirror_flag()) {
            init_data.position.x *= -1.0f;
            init_data.mirrored ^= 1;
        }

        init_data.life = this->parse_int_as_arg(3, IntArg(enm_args_offset + 2));
        init_data.score = this->parse_int_as_arg(4, IntArg(enm_args_offset + 3));
        init_data.item_drop = this->parse_int_as_arg(5, IntArg(enm_args_offset + 4));
        __builtin_memcpy(init_data.int_vars, this->int_vars, sizeof(this->int_vars));
        __builtin_memcpy(init_data.float_vars, this->float_vars, sizeof(this->float_vars));
        init_data.parent_id = this->enemy()->id;
        ENEMY_MANAGER_PTR->allocate_new_enemy(StringArg(4), &init_data);
    }
    return 0;
}

// 0x436BB0
dllexport gnu_noinline void thiscall EnemyData::anm_set_slot_impl() {
    int32_t slot = this->get_int_arg(0);
    int32_t sprite = this->get_int_arg(1);
    AnmID& id = this->anm_vms[slot];
    id.mark_tree_for_delete();
    if (sprite >= 0) {
        sprite = this->get_int_arg(1);
        id = ENEMY_MANAGER_PTR->anm_file_lookup(this->anm_source_index)->instantiate_vm_to_world_list_front(sprite, this->anm_base_layer + 7);
        if (slot == 0) {
            this->anm_slot_0_script = this->get_int_arg(1);
            this->anm_slot_0_source_index = this->anm_source_index;
        }
        AnmVM* vm = id.get_vm_ptr();
        if (slot == 0) {
            this->final_sprite_size.x = vm->get_scaled_sprite_y_size();
            this->final_sprite_size.y = vm->get_scaled_sprite_x_size();
        }
        if (this->intangible) {
            id.__tree_clear_visible2();
        }
    }
}

inline void thiscall EnemyData::anm_set_slot_main_impl() {
    int32_t slot = this->get_int_arg(0);
    int32_t sprite = this->get_int_arg(1);
    AnmID& id = this->anm_vms[slot];
    id.mark_tree_for_delete();
    id = ENEMY_MANAGER_PTR->anm_file_lookup(this->anm_source_index)->instantiate_vm_to_world_list_front(sprite, this->anm_base_layer + 7);
    AnmVM* vm = id.get_vm_ptr();
    if (slot == 0) {
        this->final_sprite_size.x = vm->get_scaled_sprite_y_size();
        this->final_sprite_size.y = vm->get_scaled_sprite_x_size();
    }
    if (this->intangible) {
        id.__tree_clear_visible2();
    }
    if (slot == 0) {
        this->__unknown_flag_I = true;
        this->current_anm_script = sprite;
        this->anm_slot_0_script = sprite;
        this->current_anm_pose = 0;
        this->anm_slot_0_source_index = this->anm_source_index;
    }
}

// 0x436CF0
dllexport gnu_noinline void thiscall EnemyData::ecl_set_anm_data() {
    using namespace Ecl;
    
    EclContext* current_context = this->vm->current_context;
    EclInstruction* current_instruction = current_context->get_current_instruction();

    int32_t slot = current_context->get_int_arg(0);
    if (slot <= ENEMY_ANM_SLOTS) {
        AnmVM* vm = this->anm_vms[slot].get_vm_ptr();
        if (!vm) {
            return;
        }

        switch (current_instruction->opcode) {
            case anm_rotate_slot: { // 319
                float rotation = this->vm->current_context->get_float_arg(1);
                vm->set_z_rotation(rotation);
                break;
            }
            case anm_scale_slot: { // 329
                float y_scale = this->vm->current_context->get_float_arg(2);
                float x_scale = this->vm->current_context->get_float_arg(1);
                vm->set_scale(x_scale, y_scale);
                break;
            }
            case anm_scale2_slot: { // 335
                float y_scale = this->vm->current_context->get_float_arg(2);
                float x_scale = this->vm->current_context->get_float_arg(1);
                vm->set_scale2(x_scale, y_scale);
                break;
            }
            case anm_scale_slot_interp: { // 330
                Float2 scale;
                scale.y = this->vm->current_context->get_float_arg(4);
                scale.x = this->vm->current_context->get_float_arg(3);
                int32_t mode = this->vm->current_context->get_int_arg(2);
                int32_t end_time = this->vm->current_context->get_int_arg(1);
                vm->data.scale_interp.__initialize_but_ignores_bezier(end_time, mode, vm->data.scale, scale);
                break;
            }
            case anm_color_slot: { // 325
                int B = this->vm->current_context->get_int_arg(3);
                int G = this->vm->current_context->get_int_arg(2);
                int R = this->vm->current_context->get_int_arg(1);
                RED(vm->data.color1) = R;
                GREEN(vm->data.color1) = G;
                BLUE(vm->data.color1) = B;
                break;
            }
            case anm_color_slot_interp: { // 326
                uint8_t R = this->vm->current_context->get_int_arg(3);
                uint8_t G = this->vm->current_context->get_int_arg(4);
                uint8_t B = this->vm->current_context->get_int_arg(5);
                int32_t mode = this->vm->current_context->get_int_arg(2);
                int32_t end_time = this->vm->current_context->get_int_arg(1);
                vm->data.color_interp.end_time = end_time;
                RGB color = {};
                vm->data.color_interp.bezier1 = color;
                vm->data.color_interp.bezier2 = color;
                color = { R, G, B };
                vm->data.color_interp.initial_value = {
                    RED(vm->data.color1),
                    GREEN(vm->data.color1),
                    BLUE(vm->data.color1)
                };
                vm->data.color_interp.mode = mode;
                vm->data.color_interp.final_value = color;
                vm->data.color_interp.time.reset();
                break;
            }
            case anm_alpha_slot: { // 327
                int32_t alpha = this->vm->current_context->get_int_arg(1);
                vm->set_alpha(alpha);
                break;
            }
            case anm_alpha_slot_interp: { // 328
                uint32_t alpha = this->vm->current_context->get_int_arg(3);
                int32_t mode = this->vm->current_context->get_int_arg(2);
                int32_t end_time = this->vm->current_context->get_int_arg(1);
                vm->data.alpha_interp.initial_value = vm->get_alpha();
                vm->data.alpha_interp.bezier1 = 0;
                vm->data.alpha_interp.bezier2 = 0;
                vm->data.alpha_interp.mode = mode;
                vm->data.alpha_interp.final_value = (uint8_t)alpha;
                vm->data.alpha_interp.time.reset();
                break;
            }
            case anm_alpha2_slot: { // 331
                int32_t alpha = this->vm->current_context->get_int_arg(1);
                ((uint8_t*)&vm->data.color2)[3] = alpha;
                break;
            }
            case anm_alpha2_slot_interp: { // 332
                uint32_t alpha = this->vm->current_context->get_int_arg(3);
                int32_t mode = this->vm->current_context->get_int_arg(2);
                int32_t end_time = this->vm->current_context->get_int_arg(1);
                vm->data.alpha2_interp.initial_value = ((uint8_t*)&vm->data.color2)[3];
                vm->data.alpha2_interp.mode = mode;
                vm->data.alpha2_interp.final_value = (uint8_t)alpha;
                vm->data.alpha2_interp.time.reset();
                if (vm->data.color_mode == 0) {
                    vm->data.color_mode = 1;
                }
                break;
            }
            case anm_move_position_slot_interp: { // 333
                float Y = this->vm->current_context->get_float_arg(4);
                float X = this->vm->current_context->get_float_arg(3);
                Float3 position = { X, Y, 0.0f };
                slot = this->vm->current_context->get_int_arg(0);
                int32_t mode = this->vm->current_context->get_int_arg(2);
                int32_t end_time = this->vm->current_context->get_int_arg(1);
                vm = this->anm_vms[slot].get_vm_ptr();
                vm->initialize_position_interp(end_time, mode, &vm->controller.position, &position);
                break;
            }
            case __anm_layer_slot: { // 336
                int32_t layer = this->vm->current_context->get_int_arg(1);
                vm->set_layer(layer);
                break;
            }
            case anm_blend_mode_slot: { // 337
                int32_t mode = this->vm->current_context->get_int_arg(1);
                vm->data.blend_mode = mode;
                break;
            }
        }
    }
}

inline void thiscall EnemyData::anm_play_main_impl() {
    this->anm_vms[0].mark_tree_for_delete();
    this->anm_vms[0] = ENEMY_MANAGER_PTR->anm_file_lookup(this->anm_source_index)->instantiate_vm_to_world_list_front(this->current_anm_script, this->anm_base_layer + 7);
    this->__unknown_flag_I = false;
    this->anm_slot_0_script = this->current_anm_script;
    this->current_anm_pose = 0;
    this->anm_slot_0_source_index = this->anm_source_index;
}

inline void thiscall EnemyData::anm_play_attack_impl() {
    int32_t slot = this->get_int_arg(0);
    this->anm_vms[slot].mark_tree_for_delete();
    this->anm_vms[slot] = ENEMY_MANAGER_PTR->anm_file_lookup(this->anm_source_index)->instantiate_vm_to_world_list_front(this->current_anm_script + 5, this->anm_base_layer + 7);
    AnmVM* vm = this->anm_vms[slot].get_vm_ptr();
    if (slot == 0) {
        this->final_sprite_size.x = vm->get_scaled_sprite_y_size();
        this->final_sprite_size.y = vm->get_scaled_sprite_x_size();
    }
    if (this->intangible) {
        this->anm_vms[slot].__tree_clear_visible2();
    }
}

inline void thiscall EnemyData::anm_play_attack_ex_impl() {
    int32_t slot = this->get_int_arg(0);
    int32_t attack_index = this->get_int_arg(1);
    AnmID& id = this->anm_vms[slot];
    id.mark_tree_for_delete();
    int32_t sprite = this->current_anm_script;
    if (attack_index >= 0) {
        sprite += attack_index + 5;
    }
    id = ENEMY_MANAGER_PTR->anm_file_lookup(this->anm_source_index)->instantiate_vm_to_world_list_front(sprite, this->anm_base_layer + 7);
    AnmVM* vm = this->anm_vms[slot].get_vm_ptr();
    if (slot == 0) {
        this->final_sprite_size.x = vm->get_scaled_sprite_y_size();
        this->final_sprite_size.y = vm->get_scaled_sprite_x_size();
    }
    if (this->intangible) {
        this->anm_vms[slot].__tree_clear_visible2();
    }
}

template <bool sanity_check_script>
inline float EnemyData::kill_effects() {
    SOUND_MANAGER.play_sound_positioned_validate(this->death_sound, this->current_motion.position.x);

    float angle = -HALF_PI_f;

    static constexpr float A = 1.0f / 25.0f;
    if (!(this->position_of_last_damage_source_to_hit.distance_squared(&this->current_motion.position) < A)) {
        angle = this->current_motion.position.angle_to(&this->position_of_last_damage_source_to_hit);
    }

    int32_t death_script = this->death_anm_script;
    if (sanity_check_script && death_script >= 0) {
        AnmID death_anm = ENEMY_MANAGER_PTR->anm_file_lookup(this->death_anm_index)->instantiate_vm_to_world_list_back(death_script, &this->current_motion.position, angle, 3);
        EFFECT_MANAGER_PTR->fill_available_slot(death_anm);
    }

    return angle;
}

// 0x48B030
dllexport gnu_noinline ZUNResult thiscall EclContext::call(EclContext* new_context, int32_t va_index, int32_t) {
    EclInstruction* current_instruction = this->get_current_instruction(); // EBP-8 (LOCAL.2)
    int32_t va_offset = IntArg(0) + sizeof(int32_t[va_index]); // EBP-10 (LOCAL.4)
    int32_t stack_pointer = new_context->stack.pointer; // EBP-14 (LOCAL.5)
    int32_t new_stack_pointer; // EBP-C (LOCAL.3)
    if (!stack_pointer) {
        new_stack_pointer = sizeof(int32_t[5]);
        new_context->stack.push(0);
    } else {
        new_stack_pointer = stack_pointer + sizeof(int32_t[4]);
    }
    if (++va_index < current_instruction->param_count) {
        uint8_t* stack_write_ptr = &new_context->stack.raw[new_stack_pointer];
        const EclRawValue* call_args_ptr = based_pointer<EclRawValue>(StringArg(4), va_offset);
        // Yes, all this weird pointer arithmetic seems to be in the original code.
        // There's too much BS for it to be simple.
        do {
            switch (call_args_ptr->type) {
                default:
                {
                    int32_t value = this->parse_int_as_arg_pop(va_index, IntArg((&call_args_ptr->integer - &IntArg(0)) + 1));
                    if (call_args_ptr->type2 == 'f') {
                        *(float*)stack_write_ptr = value;
                    } else {
                        *(int32_t*)stack_write_ptr = value;
                    }
                    break;
                }
                case 'f': case 'g':
                {
                    float value = this->parse_float_as_arg_pop(va_index, FloatArg((&call_args_ptr->real - &FloatArg(0)) + 1));
                    if (call_args_ptr->type2 == 'f') {
                        *(float*)stack_write_ptr = value;
                    } else {
                        *(int32_t*)stack_write_ptr = value;
                    }
                    break;
                }
            }
            call_args_ptr += 2;
            stack_write_ptr += sizeof(int32_t);
        } while (++va_index < current_instruction->param_count);
    }
    int32_t current_stack_pointer = new_context->stack.pointer; // EBP-14 (LOCAL.5)
    if (stack_pointer) {
        int32_t idk_what = new_context->stack.pop<int32_t>();
        new_context->stack.pointer = stack_pointer;
        new_context->stack.write_temp(-1, idk_what);
        new_context->stack.write_temp(-2, current_stack_pointer);
        new_context->stack.push(this->time);
        new_context->stack.push(this->location.instruction_offset);
        new_context->stack.push(this->location.sub_index);
    } else {
        new_context->stack.pointer = sizeof(int32_t);
        new_context->stack.write_temp(0, current_stack_pointer);
        new_context->stack.push(-1);
        new_context->stack.push(-1);
        new_context->stack.push(-1);
    }
    new_context->stack.pointer += sizeof(int32_t);
    std::swap(new_context, this->vm->current_context);
    const char* sub_name = StringArg(4);
    clang_forceinline this->vm->set_context_to_sub(sub_name);
    if (this->get_current_instruction()) {
        this->vm->current_context = new_context;
        return ZUN_SUCCESS;
    } else {
        DebugLogger::__debug_log_stub_5(JpEnStr("", " error : undefined function name %s\n"), sub_name);
        this->location.reset();
        return ZUN_ERROR;
    }
}

#if INCLUDE_PATCH_CODE
inline void EclContext::basic_call(EclContext* new_context, const char* sub_name) {
    int32_t stack_pointer = new_context->stack.pointer; // EBP-14 (LOCAL.5)
    if (stack_pointer) {
        int32_t idk_what = new_context->stack.pop<int32_t>();
        new_context->stack.pointer = stack_pointer;
        new_context->stack.write_temp(-1, idk_what);
        new_context->stack.write_temp(-2, stack_pointer);
        new_context->stack.push(this->time);
        new_context->stack.push(this->location.instruction_offset);
        new_context->stack.push(this->location.sub_index);
    } else {
        new_context->stack.push(0);
        new_context->stack.pointer = sizeof(int32_t);
        new_context->stack.write_temp(0, stack_pointer);
        new_context->stack.push(-1);
        new_context->stack.push(-1);
        new_context->stack.push(-1);
    }
    new_context->stack.pointer += sizeof(int32_t);

    //int32_t stack_pointer = new_context->stack.pointer;

}
#endif

// 0x48B3A0
dllexport gnu_noinline ZUNResult vectorcall EclContext::low_ecl_run(float, float current_gamespeed) {
    using namespace Ecl;

    EclInstruction* current_instruction = this->get_current_instruction(); // ESP+8
    if (expect(current_instruction == NULL, false)) {
        return ZUN_ERROR;
    }
    float& current_time = this->time;
    while (current_time <= (float)current_instruction->time) {
        if (current_instruction->difficulty_mask & this->difficulty_mask) {
            int32_t opcode = current_instruction->opcode;
            switch (opcode) {
                case ret: // 10
                    if (ZUN_SUCCEEDED(this->stack.leave_frame())) {
                        this->location.sub_index = this->stack.pop<int32_t>();
                        this->location.instruction_offset = this->stack.pop<int32_t>();
                        this->time = this->stack.pop<float>();
                        this->stack.pointer = this->stack.pop<int32_t>();
                        current_instruction = this->get_current_instruction();
                        if (this->location.instruction_offset >= 0) {
                            break;
                        }
                    }
                case enemy_delete: // 1
                delete_enemy:
                    this->location.reset();
                    return ZUN_ERROR;
                case async_call: // 15
                    this->vm->new_async(-1, 0);
                    goto skip_stack_adjust;
                case async_stop_all: // 21
                    this->vm->context_list.as_head().for_each_safeB([](EclContext* context) {
                        context->location.reset();
                    });
                    goto skip_stack_adjust;
                case async_call_id: { // 16
                    int32_t string_len = IntArg(0);
                    int32_t dword_len = (string_len + sizeof(int32_t)) / sizeof(int32_t);
                    int32_t id = this->parse_int_as_arg_pop(1, IntArg(dword_len));
                    this->vm->new_async(id, 1);
                    goto skip_stack_adjust;
                }
                case async_stop_id: { // 17
                    int32_t id = this->get_int_arg(0);
                    auto async_id_matches = [=](EclContext* context) {
                        return context->async_id == id;
                    };
                    if (EclContext* context = this->vm->context_list.find_if(async_id_matches)) {
                        context->location.instruction_offset = -1;
                    }
                    break;
                }
                case __async_unknown_flag_set: { // 18
                    int32_t id = this->get_int_arg(0);
                    auto async_id_matches = [=](EclContext* context) {
                        return context->async_id == id;
                    };
                    if (EclContext* context = this->vm->context_list.find_if(async_id_matches)) {
                        context->__unknown_flag_A = true;
                    }
                    break;
                }
                case __async_unknown_flag_clear: { // 19
                    int32_t id = this->get_int_arg(0);
                    auto async_id_matches = [=](EclContext* context) {
                        return context->async_id == id;
                    };
                    if (EclContext* context = this->vm->context_list.find_if(async_id_matches)) {
                        context->__unknown_flag_A = false;
                    }
                    break;
                }
                case __async_unknown_value: { // 20
                    int32_t id = this->get_int_arg(0);
                    auto async_id_matches = [=](EclContext* context) {
                        return context->async_id == id;
                    };
                    if (EclContext* context = this->vm->context_list.find_if(async_id_matches)) {
                        context->__int_101C = this->get_int_arg(1);
                    }
                    break;
                }
                case Opcode::call: // 11
                    current_instruction->stack_adjust = 0; // Evil hack by ZUN
                    if (ZUN_FAILED(this->call(this, 0))) {
                        goto delete_enemy;
                    }
                    current_instruction = this->get_current_instruction();
                    continue;
                case jump_neq: // 14
                    if (this->stack.pop_cast<int32_t>()) {
                        goto jump;
                    }
                    break;
                case jump_equ: // 13
                    if (this->stack.pop_cast<int32_t>()) {
                        break;
                    }
                case jump: // 12
                jump:
                    this->time = IntArg(1);
                    this->location.instruction_offset += IntArg(0);
                    IndexInstr(IntArg(0));
                    continue;
                case ecl_time_sub: // 23
                    this->time -= this->get_int_arg(0);
                    break;
                case ecl_time_sub_float: // 24
                    this->time -= this->get_float_arg(0);
                    break;
                case frame_enter: { // 40
                    int32_t locals_size = this->get_int_arg(0);
                    this->stack.enter_frame(locals_size);
                    break;
                }
                case frame_leave: // 41
                    this->stack.leave_frame();
                    break;
                case push_int: // 42
                    this->stack.push(this->get_int_arg_pop(0));
                    goto skip_stack_adjust;
                case push_float: // 44
                    this->stack.push(this->get_float_arg_pop(0));
                    goto skip_stack_adjust;
                case pop_int: { // 43
                    int32_t* write = this->get_int_ptr_arg(0);
                    *write = this->stack.pop_cast<int32_t>();
                    goto skip_stack_adjust;
                }
                case pop_float: { // 45
                    float* write = this->get_float_ptr_arg(0);
                    *write = this->stack.pop_cast<float>();
                    goto skip_stack_adjust;
                }
                case math_int_add: // 50
                    this->stack.binary_op([](int32_t lhs, int32_t rhs) {
                        return lhs + rhs;
                    });
                    goto skip_stack_adjust;
                case math_int_sub: // 52
                    this->stack.binary_op([](int32_t lhs, int32_t rhs) {
                        return lhs - rhs;
                    });
                    goto skip_stack_adjust;
                case math_int_mul: // 54
                    this->stack.binary_op([](int32_t lhs, int32_t rhs) {
                        return lhs * rhs;
                    });
                    goto skip_stack_adjust;
                case math_int_div: // 56
                    this->stack.binary_op([](int32_t lhs, int32_t rhs) {
                        return lhs / rhs;
                    });
                    goto skip_stack_adjust;
                case math_int_mod: // 58
                    this->stack.binary_op([](int32_t lhs, int32_t rhs) {
                        return lhs % rhs;
                    });
                    goto skip_stack_adjust;
                case math_float_add: // 51
                    this->stack.binary_op([](float lhs, float rhs) {
                        return lhs + rhs;
                    });
                    goto skip_stack_adjust;
                case math_float_sub: // 53
                    this->stack.binary_op([](float lhs, float rhs) {
                        return lhs - rhs;
                    });
                    goto skip_stack_adjust;
                case math_float_mul: // 55
                    this->stack.binary_op([](float lhs, float rhs) {
                        return lhs * rhs;
                    });
                    goto skip_stack_adjust;
                case math_float_div: // 57
                    this->stack.binary_op([](float lhs, float rhs) {
                        return lhs / rhs;
                    });
                    goto skip_stack_adjust;
                case cmp_int_equ: // 59
                    this->stack.binary_op([](int32_t lhs, int32_t rhs) {
                        return lhs == rhs;
                    });
                    goto skip_stack_adjust;
                case cmp_int_neq: // 61
                    this->stack.binary_op([](int32_t lhs, int32_t rhs) {
                        return lhs != rhs;
                    });
                    goto skip_stack_adjust;
                case cmp_int_les: // 63
                    this->stack.binary_op([](int32_t lhs, int32_t rhs) {
                        return lhs < rhs;
                    });
                    goto skip_stack_adjust;
                case cmp_int_leq: // 65
                    this->stack.binary_op([](int32_t lhs, int32_t rhs) {
                        return lhs <= rhs;
                    });
                    goto skip_stack_adjust;
                case cmp_int_gre: // 67
                    this->stack.binary_op([](int32_t lhs, int32_t rhs) {
                        return lhs > rhs;
                    });
                    goto skip_stack_adjust;
                case cmp_int_geq: // 69
                    this->stack.binary_op([](int32_t lhs, int32_t rhs) {
                        return lhs >= rhs;
                    });
                    goto skip_stack_adjust;
                case cmp_int_not: // 71
                    this->stack.unary_op([](int32_t value) {
                        return !value;
                    });
                    goto skip_stack_adjust;
                case cmp_float_equ: // 60
                    this->stack.binary_op([](float lhs, float rhs) {
                        return lhs == rhs;
                    });
                    goto skip_stack_adjust;
                case cmp_float_neq: // 62
                    this->stack.binary_op([](float lhs, float rhs) {
                        return lhs != rhs;
                    });
                    goto skip_stack_adjust;
                case cmp_float_les: // 64
                    this->stack.binary_op([](float lhs, float rhs) {
                        return lhs < rhs;
                    });
                    goto skip_stack_adjust;
                case cmp_float_leq: // 66
                    this->stack.binary_op([](float lhs, float rhs) {
                        return lhs <= rhs;
                    });
                    goto skip_stack_adjust;
                case cmp_float_gre: // 68
                    this->stack.binary_op([](float lhs, float rhs) {
                        return lhs > rhs;
                    });
                    goto skip_stack_adjust;
                case cmp_float_geq: // 70
                    this->stack.binary_op([](float lhs, float rhs) {
                        return lhs >= rhs;
                    });
                    goto skip_stack_adjust;
                case cmp_float_not: // 72
                    this->stack.unary_op([](float value) {
                        return value != 0.0f;
                    });
                    goto skip_stack_adjust;
                case cmp_or: // 73
                    this->stack.binary_op([](int32_t lhs, int32_t rhs) {
                        return lhs || rhs;
                    });
                    goto skip_stack_adjust;
                case cmp_and: // 74
                    this->stack.binary_op([](int32_t lhs, int32_t rhs) {
                        return lhs && rhs;
                    });
                    goto skip_stack_adjust;
                case math_bit_xor: // 75
                    this->stack.binary_op([](int32_t lhs, int32_t rhs) {
                        return lhs ^ rhs;
                    });
                    goto skip_stack_adjust;
                case math_bit_or: // 76
                    this->stack.binary_op([](int32_t lhs, int32_t rhs) {
                        return lhs | rhs;
                    });
                    goto skip_stack_adjust;
                case math_int_neg: // 83
                    this->stack.unary_op([](int32_t value) {
                        return -value;
                    });
                    goto skip_stack_adjust;
                case math_float_neg: // 84
                    this->stack.unary_op([](float value) {
                        return -value;
                    });
                    goto skip_stack_adjust;
                case math_post_dec: { // 78
                    int32_t value = this->get_int_arg(0);
                    int32_t* write = this->get_int_ptr_arg(0);
                    *write = value - 1;
                    this->stack.push(value);
                    goto skip_stack_adjust;
                }
                case math_sin: // 79
                    this->stack.unary_op([](float value) {
                        return zsin(value);
                    });
                    goto skip_stack_adjust;
                case math_sqrt: // 88
                    this->stack.unary_op([](float value) {
                        return zsqrt(value);
                    });
                    goto skip_stack_adjust;
                case math_cos: // 80
                    this->stack.unary_op([](float value) {
                        return zcos(value);
                    });
                    goto skip_stack_adjust;
                case math_circle_pos: { // 81
                    float angle = reduce_angle(this->get_float_arg(2));
                    float radius = this->get_float_arg(3);
                    Float2 position;
                    position.make_from_vector(angle, radius);
                    float* x_write = this->get_float_ptr_arg(0);
                    *x_write = position.x;
                    float* y_write = this->get_float_ptr_arg(1);
                    *y_write = position.y;
                    break;
                }
                case math_hypot_squared: { // 85
                    Float2 size;
                    size.x = this->get_float_arg(1);
                    size.y = this->get_float_arg(2);
                    float* write = this->get_float_ptr_arg(0);
                    *write = size.hypot_squared();
                    break;
                }
                case math_hypot: { // 86
                    Float2 size;
                    size.x = this->get_float_arg(1);
                    size.y = this->get_float_arg(2);
                    float* write = this->get_float_ptr_arg(0);
                    *write = size.hypot();
                    break;
                }
                case math_reduce_angle: { // 82
                    float angle = reduce_angle(this->get_float_arg(0));
                    float* write = this->get_float_ptr_arg(0);
                    *write = angle;
                    break;
                }
                case math_line_angle: { // 87
                    Float2 lhs;
                    Float2 rhs;
                    lhs.x = this->get_float_arg(1);
                    lhs.y = this->get_float_arg(2);
                    rhs.x = this->get_float_arg(3);
                    rhs.y = this->get_float_arg(4);
                    float angle = rhs.angle_to(lhs);
                    float* write = this->get_float_ptr_arg(0);
                    *write = angle;
                    break;
                }
                case math_angle_diff: { // 89
                    float angle1 = this->get_float_arg(1);
                    float angle2 = this->get_float_arg(2);
                    float diff = reduced_angle_diff(angle2, angle1);
                    float* write = this->get_float_ptr_arg(0);
                    *write = diff;
                    break;
                }
                case math_point_rotate: { // 90
                    Float2 position;
                    position.x = this->get_float_arg(2);
                    position.y = this->get_float_arg(3);
                    float angle = reduce_angle(this->get_float_arg(4));
                    position = position.rotate_around_origin(angle);
                    float* x_write = this->get_float_ptr_arg(0);
                    *x_write = position.x;
                    float* y_write = this->get_float_ptr_arg(1);
                    *y_write = position.y;
                    break;
                }
                case math_float_interp: { // 91
                    int32_t slot = this->get_int_arg(0);
                    this->float_interp_locations[slot] = this->location;
                    this->float_interps[slot].step(); // why?
                    this->float_interps[slot].end_time = this->get_int_arg(2);
                    this->float_interps[slot].mode = this->get_int_arg(3);
                    float initial_value = this->get_float_arg(4);
                    float final_value = this->get_float_arg(5);
                    this->float_interps[slot].initial_value = initial_value;
                    this->float_interps[slot].final_value = final_value;
                    float* interp_write = this->get_float_ptr_arg(1);
                    *interp_write = initial_value;
                    this->float_interps[slot].time.reset();
                    this->float_interp_stack_offsets[slot] = this->stack.base;
                    break;
                }
                case math_float_interp_bezier: { // 92
                    int32_t slot = this->get_int_arg(0);
                    this->float_interp_locations[slot] = this->location;
                    this->float_interps[slot].step(); // why?
                    this->float_interps[slot].end_time = this->get_int_arg(2);
                    this->float_interps[slot].mode = this->get_int_arg(3);
                    float initial_value = this->get_float_arg(4);
                    float final_value = this->get_float_arg(5);
                    this->float_interps[slot].initial_value = initial_value;
                    this->float_interps[slot].final_value = final_value;
                    float* interp_write = this->get_float_ptr_arg(1);
                    *interp_write = initial_value;
                    float bezier1 = this->get_float_arg(6);
                    float bezier2 = this->get_float_arg(7);
                    this->float_interps[slot].bezier1 = bezier1;
                    this->float_interps[slot].bezier2 = bezier2;
                    this->float_interps[slot].time.reset();
                    this->float_interp_stack_offsets[slot] = this->stack.base;
                    break;
                }
                case math_circle_pos_rand: { // 93
                    float min_radius = this->get_float_arg(0);
                    float max_radius = this->get_float_arg(1);
                    float angle = REPLAY_RNG.rand_angle();
                    float percent = REPLAY_RNG.rand_float_signed();
                    float radius = lerp(min_radius, max_radius, percent);
                    Float2 position;
                    position.make_from_vector(angle, radius);
                    float* x_write = this->get_float_ptr_arg(0);
                    *x_write = position.x;
                    float* y_write = this->get_float_ptr_arg(1);
                    *y_write = position.y;
                    break;
                }
                case math_ellipse_pos: { // 94
                    float angle = this->get_float_arg(2);
                    float offset = this->get_float_arg(4);
                    angle = reduce_angle(angle - offset);
                    float radius = this->get_float_arg(3);
                    Float2 position;
                    position.make_from_vector(angle, radius);
                    float ellipse_factor = this->get_float_arg(5);
                    position.x *= ellipse_factor;
                    position.rotate_around_origin(offset);
                    float* x_write = this->get_float_ptr_arg(0);
                    *x_write = position.x;
                    float* y_write = this->get_float_ptr_arg(1);
                    *y_write = position.y;
                    break;
                }
#if INCLUDE_PATCH_CODE
                case 95: // debug_breakpoint
                    __asm INT3
                    break;
                case 96: { // thcrap_expr
                    int32_t* write = this->get_int_ptr_arg(0);
                    eval_expr(StringArg(1), '\0', write, NULL, 0, NULL);
                    break;
                }
                case 97: // math_shl
                    this->stack.binary_op_fast([](uint32_t lhs, uint32_t rhs) {
                        return lhs << rhs;
                    });
                    break;
                case 98: // math_shr
                    this->stack.binary_op_fast([](uint32_t lhs, uint32_t rhs) {
                        return lhs >> rhs;
                    });
                    break;
                case 99: // math_sar
                    this->stack.binary_op_fast([](int32_t lhs, int32_t rhs) {
                        return lhs >> rhs;
                    });
                    break;
                case 100: // math_rol
                    this->stack.binary_op_fast([](uint32_t lhs, uint32_t rhs) {
                        return _rotl(lhs, rhs);
                    });
                    break;
                case 101: // math_ror
                    this->stack.binary_op_fast([](uint32_t lhs, uint32_t rhs) {
                        return _rotr(lhs, rhs);
                    });
                    break;
                case 102: // math_udiv
                    this->stack.binary_op_fast([](uint32_t lhs, uint32_t rhs) {
                        return lhs / rhs;
                    });
                    break;
                case 103: // math_umod
                    this->stack.binary_op_fast([](uint32_t lhs, uint32_t rhs) {
                        return lhs % rhs;
                    });
                    break;
#endif
                default:
                    switch (this->vm->high_ecl_run()) {
                        case -1:
                            goto step_interps;
                        case 0:
                            break;
                        case 1:
                            goto skip_stack_adjust;
                    }
                    break;
                case nop:
                case __debug_unknown_A:
                case debug_print:
                case __debug_unknown_B:
                    // These don't go to the default case
                    break;
            }
            if (uint8_t stack_adjust = current_instruction->stack_adjust) {
                this->stack.pointer -= stack_adjust;
            }
        }
    skip_stack_adjust:
        this->location.instruction_offset += current_instruction->offset_to_next;
        IndexInstr(current_instruction->offset_to_next);
    }
    current_time += current_gamespeed;
step_interps:
    this->step_float_interps();
    return ZUN_SUCCESS;
}

// 0x430D40
dllexport gnu_noinline int32_t thiscall EnemyData::high_ecl_run() {
    using namespace Ecl;

    // this // EBP-570, EDI
    EclVM** vm_ptr = &this->vm; // EBP-578, ESI
    EclInstruction* current_instruction = this->vm->current_context->get_current_instruction(); // EBP-57C
    int16_t opcode = current_instruction->opcode; // EBP-56C

    switch (opcode) {
        case enemy_create_rel_stage: case enemy_create_abs_stage: // 309, 310
        case enemy_create_rel_stage_mirror: case enemy_create_abs_stage_mirror: // 311, 312
            clang_forceinline if (ENEMY_MANAGER_PTR->get_boss_by_index(0)) {
                break;
            }
        case enemy_create_rel: case enemy_create_abs: // 300, 301
        case enemy_create_rel_mirror: case enemy_create_abs_mirror: // 304, 305
        case __enemy_create_rel_2: // 321
            this->ecl_enm_create();
            break;
        case anm_source: // 302
            this->anm_source_index = this->get_int_arg(0);
            break;
        case enemy_flag_mirror: // 424
            this->mirrored = this->get_int_arg(0);
            break;
        case __enemy_manager_flag_unknown_A: // 631
            ENEMY_MANAGER_PTR->__unknown_flag_A = this->get_int_arg(0);
            break;
        case anm_layer_base: // 552
            this->anm_base_layer = this->get_int_arg(0);
            break;
        case enemy_damage_sound: // 553
            this->hit_sound = this->get_int_arg(0);
            break;
        case score_add: { // 638
            int32_t score_bonus = this->get_int_arg(0);
            GAME_MANAGER.add_to_score(score_bonus);
            POPUP_MANAGER_PTR->create_popup(&this->current_motion.position, score_bonus, PackD3DCOLOR(255, 255, 255, 255));
            break;
        }
        case anm_set_slot: // 303
            this->anm_set_slot_impl();
            break;
        case anm_move_position_slot: { // 320
            int32_t slot = this->get_int_arg(0);
            this->anm_positions[slot].x = this->get_float_arg(1);
            this->anm_positions[slot].y = this->get_float_arg(2);
            this->anm_positions[slot].z = 0.0f;
            break;
        }
        // TODO
        case enemy_kill: // 566
            if (this->enemy()->kill()) {
                return 1;
            }
            break;
        case anm_death_effects: // 323
            this->death_anm_index = this->get_int_arg(0);
            this->death_anm_script = this->get_int_arg(1);
            break;
        case __enemy_kill_effect_create: // 561
            this->kill_effects<false>();
            break;
        case __anm_set_slot_anchor_index: // 322
            this->anm_vm_indices[this->get_int_arg(0)] = this->get_int_arg(1);
            break;
        case __stage_logo: // 554
            GUI_PTR->__display_stage_logo();
            break;
        case anm_create_rel_front_rotated: { // 338
            float Y = this->get_float_arg(3);
            float X = this->get_float_arg(2);
            Float3 position = this->current_motion.position + Float3(X, Y);
            float rotation = this->get_float_arg(4);
            int32_t script = this->get_int_arg(1);
            AnmID id = ENEMY_MANAGER_PTR->anm_file_lookup(this->get_int_arg(0))->instantiate_vm(
                script, &position, rotation, -1, WORLD_LIST_FRONT, NULL
            );
            EFFECT_MANAGER_PTR->fill_available_slot(id);
            break;
        }
        case anm_create_front: { // 307
            int32_t script = this->get_int_arg(1);
            AnmID id = ENEMY_MANAGER_PTR->anm_file_lookup(this->get_int_arg(0))->instantiate_vm(
                script, &this->current_motion.position, 0.0f, -1, WORLD_LIST_FRONT, NULL
            );
            EFFECT_MANAGER_PTR->fill_available_slot(id);
            break;
        }
        case anm_create_back: { // 314
            int32_t script = this->get_int_arg(1);
            AnmID id = ENEMY_MANAGER_PTR->anm_file_lookup(this->get_int_arg(0))->instantiate_vm(
                script, &this->current_motion.position, 0.0f, -1, WORLD_LIST_BACK, NULL
            );
            EFFECT_MANAGER_PTR->fill_available_slot(id);
            break;
        }
        case anm_create_zero_front: { // 308
            int32_t anm_index = this->get_int_arg(0);
            int32_t script = this->get_int_arg(1);
            AnmID id = ENEMY_MANAGER_PTR->anm_file_lookup(anm_index)->instantiate_vm(
                script, NULL, 0.0f, -1, WORLD_LIST_FRONT, NULL
            );
            EFFECT_MANAGER_PTR->fill_available_slot(id);
            break;
        }
        case __anm_create_zero_front_and_run: { // 339
            int32_t anm_index = this->get_int_arg(0);
            int32_t script = this->get_int_arg(1);
            AnmID id = ENEMY_MANAGER_PTR->anm_file_lookup(anm_index)->instantiate_vm(
                script, NULL, 0.0f, -1, WORLD_LIST_FRONT, NULL
            );
            EFFECT_MANAGER_PTR->fill_available_slot(id);
            AnmVM* vm = id.get_vm_ptr();
            for (int32_t i = 0; i < this->get_int_arg(2); ++i) {
                vm->run_anm();
            }
            break;
        }
        case anm_create_front_rotated: { // 315
            AnmID id;
            id = ENEMY_MANAGER_PTR->anm_file_lookup(this->get_int_arg(0))->instantiate_vm_to_world_list_front(this->get_int_arg(1), &this->get_position(), 0.0f);
            AnmVM* vm = id.get_vm_ptr();
            if (vm) {
                vm->set_controller_position(&this->get_position());
                clang_noinline vm->set_z_rotation(this->get_float_arg(2));
            }
            EFFECT_MANAGER_PTR->fill_available_slot(id);
            break;
        }
        case __effect_create_special: // 334
            EFFECT_MANAGER_PTR->create_effect(this->get_int_arg(0), &this->get_position(), 0);
            break;
        case anm_set_slot_main: // 306
            this->anm_set_slot_main_impl();
            break;
        case anm_play_main: // 318
            this->anm_play_main_impl();
            break;
        case anm_play_attack: // 313
            this->anm_play_attack_impl();
            break;
        case anm_play_attack_ex: // 316
            this->anm_play_attack_ex_impl();
            break;
        case anm_interrupt_slot: { // 317
            int32_t slot = this->get_int_arg(0);
            int16_t interrupt = this->get_int_arg(1);
            this->anm_vms[slot].interrupt_tree(interrupt);
            break;
        }
        case move_stop: { // 427
            MotionData& motion_rel = this->motion.relative;
            MotionData& motion_abs = this->motion.absolute;
            motion_abs.get_position() += motion_rel.get_position();
            motion_rel.position = UNKNOWN_FLOAT3_A;
            motion_rel.set_speed(0.0f);
            motion_abs.set_speed(0.0f);
            motion_rel.set_orbit_origin(UNKNOWN_FLOAT3_A);
            motion_abs.set_orbit_origin(UNKNOWN_FLOAT3_A);
            motion_rel.set_axis_velocity_mode();
            motion_abs.set_axis_velocity_mode();
            this->position_interp.absolute.reset_end_time();
            this->position_interp.relative.reset_end_time();
            this->angle_interp_absolute.reset_end_time();
            this->angle_interp_relative.reset_end_time();
            this->speed_interp_absolute.reset_end_time();
            this->speed_interp_relative.reset_end_time();
            this->orbit_radius_interp.absolute.reset_end_time();
            this->orbit_radius_interp.relative.reset_end_time();
            this->ellipse_interp.absolute.reset_end_time();
            this->ellipse_interp.relative.reset_end_time();
            break;
        }
        case move_position_abs: case move_position_rel: { // 400, 402
            MotionData& motion = (opcode != move_position_abs) ? this->motion.relative : this->motion.absolute;
            float X = this->get_float_arg(0);
            float Y = this->get_float_arg(1);
            if (X > -999999.0) {
                motion.set_position_x(X);
            }
            if (Y > -999999.0) {
                motion.set_position_y(Y);
            }
            motion.set_axis_velocity_mode();
            this->current_motion.get_position() = this->motion.relative.get_position() + this->motion.absolute.get_position();
            this->update_current_motion();
            break;
        }
        case move_position_add_abs: case move_position_add_rel: { // 416 417
            MotionData& motion = (opcode == move_position_abs) ? this->motion.absolute : this->motion.relative;
            float X = this->get_float_arg(0);
            float Y = this->get_float_arg(1);
            float Z = this->get_float_arg(2);
            motion.get_position().x += X;
            motion.get_position().y += Y;
            motion.get_position().z += Z;
            this->update_current_motion();
            break;
        }
        case move_position_abs_interp: case move_position_rel_interp: // 401, 403
        case __move_position_offset_abs_interp: case __move_position_offset_rel_interp: // 436, 437
        {
            MotionData& motion = (opcode != move_position_abs_interp && opcode != __move_position_offset_abs_interp) ? this->motion.relative : this->motion.absolute;
            ZUNInterpEx<Float3>& position_interp = (opcode != move_position_abs_interp && opcode != __move_position_offset_abs_interp) ? this->position_interp.relative : this->position_interp.absolute;
            float X = this->get_float_arg(2);
            float Y = this->get_float_arg(3);
            if (this->get_int_arg(0) <= 0) {
                position_interp.reset_end_time();
                break;
            }
            if (opcode == __move_position_offset_abs_interp || opcode == __move_position_offset_rel_interp) {
                if (!this->get_mirror_flag()) {
                    X = motion.get_position_x() + X;
                } else {
                    X = motion.get_position_x() - X;
                }
                Y = motion.get_position_y() + Y;
            }
            position_interp.set_end_time(this->get_int_arg(0));
            position_interp.set_bezier1(UNKNOWN_FLOAT3_A);
            position_interp.set_bezier2(UNKNOWN_FLOAT3_A);
            position_interp.set_combined_mode(this->get_int_arg(1));
            position_interp.set_initial_value(motion.get_position());
            if (!(Y > -999999.0f)) {
                Y = motion.get_position_y();
            }
            if (!(X > -999999.0f)) {
                X = motion.get_position_x();
            }
            position_interp.set_final_value(Float3(X, Y, 0.0f));
            position_interp.reset_timer();
            motion.set_axis_velocity_mode();
            break;
        }
        case move_axis_interp_abs: case move_axis_interp_rel: // 434, 435
        case __move_axis_offset_abs_interp: case __move_axis_offset_rel_interp: // 438, 439
        {
            MotionData& motion = (opcode != move_axis_interp_abs && opcode != __move_axis_offset_abs_interp) ? this->motion.relative : this->motion.absolute;
            ZUNInterpEx<Float3>& position_interp = (opcode != move_axis_interp_abs && opcode != __move_axis_offset_abs_interp) ? this->position_interp.relative : this->position_interp.absolute;
            float X = this->get_float_arg(3);
            float Y = this->get_float_arg(4);
            if (this->get_int_arg(0) <= 0) {
                position_interp.reset_end_time();
                break;
            }
            if (opcode == __move_axis_offset_abs_interp || opcode == __move_axis_offset_rel_interp) {
                if (!this->get_mirror_flag()) {
                    X = motion.get_position_x() + X;
                } else {
                    X = motion.get_position_x() - X;
                }
                Y = motion.get_position_y() + Y;
            }
            position_interp.set_end_time(this->get_int_arg(0));
            position_interp.set_bezier1(UNKNOWN_FLOAT3_A);
            position_interp.set_bezier2(UNKNOWN_FLOAT3_A);
            position_interp.set_axis_mode(0, this->get_int_arg(1));
            position_interp.set_axis_mode(1, this->get_int_arg(2));
            position_interp.set_initial_value(motion.get_position());
            if (!(Y > -999999.0f)) {
                Y = motion.get_position_y();
            }
            if (!(X > -999999.0f)) {
                X = motion.get_position_x();
            }
            position_interp.set_final_value(Float3(X, Y, 0.0f));
            position_interp.reset_timer();
            motion.set_axis_velocity_mode();
            break;
        }
        case move_bezier_abs: case move_bezier_rel: { // 425, 426
            MotionData& motion = (opcode == move_bezier_abs) ? this->motion.absolute : this->motion.relative;
            ZUNInterpEx<Float3>& position_interp = (opcode == move_bezier_abs) ? this->position_interp.absolute : this->position_interp.relative;
            float X = this->get_float_arg(3);
            float Y = this->get_float_arg(4);
            float Z = 0.0f;
            Float3 bezier1 = {};
            Float3 bezier2 = {};
            bezier1.x = this->get_float_arg(1);
            bezier1.y = this->get_float_arg(2);
            bezier1.z = 0.0f;
            bezier2.x = this->get_float_arg(5);
            bezier2.y = this->get_float_arg(6);
            bezier2.z = 0.0f;
            position_interp.set_end_time(this->get_int_arg(0));
            position_interp.set_bezier1(bezier1);
            position_interp.set_bezier2(bezier2);
            position_interp.set_combined_mode(Bezier);
            position_interp.set_initial_value(motion.get_position());
            if (!(Y > -999999.0)) {
                Y = motion.get_position_y();
            }
            if (!(X > -999999.0)) {
                X = motion.get_position_x();
            }
            position_interp.set_final_value(Float3(X, Y, Z));
            position_interp.reset_timer();
            motion.set_axis_velocity_mode();
            break;
        }
        case move_velocity_abs: case move_velocity_rel: // 404, 406
        case move_velocity_no_mirror_abs: case move_velocity_no_mirror_rel: // 428, 430
        {
            MotionData& motion = (opcode != move_velocity_abs && opcode != move_velocity_no_mirror_abs) ? this->motion.relative : this->motion.absolute;
            float angle = this->get_float_arg(0);
            float speed = this->get_float_arg(1);
            if (angle > -999999.0) {
                if (this->get_mirror_flag() && (opcode == move_velocity_abs || opcode == move_velocity_rel)) {
                    angle = reduce_angle(HALF_PI_f - reduce_angle(angle - HALF_PI_f));
                }
                motion.set_angle(angle);
            }
            if (speed > -999999.0) {
                motion.set_speed(speed);
            }
            motion.set_axis_velocity_mode();
            break;
        }
        case move_velocity_abs_interp: case move_velocity_rel_interp: // 405, 407
        case move_velocity_no_mirror_abs_interp: case move_velocity_no_mirror_rel_interp: // 429, 431
        {
            MotionData& motion = (opcode != move_velocity_abs_interp && opcode != move_velocity_no_mirror_abs_interp) ? this->motion.relative : this->motion.absolute;
            ZUNInterp<float>& angle_interp = (opcode != move_velocity_abs_interp && opcode != move_velocity_no_mirror_abs_interp) ? this->angle_interp_relative : this->angle_interp_absolute;
            ZUNInterp<float>& speed_interp = (opcode != move_velocity_abs_interp && opcode != move_velocity_no_mirror_abs_interp) ? this->speed_interp_relative : this->speed_interp_absolute;
            float angle = this->get_float_arg(2);
            float speed = this->get_float_arg(3);
            Float2 final_val = {};
            if (this->get_int_arg(0) <= 0) {
                angle_interp.reset_end_time();
                speed_interp.reset_end_time();
                break;
            }
            int32_t interp_mode = this->get_int_arg(1);
            if (interp_mode != ConstantVelocity) {
                if (angle > -999999.0) {
                    if (this->get_mirror_flag() && (opcode == move_velocity_abs_interp || opcode == move_velocity_rel_interp)) {
                        final_val.x = reduce_angle(HALF_PI_f - reduce_angle(angle - HALF_PI_f));
                    } else {
                        final_val.x = angle;
                    }
                } else {
                    final_val.x = motion.get_angle();
                }
                if (speed > -999999.0) {
                    final_val.y = speed;
                } else {
                    final_val.y = motion.get_speed();
                }
            } else {
                if (angle > -999999.0) {
                    if (this->get_mirror_flag() && (opcode == move_velocity_abs_interp || opcode == move_velocity_rel_interp)) {
                        final_val.x = -angle;
                    } else {
                        final_val.x = angle;
                    }
                } else {
                    final_val.x = 0.0f;
                }
                if (speed > -999999.0) {
                    final_val.y = speed;
                } else {
                    final_val.y = 0.0f;
                }
            }
            Float2 initial_val = Float2(motion.get_angle(), motion.get_speed());
            if (zfabsf<NoInline>(initial_val.x - final_val.x) >= PI_f) {
                if (final_val.x > initial_val.x) {
                    initial_val.x += TWO_PI_f;
                } else {
                    final_val.x += TWO_PI_f;
                }
            }
            angle_interp.initialize(this->get_int_arg(0), interp_mode, initial_val.x, final_val.x);
            speed_interp.initialize(this->get_int_arg(0), interp_mode, initial_val.y, final_val.y);
            motion.set_axis_velocity_mode();
            break;
        }
        case move_angle_abs: case move_angle_rel: // 440, 442
        {
            MotionData& motion = (opcode == move_angle_abs) ? this->motion.absolute : this->motion.relative;
            float angle = this->get_float_arg(0);
            if (this->get_mirror_flag()) {
                motion.set_angle(reduce_angle(HALF_PI_f - reduce_angle(angle - HALF_PI_f)));
                motion.set_axis_velocity_mode();
            } else {
                motion.set_angle(angle);
                motion.set_axis_velocity_mode();
            }
            break;
        }
        case move_angle_abs_interp: case move_angle_rel_interp: { // 441, 443
            MotionData& motion = (opcode == move_angle_abs) ? this->motion.absolute : this->motion.relative;
            ZUNInterp<float>& angle_interp = (opcode == move_angle_abs) ? this->angle_interp_absolute : this->angle_interp_relative;
            float angle = this->get_float_arg(2);
            if (this->get_int_arg(0) <= 0) {
                angle_interp.reset_end_time();
                break;
            }
            int32_t interp_mode = this->get_int_arg(1);
            if (interp_mode != ConstantVelocity) {
                if (angle > -999999.0) {
                    if (this->get_mirror_flag() && (opcode == move_angle_abs_interp || opcode == move_angle_rel_interp)) {
                        angle = reduce_angle(HALF_PI_f - reduce_angle(angle - HALF_PI_f));
                    }
                } else {
                    angle = motion.get_angle();
                }
            } else {
                if (angle > -999999.0) {
                    if (this->get_mirror_flag() && (opcode == move_angle_abs_interp || opcode == move_angle_rel_interp)) {
                        angle = -angle;
                    }
                } else {
                    angle = 0.0f;
                }
            }
            float current_angle = motion.get_angle();
            angle = reduced_angle_diff(current_angle, angle) + current_angle;
            angle_interp.initialize(this->get_int_arg(0), interp_mode, current_angle, angle);
            motion.set_axis_velocity_mode();
            break;
        }
        case move_speed_abs: case move_speed_rel: { // 444, 446
            MotionData& motion = (opcode == move_speed_abs) ? this->motion.absolute : this->motion.relative;
            float speed = this->get_float_arg(0);
            if (speed > -999999.0) {
                motion.set_speed(speed);
            }
            motion.set_axis_velocity_mode();
            break;
        }
        case move_speed_abs_interp: case move_speed_rel_interp: { // 445, 447
            MotionData& motion = (opcode == move_speed_abs) ? this->motion.absolute : this->motion.relative;
            ZUNInterp<float>& speed_interp = (opcode == move_speed_abs) ? this->speed_interp_absolute : this->speed_interp_relative;
            float speed = this->get_float_arg(2);
            float current_speed = motion.get_speed();
            if (this->get_int_arg(0) <= 0) {
                speed_interp.reset_end_time();
                break;
            }
            int32_t interp_mode = this->get_int_arg(1);
            if (interp_mode != ConstantVelocity) {
                if (!(speed > -999999.0)) {
                    speed = motion.get_speed();
                }
            } else {
                if (!(speed > -999999.0)) {
                    speed = 0.0f;
                }
            }
            speed_interp.initialize(this->get_int_arg(0), interp_mode, current_speed, speed);
            motion.set_axis_velocity_mode();
            break;
        }
        case move_orbit_abs: case move_orbit_rel: { // 408, 410
            MotionData& motion = (opcode == move_orbit_abs) ? this->motion.absolute : this->motion.relative;
            float angle = this->get_float_arg(0);
            float speed = this->get_float_arg(1);
            float orbit_radius = this->get_float_arg(2);
            float orbit_radius_delta = this->get_float_arg(3);
            if (motion.mode_is_orbit()) {
                motion.set_orbit_origin(motion.get_position());
            }
            if (angle > -999999.0) {
                motion.set_angle(angle);
            }
            if (speed > -999999.0) {
                motion.set_speed(speed);
            }
            if (orbit_radius > -999999.0) {
                motion.set_orbit_radius(orbit_radius);
            }
            if (orbit_radius_delta > -999999.0) {
                motion.set_orbit_radius_delta(orbit_radius_delta);
            }
            motion.set_orbit_mode();
            motion.update2();
            this->update_current_motion();
            break;
        }
        case move_orbit_abs_interp: case move_orbit_rel_interp: { // 409, 411
            MotionData& motion = (opcode == move_orbit_abs_interp) ? this->motion.absolute : this->motion.relative;
            ZUNInterp<float>& speed_interp = (opcode == move_orbit_abs_interp) ? this->speed_interp_absolute : this->speed_interp_relative;
            ZUNInterp<Float2>& orbit_radius_interp = (opcode == move_orbit_abs_interp) ? this->orbit_radius_interp.absolute : this->orbit_radius_interp.relative;
            float speed = this->get_float_arg(2);
            float orbit_radius = this->get_float_arg(3);
            float orbit_radius_delta = this->get_float_arg(4);
            if (!(speed > -999999.0)) {
                speed = motion.get_speed();
            }
            Float2 final_speed = Float2(0.0f, speed);
            Float2 initial_speed = Float2(0.0f, motion.get_speed());
            if (!(orbit_radius_delta > -999999.0)) {
                orbit_radius_delta = motion.get_orbit_radius_delta();
            }
            if (!(orbit_radius > -999999.0)) {
                orbit_radius = motion.get_orbit_radius();
            }
            Float2 final_orbit = Float2(orbit_radius, orbit_radius_delta);
            Float2 initial_orbit = Float2(motion.get_orbit_radius(), motion.get_orbit_radius_delta());
            int32_t end_time = this->get_int_arg(0);
            int32_t interp_mode = this->get_int_arg(1);
            if (end_time <= 0) {
                speed_interp.reset_end_time();
                orbit_radius_interp.reset_end_time();
                break;
            }
            speed_interp.initialize(end_time, interp_mode, initial_speed.y, final_speed.y);
            orbit_radius_interp.initialize_bezier(end_time, interp_mode, initial_orbit, final_orbit, UNKNOWN_FLOAT2_A, UNKNOWN_FLOAT2_A);
            motion.set_orbit_mode();
            motion.update2();
            this->update_current_motion();
            break;
        }
        case move_origin_abs: case move_origin_rel: { // 418, 419
            MotionData& motion = (opcode == move_origin_abs) ? this->motion.absolute : this->motion.relative;
            float X = this->get_float_arg(0);
            float Y = this->get_float_arg(1);
            if (X > -999999.0) {
                motion.set_orbit_origin_x(X);
            }
            if (Y > -999999.0) {
                motion.set_orbit_origin_y(Y);
            }
            motion.update2();
            this->update_current_motion();
            // break; // Nice one ZUN
        }
        case move_ellipse_abs: case move_ellipse_rel: { // 420, 422
            MotionData& motion = (opcode == move_ellipse_abs) ? this->motion.absolute : this->motion.relative;
            float angle = this->get_float_arg(0);
            float speed = this->get_float_arg(1);
            float orbit_radius = this->get_float_arg(2);
            float orbit_radius_delta = this->get_float_arg(3);
            float ellipse_angle = this->get_float_arg(4);
            float ellipse_ratio = this->get_float_arg(5);
            if (motion.mode_is_orbit()) {
                motion.set_orbit_origin(motion.get_position());
            }
            if (angle > -999999.0) {
                motion.set_angle(angle);
            }
            if (speed > -999999.0) {
                motion.set_speed(speed);
            }
            if (orbit_radius > -999999.0) {
                motion.set_orbit_radius(orbit_radius);
            }
            if (orbit_radius_delta > -999999.0) {
                motion.set_orbit_radius_delta(orbit_radius_delta);
            }
            if (ellipse_angle > -999999.0) {
                motion.set_ellipse_angle(ellipse_angle);
            }
            if (ellipse_ratio > -999999.0) {
                motion.set_ellipse_ratio(ellipse_ratio);
            }
            motion.set_orbit_mode();
            motion.set_ellipse_mode();
            motion.update2();
            this->update_current_motion();
            break;
        }
        case move_ellipse_abs_interp: case move_ellipse_rel_interp: { // 421, 423
            MotionData& motion = (opcode == move_ellipse_abs_interp) ? this->motion.absolute : this->motion.relative;
            ZUNInterp<float>& speed_interp = (opcode == move_ellipse_abs_interp) ? this->speed_interp_absolute : this->speed_interp_relative;
            ZUNInterp<Float2>& orbit_radius_interp = (opcode == move_ellipse_abs_interp) ? this->orbit_radius_interp.absolute : this->orbit_radius_interp.relative;
            ZUNInterp<Float2>& ellipse_interp = (opcode == move_ellipse_abs_interp) ? this->ellipse_interp.absolute : this->ellipse_interp.relative;
            float speed = this->get_float_arg(2);
            float orbit_radius = this->get_float_arg(3);
            float orbit_radius_delta = this->get_float_arg(4);
            float ellipse_angle = this->get_float_arg(5);
            float ellipse_ratio = this->get_float_arg(6);
            if (!(speed > -999999.0)) {
                speed = motion.get_speed();
            }
            Float2 final_speed = Float2(0.0f, speed);
            Float2 initial_speed = Float2(0.0f, motion.get_speed());
            if (!(orbit_radius_delta > -999999.0)) {
                orbit_radius_delta = motion.get_orbit_radius_delta();
            }
            if (!(orbit_radius > -999999.0)) {
                orbit_radius = motion.get_orbit_radius();
            }
            Float2 final_orbit = Float2(orbit_radius, orbit_radius_delta);
            Float2 initial_orbit = Float2(motion.get_orbit_radius(), motion.get_orbit_radius_delta());
            if (!(ellipse_ratio > -999999.0)) {
                ellipse_ratio = motion.get_ellipse_ratio();
            }
            if (!(ellipse_angle > -999999.0)) {
                ellipse_angle = motion.get_ellipse_angle();
            }
            Float2 final_ellipse = Float2(ellipse_angle, ellipse_ratio);
            Float2 initial_ellipse = Float2(motion.get_ellipse_angle(), motion.get_ellipse_ratio());
            int32_t end_time = this->get_int_arg(0);
            int32_t interp_mode = this->get_int_arg(1);
            if (end_time <= 0) {
                speed_interp.reset_end_time();
                orbit_radius_interp.reset_end_time();
                ellipse_interp.reset_end_time();
                break;
            }
            speed_interp.initialize(end_time, interp_mode, initial_speed.y, final_speed.y);
            orbit_radius_interp.initialize_bezier(end_time, interp_mode, initial_orbit, final_orbit, UNKNOWN_FLOAT2_A, UNKNOWN_FLOAT2_A);
            ellipse_interp.initialize_bezier(end_time, interp_mode, initial_ellipse, final_ellipse, UNKNOWN_FLOAT2_A, UNKNOWN_FLOAT2_A);
            motion.set_orbit_origin(motion.get_position());
            motion.set_orbit_mode();
            motion.set_ellipse_mode();
            motion.update2();
            this->update_current_motion();
            break;
        }
        case move_to_boss0_abs: // 414
            this->motion.absolute.set_positionB(&ENEMY_MANAGER_PTR->get_boss_by_index(0)->get_current_motion()->position);
            break;
        case move_to_boss0_rel: // 415
            this->motion.relative.set_positionB(&ENEMY_MANAGER_PTR->get_boss_by_index(0)->get_current_motion()->position);
            break;
        case move_to_enemy_id_abs: // 432
            this->motion.absolute.set_positionB(&ENEMY_MANAGER_PTR->get_enemy_by_id(this->get_int_arg(0))->get_current_motion()->position);
            break;
        case move_to_enemy_id_rel: // 433
            this->motion.relative.set_positionB(&ENEMY_MANAGER_PTR->get_enemy_by_id(this->get_int_arg(0))->get_current_motion()->position);
            break;
        case move_bounds_set: // 504
            this->move_bounds_enable = true;
            this->move_bounds_center.x = this->get_float_arg(0);
            this->move_bounds_center.y = this->get_float_arg(1);
            this->move_bounds_size.x = this->get_float_arg(2);
            this->move_bounds_size.y = this->get_float_arg(3);
            break;
        case move_bounds_disable: // 505
            this->move_bounds_enable = false;
            break;
        case player_protect_range: { // 526
            float radius = this->get_float_arg(0);
            this->player_protect_radius_squared = radius * radius;
            break;
        }
        case move_rand_interp_abs: case move_rand_interp_rel: { // 412, 413
            // nooooo this one sucks, I'll do it later
            break;
        }
        case enemy_lifebar_color: { // 527
            D3DCOLOR color = this->get_int_arg(2);
            float hp_position = this->get_float_arg(1);
            int32_t slot = this->get_int_arg(0);
            hp_position /= this->get_life_data().get_maximum();
            GUI_PTR->set_lifebar_marker(this->boss_id, slot, color, hp_position);
            break;
        }
        case ex_ins_repeat: { // 632
            int32_t index = this->get_int_arg(0);
            this->__is_func_set_2 = FALSE;
            this->func_set_func = ECL_FUNC_CALL_TABLE[index];
            break;
        }
        case __ex_ins_repeat2: { // 639
            int32_t index = this->get_int_arg(0);
            this->__is_func_set_2 = TRUE;
            this->func_set_func = ECL_FUNC_CALL_TABLE[index];
            break;
        }
        case enemy_damage_ex: { // 633
            int32_t index = this->get_int_arg(0);
            this->extra_damage_func = EXTRA_DAMAGE_FUNC_TABLE[index];
            break;
        }
        case enemy_hitbox_ex: { // 634
            int32_t index = this->get_int_arg(0);
            this->extra_hitbox_func = EXTRA_HITBOX_FUNC_TABLE[index];
            break;
        }
        case ex_ins_call: { // 637
            int32_t index = this->get_int_arg(0);
            ECL_FUNC_CALL_TABLE[index](this);
            break;
        }
        case enemy_set_hitbox: // 500
            this->hitbox_size.x = this->get_float_arg(0);
            this->hitbox_size.y = this->get_float_arg(1);
            if (!this->chapter_spawn_weight) {
                this->chapter_spawn_weight = 1;
                GAME_MANAGER.globals.__add_to_int_8C(1);
            }
            break;
        case enemy_set_collision: // 501
            this->collision_size.x = this->get_float_arg(0);
            this->collision_size.y = this->get_float_arg(1);
            break;
        case __enemy_set_chapter_spawn_weight: { // 569
            int32_t weight;
            switch (this->chapter_spawn_weight) {
                case 0:
                    weight = this->get_int_arg(0);
                    this->chapter_spawn_weight = weight;
                    if (weight > 0) {
                        GAME_MANAGER.globals.__add_to_int_8C(weight);
                    }
                    break;
                case 1:
                    weight = this->get_int_arg(0);
                    this->chapter_spawn_weight = weight;
                    GAME_MANAGER.globals.__add_to_int_8C(weight - 1);
                    break;
            }
            break;
        }
        case __enemy_add_spawn_weight_to_destroy: // 570
            this->add_spawn_weight_to_chapter_destroy<false>();
            break;
        case enemy_flag_hitbox_shape: // 563
            this->rectangular_hitbox = this->get_int_arg(0);
            break;
        case enemy_set_hitbox_rotation: // 564
            this->hitbox_rotation = this->get_float_arg(0);
            break;
        case enemy_bomb_shield_multiplier: // 565
            this->bomb_damage_multiplier = this->get_float_arg(0);
            break;
        case enemy_flags_set: // 502
            this->flags_low |= this->get_int_arg(0);
            if (this->intangible) {
                for (size_t i = 0; i < ENEMY_ANM_SLOTS; ++i) {
                    this->anm_vms[i].__tree_clear_visible2();
                }
            }
            break;
        case enemy_flags_clear: // 503
            this->flags_low &= ~this->get_int_arg(0);
            if (this->intangible) {
                for (size_t i = 0; i < ENEMY_ANM_SLOTS; ++i) {
                    this->anm_vms[i].__tree_set_visible2();
                }
            }
            break;
        case item_bonus_slots_reset: // 506
            this->drops.reset_extra_drops();
            break;
        case item_bonus_slot_set: { // 507
            int32_t slot = this->get_int_arg(0);
            int32_t item = this->get_int_arg(1);
            this->drops.set_extra_drop(slot, item);
            break;
        }
        case item_timed_bonus_slot_set: { // 573
            int32_t slot = this->get_int_arg(0);
            int32_t item = this->get_int_arg(1);
            this->drops.set_timed_extra_drop(slot, item);
            break;
        }
        case item_drop_area: { // 508
            float height = this->get_float_arg(1);
            float width = this->get_float_arg(0);
            this->drops.set_area(width, height);
            break;
        }
        case drop_item_rewards: // 509
            if (GAME_MANAGER.__unknown_field_A_is_2()) {
        case drop_item_rewards_force: // 562
                this->drops.spawn_items(&this->get_position());
            }
            break;
        case item_reward_set: { // 510
            int32_t item = this->get_int_arg(0);
            this->drops.set_main_drop(item);
            break;
        }
        case enemy_life_set: { // 511
            EnemyLife& life = this->life;
            int32_t hp = this->get_int_arg(0);
            life.set_current(hp);
            life.set_maximum(life.get_current());
            life.set_current_remaining(life.get_current());
            if (this->is_boss) {
                this->__unknown_flag_O = true;
            }
            life.set_current_scaled(life.get_current());
            break;
        }
        case __enemy_life_set_current: { // 572
            int32_t hp = this->get_int_arg(0);
            this->life.set_current(hp);
            this->life.set_current_scaled(this->life.get_current());
            break;
        }
        case boss_set: {
            int32_t index = this->get_int_arg(0);
            ENEMY_MANAGER_PTR->__set_unkown_flag_A(false);
            if (index < 0) {
                if (this->is_boss) {
                    ENEMY_MANAGER_PTR->set_boss(this->boss_id, NULL);
                }
                this->is_boss = false;
            }
            else {
                this->is_boss = true;
                ENEMY_MANAGER_PTR->set_boss(index, this->enemy());
                this->boss_id = index;
            }
            break;
        }
        case enemy_invincible_timer: { // 515
            int32_t duration = this->get_int_arg(0);
            this->invulnerable_timer.set(duration);
            break;
        }
        case enemy_no_collision_timer: { // 541
            int32_t duration = this->get_int_arg(0);
            this->no_collision_timer.set(duration);
            break;
        }
        case enemy_kill_all_id: { // 551
            int32_t kill_id = this->get_int_arg(0);
            ENEMY_MANAGER_PTR->kill_all_by_kill_id(kill_id);
            break;
        }
        case enemy_kill_all_no_callbacks: // 571
            ENEMY_MANAGER_PTR->kill_all_no_callbacks();
            break;
        case set_int_difficulty: { // 535
            int32_t easy = this->get_int_arg(1);
            int32_t normal = this->get_int_arg(2);
            int32_t hard = this->get_int_arg(3);
            int32_t lunatic = this->get_int_arg(4);
            switch (GAME_MANAGER.get_difficulty()) {
                case EASY:
                    *this->get_int_ptr_arg(0) = easy;
                    break;
                case NORMAL:
                    *this->get_int_ptr_arg(0) = normal;
                    break;
                case HARD:
                    *this->get_int_ptr_arg(0) = hard;
                    break;
                default:
                    *this->get_int_ptr_arg(0) = lunatic;
                    break;
            }
            break;
        }
        case set_float_difficulty: { // 536
            float easy = this->get_float_arg(1);
            float normal = this->get_float_arg(2);
            float hard = this->get_float_arg(3);
            float lunatic = this->get_float_arg(4);
            switch (GAME_MANAGER.get_difficulty()) {
                case EASY:
                    *this->get_float_ptr_arg(0) = easy;
                    break;
                case NORMAL:
                    *this->get_float_ptr_arg(0) = normal;
                    break;
                case HARD:
                    *this->get_float_ptr_arg(0) = hard;
                    break;
                default:
                    *this->get_float_ptr_arg(0) = lunatic;
                    break;
            }
            break;
        }
        case shooter_reset: { // 600
            int32_t slot = this->get_int_arg(0);
            this->shooters[slot].zero_contents();
            this->shooters[slot].angle1 = 0.0f;
            this->shooters[slot].speed1 = 2.0f;
            this->shooters[slot].count1 = 1;
            this->shooters[slot].count2 = 1;
            this->shooters[slot].shoot_sound = 21;
            this->shooters[slot].transform_sound = 38;
            this->shooters[slot].flags = 0x23; // TODO: convert to bitfields
            this->shooter_offsets[slot].x = 0.0f;
            this->shooter_offsets[slot].y = 0.0f;
            this->shooter_origins[slot].x = 0.0f;
            this->shooter_origins[slot].y = 0.0f;
            this->shooter_origins[slot].z = 0.0f;
            this->bullet_effect_indices[slot] = 0;
            break;
        }
        case shooter_copy: { // 614
            int32_t dst = this->get_int_arg(0);
            int32_t src = this->get_int_arg(1);
            this->shooters[dst] = this->shooters[src];
            this->shooter_offsets[dst] = this->shooter_offsets[src];
            this->shooter_origins[dst] = this->shooter_origins[src];
            break;
        }
        case shoot_now: { // 601
            int32_t slot = this->get_int_arg(0);
            if (this->shooter_origins[slot].z > 0.9f) {
                this->shooters[slot].position.set(this->shooter_offsets[slot].as2() + this->shooter_origins[slot].as2());
            } else {
                this->shooters[slot].position = this->current_motion.get_position() + this->shooter_offsets[slot];
            }
            BULLET_MANAGER_PTR->set_player_protect_radius_squared(this->player_protect_radius_squared);
            BULLET_MANAGER_PTR->shoot_bullets(&this->shooters[slot]);
            BULLET_MANAGER_PTR->set_player_protect_radius_squared(0.0f);
            break;
        }
        case bullet_sprite: { // 602
            int32_t slot = this->get_int_arg(0);
            int32_t type = this->get_int_arg(1);
            this->shooters[slot].type = type;
            int32_t color = this->get_int_arg(2);
            this->shooters[slot].color = color;
            break;
        }
        case shoot_offset: { // 603
            int32_t slot = this->get_int_arg(0);
            float x = this->get_float_arg(1);
            this->shooter_offsets[slot].x = x;
            float y = this->get_float_arg(2);
            this->shooter_offsets[slot].y = y;
            break;
        }
        case shoot_offset_circle: { // 626
            int32_t slot = this->get_int_arg(0);
            float angle = this->get_float_arg(1);
            float radius = this->get_float_arg(2);
            Float3 offset;
            offset.make_from_vector(angle, radius);
            this->shooter_offsets[slot].x = offset.x;
            this->shooter_offsets[slot].y = offset.y;
            break;
        }
        case shoot_spawn_distance: { // 627
            int32_t slot = this->get_int_arg(0);
            float distance = this->get_float_arg(1);
            this->shooters[slot].distance = distance;
            break;
        }
        case __shoot_origin: { // 628
            int32_t slot = this->get_int_arg(0);
            float x = this->get_float_arg(1);
            this->shooter_origins[slot].x = x;
            float y = this->get_float_arg(2);
            this->shooter_origins[slot].y = y;
            if (this->shooter_origins[slot].x < -990.0f) {
                this->shooter_origins[slot].z = 0.0f;
            } else {
                this->shooter_origins[slot].z = 1.0f;
            }
            break;
        }
        case shoot_angle: { // 604
            int32_t slot = this->get_int_arg(0);
            float angle1 = reduce_angle(this->get_float_arg(1));
            this->shooters[slot].angle1 = angle1;
            float angle2 = reduce_angle(this->get_float_arg(2));
            this->shooters[slot].angle2 = angle2;
            break;
        }
        case bullet_speed: { // 605
            int32_t slot = this->get_int_arg(0);
            float speed1 = this->get_float_arg(1);
            this->shooters[slot].speed1 = speed1;
            float speed2 = this->get_float_arg(2);
            this->shooters[slot].speed2 = speed2;
            break;
        }
        case bullet_count: { // 606
            int32_t slot = this->get_int_arg(0);
            int32_t count1 = this->get_int_arg(1);
            this->shooters[slot].count1 = count1;
            int32_t count2 = this->get_int_arg(2);
            this->shooters[slot].count2 = count2;
            break;
        }
        case bullet_speed_difficulty: { // 624
            int32_t slot = this->get_int_arg(0);
            int32_t arg_index;
            if (GAME_MANAGER.get_difficulty() == EASY) {
                arg_index = 1;
            } else if (GAME_MANAGER.get_difficulty() == NORMAL) {
                arg_index = 2;
            } else if (GAME_MANAGER.get_difficulty() == HARD) {
                arg_index = 3;
            } else {
                arg_index = 4;
            }
            float speed1 = this->get_float_arg(arg_index);
            this->shooters[slot].speed1 = speed1;
            if (GAME_MANAGER.get_difficulty() == EASY) {
                arg_index = 5;
            } else if (GAME_MANAGER.get_difficulty() == NORMAL) {
                arg_index = 6;
            } else if (GAME_MANAGER.get_difficulty() == HARD) {
                arg_index = 7;
            } else {
                arg_index = 8;
            }
            float speed2 = this->get_float_arg(arg_index);
            this->shooters[slot].speed2 = speed2;
            break;
        }
        case bullet_count_difficulty: { // 625
            int32_t slot = this->get_int_arg(0);
            int32_t arg_index;
            if (GAME_MANAGER.get_difficulty() == EASY) {
                arg_index = 1;
            } else if (GAME_MANAGER.get_difficulty() == NORMAL) {
                arg_index = 2;
            } else if (GAME_MANAGER.get_difficulty() == HARD) {
                arg_index = 3;
            } else {
                arg_index = 4;
            }
            int32_t count1 = this->get_int_arg(arg_index);
            this->shooters[slot].count1 = count1;
            if (GAME_MANAGER.get_difficulty() == EASY) {
                arg_index = 5;
            } else if (GAME_MANAGER.get_difficulty() == NORMAL) {
                arg_index = 6;
            } else if (GAME_MANAGER.get_difficulty() == HARD) {
                arg_index = 7;
            } else {
                arg_index = 8;
            }
            int32_t count2 = this->get_int_arg(arg_index);
            this->shooters[slot].count2 = count2;
            break;
        }
        case bullet_speed_rank_3: { // 617
            int32_t slot = this->get_int_arg(0);
            int32_t arg1_index;
            int32_t arg2_index;
            if (GAME_MANAGER.globals.get_rank() >= 512) {
                arg1_index = 5;
                arg2_index = 6;
            }
            else if (GAME_MANAGER.globals.get_rank() >= -512) {
                arg1_index = 3;
                arg2_index = 4;
            }
            else {
                arg1_index = 1;
                arg2_index = 2;
            }
            float speed1 = this->get_float_arg(arg1_index);
            this->shooters[slot].speed1 = speed1;
            float speed2 = this->get_float_arg(arg2_index);
            this->shooters[slot].speed2 = speed2;
            break;
        }
        case bullet_speed_rank_5: { // 618
            int32_t slot = this->get_int_arg(0);
            int32_t arg1_index;
            int32_t arg2_index;
            if (GAME_MANAGER.globals.get_rank() >= 600) {
                arg1_index = 9;
                arg2_index = 10;
            }
            else if (GAME_MANAGER.globals.get_rank() >= 200) {
                arg1_index = 7;
                arg2_index = 8;
            }
            else if (GAME_MANAGER.globals.get_rank() >= -200) {
                arg1_index = 5;
                arg2_index = 6;
            }
            else if (GAME_MANAGER.globals.get_rank() >= -600) {
                arg1_index = 3;
                arg2_index = 4;
            }
            else {
                arg1_index = 1;
                arg2_index = 2;
            }
            float speed1 = this->get_float_arg(arg1_index);
            this->shooters[slot].speed1 = speed1;
            float speed2 = this->get_float_arg(arg2_index);
            this->shooters[slot].speed2 = speed2;
            break;
        }
        case bullet_speed_rank_lerp: { // 619
            int32_t slot = this->get_int_arg(0);
            float speed1_low = this->get_float_arg(1);
            float speed2_low = this->get_float_arg(2);
            float speed1_high = this->get_float_arg(3);
            float speed2_high = this->get_float_arg(4);
            this->shooters[slot].speed1 = GAME_MANAGER.globals.rank_lerp(speed1_low, speed1_high);
            this->shooters[slot].speed2 = GAME_MANAGER.globals.rank_lerp(speed2_low, speed2_high);
            break;
        }
        case bullet_count_rank_3: { // 620
            int32_t slot = this->get_int_arg(0);
            int32_t arg1_index;
            int32_t arg2_index;
            if (GAME_MANAGER.globals.get_rank() >= 512) {
                arg1_index = 5;
                arg2_index = 6;
            }
            else if (GAME_MANAGER.globals.get_rank() >= -512) {
                arg1_index = 3;
                arg2_index = 4;
            }
            else {
                arg1_index = 1;
                arg2_index = 2;
            }
            int32_t count1 = this->get_int_arg(arg1_index);
            this->shooters[slot].count1 = count1;
            int32_t count2 = this->get_int_arg(arg2_index);
            this->shooters[slot].count2 = count2;
            break;
        }
        case bullet_count_rank_5: { // 621
            int32_t slot = this->get_int_arg(0);
            int32_t arg1_index;
            int32_t arg2_index;
            if (GAME_MANAGER.globals.get_rank() >= 600) {
                arg1_index = 9;
                arg2_index = 10;
            }
            else if (GAME_MANAGER.globals.get_rank() >= 200) {
                arg1_index = 7;
                arg2_index = 8;
            }
            else if (GAME_MANAGER.globals.get_rank() >= -200) {
                arg1_index = 5;
                arg2_index = 6;
            }
            else if (GAME_MANAGER.globals.get_rank() >= -600) {
                arg1_index = 3;
                arg2_index = 4;
            }
            else {
                arg1_index = 1;
                arg2_index = 2;
            }
            int32_t count1 = this->get_int_arg(arg1_index);
            this->shooters[slot].count1 = count1;
            int32_t count2 = this->get_int_arg(arg2_index);
            this->shooters[slot].count2 = count2;
            break;
        }
        case bullet_count_rank_lerp: { // 619
            int32_t slot = this->get_int_arg(0);
            int32_t count1_low = this->get_int_arg(1);
            int32_t count2_low = this->get_int_arg(2);
            int32_t count1_high = this->get_int_arg(3);
            int32_t count2_high = this->get_int_arg(4);
            this->shooters[slot].count1 = GAME_MANAGER.globals.rank_lerp(count1_low, count1_high);
            this->shooters[slot].count2 = GAME_MANAGER.globals.rank_lerp(count2_low, count2_high);
            break;
        }
        case shoot_aim_mode: { // 607
            int32_t slot = this->get_int_arg(0);
            int32_t mode = this->get_int_arg(1);
            this->shooters[slot].aim_mode = mode;
            break;
        }
        case bullet_sound: { // 608
            int32_t slot = this->get_int_arg(0);
            int32_t shoot_sound = this->get_int_arg(1);
            this->shooters[slot].shoot_sound = shoot_sound;
            int32_t transform_sound = this->get_int_arg(2);
            this->shooters[slot].transform_sound = transform_sound;
            break;
        }
        case bullet_effects: case bullet_effects_ex: // 609, 610
        case bullet_effects_add: case bullet_effects_add_ex: // 611, 612
        {
            // BUG: this is the argument used to select
            // a shooter, not the effect index.
            int32_t shooter_slot = this->get_int_arg(0);
            if (shooter_slot >= BULLET_EFFECT_MAX || shooter_slot < 0) {
                DebugLogger::__debug_log_stub_3("error et_ex over \n");
                shooter_slot = 0;
            }

            opcode = current_instruction->opcode;

            int32_t effect_arg_index; // ESI
            if (
                opcode != bullet_effects_add && // 611
                opcode != bullet_effects_add_ex // 612
            ) {
                effect_arg_index = 2;
            } else {
                effect_arg_index = 1;
            }

            int32_t effect_slot;
            if (
                opcode != bullet_effects_add && // 611
                opcode != bullet_effects_add_ex // 612
            ) {
                effect_slot = this->get_int_arg(1);
            } else {
                effect_slot = this->bullet_effect_indices[shooter_slot];
            }

            int32_t async = this->get_int_arg(effect_arg_index);
            ++effect_arg_index;
            this->shooters[shooter_slot].effects[effect_slot].async = async;

            int32_t type = this->get_int_arg(effect_arg_index);
            ++effect_arg_index;
            this->shooters[shooter_slot].effects[effect_slot].type = (BulletEffectType)type;

            int32_t A = this->get_int_arg(effect_arg_index);
            ++effect_arg_index;
            this->shooters[shooter_slot].effects[effect_slot].int_values[0] = A;
            int32_t B = this->get_int_arg(effect_arg_index);
            ++effect_arg_index;
            this->shooters[shooter_slot].effects[effect_slot].int_values[1] = B;

            opcode = current_instruction->opcode;
            if (
                opcode == bullet_effects_ex || // 610
                opcode == bullet_effects_add_ex // 612
            ) {
                int32_t C = this->get_int_arg(effect_arg_index);
                ++effect_arg_index;
                this->shooters[shooter_slot].effects[effect_slot].int_values[2] = C;
                int32_t D = this->get_int_arg(effect_arg_index);
                ++effect_arg_index;
                this->shooters[shooter_slot].effects[effect_slot].int_values[2] = D;
            }

            float R = this->get_float_arg(effect_arg_index);
            ++effect_arg_index;
            this->shooters[shooter_slot].effects[effect_slot].float_values[0] = R;
            float S = this->get_float_arg(effect_arg_index);
            ++effect_arg_index;
            this->shooters[shooter_slot].effects[effect_slot].float_values[1] = S;

            opcode = current_instruction->opcode;
            if (
                opcode == bullet_effects_ex || // 610
                opcode == bullet_effects_add_ex // 612
            ) {
                float M = this->get_float_arg(effect_arg_index);
                ++effect_arg_index;
                this->shooters[shooter_slot].effects[effect_slot].float_values[2] = M;
                float N = this->get_float_arg(effect_arg_index);
                ++effect_arg_index;
                this->shooters[shooter_slot].effects[effect_slot].float_values[3] = N;
            }

            opcode = current_instruction->opcode;
            if (
                opcode != bullet_effects_add && // 611
                opcode != bullet_effects_add_ex // 612
            ) {
                this->bullet_effect_indices[shooter_slot] = effect_slot + 1;
            } else {
                ++this->bullet_effect_indices[shooter_slot];
            }
            break;
        }
        case __bullet_effects_prev: { // 641
            int32_t slot = this->get_int_arg(0);
            if (--this->bullet_effect_indices[slot] < 0) {
                this->bullet_effect_indices[slot] = 0;
            }
            break;
        }
        case bullet_effects_set_string: { // 640
            int32_t shooter_slot = this->get_int_arg(0);
            int32_t effect_slot = this->get_int_arg(1);
            this->shooters[shooter_slot].effects[effect_slot].string = StringArg(2);
            break;
        }
        case laser_size_data: { // 700
            int32_t slot = this->get_int_arg(0);
            float length = this->get_float_arg(1);
            this->shooters[slot].position.x = length;
            float B = this->get_float_arg(2);
            this->shooters[slot].position.y = B;
            float C = this->get_float_arg(3);
            this->shooters[slot].position.z = C;
            float width = this->get_float_arg(4);
            this->shooters[slot].width = width;
            break;
        }
        case laser_timing_data: { // 701
            int32_t slot = this->get_int_arg(0);
            int32_t start_time = this->get_int_arg(1);
            this->shooters[slot].start_time = start_time;
            int32_t A = this->get_int_arg(2);
            this->shooters[slot].__transform_A = A;
            int32_t duration = this->get_int_arg(3);
            this->shooters[slot].duration = duration;
            int32_t B = this->get_int_arg(4);
            this->shooters[slot].__transform_B = B;
            int32_t __laser_flags = this->get_int_arg(5);
            this->shooters[slot].__laser_flags = __laser_flags;
            break;
        }
        case callback_ex: { // 514
            const char* callback_sub = StringArg(4);
            int32_t chapter;
            if (
                GAME_MANAGER.__unknown_field_A_is_2() &&
                this->is_boss
            ) {
                // This section is very strange.
                // The logic seems to be 100% redudant,
                // so maybe it's a leftover structure
                // from a previous game?
                callback_sub = "BossDead";
                if (this->boss_id == 0) {
                    if (
                        GAME_MANAGER.get_current_stage() == 7 &&
                        GAME_MANAGER.get_chapter() < 41
                    ) {
                        callback_sub = "MBossDead";
                    }
                }
                else {
                    if (
                        GAME_MANAGER.get_current_stage() == 7 &&
                        GAME_MANAGER.get_chapter() < 41
                    ) {
                        callback_sub = "MBossDead";
                    }
                }

                int32_t time_duration = this->get_int_arg(2);
                int32_t callback_index = this->get_int_arg(0);
                this->enemy()->set_callback(callback_index, 0, time_duration, callback_sub);
                callback_index = this->get_int_arg(0);
                this->enemy()->set_callback_time_sub_name(callback_index, "BossEscape");
            }
            else {
                int32_t time_duration = this->get_int_arg(2);
                int32_t life_threshold = this->get_int_arg(1);
                int32_t callback_index = this->get_int_arg(0);
                this->enemy()->set_callback(callback_index, life_threshold, time_duration, callback_sub);
            }
            break;
        }
        case timer_callback_sub: { // 521
            const char* callback_sub = StringArg(1);
            int32_t callback_index = this->get_int_arg(0);
            this->enemy()->set_callback_time_sub_name(callback_index, callback_sub);
            break;
        }
        case Opcode::death_callback_sub: { // 556
            const char* callback_sub = StringArg(0);
            byteloop_strcpy(this->death_callback_sub, callback_sub);
            break;
        }
        case bullet_cancel: // 613
            BULLET_MANAGER_PTR->cancel_all(CancelType0);
            LASER_MANAGER_PTR->cancel_all(1, 0);
            break;
        case effect_sound: { // 516
            Float3* position = &this->get_position();
            int32_t sound = this->get_int_arg(0);
            SOUND_MANAGER.play_sound_positioned(sound, position->x);
            break;
        }
        case effect_screen_shake: { // 517
            // TODO
            break;
        }
        case msg_read: { // 518
            // TODO
        }
            [[fallthrough]];
        case enemy_kill_all: // 525
            ENEMY_MANAGER_PTR->kill_all();
            break;
        case msg_wait: // 519
            if (
                GUI_PTR->msg_vm_active() &&
                !GUI_PTR->__get_enemy_appear_counter()
            ) {
                return -1;
            }
            break;
        case boss_wait: // 520
            if (
                ENEMY_MANAGER_PTR->get_boss_by_index(0) ||
                ENEMY_MANAGER_PTR->get_boss_by_index(1) ||
                ENEMY_MANAGER_PTR->get_boss_by_index(2)
            ) {
                return -1;
            }
            break;
        case enemy_flag_mirror2: // 558
            this->mirrored = this->get_int_arg(0);
            break;
        case spellcard_start: case spellcard_start_2: // 522, 528
        case spellcard_start_difficulty: case spellcard_start_difficulty_1: case spellcard_start_difficulty_2: // 537, 538, 539
        {
            // TODO
            break;
        }
        case boss_timer_clear: // 513
            this->ecl_time.reset(); // This is definitely the right offset...
            break;
        case __enemy_flag_armored: // 568
            this->life.set_spell(this->get_int_arg(0));
            break;
        case spellcard_end: // 523
            if (SPELLCARD_PTR->__get_flag_A() && SPELLCARD_PTR->__get_flag_B()) {
                ITEM_MANAGER_PTR->spawn_item(LifeFragmentItem, &this->get_position(), -HALF_PI_f, 2.2f, 60);
            }
            SPELLCARD_PTR->end_spell();
            this->life.set_spell(false);
            break;
        case spellcard_flag_timeout_set: // 542
            SPELLCARD_PTR->__set_timeout_flag();
            break;
        case __spellcard_flag_anm_unknown: // 543
            SPELLCARD_PTR->__sub_42D670();
            break;
        case __spellcard_flag_unknown_A: { // 567
            int32_t state = this->get_int_arg(0);
            SPELLCARD_PTR->__set_flag_H(state);
            break;
        }
        case enemy_flag_homing_disable: // 544
            this->homing_disable = this->get_int_arg(0);
            break;
        case laser_line_create: { // 702
            LaserLineParams params;

            int32_t slot = this->get_int_arg(0);
            memcpy(params.effects, this->shooters[slot].effects, sizeof(BulletEffectArgs[BULLET_EFFECT_MAX]));

            if (this->shooter_origins[slot].z > 0.9f) {
                params.position.set(this->shooter_offsets[slot].as2() + this->shooter_origins[slot].as2());
            } else {
                params.position = this->current_motion.get_position() + this->shooter_offsets[slot];
            }
            params.sprite = this->shooters[slot].type;
            params.color = this->shooters[slot].color;
            params.__angle_C = reduce_angle(this->shooters[slot].angle1);
            params.__speed_1 = this->shooters[slot].speed1;
            params.length = this->shooters[slot].position.x;
            params.flags = this->shooters[slot].__laser_flags | 1;
            params.__length_related = this->shooters[slot].position.y;
            params.shot_sound = this->shooters[slot].shoot_sound;
            params.__float_18 = this->shooters[slot].position.z;
            params.transform_sound = this->shooters[slot].transform_sound;
            params.width = this->shooters[slot].width;
            params.distance = this->shooters[slot].distance;
            LASER_MANAGER_PTR->allocate_new_laser(LineLaser, &params);
            break;
        }
        case laser_infinite_create: { // 703
            LaserInfiniteParams params;

            int32_t slot = this->get_int_arg(0);
            memcpy(params.effects, this->shooters[slot].effects, sizeof(BulletEffectArgs[BULLET_EFFECT_MAX]));

            if (this->shooter_origins[slot].z > 0.9f) {
                params.position.set(this->shooter_offsets[slot].as2() + this->shooter_origins[slot].as2());
            } else {
                params.position = this->current_motion.get_position() + this->shooter_offsets[slot];
            }
            // TODO

            params.laser_id = this->get_int_arg(1);
            LASER_MANAGER_PTR->allocate_new_laser(InfiniteLaser, &params);
            break;
        }
        case laser_beam_create: { // 713
            LaserBeamParams params;

            int32_t slot = this->get_int_arg(0);
            memcpy(params.effects, this->shooters[slot].effects, sizeof(BulletEffectArgs[BULLET_EFFECT_MAX]));

            if (this->shooter_origins[slot].z > 0.9f) {
                params.position.set(this->shooter_offsets[slot].as2() + this->shooter_origins[slot].as2());
            } else {
                params.position = this->current_motion.get_position() + this->shooter_offsets[slot];
            }
            params.color = this->shooters[slot].color;
            params.__angle_18 = reduce_angle(this->shooters[slot].angle1);
            params.__float_20 = this->shooters[slot].position.z;
            params.start_time = this->shooters[slot].start_time;
            params.distance = this->shooters[slot].distance;
            params.laser_id = this->get_int_arg(1);
            LASER_MANAGER_PTR->allocate_new_laser(BeamLaser, &params);
            break;
        }
        case laser_curve_create: { // 711
            LaserCurveParams params;

            int32_t slot = this->get_int_arg(0);
            memcpy(params.effects, this->shooters[slot].effects, sizeof(BulletEffectArgs[BULLET_EFFECT_MAX]));

            if (this->shooter_origins[slot].z > 0.9f) {
                params.position.set(this->shooter_offsets[slot].as2() + this->shooter_origins[slot].as2());
            } else {
                params.position = this->current_motion.get_position() + this->shooter_offsets[slot];
            }
            // TODO

            LASER_MANAGER_PTR->allocate_new_laser(CurvyLaser, &params);
            break;
        }
        case laser_clear: // 710
            while (LaserData* laser = LASER_MANAGER_PTR->get_laser_with_id(this->get_int_arg(0))) {
                laser->cancel(0, 0);
                laser->set_id(0);
            }
            break;
        case laser_offset: { // 704
            LaserData* laser = LASER_MANAGER_PTR->get_laser_with_id(this->get_int_arg(0));
            Float3 position;
            position.x = this->get_float_arg(1);
            position.y = this->get_float_arg(2);
            if (laser) {
                position.z = 0.0f;
                laser->set_position(&position);
            }
            break;
        }
        case laser_target: { // 705
            LaserData* laser = LASER_MANAGER_PTR->get_laser_with_id(this->get_int_arg(0));
            Float3 velocity;
            velocity.x = this->get_float_arg(1);
            velocity.y = this->get_float_arg(2);
            if (laser) {
                velocity.z = 0.0f;
                laser->set_velocity(&velocity);
            }
            break;
        }
        case laser_speed: // 706
            if (LaserData* laser = LASER_MANAGER_PTR->get_laser_with_id(this->get_int_arg(0))) {
                float speed = this->get_float_arg(1);
                laser->set_speed(speed);
            }
            break;
        case laser_width: // 707
            if (LaserData* laser = LASER_MANAGER_PTR->get_laser_with_id(this->get_int_arg(0))) {
                float width = this->get_float_arg(1);
                laser->set_width(width);
            }
            break;
        case laser_angle: // 708
            if (LaserData* laser = LASER_MANAGER_PTR->get_laser_with_id(this->get_int_arg(0))) {
                float angle = this->get_float_arg(1);
                laser->set_angle(angle);
            }
            break;
        case laser_rotate: // 709
            if (LaserData* laser = LASER_MANAGER_PTR->get_laser_with_id(this->get_int_arg(0))) {
                float angular_velocity = this->get_float_arg(1);
                laser->set_angular_velocity(angular_velocity);
            }
            break;
        case __laser_beam_flag_unknown_A: // 714
            if (LaserData* laser = LASER_MANAGER_PTR->get_laser_with_id(this->get_int_arg(0))) {
                int32_t state = this->get_int_arg(1);
                laser->__method_8(state);
            }
            break;
        case Opcode::bullet_cancel_radius: { // 615
            float radius = this->get_float_arg(0);
            BULLET_MANAGER_PTR->cancel_radius(&this->get_position(), radius, CancelType1);
            LASER_MANAGER_PTR->cancel_in_radius(&this->get_position(), radius, 1, 1);
            break;
        }
        case __bullet_cancel_weak_rectangle: { // 712
            Float3 size;
            size.x = this->get_float_arg(0);
            size.y = this->get_float_arg(1);
            float rotation = this->anm_vms[0].get_vm_ptr()->get_z_rotation();
            BULLET_MANAGER_PTR->cancel_rotated_rectangle_as_bomb(&this->get_position(), &size, rotation, CancelType1, 0);
            break;
        }
        case bullet_clear_radius: { // 615
            float radius = this->get_float_arg(0);
            BULLET_MANAGER_PTR->cancel_radius(&this->get_position(), radius, CancelType0);
            LASER_MANAGER_PTR->cancel_in_radius(&this->get_position(), radius, 0, 1);
            break;
        }
        case bullet_cancel_weak_radius: { // 635
            float radius = this->get_float_arg(0);
            BULLET_MANAGER_PTR->cancel_radius_as_bomb(&this->get_position(), radius, CancelType1, 99999, 0);
            LASER_MANAGER_PTR->cancel_in_radius(&this->get_position(), radius, 1, 1);
            break;
        }
        case bullet_clear_weak_radius: { // 636
            float radius = this->get_float_arg(0);
            BULLET_MANAGER_PTR->cancel_radius_as_bomb(&this->get_position(), radius, CancelType0, 99999, 0);
            LASER_MANAGER_PTR->cancel_in_radius(&this->get_position(), radius, 0, 1);
            break;
        }
        case chapter_set: { // 524
            int32_t chapter = this->get_int_arg(0);
            GAME_THREAD_PTR->set_chapter(chapter);
            this->chapter = chapter;
            this->chapter_spawn_weight = 0;
            break;
        }
        case set_float_rank_3: // 529
            if (GAME_MANAGER.globals.get_rank() >= 512) {
                *this->get_float_ptr_arg(0) = this->get_float_arg(2);
            }
            // BUG: Middle case is optimized out as impossible,
            // likely because of a missing negative sign.
            else if (GAME_MANAGER.globals.get_rank() >= 512) {
                *this->get_float_ptr_arg(0) = this->get_float_arg(1);
            }
            else {
                *this->get_float_ptr_arg(0) = this->get_float_arg(0);
            }
            break;
        case set_float_rank_5: // 530
            if (GAME_MANAGER.globals.get_rank() >= 600) {
                *this->get_float_ptr_arg(0) = this->get_float_arg(4);
            }
            else if (GAME_MANAGER.globals.get_rank() >= 200) {
                *this->get_float_ptr_arg(0) = this->get_float_arg(3);
            }
            else if (GAME_MANAGER.globals.get_rank() >= -200) {
                *this->get_float_ptr_arg(0) = this->get_float_arg(2);
            }
            else if (GAME_MANAGER.globals.get_rank() >= -400) {
                *this->get_float_ptr_arg(0) = this->get_float_arg(1);
            }
            else {
                *this->get_float_ptr_arg(0) = this->get_float_arg(0);
            }
            break;
        case math_float_rank_lerp: { // 531
            float low = this->get_float_arg(1);
            float high = this->get_float_arg(2);
            *this->get_float_ptr_arg(0) = GAME_MANAGER.globals.rank_lerp(low, high);
            break;
        }
        case set_int_rank_3: // 532
            if (GAME_MANAGER.globals.get_rank() >= 512) {
                *this->get_int_ptr_arg(0) = this->get_int_arg(2);
            }
            // BUG: Middle case is optimized out as impossible,
            // likely because of a missing negative sign.
            else if (GAME_MANAGER.globals.get_rank() >= 512) {
                *this->get_int_ptr_arg(0) = this->get_int_arg(1);
            }
            else {
                *this->get_int_ptr_arg(0) = this->get_int_arg(0);
            }
            break;
        case set_int_rank_5: // 533
            if (GAME_MANAGER.globals.get_rank() >= 600) {
                *this->get_int_ptr_arg(0) = this->get_int_arg(4);
            }
            else if (GAME_MANAGER.globals.get_rank() >= 200) {
                *this->get_int_ptr_arg(0) = this->get_int_arg(3);
            }
            else if (GAME_MANAGER.globals.get_rank() >= -200) {
                *this->get_int_ptr_arg(0) = this->get_int_arg(2);
            }
            else if (GAME_MANAGER.globals.get_rank() >= -400) {
                *this->get_int_ptr_arg(0) = this->get_int_arg(1);
            }
            else {
                *this->get_int_ptr_arg(0) = this->get_int_arg(0);
            }
            break;
        case math_int_rank_lerp: { // 534
            int32_t low = this->get_int_arg(1);
            int32_t high = this->get_int_arg(2);
            *this->get_int_ptr_arg(0) = GAME_MANAGER.globals.rank_lerp(low, high);
            break;
        }
        case boss_set_life_count: { // 540
            int32_t lives = this->get_int_arg(0);
            GUI_PTR->__set_boss_life_count(lives);
            break;
        }
        case laser_clear_all: // 545
            LASER_MANAGER_PTR->clear_all();
            break;
        case enemy_bomb_shield: { // 546
            this->bomb_shield = this->get_int_arg(0);
            int32_t anm_script = this->get_int_arg(1);
            this->disable_hitbox = false;
            this->bomb_shield_active = false;
            this->bombshield_on_anm = anm_script;
            this->bombshield_off_anm = this->current_anm_script;
            break;
        }
        case enemy_limit_set: { // 559
            int32_t limit = this->get_int_arg(0);
            ENEMY_MANAGER_PTR->set_enemy_limit(limit);
            break;
        }
        case game_speed_set: { // 547
            float speed = this->get_float_arg(0);
            GAME_SPEED.set(speed);
            break;
        }
        case set_float_angle_to_player_from_point: { // 623
            float x_pos = PLAYER_PTR->get_position()->x - this->get_float_arg(0);
            float y_pos = PLAYER_PTR->get_position()->y - this->get_float_arg(1);
            *this->get_float_ptr_arg(0) = zatan2f(y_pos, x_pos);
            break;
        }
        case ecl_time_sub_difficulty: { // 548
            int32_t easy = this->get_int_arg(0);
            int32_t normal = this->get_int_arg(1);
            int32_t hard = this->get_int_arg(2);
            int32_t lunatic = this->get_int_arg(3);
            if (GAME_MANAGER.get_difficulty() == EASY) {
                this->enemy()->subtract_time_float(easy);
            } else if (GAME_MANAGER.get_difficulty() == NORMAL) {
                this->enemy()->subtract_time_float(normal);
            } else if (GAME_MANAGER.get_difficulty() == HARD) {
                this->enemy()->subtract_time_float(hard);
            } else {
                this->enemy()->subtract_time_float(lunatic);
            }
            break;
        }
        case enemy_fog_spawn: { // 629
            // TODO
            break;
        }
        case std_interrupt: { // 630
            int32_t interrupt = this->get_int_arg(0);
            // STAGE_PTR->std_interrupt(interrupt);
            break;
        }
        case std_fog_interp: { // 557
            // TODO
            break;
        }
        case __enemy_flag_unknown_A: // 549
            this->__anm_related_flag_A = this->get_int_arg(0);
            break;
        case enemy_set_kill_id: // 550
            this->kill_id = this->get_int_arg(0);
            break;
        case enemy_id_exists: { // 555
            int32_t* write = this->get_int_ptr_arg(0);
            int32_t id = this->get_int_arg(1);
            *write = ENEMY_MANAGER_PTR->enemy_exists_with_id(id);
            break;
        }
        case enemy_id_get_position_crash: { // 801
            int32_t id = this->get_int_arg(2);
            Enemy* enemy = ENEMY_MANAGER_PTR->get_enemy_by_id(id);
            *this->get_float_ptr_arg(0) = enemy->get_current_motion()->position.x;
            *this->get_float_ptr_arg(1) = enemy->get_current_motion()->position.y;
            break;
        }
        case boss_callback: { // 802
            int32_t slot = this->get_int_arg(0);
            for (int32_t i = 0; i < 4; ++i) {
                Enemy* boss = ENEMY_MANAGER_PTR->get_boss_by_index(i);
                if (
                    i != this->boss_id &&
                    boss != NULL &&
                    boss->get_data().callbacks[slot].life >= 0 &&
                    boss->get_data().callbacks[slot].life_sub // BUG: This is checking if the array exists
                ) {
                    // this is definitely an inlined call to
                    // reinitialize_vm_with_sub of some sort,
                    // but getting the get_data() call to match is
                    // pain so I'm leaving it as-is
                    boss->cleanup_vm();
                    boss->initialize_vm();
                    boss->set_context_to_sub(boss->get_data().callbacks[slot].life_sub);
                }
            }
            break;
        }
        case enemy_id_change_sub: { // 800
            int32_t id = this->get_int_arg(0);
            if (Enemy* enemy = ENEMY_MANAGER_PTR->get_enemy_by_id(id)) {
                enemy->reinitialize_vm_with_sub(StringArg(1));
                //enemy->cleanup_vm();
                //enemy->initialize_vm();
                //enemy->set_context_to_sub(StringArg(1));
            }
            break;
        }
        case enemy_id_get_position: { // 324
            int32_t id = this->get_int_arg(2);
            if (Enemy* enemy = ENEMY_MANAGER_PTR->get_enemy_by_id(id)) {
                *this->get_float_ptr_arg(0) = enemy->get_current_motion()->position.x;
                *this->get_float_ptr_arg(1) = enemy->get_current_motion()->position.y;
            } else {
                *this->get_float_ptr_arg(0) = this->get_current_motion().position.x;
                *this->get_float_ptr_arg(1) = this->get_current_motion().position.y;
            }
            break;
        }
        case bullet_bounce_bounds_set: { // 560
            float height = this->get_float_arg(1);
            float width = this->get_float_arg(0);
            BULLET_MANAGER_PTR->__set_bounce_bounds(width, height);
            break;
        }
        case __enemy_id_set_flag_unknown_B: { // 340
            int32_t id = this->get_int_arg(0);
            if (Enemy* enemy = ENEMY_MANAGER_PTR->get_enemy_by_id(id)) {
                enemy->__set_unknown_flag_B();
            }
            break;
        }
        case __globals_flag_unknown_A: { // 1001
            int32_t state = this->get_int_arg(0);
            GAME_MANAGER.globals.__set_unknown_flag_A(state);
            break;
        }
#if INCLUDE_PATCH_CODE
        //case 1002: { // set_int_card_count
            // The code wouldn't really include well if I wrote it here...
        //}
        case 1003: { // enemy_interrupt_set
            uint32_t slot = this->get_int_arg(0);
            this->set_interrupt(slot, StringArg(1));
            break;
        }
#endif
    }
    return 0;
}

// 0x4B4144
static inline constexpr const char* TWO_LETTER_DIFFICULTY_NAMES[] = {
    "E ",
    "N ",
    "H ",
    "L ",
    "EX",
    "OD"
};

// 0x4B4160
static inline constexpr const char* THREE_LETTER_STAGE_NAMES[] = {
    "tst",
    "St1",
    "St2",
    "St3",
    "St4",
    "St5",
    "St6",
    "Ex ",
    "All",
    "ExA"
};

// 0x4B4190
static inline constexpr const char* SEVEN_LETTER_STAGE_NAMES[] = {
    "test   ",
    "Stage 1",
    "Stage 2",
    "Stage 3",
    "Stage 4",
    "Stage 5",
    "Stage 6",
    "Extra  ",
    "Clear  ",
    "ExClear"
};

// 0x4B41C0
static inline constexpr const char* SEVEN_LETTER_DIFFICULTY_NAMES[] = {
    "Easy   ",
    "Normal ",
    "Hard   ",
    "Lunatic",
    "Extra  ",
    "O.D.   ",
    "r" // This is definitely part of the table. Why?
};

// 0x4B41E0
static inline constexpr const char* SIX_LETTER_SHOTTYPE_NAMES[] = {
    "Reimu ",
    "Marisa",
    "Sakuya",
    "Sanae "
};

static inline constexpr uint32_t REPLAY_MAGIC = PackUInt('t', '1', '8', 'r');
static inline constexpr uint32_t REPLAY_USER_MAGIC = PackUInt('U', 'S', 'E', 'R');
static inline constexpr uint16_t REPLAY_VERSION_NUMBER = 6; // I'm just guessing at this

// size: 0x24
struct ReplayHeader {
    ZUNMagic magic; // 0x0
    uint16_t __version; // 0x4
    unknown_fields(0x6); // 0x6
    uint32_t file_size; // 0xC
    int __int_10; // 0x10
    unknown_fields(0x8); // 0x14
    uint32_t compressed_size; // 0x1C
    uint32_t uncompressed_size; // 0x20
    // 0x24

    inline void zero_contents() {
        zero_this_inline();
    }

    inline ReplayHeader(uint32_t magic, uint16_t version) {
        this->zero_contents();
        this->magic.as_uint = magic;
        this->__version = version;
        this->__int_10 = 256;
    }
};
#pragma region // ReplayHeader Verification
ValidateFieldOffset32(0x0, ReplayHeader, magic);
ValidateFieldOffset32(0x4, ReplayHeader, __version);
ValidateFieldOffset32(0x10, ReplayHeader, __int_10);
ValidateFieldOffset32(0x1C, ReplayHeader, compressed_size);
ValidateFieldOffset32(0x20, ReplayHeader, uncompressed_size);
ValidateStructSize32(0x24, ReplayHeader);
#pragma endregion

// size: 0xC+
struct ReplayUserData {
    ZUNMagic magic; // 0x0
    int32_t size; // 0x4
    uint8_t __byte_8; // 0x8
    probably_padding_bytes(3); // 0x9
    char text[]; // 0xC
};
#pragma region // ReplayUserData Verification
ValidateFieldOffset32(0x0, ReplayUserData, magic);
ValidateFieldOffset32(0x4, ReplayUserData, size);
ValidateFieldOffset32(0x8, ReplayUserData, __byte_8);
ValidateFieldOffset32(0xC, ReplayUserData, text);
ValidateStructSize32(0xC, ReplayUserData);
#pragma endregion

// size: 0x6
struct ReplayFrameInput {
    uint16_t current; // 0x0
    uint16_t rising_edge; // 0x2
    uint16_t falling_edge; // 0x4
    // 0x6

    inline bool is_end() const {
        return this->current == 0xFFFF && this->rising_edge == 0xFFFF && this->falling_edge == 0xFFFF;
    }
};
#pragma region // ReplayFrameInput Verification
ValidateFieldOffset32(0x0, ReplayFrameInput, current);
ValidateFieldOffset32(0x2, ReplayFrameInput, rising_edge);
ValidateFieldOffset32(0x4, ReplayFrameInput, falling_edge);
ValidateStructSize32(0x6, ReplayFrameInput);
#pragma endregion

static inline constexpr ReplayFrameInput REPLAY_INPUT_END = { 0xFFFF, 0xFFFF, 0xFFFF };

// size: 0x126C+
struct ReplayGamestate {
    int16_t stage_number; // 0x0
    uint16_t rng; // 0x2
    uint32_t input_count; // 0x4
    uint32_t extra_size; // 0x8
    int __dword_C; // 0xC
    int __dword_10; // 0x10
    unknown_fields(0x4); // 0x14
    int __dword_array_18[20]; // 0x18
    Globals globals; // 0x68
    int32_t cards_owned[0x100]; // 0x164
    int32_t card_replay_states[0x100]; // 0x564
    int32_t card_selected; // 0x964
    Globals __globalsB; // 0x968
    int32_t __cards_ownedB[0x100]; // 0xA64
    int32_t __card_replay_statesB[0x100]; // 0xE64
    int32_t __card_selectedB; // 0x1264
    union {
        uint32_t flags; // 0x1268
        struct {
            uint32_t __unknown_flag_A : 1;
        };
    };
    unsigned char extra[]; // 0x126C

    inline void zero_contents() {
        zero_this();
    }

    inline ReplayGamestate() {
        this->zero_contents();
    }
};
#pragma region // ReplayGamestate Verification
ValidateFieldOffset32(0x0, ReplayGamestate, stage_number);
ValidateFieldOffset32(0x2, ReplayGamestate, rng);
ValidateFieldOffset32(0x4, ReplayGamestate, input_count);
ValidateFieldOffset32(0x8, ReplayGamestate, extra_size);
ValidateFieldOffset32(0xC, ReplayGamestate, __dword_C);
ValidateFieldOffset32(0x10, ReplayGamestate, __dword_10);
ValidateFieldOffset32(0x18, ReplayGamestate, __dword_array_18);
ValidateFieldOffset32(0x68, ReplayGamestate, globals);
ValidateFieldOffset32(0x164, ReplayGamestate, cards_owned);
ValidateFieldOffset32(0x564, ReplayGamestate, card_replay_states);
ValidateFieldOffset32(0x964, ReplayGamestate, card_selected);
ValidateFieldOffset32(0x968, ReplayGamestate, __globalsB);
ValidateFieldOffset32(0xA64, ReplayGamestate, __cards_ownedB);
ValidateFieldOffset32(0xE64, ReplayGamestate, __card_replay_statesB);
ValidateFieldOffset32(0x1264, ReplayGamestate, __card_selectedB);
ValidateFieldOffset32(0x1268, ReplayGamestate, flags);
ValidateFieldOffset32(0x126C, ReplayGamestate, extra);
ValidateStructSize32(0x126C, ReplayGamestate);
#pragma endregion

// size: 0xC8
struct ReplayInfo {
    char name[9]; // 0x0
    unknown_fields(0x1); // 0x9
    union {
        uint8_t flags; // 0xA
        struct {
            uint8_t practice_mode : 1;
            uint8_t __unknown_flag_A : 1;
        };
    };
    unknown_fields(0x5); // 0xB
    time_t time; // 0x10 
    int32_t score; // 0x18
    Config config; // 0x1C
    float slowdown_rate; // 0xA4
    int32_t stage_count; // 0xA8
    int32_t character; // 0xAC
    int32_t shottype; // 0xB0
    int32_t difficulty; // 0xB4
    int32_t __end_stage; // 0xB8
    int32_t __int_BC; // 0xBC
    int32_t __ecl_var_9907; // 0xC0
    unknown_fields(0x4); // 0xC4
    // 0xC8

    inline void zero_contents() {
        zero_this();
    }

    inline ReplayInfo() {
        this->zero_contents();
    }

    inline int32_t shottype_index() const {
        return this->character + this->shottype * SHOTTYPES_PER_CHARACTER;
    }

private:
    // 0x457D80
    dllexport gnu_noinline void stdcall __print_in_menuA(int arg1, Float3* position, ReplayInfo* info) {
        tm* time = localtime(&info->time);

        ++arg1;
        if (!info->__unknown_flag_A) {
            ASCII_MANAGER_PTR->printf(position,
                "No.%.2d %s %.2d/%.2d/%.2d %s %s %s",
                arg1, info->name,
                time->tm_year % 100, time->tm_mon + 1, time->tm_mday,
                SIX_LETTER_SHOTTYPE_NAMES[info->shottype_index()],
                TWO_LETTER_DIFFICULTY_NAMES[info->difficulty],
                THREE_LETTER_STAGE_NAMES[info->__end_stage]
            );
        }
        else {
            ASCII_MANAGER_PTR->printf(position,
                "No.%.2d %s %.2d/%.2d/%.2d %s Sp %3d",
                arg1, info->name,
                time->tm_year % 100, time->tm_mon + 1, time->tm_mday,
                SIX_LETTER_SHOTTYPE_NAMES[info->shottype_index()],
                info->__ecl_var_9907 + 1
            );
        }
    }
public:

    inline void __print_in_menuA(int arg1, Float3* position) {
        return ReplayInfo::__print_in_menuA(arg1, position, this);
    }
};
#pragma region // ReplayFrameInput Verification
ValidateFieldOffset32(0x0, ReplayInfo, name);
ValidateFieldOffset32(0xA, ReplayInfo, flags);
ValidateFieldOffset32(0x10, ReplayInfo, time);
ValidateFieldOffset32(0x18, ReplayInfo, score);
ValidateFieldOffset32(0x1C, ReplayInfo, config);
ValidateFieldOffset32(0xA4, ReplayInfo, slowdown_rate);
ValidateFieldOffset32(0xA8, ReplayInfo, stage_count);
ValidateFieldOffset32(0xAC, ReplayInfo, character);
ValidateFieldOffset32(0xB0, ReplayInfo, shottype);
ValidateFieldOffset32(0xB4, ReplayInfo, difficulty);
ValidateFieldOffset32(0xB8, ReplayInfo, __end_stage);
ValidateFieldOffset32(0xBC, ReplayInfo, __int_BC);
ValidateFieldOffset32(0xC0, ReplayInfo, __ecl_var_9907);
ValidateStructSize32(0xC8, ReplayInfo);
#pragma endregion

// size: 0x28
struct ReplayStageData {
    ReplayFrameInput* input_start; // 0x0
    ReplayFrameInput* inputs_current; // 0x4
    uint8_t* fps_counts_start; // 0x8
    uint8_t* fps_counts_current; // 0xC
    ReplayGamestate* gamestate_start; // 0x10
    int32_t current_frame; // 0x14
    ZUNList<ReplayStageData> list_node; // 0x18
    // 0x28

    inline void zero_contents() {
        zero_this_inline();
    }

    // 0x4631F0
    ReplayStageData() {
        this->zero_contents();
        this->fps_counts_current = this->fps_counts_start;
        this->list_node.initialize_with(this);
    }

    // 0x463220
    ~ReplayStageData() {
        this->list_node.unlink();
    }
};
#pragma region // ReplayStageData Verification
ValidateFieldOffset32(0x0, ReplayStageData, input_start);
ValidateFieldOffset32(0x4, ReplayStageData, inputs_current);
ValidateFieldOffset32(0x8, ReplayStageData, fps_counts_start);
ValidateFieldOffset32(0xC, ReplayStageData, fps_counts_current);
ValidateFieldOffset32(0x10, ReplayStageData, gamestate_start);
ValidateFieldOffset32(0x14, ReplayStageData, current_frame);
ValidateFieldOffset32(0x18, ReplayStageData, list_node);
ValidateStructSize32(0x28, ReplayStageData);
#pragma endregion

// size: 0x18B4
struct ReplayChunk {
    ReplayFrameInput inputs[900]; // 0x0
    ReplayFrameInput* next_input_write_pos; // 0x1518
    uint8_t fps_counts[900]; // 0x151C
    uint8_t* next_fps_count_write_pos; // 0x18A0
    ZUNList<ReplayChunk> list_node; // 0x18A4
    // 0x18B4

    inline void zero_contents() {
        zero_this();
    }

    ReplayChunk() {
        this->zero_contents();
        this->next_input_write_pos = this->inputs;
        this->next_fps_count_write_pos = this->fps_counts;
        this->list_node.initialize_with(this);

    }

    inline void cleanup() {
        this->list_node.unlink();
    }

    // 0x463060
    dllexport bool write_input(uint16_t current, uint16_t rising_edge, uint16_t falling_edge) asm_symbol_rel(0x463060) {
        this->next_input_write_pos->current = current;
        this->next_input_write_pos->rising_edge = rising_edge;
        this->next_input_write_pos->falling_edge = falling_edge;
        ++this->next_input_write_pos;
        return this->input_buffer_full();
    }

    inline bool write_input(const ReplayFrameInput& input) {
        return this->write_input(input.current, input.rising_edge, input.falling_edge);
    }

    inline ptrdiff_t input_count() {
        return this->next_input_write_pos - this->inputs;
    }

    inline size_t input_size() {
        return this->input_count() * sizeof(ReplayFrameInput);
    }

    // Fun fact, if this actually overflows then the pointer is completely invalid anyway
    inline bool input_buffer_full() {
        return this->input_count() >= countof(this->inputs);
    }

    inline ptrdiff_t fps_count() {
        return this->next_fps_count_write_pos - this->fps_counts;
    }

    inline size_t fps_size() {
        return this->fps_count() * sizeof(uint8_t);
    }
};
#pragma region // ReplayChunk Verification
ValidateFieldOffset32(0x0, ReplayChunk, inputs);
ValidateFieldOffset32(0x1518, ReplayChunk, next_input_write_pos);
ValidateFieldOffset32(0x151C, ReplayChunk, fps_counts);
ValidateFieldOffset32(0x18A0, ReplayChunk, next_fps_count_write_pos);
ValidateFieldOffset32(0x18A4, ReplayChunk, list_node);
ValidateStructSize32(0x18B4, ReplayChunk);
#pragma endregion

typedef struct ReplayManager ReplayManager;
extern "C" {
    // 0x4CF40C
    externcg ReplayManager* REPLAY_MANAGER_PTR cgasm("_REPLAY_MANAGER_PTR");
}

// size: 0x31C
struct ReplayManager : ZUNTask {
    // ZUNTask base; // 0x0
    ReplayMode mode; // 0xC
    int __dword_10; // 0x10
    ReplayHeader* header; // 0x14
    ReplayInfo* info; // 0x18
    ReplayGamestate* game_states[STAGE_COUNT]; // 0x1C
    ZUNListHead<ReplayChunk> chunk_lists[STAGE_COUNT]; // 0x3C
    ZUNList<ReplayChunk>* current_chunk_node; // 0xBC
    int __chunk_count; // 0xC0
    ReplayStageData stage_data[STAGE_COUNT]; // 0xC4
    void* file_buffer; // 0x204
    uint8_t __byte_208; // 0x208
    probably_padding_bytes(3); // 0x209
    int32_t __int_20C; // 0x20C
    UpdateFunc* on_tick_func_B; // 0x210
    int32_t stage_number; // 0x214
    union {
        uint32_t flags; // 0x218
        struct {
            uint32_t __unknown_flag_B : 1;
            uint32_t __unknown_flag_A : 1;
        };
    };
    char file_path[0x100]; // 0x21C
    // 0x31C

    inline void zero_contents() {
        zero_this();
    }

    inline ReplayManager() {
        this->zero_contents();
    }

    // 0x461AD0
    dllexport gnu_noinline ~ReplayManager() {
        delete this->header;

        this->chunk_lists->for_each_safe([](ReplayChunk* chunk) {
            chunk->list_node.unlink();
            delete chunk;
        });

        delete this->info;
        this->info = NULL;

        for (size_t i = 0; i < STAGE_COUNT; ++i) {
            delete this->game_states[i];
            this->game_states[i] = NULL;
        }

        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func_B);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);

        if (REPLAY_MANAGER_PTR == this) {
            REPLAY_MANAGER_PTR = NULL;
        }
    }

    // 0x462D20
    dllexport static void __sub_462D20() asm_symbol_rel(0x462D20) {
        ReplayManager* replay_manager = REPLAY_MANAGER_PTR;

        replay_manager->enable_tick();
        if (UpdateFunc* on_tick_B = replay_manager->on_tick_func_B) {
            on_tick_B->run_on_update = true;
        }
        replay_manager->enable_draw();

        INPUT_STATES[0].__reset_inputs();

        switch (replay_manager->mode) {
            case __replay_recording: {
                int32_t stage_number = GAME_MANAGER.globals.current_stage;
                ReplayGamestate* game_state = replay_manager->game_states[stage_number];
                replay_manager->delete_chunk_list(stage_number);
                replay_manager->current_chunk_node = replay_manager->allocate_chunk(GAME_MANAGER.globals.current_stage);
                replay_manager->stage_number = GAME_MANAGER.globals.current_stage;
                ABILITY_MANAGER_PTR->equipped_cards_get_ids(game_state->cards_owned);
                ABILITY_MANAGER_PTR->__equipped_cards_get_replay_states(game_state->card_replay_states);
                break;
            }
            case __replay_playback: {
                int32_t stage_number = GAME_MANAGER.globals.current_stage;
                replay_manager->stage_number = stage_number;
                ReplayGamestate* game_state = replay_manager->stage_data[stage_number].gamestate_start;
                ABILITY_MANAGER_PTR->__sub_407DA0(FALSE);
                for (size_t i = 0; i < countof(game_state->cards_owned); ++i) {
                    int32_t card_id = game_state->cards_owned[i];
                    if (card_id < 0) {
                        break;
                    }
                    ABILITY_MANAGER_PTR->allocate_new_card(card_id, 1);
                }
                ABILITY_MANAGER_PTR->__sub_408B00(game_state->card_selected);
                int32_t* card_replay_states = game_state->card_replay_states;
                ABILITY_MANAGER_PTR->card_list.for_each([&](CardBase* card) {
                    card->__set_replay_state(*card_replay_states++);
                });
                break;
            }
        }
        replay_manager->__int_20C = 0;
    }

    // 0x462940
    dllexport static UpdateFuncRet UpdateFuncCC on_tick_A1(void* ptr) asm_symbol_rel(0x462940) {
        ReplayManager* self = (ReplayManager*)ptr;
        if (GAME_THREAD_PTR) {
            INPUT_STATES[0].inputs_previous = INPUT_STATES[0].inputs_current;
            INPUT_STATES[0].inputs_current = (uint16_t)INPUT_STATES[0].hardware_inputs_current;
            __update_input0();
            if (
                SUPERVISOR.config.__unknown_flag_C &&
                INPUT_STATES[0].check_inputs(BUTTON_SHOOT) &&
                INPUT_STATES[0].inputs_held[BUTTON_SHOOT_INDEX] >= 10
            ) {
                INPUT_STATES[0].inputs_current |= BUTTON_FOCUS;
            }
            if (self->__int_20C >= 0 && !ABILITY_SHOP_PTR) {
                if (!(self->__int_20C % 30)) {
                    float fps_count_f = FPS_COUNTER_PTR->__fps + 0.5f;
                    int32_t fps_count = fps_count_f < 256.0f ? fps_count_f : 255;
                    ReplayChunk* cur_chunk = self->current_chunk_node->data;
                    *cur_chunk->next_fps_count_write_pos++ = fps_count;
                }
                if (self->current_chunk_node->data->write_input(INPUT_STATES[0].inputs_current, INPUT_STATES[0].inputs_rising_edge, INPUT_STATES[0].inputs_falling_edge)) {
                    self->current_chunk_node = self->allocate_chunk(self->stage_number);
                }
                ++self->__int_20C;
            }
        }
        return UpdateFuncNext;
    }

    // 0x462A50
    dllexport static UpdateFuncRet UpdateFuncCC on_tick_A2(void* ptr) asm_symbol_rel(0x462A50) {
        ReplayManager* self = (ReplayManager*)ptr;
        if (GAME_THREAD_PTR && !self->__unknown_flag_A) {
            if (self->stage_data[self->stage_number].current_frame < 0) {
                INPUT_STATES[0].inputs_current = 0;
                INPUT_STATES[0].inputs_rising_edge = 0;
                INPUT_STATES[0].inputs_falling_edge = 0;
            }
            else if (!ABILITY_SHOP_PTR) {
                if (self->stage_number >= 0) {
                    INPUT_STATES[0].inputs_previous = INPUT_STATES[0].inputs_current;
                    if (self->stage_data[self->stage_number].current_frame < self->stage_data[self->stage_number].gamestate_start->input_count) {
                        if (self->stage_data[self->stage_number].inputs_current->is_end()) {
                            INPUT_STATES[0].inputs_current = 0;
                            INPUT_STATES[0].inputs_rising_edge = 0;
                            INPUT_STATES[0].inputs_falling_edge = 0;
                            // some mess with the pause screen, probably just replay end
                            self->stage_number = -1;
                        }
                        else {
                            INPUT_STATES[0].inputs_current = self->stage_data[self->stage_number].inputs_current->current;
                            INPUT_STATES[0].inputs_rising_edge = self->stage_data[self->stage_number].inputs_current->rising_edge;
                            INPUT_STATES[0].inputs_falling_edge = self->stage_data[self->stage_number].inputs_current->falling_edge;
                            __update_input0();
                            self->__byte_208 = *self->stage_data[self->stage_number].fps_counts_current;
                            ++self->stage_data[self->stage_number].inputs_current;
                            if (!(self->__int_20C % 30)) {
                                ++self->stage_data[self->stage_number].fps_counts_current;
                            }
                        }
                    }
                    else {
                        INPUT_STATES[0].inputs_current = 0;
                        INPUT_STATES[0].inputs_rising_edge = 0;
                        INPUT_STATES[0].inputs_falling_edge = 0;
                    }
                    ++self->stage_data[self->stage_number].current_frame;
                    ++self->__int_20C;
                }
                else {
                    INPUT_STATES[0].inputs_current = 0;
                    INPUT_STATES[0].inputs_rising_edge = 0;
                    INPUT_STATES[0].inputs_falling_edge = 0;
                    ++self->__int_20C;
                }
            }
        }
        return UpdateFuncNext;
    }

    // 0x461DB0
    dllexport gnu_noinline UpdateFuncRet thiscall on_tick_B() asm_symbol_rel(0x461DB0) {
        if (
            GAME_THREAD_PTR && this->mode == __replay_playback
        ) {
            if (!INPUT_STATES[0].check_hardware_inputs(BUTTON_SHOOT | BUTTON_DOWN)) {
                if (!this->__dword_10) {
                    SOUND_MANAGER.__unknown_sme_ptr_5704->__sub_48AF10(GAME_MANAGER.globals.__counter_14 / 60.0);
                }
                this->__dword_10 = 0;
            }
            else {
                if (this->__int_20C % 8) {
                    return UpdateFuncRestartTick;
                }
            }
        }
        return UpdateFuncNext;
    }

    // 0x462C30
    dllexport static UpdateFuncRet UpdateFuncCC on_tick_B(void* ptr) asm_symbol_rel(0x462C30) {
        GameThread* game_thread_ptr = GAME_THREAD_PTR;
        if (game_thread_ptr && game_thread_ptr->skip_flag) {
            return UpdateFuncNext;
        }
        return ((ReplayManager*)ptr)->on_tick_B();
    }

    // 0x462C50
    dllexport static UpdateFuncRet UpdateFuncCC on_draw(void* ptr) asm_symbol_rel(0x462C50) {
        ReplayManager* self = (ReplayManager*)ptr;

        GameThread* game_thread_ptr = GAME_THREAD_PTR;
        if (game_thread_ptr && !game_thread_ptr->skip_flag) {
            switch (self->mode) {
                case __replay_recording:
                    break;
                case __replay_playback:
                    Float3 position = {
                        383.0f, 450.0f, 0.0f
                    };
                    float A = self->__byte_208;
                    D3DCOLOR color;
                    if (A < 30.0f) { // IDK why these were ever floats
                        color = PackD3DCOLOR(255, 80, 80, 255);
                    } else if (A < 50.0f) {
                        color = PackD3DCOLOR(255, 160, 160, 255);
                    } else {
                        color = PackD3DCOLOR(255, 255, 255, 255);
                    }
                    AsciiManager* ascii_manager = ASCII_MANAGER_PTR;
                    ascii_manager->color = color;
                    ascii_manager->printf(&position, "%3d", self->__byte_208);
                    ASCII_MANAGER_PTR->color = PackD3DCOLOR(255, 255, 255, 255);
            }
        }
        return UpdateFuncNext;
    }

    // 0x463180
    dllexport gnu_noinline void thiscall delete_chunk_list(int32_t stage_number) asm_symbol_rel(0x463180) {
        this->chunk_lists[stage_number].for_each_safe([](ReplayChunk* chunk) {
            chunk->cleanup();
            delete chunk;
        });
    }

    // 0x4630E0
    dllexport gnu_noinline ZUNList<ReplayChunk>* thiscall allocate_chunk(int32_t stage_number) asm_symbol_rel(0x4630E0) {
        ReplayChunk* chunk = new ReplayChunk();
        this->chunk_lists[stage_number].append_to_list_end(&chunk->list_node);
        ++this->__chunk_count;
        return &chunk->list_node;
    }

    inline void __inline_sub_A() {
        switch (this->mode) {
            case __replay_recording: {
                this->game_states[GAME_MANAGER.globals.current_stage] = new ReplayGamestate();
                ReplayGamestate* game_state = this->game_states[GAME_MANAGER.globals.current_stage];
                game_state->stage_number = GAME_MANAGER.globals.current_stage;
                game_state->rng = REPLAY_RNG.value;
                REPLAY_RNG.index = 0;
                game_state->__unknown_flag_A = SUPERVISOR.__int_804;
                break;
            }
            case __replay_playback: {
                ReplayStageData* stage_data = &this->stage_data[GAME_MANAGER.globals.current_stage];
                ReplayGamestate* game_state = stage_data->gamestate_start;
                stage_data->inputs_current = stage_data->input_start;
                stage_data->fps_counts_current = stage_data->fps_counts_start;
                stage_data->current_frame = -1;
                REPLAY_RNG.value = game_state->rng;
                RNG.value = game_state->rng;
                REPLAY_RNG.index = 0;
                break;
            }
        }
    }

    // 0x4615E0
    dllexport gnu_noinline ZUNResult thiscall initialize(ReplayMode mode, const char* path) asm_symbol_rel(0x4615E0) {
        this->mode = mode;
        switch (mode) {
            case __replay_recording: {
                REPLAY_MANAGER_PTR = this;
                this->delete_chunk_list(GAME_MANAGER.globals.current_stage);
                this->current_chunk_node = this->allocate_chunk(GAME_MANAGER.globals.current_stage);
                this->header = new ReplayHeader(REPLAY_MAGIC, REPLAY_VERSION_NUMBER);
                this->info = new ReplayInfo();
                this->game_states[GAME_MANAGER.globals.current_stage] = new ReplayGamestate();
                ReplayGamestate* game_state = this->game_states[GAME_MANAGER.globals.current_stage];
                this->info->character = GAME_MANAGER.globals.character;
                this->info->shottype = GAME_MANAGER.globals.shottype;
                this->info->difficulty = GAME_MANAGER.globals.difficulty;
                this->info->practice_mode = GAME_MANAGER.__unknown_field_A & 1;
                this->info->__unknown_flag_A = GAME_MANAGER.__unknown_field_A_is_2();
                this->info->__ecl_var_9907 = GAME_MANAGER.globals.__ecl_var_9907;
                if (GameThread* game_thread_ptr = GAME_THREAD_PTR) {
                    this->info->config = game_thread_ptr->config;
                }
                game_state->stage_number = GAME_MANAGER.globals.current_stage;
                game_state->rng = REPLAY_RNG.value;
                REPLAY_RNG.index = 0;
                game_state->__unknown_flag_A = SUPERVISOR.__int_804;
                if (SUPERVISOR.__int_804) {
                    game_state->__dword_C = 0;
                    game_state->__dword_10 = 0;
                }
                game_state->globals = GAME_MANAGER.globals;

                size_t bs_value = 0;
                for (size_t i = 0; i < countof(game_state->__dword_array_18); ++i) {
                    game_state->__dword_array_18[i] = bs_value;
                    bs_value -= 0x21522153; // This is a suspiciously repetitve constant...
                }

                this->info->__int_BC = GAME_MANAGER.globals.continues;

                UpdateFunc* update_func = new UpdateFunc(&on_tick_A1, false, this);
                UpdateFuncRegistry::register_on_tick(update_func, 17);
                this->on_tick_func = update_func;
                update_func = new UpdateFunc(&on_tick_B, false, this);
                UpdateFuncRegistry::register_on_tick(update_func, 35);
                this->on_tick_func_B = update_func;
                update_func = new UpdateFunc(&on_draw, false, this);
                UpdateFuncRegistry::register_on_draw(update_func, 77);
                this->on_draw_func = update_func;

                this->stage_number = GAME_MANAGER.globals.current_stage;
                this->__int_20C = -1;
                return ZUN_SUCCESS;
            }
            case __replay_playback: {
                if (ZUN_SUCCEEDED(this->__load_from_path(path))) {
                    GAME_THREAD_PTR->config = this->info->config;
                    ReplayStageData& cur_stage_data = this->stage_data[GAME_MANAGER.globals.current_stage];
                    ReplayGamestate* game_state = cur_stage_data.gamestate_start;
                    cur_stage_data.inputs_current = cur_stage_data.input_start;
                    cur_stage_data.fps_counts_current = cur_stage_data.fps_counts_start;
                    cur_stage_data.current_frame = -1;
                    GAME_MANAGER.globals.character = this->info->character;
                    GAME_MANAGER.globals.shottype = this->info->shottype;
                    GAME_MANAGER.globals.difficulty = this->info->difficulty;
                    REPLAY_RNG.value = game_state->rng;
                    REPLAY_RNG.index = 0;
                    GAME_MANAGER.globals = game_state->globals;

                    int32_t A = GAME_MANAGER.globals.__ecl_var_9907;
                    if (A >= 0) {
                        if (GAME_MANAGER.globals.__unknown_field_A != 2) {
                            A = -1;
                        }
                        GAME_MANAGER.globals.__unknown_field_A = 2;
                    } else {
                        if (GAME_MANAGER.globals.__unknown_field_A != 2) {
                            A = -1;
                        }
                        GAME_MANAGER.globals.__unknown_field_A = 0;
                    }
                    GAME_MANAGER.globals.__ecl_var_9907 = A;

                    UpdateFunc* update_func = new UpdateFunc(&on_tick_A2, false, this);
                    UpdateFuncRegistry::register_on_tick(update_func, 17);
                    this->on_tick_func = update_func;
                    update_func = new UpdateFunc(&on_tick_B, false, this);
                    UpdateFuncRegistry::register_on_tick(update_func, 35);
                    this->on_tick_func_B = update_func;
                    update_func = new UpdateFunc(&on_draw, false, this);
                    UpdateFuncRegistry::register_on_draw(update_func, 77);
                    this->on_draw_func = update_func;

                    this->stage_number = -1;
                    return ZUN_SUCCESS;
                }
                break;
            }
            case __replay_mode_2: {
                if (ZUN_SUCCEEDED(this->__load_from_path(path))) {
                    return ZUN_SUCCESS;
                }
                break;
            }
        }
        return ZUN_ERROR;
    }

    // 0x462680
    dllexport gnu_noinline ZUNResult thiscall __load_from_path(const char* path) asm_symbol_rel(0x462680);

    // 0x461E90
    dllexport gnu_noinline ZUNResult thiscall __write_to_path(const char* path, const char* name, bool arg3, bool arg4) asm_symbol_rel(0x461E90);

    // 0x461CF0
    dllexport static gnu_noinline ReplayManager* fastcall allocate(const char* path) asm_symbol_rel(0x461CF0) {
        ReplayManager* replay_manager = new ReplayManager();
        replay_manager->mode = __replay_mode_2;
        if (ZUN_FAILED(replay_manager->__load_from_path(path))) {
            delete replay_manager;
            return NULL;
        }
        return replay_manager;
    }
};
#pragma region // ReplayManager Verification
ValidateFieldOffset32(0x0, ReplayManager, task_flags);
ValidateFieldOffset32(0x4, ReplayManager, on_tick_func);
ValidateFieldOffset32(0x8, ReplayManager, on_draw_func);
ValidateFieldOffset32(0xC, ReplayManager, mode);
ValidateFieldOffset32(0x10, ReplayManager, __dword_10);
ValidateFieldOffset32(0x14, ReplayManager, header);
ValidateFieldOffset32(0x18, ReplayManager, info);
ValidateFieldOffset32(0x1C, ReplayManager, game_states);
ValidateFieldOffset32(0x3C, ReplayManager, chunk_lists);
ValidateFieldOffset32(0xBC, ReplayManager, current_chunk_node);
ValidateFieldOffset32(0xC0, ReplayManager, __chunk_count);
ValidateFieldOffset32(0xC4, ReplayManager, stage_data);
ValidateFieldOffset32(0x204, ReplayManager, file_buffer);
ValidateFieldOffset32(0x208, ReplayManager, __byte_208);
ValidateFieldOffset32(0x20C, ReplayManager, __int_20C);
ValidateFieldOffset32(0x210, ReplayManager, on_tick_func_B);
ValidateFieldOffset32(0x214, ReplayManager, stage_number);
ValidateFieldOffset32(0x218, ReplayManager, flags);
ValidateFieldOffset32(0x21C, ReplayManager, file_path);
ValidateStructSize32(0x31C, ReplayManager);
#pragma endregion

static inline bool is_replay() {
    return REPLAY_MANAGER_PTR->mode == __replay_playback;
}

// 0x417880
dllexport gnu_noinline void thiscall AbilityShop::cleanup() {
    // how did you do this zun
    AbilityShop* ability_shop = this;
    __asm__ volatile ("":"+c"(ability_shop));
    if (ability_shop) {
        INPUT_STATES[0].__reset_inputs();
        INPUT_STATES[1].__reset_inputs();
        INPUT_STATES[2].__reset_inputs();

        ReplayManager* replay_manager = REPLAY_MANAGER_PTR;
        if (replay_manager) {
            if (!GAME_MANAGER.globals.__timer_C4) {
                ReplayGamestate* game_state = replay_manager->game_states[GAME_MANAGER.globals.current_stage];

                ABILITY_MANAGER_PTR->equipped_cards_get_ids(game_state->__cards_ownedB);
                ABILITY_MANAGER_PTR->__equipped_cards_get_replay_states(game_state->__card_replay_statesB);
                game_state->globals = GAME_MANAGER.globals;
                ABILITY_MANAGER_PTR->equipped_cards_run_on_load();
            }
            else {
                uint32_t current_stage = GAME_MANAGER.globals.current_stage;
                ReplayGamestate* game_state = replay_manager->stage_data[current_stage].gamestate_start;
                if (game_state->__globalsB.current_stage == current_stage) {
                    ABILITY_MANAGER_PTR->__sub_407DA0(FALSE);

                    for (int32_t i = 0; i < countof(game_state->__cards_ownedB); ++i) {
                        int32_t id = game_state->__cards_ownedB[i];
                        if (id < 0) {
                            break;
                        }
                        ABILITY_MANAGER_PTR->allocate_new_card(id, 3);
                    }

                    ABILITY_MANAGER_PTR->__sub_408B00(game_state->__card_selectedB);

                    int32_t* card_replay_states = game_state->__card_replay_statesB;
                    ABILITY_MANAGER_PTR->card_list.for_each([&](CardBase* card) {
                        card->__set_replay_state(*card_replay_states++);
                    });

                    GAME_MANAGER.globals = game_state->globals;

                    ABILITY_MANAGER_PTR->card_list.for_each([](CardBase* card) {
                        card->on_load();
                    });

                    PLAYER_PTR->__sub_416D50();

                    // Yes, this is called twice. No, IDK why
                    PLAYER_PTR->data.__update_option_power_levels();
                    PLAYER_PTR->data.__update_option_power_levels();

                    __update_life_ui();
                    __update_bomb_ui();
                }
            }
        }
        delete ability_shop;
    }
}

typedef struct HelpMenu HelpMenu;

extern "C" {
    // 0x4CF2E8
    externcg HelpMenu* HELP_MENU_PTR cgasm("_HELP_MENU_PTR");
}

// size: 0x1BC
struct HelpMenu : ZUNTask {
    // ZUNTask base; // 0x0
    int __int_C; // 0xC
    Timer __timer_10; // 0x10
    MenuSelect __menu_select_24; // 0x24
    AnmID __anm_id_array_FC[7]; // 0xFC
    unknown_fields(0x8); // 0x118
    AnmID __anm_id_120; // 0x120
    int __int_124; // 0x124
    float __float_128; // 0x128
    AnmLoaded* help_anm; // 0x12C
    void* file_buffer; // 0x130
    int __int_134; // 0x134
    char filename_buffer[128]; // 0x138
    int32_t __int_1B8; // 0x1B8
    // 0x1BC

    inline void zero_contents() {
        zero_this();
    }

    inline HelpMenu() {
        this->zero_contents();
        this->__unknown_task_flag_A = true;
    }

    // 0x4450B0
    dllexport gnu_noinline ~HelpMenu() {
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);

        ANM_MANAGER_PTR->unload_anm(19);

        HELP_MENU_PTR = NULL;
    }

    // 0x4451C0
    dllexport gnu_noinline UpdateFuncRet thiscall on_tick() asm_symbol_rel(0x4451C0) {

    }

    // 0x445690
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_tick(void* ptr) asm_symbol_rel(0x445690) {
        return ((HelpMenu*)ptr)->on_tick();
    }

    // 0x4456A0
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw(void* ptr) asm_symbol_rel(0x4456A0) {
        return UpdateFuncNext;
    }

    // 0x444EC0
    dllexport gnu_noinline static void cdecl thread_func_load_file(void* arg) asm_symbol_rel(0x444EC0) {
        HelpMenu* help_menu = HELP_MENU_PTR;
        void* file = read_file_to_buffer(help_menu->filename_buffer, &help_menu->__int_1B8, false);
        help_menu = HELP_MENU_PTR;
        help_menu->file_buffer = file;
        help_menu->__int_134 = 3;
        SUPERVISOR.__thread_A94.__bool_10 = FALSE;
        SUPERVISOR.__thread_A94.__bool_C = TRUE;
    }

    // 0x444E60
    dllexport gnu_noinline static void cdecl thread_func_load_anm(void* arg) asm_symbol_rel(0x444E60) {
        AnmLoaded* anm_loaded = ANM_MANAGER_PTR->preload_anm(19, "help.anm");
        HelpMenu* help_menu = HELP_MENU_PTR;
        help_menu->help_anm = anm_loaded;
        if (!anm_loaded) {
            LOG_BUFFER.write(JpEnStr("", "Screen configuration data not found. data is corrupted\r\n"));
        }
        else {
            SUPERVISOR.__thread_A94.__bool_10 = FALSE;
            SUPERVISOR.__thread_A94.__bool_C = TRUE;
            help_menu->enable_funcs_unsafe();
        }
    }

    inline ZUNResult initialize() {
        UpdateFunc* update_func = new UpdateFunc(&on_tick, false, this);
        UpdateFuncRegistry::register_on_tick(update_func, 13);
        this->on_tick_func = update_func;
        update_func = new UpdateFunc(&on_draw, false, this);
        UpdateFuncRegistry::register_on_draw(update_func, 78);
        this->on_draw_func = update_func;

        SUPERVISOR.__start_thread_A94((_beginthreadex_proc_type)&thread_func_load_anm);

        this->__timer_10.reset();
        this->__int_C = 0;

        return ZUN_SUCCESS;
    }

    dllexport gnu_noinline HelpMenu* allocate() {
        HelpMenu* help_menu = new HelpMenu();
        HELP_MENU_PTR = help_menu;
        if (ZUN_FAILED(help_menu->initialize())) {
            delete help_menu;
            return NULL;
        }
        return help_menu;
    }
};
#pragma region // HelpMenu Verification
ValidateFieldOffset32(0x0, HelpMenu, task_flags);
ValidateFieldOffset32(0x4, HelpMenu, on_tick_func);
ValidateFieldOffset32(0x8, HelpMenu, on_draw_func);
ValidateFieldOffset32(0xC, HelpMenu, __int_C);
ValidateFieldOffset32(0x10, HelpMenu, __timer_10);
ValidateFieldOffset32(0x24, HelpMenu, __menu_select_24);
ValidateFieldOffset32(0xFC, HelpMenu, __anm_id_array_FC);
ValidateFieldOffset32(0x120, HelpMenu, __anm_id_120);
ValidateFieldOffset32(0x124, HelpMenu, __int_124);
ValidateFieldOffset32(0x128, HelpMenu, __float_128);
ValidateFieldOffset32(0x12C, HelpMenu, help_anm);
ValidateFieldOffset32(0x130, HelpMenu, file_buffer);
ValidateFieldOffset32(0x134, HelpMenu, __int_134);
ValidateFieldOffset32(0x138, HelpMenu, filename_buffer);
ValidateFieldOffset32(0x1B8, HelpMenu, __int_1B8);
ValidateStructSize32(0x1BC, HelpMenu);
#pragma endregion

// 0x4B6700
static inline constexpr const char *const KEY_CONFIG_MENU_ENTRIES[] = {
    "Shot",
    "Bomb",
    "Slow",
    "Item",
    "Change",
    "Pause",
    "Default",
    "Quit"
};

typedef struct KeyConfigMenu KeyConfigMenu;
extern "C" {
    // 0x4CF3F0
    externcg KeyConfigMenu* KEY_CONFIG_MENU_PTR cgasm("_KEY_CONFIG_MENU_PTR");
}

// size: 0x180
struct KeyConfigMenu : ZUNTask {
    // ZUNTask base; // 0x0
    unknown_fields(0x4); // 0xC
    MenuSelect menu_select; // 0x10
    InputMapping joypad_mapping; // 0xE8
    unknown_fields(0xC); // 0xFC
    InputMapping xinput_mapping; // 0x108
    unknown_fields(0xC); // 0x11C
    InputMapping keyboard_mapping; // 0x128
    unknown_fields(0xC); // 0x13C
    Timer __timer_148; // 0x148
    Float3 __float3_15C; // 0x15C
    Timer __timer_168; // 0x168
    int __int_17C; // 0x17C
    // 0x180

    inline void zero_contents() {
        zero_this();
    }

    inline KeyConfigMenu() {
        this->zero_contents();
        this->__unknown_task_flag_A = true;
    }

    // 0x447630
    dllexport gnu_noinline ~KeyConfigMenu() {
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);

        KEY_CONFIG_MENU_PTR = NULL;

        //__save_config_file();
    }

    // 0x447450
    dllexport gnu_noinline void thiscall __sub_447450(int arg1) asm_symbol_rel(0x447450) {
        this->__int_17C = arg1;
        this->__timer_148.reset();
    }

    // 0x447700
    dllexport gnu_noinline UpdateFuncRet thiscall on_tick() asm_symbol_rel(0x447700) {

    }

    // 0x447CF0
    dllexport gnu_noinline UpdateFuncRet thiscall on_draw() asm_symbol_rel(0x447CF0) {

    }

    // 0x447FA0
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_tick(void* ptr) asm_symbol_rel(0x447FA0) {
        return ((KeyConfigMenu*)ptr)->on_tick();
    }

    // 0x447FB0
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw(void* ptr) asm_symbol_rel(0x447FB0) {
        return ((KeyConfigMenu*)ptr)->on_draw();
    }

    inline ZUNResult initialize(Float3* arg1) {
        UpdateFunc* update_func = new UpdateFunc(&on_tick, true, this);
        UpdateFuncRegistry::register_on_tick(update_func, 7);
        this->on_tick_func = update_func;
        update_func = new UpdateFunc(&on_draw, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 80);
        this->on_draw_func = update_func;
        this->enable_funcs_unsafe();

        // TODO

        this->__timer_148.reset();
        this->__float3_15C = *arg1;

        return ZUN_SUCCESS;
    }

    // 0x4474A0
    dllexport gnu_noinline static KeyConfigMenu* fastcall allocate(Float3* arg1) asm_symbol_rel(0x4474A0) {
        KeyConfigMenu* key_config_menu = new KeyConfigMenu();
        KEY_CONFIG_MENU_PTR = key_config_menu;
        if (ZUN_FAILED(key_config_menu->initialize(arg1))) {
            delete key_config_menu;
            return NULL;
        }
        return key_config_menu;
    }
};
#pragma region // KeyConfigMenu Verification
ValidateFieldOffset32(0x0, KeyConfigMenu, task_flags);
ValidateFieldOffset32(0x4, KeyConfigMenu, on_tick_func);
ValidateFieldOffset32(0x8, KeyConfigMenu, on_draw_func);
ValidateFieldOffset32(0x10, KeyConfigMenu, menu_select);
ValidateFieldOffset32(0xE8, KeyConfigMenu, joypad_mapping);
ValidateFieldOffset32(0x108, KeyConfigMenu, xinput_mapping);
ValidateFieldOffset32(0x128, KeyConfigMenu, keyboard_mapping);
ValidateFieldOffset32(0x148, KeyConfigMenu, __timer_148);
ValidateFieldOffset32(0x15C, KeyConfigMenu, __float3_15C);
ValidateFieldOffset32(0x168, KeyConfigMenu, __timer_168);
ValidateFieldOffset32(0x17C, KeyConfigMenu, __int_17C);
ValidateStructSize32(0x180, KeyConfigMenu);
#pragma endregion

typedef struct OptionsMenu OptionsMenu;
extern "C" {
    // 0x4CF408
    externcg OptionsMenu* OPTIONS_MENU_PTR cgasm("_OPTIONS_MENU_PTR");
}

// size: 0x138
struct OptionsMenu : ZUNTask {
    // ZUNTask base; // 0x0
    unknown_fields(0x4); // 0xC
    MenuSelect menu_select; // 0x10
    Timer __timer_E8; // 0xE8
    Float3 __float3_FC; // 0xFC
    Timer __timer_108; // 0x108
    Timer __timer_11C; // 0x11C
    int __dword_130; // 0x130
    int __int_134; // 0x134
    // 0x138

    inline void zero_contents() {
        zero_this();
    }

    inline OptionsMenu() {
        this->zero_contents();
        this->__unknown_task_flag_A = true;
    }

    // 0x456A90
    dllexport gnu_noinline ~OptionsMenu() {
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);

        OPTIONS_MENU_PTR = NULL;

        //__save_config_file();
    }


    // 0x456B60
    dllexport gnu_noinline UpdateFuncRet thiscall on_tick() asm_symbol_rel(0x456B60) {

    }

    inline UpdateFuncRet on_draw() {

    }

    // 0x457190
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_tick(void* ptr) asm_symbol_rel(0x457190) {
        return ((OptionsMenu*)ptr)->on_tick();
    }

    // 0x4571A0
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw(void* ptr) asm_symbol_rel(0x4571A0) {
        return ((OptionsMenu*)ptr)->on_draw();
    }

    inline ZUNResult initialize(Float3* arg1) {
        UpdateFunc* update_func = new UpdateFunc(&on_tick, true, this);
        UpdateFuncRegistry::register_on_tick(update_func, 7);
        this->on_tick_func = update_func;
        update_func = new UpdateFunc(&on_draw, true, this);
        UpdateFuncRegistry::register_on_draw(update_func, 80);
        this->on_draw_func = update_func;
        this->enable_funcs_unsafe();

        // TODO

        this->__timer_E8.reset();
        this->__timer_108.reset();
        this->__timer_11C.reset();
        this->__float3_FC = *arg1;

        return ZUN_SUCCESS;
    }

    // 0x456880
    dllexport gnu_noinline static OptionsMenu* fastcall allocate(Float3* arg1) asm_symbol_rel(0x456880) {
        OptionsMenu* options_menu = new OptionsMenu();
        OPTIONS_MENU_PTR = options_menu;
        if (ZUN_FAILED(options_menu->initialize(arg1))) {
            delete options_menu;
            return NULL;
        }
        return options_menu;
    }
};
#pragma region // OptionsMenu Verification
ValidateFieldOffset32(0x0, OptionsMenu, task_flags);
ValidateFieldOffset32(0x4, OptionsMenu, on_tick_func);
ValidateFieldOffset32(0x8, OptionsMenu, on_draw_func);
ValidateFieldOffset32(0x10, OptionsMenu, menu_select);
ValidateFieldOffset32(0xE8, OptionsMenu, __timer_E8);
ValidateFieldOffset32(0xFC, OptionsMenu, __float3_FC);
ValidateFieldOffset32(0x108, OptionsMenu, __timer_108);
ValidateFieldOffset32(0x11C, OptionsMenu, __timer_11C);
ValidateFieldOffset32(0x134, OptionsMenu, __int_134);
ValidateStructSize32(0x138, OptionsMenu);
#pragma endregion

typedef struct PauseMenu PauseMenu;
extern "C" {
    // 0x4CF40C
    externcg PauseMenu* PAUSE_MENU_PTR cgasm("_PAUSE_MENU_PTR");
}

// size: 0x3F8
struct PauseMenu : ZUNTask {
    //ZUNTask base; // 0x0
    Timer __timer_C; // 0xC
    Timer __timer_20; // 0x20
    MenuSelect __menu_select_34; // 0x34
    MenuSelect __menu_select_10C; // 0x10C
    AnmID __vm_id_1E4; // 0x1E4
    AnmID __vm_id_1E8; // 0x1E8
    int __dword_1EC; // 0x1EC
    int __dword_1F0; // 0x1F0
    int __dword_1F4; // 0x1F4
    int __dword_1F8; // 0x1F8
    int __dword_1FC; // 0x1FC
    unknown_fields(0x8); // 0x200
    int __dword_208; // 0x208
    ReplayManager* __replay_manager_array_20C[25]; // 0x20C
    unknown_fields(0x70); // 0x270
    float __float_2E0; // 0x2E0
    unknown_fields(0x10C); // 0x2E4
    union {
        uint32_t __flags_3F0; // 0x3F0
        struct {
            uint32_t __unknown_bitfield_A : 2;
            uint32_t __unknown_flag_B : 1;
        };
    };
    AnmLoaded* __anm_loaded_3F4; // 0x3F4
    // 0x3F8

    inline void zero_contents() {
        zero_this();
    }

    inline PauseMenu() {
        this->zero_contents();
        this->__unknown_task_flag_A = true;
    }

    // 0x457960
    dllexport gnu_noinline ~PauseMenu() {
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);

        for (size_t i = 0; i < countof(this->__replay_manager_array_20C); ++i) {
            delete this->__replay_manager_array_20C[i];
        }

        PAUSE_MENU_PTR = NULL;
    }

    // 0x457A60
    dllexport gnu_noinline UpdateFuncRet thiscall on_tick() asm_symbol_rel(0x457A60) {

    }

    // 0x458090
    dllexport gnu_noinline UpdateFuncRet thiscall on_draw() asm_symbol_rel(0x458090) {

    }

    // 0x457BE0
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_tick(void* ptr) asm_symbol_rel(0x457BE0) {
        return ((PauseMenu*)ptr)->on_tick();
    }

    // 0x458470
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw(void* ptr) asm_symbol_rel(0x458470) {
        return ((PauseMenu*)ptr)->on_draw();
    }

    inline ZUNResult initialize() {
        UpdateFunc* update_func = new UpdateFunc(&on_tick, false, this);
        UpdateFuncRegistry::register_on_tick(update_func, 12);
        this->on_tick_func = update_func;
        update_func = new UpdateFunc(&on_draw, false, this);
        UpdateFuncRegistry::register_on_draw(update_func, 81);
        this->on_draw_func = update_func;

        this->__timer_C.reset();
        this->__timer_20.reset();

        return ZUN_SUCCESS;
    }

    static inline PauseMenu* allocate() {
        PauseMenu* pause_menu = new PauseMenu();
        PAUSE_MENU_PTR = pause_menu;
        if (ZUN_FAILED(pause_menu->initialize())) {
            delete pause_menu;
            return NULL;
        }
        return pause_menu;
    }
};
#pragma region // PauseMenu Verification
ValidateFieldOffset32(0x0, PauseMenu, task_flags);
ValidateFieldOffset32(0x4, PauseMenu, on_tick_func);
ValidateFieldOffset32(0x8, PauseMenu, on_draw_func);
ValidateFieldOffset32(0xC, PauseMenu, __timer_C);
ValidateFieldOffset32(0x20, PauseMenu, __timer_20);
ValidateFieldOffset32(0x34, PauseMenu, __menu_select_34);
ValidateFieldOffset32(0x10C, PauseMenu, __menu_select_10C);
ValidateFieldOffset32(0x1E4, PauseMenu, __vm_id_1E4);
ValidateFieldOffset32(0x1E8, PauseMenu, __vm_id_1E8);
ValidateFieldOffset32(0x1EC, PauseMenu, __dword_1EC);
ValidateFieldOffset32(0x1F0, PauseMenu, __dword_1F0);
ValidateFieldOffset32(0x1F4, PauseMenu, __dword_1F4);
ValidateFieldOffset32(0x1F8, PauseMenu, __dword_1F8);
ValidateFieldOffset32(0x1FC, PauseMenu, __dword_1FC);
ValidateFieldOffset32(0x208, PauseMenu, __dword_208);
ValidateFieldOffset32(0x20C, PauseMenu, __replay_manager_array_20C);
ValidateFieldOffset32(0x2E0, PauseMenu, __float_2E0);
ValidateFieldOffset32(0x3F0, PauseMenu, __flags_3F0);
ValidateFieldOffset32(0x3F4, PauseMenu, __anm_loaded_3F4);
ValidateStructSize32(0x3F8, PauseMenu);
#pragma endregion

typedef struct MainMenu MainMenu;

extern "C" {
    // 0x4CF43C
    externcg MainMenu* MAIN_MENU_PTR cgasm("_MAIN_MENU_PTR");
    // 0x507648
    externcg int UNKNOWN_INT_H cgasm("_UNKNOWN_INT_H");
}

// size: 0x5D98
struct MainMenu : ZUNTask {
    // void* vftable; // 0x0
    // ZUNTask base; // 0x4
    AnmLoaded* title_anm; // 0x10
    AnmLoaded* title_v_anm; // 0x14
    unknown_fields(0xC); // 0x18
    MenuSelect __menu_select_24; // 0x24
    MenuSelect __menu_select_FC; // 0xFC
    MenuSelect __menu_select_1D4; // 0x1D4
    MenuSelect __menu_select_2AC; // 0x2AC
    Timer __timer_384; // 0x384
    // 0x398

    AnmID __anm_id_650; // 0x650
    // 0x654

    ReplayManager* __replay_manager_array_5AB4[100];
    void* __ptr_5C44; // 0x5C44
    // 0x5C48
    ZUNThread __thread_5D7C; // 0x5D7C
    // 0x5D98


    inline void zero_contents() {
        zero_this();
    }

    // 0x464970
    dllexport gnu_noinline MainMenu() {
        this->zero_contents();
        MAIN_MENU_PTR = this;
        this->__unknown_task_flag_A = true;
    }

    inline ~MainMenu() {
        this->__thread_5D7C.stop_and_cleanup();

        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
        UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);

        ANM_MANAGER_PTR->unload_anm(16);
        ANM_MANAGER_PTR->unload_anm(17);

        nounroll for (size_t i = 0; i < countof(this->__replay_manager_array_5AB4); ++i) {
            delete this->__replay_manager_array_5AB4[i];
        }

        this->__anm_id_650.interrupt_tree(1);

        SAFE_FREE(this->__ptr_5C44);

        //SUPERVISOR.__sub_475380();

        MAIN_MENU_PTR = NULL;
    }

    // 0x464D20
    dllexport gnu_noinline static void cleanup() asm_symbol_rel(0x464D20) {
        delete MAIN_MENU_PTR;
    }

    // This can't actually be called because the memset at the start nukes it
    // 0x4646D0
    // Method 0
    dllexport gnu_noinline virtual size_t __method_0() asm_symbol_rel(0x4646D0) {
        return sizeof(MainMenu); // why tho
    }

    // 0x464ED0
    dllexport gnu_noinline UpdateFuncRet thiscall on_tick() asm_symbol_rel(0x464ED0) {

    }

    // 0x465870
    dllexport gnu_noinline UpdateFuncRet thiscall on_draw() asm_symbol_rel(0x465870) {

    }

    // 0x465A80
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_tick(void* ptr) asm_symbol_rel(0x465A80) {
        return ((MainMenu*)ptr)->on_tick();
    }

    // 0x465A90
    dllexport gnu_noinline static UpdateFuncRet UpdateFuncCC on_draw(void* ptr) asm_symbol_rel(0x465A90) {
        return ((MainMenu*)ptr)->on_draw();
    }

    // 0x464B80
    dllexport gnu_noinline static unsigned stdcall thread_start(void* arg) asm_symbol_rel(0x464B80) {
        MainMenu* main_menu = MAIN_MENU_PTR;

        UpdateFunc* update_func = new UpdateFunc(&on_tick, false, main_menu);
        UpdateFuncRegistry::register_on_tick(update_func, 8);
        main_menu->on_tick_func = update_func;
        update_func = new UpdateFunc(&on_draw, false, main_menu);
        UpdateFuncRegistry::register_on_draw(update_func, 75);
        main_menu->on_draw_func = update_func;

        if (
            (main_menu->title_anm = ANM_MANAGER_PTR->preload_anm(16, "title.anm")) &&
            (main_menu->title_v_anm = ANM_MANAGER_PTR->preload_anm(17, "title_v.anm"))
        ) {

        }
        else {
            LOG_BUFFER.write(JpEnStr("", "data is corrupted\r\n"));
            SUPERVISOR.gamemode_switch = SUPERVISOR.__unknown_flag_G ? 2 : 3;
        }
        return 0;
    }

    // 0x464CB0
    dllexport gnu_noinline static MainMenu* allocate() asm_symbol_rel(0x464CB0) {
        MainMenu* main_menu = new MainMenu();
        WINDOW_DATA.__int_20D0 = 0;
        main_menu->__thread_5D7C.start(&thread_start, main_menu);
        return main_menu;
    }
};
#pragma region // MainMenu Verification
ValidateVirtualFieldOffset32(0x4, MainMenu, task_flags);
ValidateVirtualFieldOffset32(0x8, MainMenu, on_tick_func);
ValidateVirtualFieldOffset32(0xC, MainMenu, on_draw_func);
ValidateVirtualFieldOffset32(0x10, MainMenu, title_anm);
ValidateVirtualFieldOffset32(0x14, MainMenu, title_v_anm);
ValidateVirtualFieldOffset32(0x24, MainMenu, __menu_select_24);
ValidateVirtualFieldOffset32(0xFC, MainMenu, __menu_select_FC);
ValidateVirtualFieldOffset32(0x1D4, MainMenu, __menu_select_1D4);
ValidateVirtualFieldOffset32(0x2AC, MainMenu, __menu_select_2AC);
ValidateVirtualFieldOffset32(0x384, MainMenu, __timer_384);
//ValidateStructSize32(0x5D98, MainMenu);
#pragma endregion

// 0x43BB70
dllexport gnu_noinline UpdateFuncRet thiscall Gui::on_tick() {
    if (this->__unknown_flag_A) {
        this->__timer_198++;
    }

    if (this->__unknown_field_A) {
        this->__timer_198++;
        if (
            this->__unknown_field_A == 1 &&
            this->__timer_198 >= 90
        ) {
            if (this->__float_11C < 0.0f) {
                if (this->__timer_198.is_multiple_of(4)) {
                    SOUND_MANAGER.play_sound(39);
                }
                this->__int_128 += this->__int_12C;
                this->__float_11C -= 1.0f;
            }
            else {
                if (this->__timer_198 != 90) {
                    SOUND_MANAGER.play_sound(47);
                }
                this->__float_11C = this->__float_120;
                this->__int_12C = 0;
                this->__int_128 = this->__int_124;
                this->__unknown_field_A = 2;
            }
        }
    }

    if (this->__timer_198 >= this->__int_1AC) {
        this->__anm_id_114.interrupt_tree(1);
        this->__unknown_field_A = 1;
        this->__timer_198.reset();
        this->__unknown_field_A = 0; // why?
    }

    if (this->__int_134) {
        AnmVM* vm = this->__anm_id_110.get_vm_ptr();
        if (!vm) {
            this->__int_134 = 0;
        }
    }

    EnemyManager* enemy_manager = ENEMY_MANAGER_PTR;
    if (
        enemy_manager &&
        this->spell_timer_seconds >= 0 &&
        get_boss_by_index(0) != NULL &&
        !enemy_manager->__unknown_flag_A &&
        !this->msg_vm &&
        !GAME_THREAD_PTR->__unknown_flag_F
    ) {
        this->__anm_vm_84->__tree_set_visible2();
        this->__anm_vm_88->__tree_set_visible2();

        int32_t state = this->__unknown_field_B;
        if (state == 0) {
            Player* player = PLAYER_PTR;
            bool spell_flag = SPELLCARD_PTR->__unknown_flag_H;
            if (
                (!spell_flag && player->data.position.y < 128.0f) ||
                (spell_flag && player->data.position.y > 320.0f)
            ) {
                this->__unknown_field_B = 1;
                this->__anm_vm_84->interrupt(5);
                this->__anm_vm_88->interrupt(5);
            }
        }
        else {
            Spellcard* spellcard = SPELLCARD_PTR;
            if (state == 1) {
                Player* player = PLAYER_PTR;
                bool spell_flag = spellcard->__unknown_flag_H;
                if (
                    (!spell_flag && player->data.position.y < 160.0f) ||
                    (spell_flag && player->data.position.y > 288.0f)
                ) {
                    this->__anm_vm_84->interrupt(4);
                    this->__anm_vm_88->interrupt(4);
                }
            }
            else {
                if (spellcard->__unknown_flag_H) {
                    this->__anm_vm_84->interrupt_and_run(2);
                    this->__anm_vm_88->interrupt_and_run(2);
                }
                else {
                    this->__anm_vm_84->interrupt_and_run(3);
                    this->__anm_vm_88->interrupt_and_run(3);
                    this->__anm_vm_84->interrupt_and_run(4);
                    this->__anm_vm_88->interrupt_and_run(4);
                }
            }
            this->__unknown_field_B = 0;
        }

        int32_t spell_seconds = this->spell_timer_seconds;
        int32_t A = this->__int_1C0;
        if (spell_seconds < A) {
            if (spell_seconds < 2) {
                this->__anm_vm_84->interrupt(9);
                this->__anm_vm_88->interrupt(9);
                SOUND_MANAGER.play_sound(12);
            }
            else if (spell_seconds < 5) {
                this->__anm_vm_84->interrupt(8);
                this->__anm_vm_88->interrupt(8);
                SOUND_MANAGER.play_sound(11);
            }
        }
        else if (spell_seconds > A) {
            this->__anm_vm_84->interrupt(7);
            this->__anm_vm_88->interrupt(7);
        }

        spell_seconds = this->spell_timer_seconds;
        if (spell_seconds != this->__int_1C0) {
            this->__anm_vm_84->set_sprite(spell_seconds / 10 + 239);
            this->__anm_vm_88->set_sprite(this->spell_timer_seconds % 10 + 239);
            spell_seconds = this->spell_timer_seconds;
        }
        this->__int_1C0 = spell_seconds;
    }
    else {
        this->__anm_vm_84->__tree_clear_visible2();
        this->__anm_vm_88->__tree_clear_visible2();
    }

    enemy_manager = ENEMY_MANAGER_PTR;
    if (
        enemy_manager &&
        !enemy_manager->__unknown_flag_A
    ) {
        for (int32_t i = 0; i < MAX_LIFEBARS_IN_GUI; ++i) {
            Enemy* boss = NULL;
            clang_forceinline boss = get_boss_by_index(i);
            if (boss) {
                int32_t life = boss->data.life.current;
                if (
                    life < 100000 &&
                    !boss->data.hide_lifebar() &&
                    !this->msg_vm
                ) {
                    Lifebar& lifebar = this->lifebars[i];
                    lifebar.current_life = life;
                    float percentage = (float)life / (float)boss->data.life.maximum;
                    lifebar.life_percentage = percentage;

                    float current_value = lifebar.bar_value;
                    if (current_value < percentage) {
                        current_value += 0.025f; // 1/40
                        lifebar.bar_value = current_value;
                    }
                    if (current_value > percentage) {
                        lifebar.bar_value = percentage;
                    }

                    if (!lifebar.vms_initialized) {
                        lifebar.main_vm = this->__anm_loaded_2C0->instantiate_vm_to_world_list_back(378);
                        lifebar.glowA_vm = this->__anm_loaded_2C0->instantiate_vm_to_world_list_back(379);
                        lifebar.glowB_vm = this->__anm_loaded_2C0->instantiate_vm_to_world_list_back(380);
                        for (size_t j = 0; j < MAX_LIFEBAR_MARKERS; ++j) {
                            lifebar.marker_vms[j] = this->__anm_loaded_2C0->instantiate_vm_to_world_list_back(381);
                        }
                        lifebar.vms_initialized = TRUE;
                    }

                    this->__sub_4422C0();

                    AnmVM* main_vm = lifebar.main_vm.get_vm_ptr();

                    main_vm->set_x_rotation(-lifebar.bar_value * TWO_PI_f);

                    Float3 position = boss->data.current_motion.position;
                    position.as2() *= 2.0f; // EBP-2C, EBP-30, EBP-50

                    main_vm->controller.position = position;

                    lifebar.glowA_vm.get_vm_ptr()->controller.position = position;
                    lifebar.glowB_vm.get_vm_ptr()->controller.position = position;

                    float offset = 0.0f; // EBP-20

                    LifebarMarker* markers = lifebar.markers;
                    AnmID* marker_vms = lifebar.marker_vms;
                    nounroll for (size_t j = 0; j < MAX_LIFEBAR_MARKERS; ++j, ++markers, ++marker_vms) {
                        AnmVM* marker_vm = marker_vms->get_vm_ptr();

                        float marker_position = markers->bar_position;
                        if (
                            !(marker_position == 0.0f) &&
                            !(marker_position >= lifebar.bar_value)
                        ) {
                            marker_vm->__tree_set_visible2();

                            float angle = reduce_angle(NPI_f - markers->bar_position * TWO_PI_f);
                            marker_vm->set_z_rotation(angle);

                            constexpr Float2 offset = { 0.0f, 112.0f };

                            marker_vm->controller.position = position + offset.rotate_around_origin(angle);
                        }
                        else {
                            marker_vm->__tree_clear_visible2();
                        }
                    }

                    if (lifebar.__dword_50) {
                        float distance_squared = get_boss_by_index(i)->data.current_motion.position.distance_squared(&PLAYER_PTR->data.position);
                        if (distance_squared >= 9216.0f) { // 96 squared
                            lifebar.interrupt_vms(2);
                        }
                    }
                    else {
                        float distance_squared = get_boss_by_index(i)->data.current_motion.position.distance_squared(&PLAYER_PTR->data.position);
                        if (distance_squared < 6400.0f) { // 80 squared
                            lifebar.interrupt_vms(3);
                        }
                    }
                }
                else {
                    this->lifebars[i].delete_vms();
                }
            }
            else {
                this->lifebars[i].clear();
            }
        }
    }

    for (size_t i = 0; i < MAX_BOSS_LIFE_MARKERS; ++i) {
        if (i < this->__boss_life_count) {
            if (!this->__boss_life_markers[i]) {
                this->__boss_life_markers[i] = this->__anm_loaded_2C0->instantiate_vm_to_world_list_back(i + 58);
            }
        }
        else {
            if (this->__boss_life_markers[i]) {
                this->__boss_life_markers[i].interrupt_tree(1);
            }
        }
    }

    if (MsgVM* msg_vm = this->msg_vm) {
        if (ZUN_FAILED(msg_vm->on_tick())) {
            SAFE_DELETE(this->msg_vm);
        }
    }

    enemy_manager = ENEMY_MANAGER_PTR;
    if (
        enemy_manager
    ) {
        Enemy* boss = NULL;
        clang_forceinline boss = enemy_manager->get_boss_by_index(0);
        if (
            boss != NULL &&
            !boss->data.intangible &&
            !boss->data.disable_hitbox
        ) {
            AnmVM* vm = this->__anm_id_8C.get_vm_ptr();
            vm->__tree_set_visible2();

            int32_t state = this->__unknown_field_C;
            if (SPELLCARD_PTR->__unknown_flag_A) {
                switch (state) {
                    case 0:
                        if (boss->data.life.remaining_current_attack < 2000) {
                            vm->interrupt(7);
                            this->__unknown_field_C = 1;
                        }
                        break;
                    case 1:
                        if (boss->data.life.remaining_current_attack < 1000) {
                            vm->interrupt(8);
                            this->__unknown_field_C = 2;
                        }
                        break;
                    case 2:
                        if (boss->data.life.remaining_current_attack < 400) {
                            vm->interrupt(9);
                            this->__unknown_field_C = 3;
                        }
                        break;
                    case 3:
                        if (boss->data.life.remaining_current_attack >= 400) {
                            vm->interrupt(10);
                            this->__unknown_field_C = 0;
                        }
                        break;
                }
            }
            else {
                switch (state) {
                    case 0:
                        if (boss->data.life.remaining_current_attack < 700) {
                            vm->interrupt(7);
                            this->__unknown_field_C = 1;
                        }
                        break;
                    case 1:
                        if (boss->data.life.remaining_current_attack < 400) {
                            vm->interrupt(8);
                            this->__unknown_field_C = 2;
                        }
                        break;
                    case 2:
                        if (boss->data.life.remaining_current_attack < 200) {
                            vm->interrupt(9);
                            this->__unknown_field_C = 3;
                        }
                        break;
                    case 3:
                        if (boss->data.life.remaining_current_attack >= 200) {
                            vm->interrupt(10);
                            this->__unknown_field_C = 0;
                        }
                        break;
                }
            }

            vm->controller.position.x = boss->data.current_motion.position.x + 32.0f + 192.0f;
            vm->controller.position.y = 960.0f;

            float x_diff = zfabsf(boss->data.current_motion.position.x - PLAYER_PTR->data.position.x);

            uint8_t alpha;
            if (x_diff >= 64.0f) {
                alpha = 255;
            }
            else {
                x_diff *= 191.0f;
                x_diff *= (1.0f / 64.0f);
                alpha = (int32_t)x_diff + 64;
            }

            vm->set_alpha(alpha);

            float X = boss->data.current_motion.position.x;
            if (
                X < -192.0f || X > 192.0f
            ) {
                vm->set_alpha(0);
            }
        }
        else {
            this->__anm_id_8C.__tree_clear_visible2();
        }
    }

    this->__timer_13C++;

    return UpdateFuncNext;
}

// 0x43CD00
dllexport gnu_noinline UpdateFuncRet thiscall Gui::on_draw() {
    Float3 position; // LOCAL 8

    AsciiManager* ascii_manager = ASCII_MANAGER_PTR;

    AnmVM* vm = this->__anm_id_108.get_vm_ptr();

    float offset = 0.0f; // LOCAL 4

    if (vm) {
        position.x = 224.0f;
        position.y = 200.0f;
        position.z = 0.0f;

        vm = this->__anm_id_108.get_vm_ptr();

        ascii_manager->set_alpha(vm->get_alpha());
        ascii_manager->group = 2;
        ascii_manager->font_id = 4;
        ascii_manager->__horizontal_positioning_mode = 0;
        ascii_manager->__vertical_positioning_mode = 0;
        ascii_manager->print_number(&position, this->__int_2C4);

        ascii_manager = ASCII_MANAGER_PTR;
        ascii_manager->set_alpha(255);
        ascii_manager->font_id = 0;
        ascii_manager->group = 0;
        ascii_manager->__horizontal_positioning_mode = 1;
        ascii_manager->__vertical_positioning_mode = 1;
    }

    if (this->__int_134) {
        position.x = 224.0f;
        position.y = 144.0f;
        position.z = 0.0f;

        AnmVM* vm = this->__anm_id_110.get_vm_ptr();

        Spellcard* spellcard = SPELLCARD_PTR;
        if (!spellcard) {
            this->__int_134 = 0;
            this->__anm_id_110.mark_tree_for_delete();
        }
        else if (!vm) {
            this->__int_134 = 0;
        }
        else {
            ascii_manager->set_alpha(vm->get_alpha());
            ascii_manager->group = 2;
            ascii_manager->font_id = 4;

            int32_t value = spellcard->__int_90 / 60;
            if (value >= 1000) {
                value = 999;
            }

            ascii_manager->printf(&position, "%3d.", value);

            ascii_manager = ASCII_MANAGER_PTR;
            spellcard = SPELLCARD_PTR;
            position.x = 268.0f;
            position.y = 150.0f;
            ascii_manager->scale.x = 0.6f;
            ascii_manager->scale.y = 0.6f;

            value = spellcard->__int_90 % 60 * 100 / 60;
            ascii_manager->printf(&position, "%.2ds", value);

            ascii_manager = ASCII_MANAGER_PTR;
            position.x = 224.0f;
            ascii_manager->color = PackD3DCOLOR(255, 128, 128, 128);
            ascii_manager->set_alpha(vm->get_alpha());
            spellcard = SPELLCARD_PTR;
            ascii_manager->scale.x = 1.0f;
            ascii_manager->scale.y = 1.0f;
            position.y = 160.0f;

            int32_t A = spellcard->__int_A8;
            int32_t B = A % 100;
            value = (B % 1000 + 934) % 1000;
            int32_t C = (B + 67) % 100;
            int32_t D = A / 100000 - 22;
            
            if (D != value + C) {
                value = 999;
                D = 99;
            }

            ASCII_MANAGER_PTR->printf(&position, "%3d.", value);

            ascii_manager = ASCII_MANAGER_PTR;
            ascii_manager->scale.x = 0.6f;
            ascii_manager->scale.y = 0.6f;
            position.x = 268.0f;
            position.y = 166.0f;

            ascii_manager->printf(&position, "%.2ds", D);

            ascii_manager = ASCII_MANAGER_PTR;
            ascii_manager->set_alpha(255);
            ascii_manager->scale.x = 1.0f;
            ascii_manager->scale.y = 1.0f;
            ascii_manager->font_id = 0;
            ascii_manager->group = 0;
            ascii_manager->color = PackD3DCOLOR(255, 255, 255, 255);
        }
    }

    // ====================
    // High score
    // ====================

    ascii_manager->color = PackD3DCOLOR(255, 112, 112, 112);
    ascii_manager->color2 = PackD3DCOLOR(128, 255, 255, 255);
    ascii_manager->font_id = 10;
    ascii_manager->group = 3;

    position.x = 620.0f;
    position.y = 42.0f;
    position.z = 0.0f;

    ascii_manager->set_alpha(this->player_life_icons[0]->get_alpha2());
    ascii_manager->set_alpha2(this->player_life_icons[0]->get_alpha2());
    ascii_manager->__horizontal_positioning_mode = 2;
    ascii_manager->__vertical_positioning_mode = 1;

    ascii_manager->print_score(&position, GAME_MANAGER.__high_score, GAME_MANAGER.__high_score_continues);

    // ====================
    // Current score
    // ====================

    ascii_manager = ASCII_MANAGER_PTR;

    position.y = 64.0f;

    ascii_manager->color = PackD3DCOLOR(255, 0, 16, 128);
    ascii_manager->color2 = PackD3DCOLOR(208, 255, 255, 255);
    ascii_manager->set_alpha(this->player_life_icons[0]->get_alpha2());
    ascii_manager->set_alpha2(this->player_life_icons[0]->get_alpha2());

    ascii_manager->print_score(&position, this->__score, GAME_MANAGER.globals.continues);

    // ====================
    // Life fragments for next life
    // ====================

    ascii_manager = ASCII_MANAGER_PTR;
    ascii_manager->__horizontal_positioning_mode = 1;
    ascii_manager->__vertical_positioning_mode = 1;

    if (LIFE_FRAGMENT_COST_TABLE[GAME_MANAGER.globals.lives_added] >= 100u) {
        offset = 7.0f;
    }

    float life_fragment_position = 576.0f - offset;

    ascii_manager->color = PackD3DCOLOR(255, 0, 0, 0);
    ascii_manager->color2 = PackD3DCOLOR(255, 255, 255, 255);
    ascii_manager->scale.x = 0.6f;
    ascii_manager->scale.y = 0.6f;

    position.x = life_fragment_position;
    position.y = 120.0f;

    ascii_manager->set_alpha(this->player_life_icons[0]->get_alpha2());
    ascii_manager->set_alpha2(this->player_life_icons[0]->get_alpha2());

    if (LIFE_FRAGMENT_COST_TABLE[GAME_MANAGER.globals.lives_added] < 999999u) {
        ascii_manager->printf(&position, "%3d", GAME_MANAGER.globals.life_fragments);

        position.x = life_fragment_position + 21.0f;

        ASCII_MANAGER_PTR->printf(&position, "/%d", LIFE_FRAGMENT_COST_TABLE[GAME_MANAGER.globals.lives_added]);
    }
    else {
        ascii_manager->printf(&position, "---/---");
    }

    // ====================
    // Bomb fragments for next bomb
    // ====================

    ascii_manager = ASCII_MANAGER_PTR;

    position.x = 576.0f;
    position.y = 158.0f;

    ascii_manager->set_alpha(this->player_life_icons[0]->get_alpha2());
    ascii_manager->set_alpha2(this->player_life_icons[0]->get_alpha2());
    ascii_manager->scale.x = 0.6f;
    ascii_manager->scale.y = 0.6f;

    ascii_manager->printf(&position, "%3d", GAME_MANAGER.globals.bomb_fragments);

    position.x = 597.0f;

    ASCII_MANAGER_PTR->printf(&position, "/%d", BOMB_FRAGMENT_COST); // Yes, this is a constant 3

    // ====================
    // Power
    // ====================

    ascii_manager = ASCII_MANAGER_PTR;

    position.x = 540.0f;
    position.y = 182.0f;

    ascii_manager->color = PackD3DCOLOR(255, 128, 0, 0);
    ascii_manager->color2 = PackD3DCOLOR(128, 255, 208, 208);
    ascii_manager->scale.x = 1.0f;
    ascii_manager->scale.y = 1.0f;
    ascii_manager->set_alpha(this->player_life_icons[0]->get_alpha2());
    ascii_manager->set_alpha2(this->player_life_icons[0]->get_alpha2());

    ascii_manager->printf(&position, "%d.", GAME_MANAGER.globals.power_level());

    ascii_manager = ASCII_MANAGER_PTR;

    position.x = 560.0f;
    position.y = 189.0f;

    ascii_manager->scale.x = 0.6f;
    ascii_manager->scale.y = 0.6f;

    ascii_manager->printf(&position, "%.2d", GAME_MANAGER.globals.power_percent_to_next_level());

    ascii_manager = ASCII_MANAGER_PTR;

    position.y = 182.0f;
    position.x = 574.0f;

    ascii_manager->scale.x = 1.0f;
    ascii_manager->scale.y = 1.0f;

    ascii_manager->printf(&position, "/%d.", GAME_MANAGER.globals.power_level_max());

    ascii_manager = ASCII_MANAGER_PTR;

    position.x = 606.0f;
    position.y = 189.0f;

    ascii_manager->scale.x = 0.6f;
    ascii_manager->scale.y = 0.6f;

    ascii_manager->printf(&position, "00");

    // ====================
    // Money
    // ====================

    ascii_manager = ASCII_MANAGER_PTR;

    position.x = 620.0f;
    position.y = 204.0f;

    ascii_manager->color = PackD3DCOLOR(255, 128, 128, 0);
    ascii_manager->color2 = PackD3DCOLOR(128, 255, 255, 208);
    ascii_manager->scale.x = 1.0f;
    ascii_manager->scale.y = 1.0f;
    ascii_manager->__horizontal_positioning_mode = 2;
    ascii_manager->__vertical_positioning_mode = 1;
    ascii_manager->set_alpha(this->player_life_icons[0]->get_alpha2());
    ascii_manager->set_alpha2(this->player_life_icons[0]->get_alpha2());

    ascii_manager->print_number(&position, GAME_MANAGER.globals.current_money);

    // ====================
    // Spell timer stuff
    // ====================

    ascii_manager = ASCII_MANAGER_PTR;

    ascii_manager->color = PackD3DCOLOR(255, 255, 255, 255);
    ascii_manager->__horizontal_positioning_mode = 1;
    ascii_manager->__vertical_positioning_mode = 1;
    ascii_manager->scale.x = 1.0f;
    ascii_manager->scale.y = 1.0f;
    ascii_manager->color2 = PackD3DCOLOR(255, 0, 0, 0);
    ascii_manager->set_alpha(255);
    ascii_manager->font_id = 0;
    ascii_manager->group = 0;

    if (
        ENEMY_MANAGER_PTR &&
        this->spell_timer_seconds >= 0 &&
        get_boss_by_index(0) != NULL &&
        !ENEMY_MANAGER_PTR->__unknown_flag_A &&
        !this->msg_vm &&
        !PAUSE_MENU_PTR->__dword_1EC &&
        !GAME_THREAD_PTR->__unknown_flag_F
    ) {
        vm = this->__anm_vm_84;

        position.z = 0.0f;
        float X = vm->data.position.x + 16.0f;
        position.x = X;
        ascii_manager->color = vm->data.color1;
        ascii_manager->font_id = 4;
        float Y = vm->data.position.y - 7.0f;
        position.y = Y;
        ascii_manager->group = 2;

        ascii_manager->printf(&position, ".");

        ascii_manager = ASCII_MANAGER_PTR;

        position.x = X + 8.0f;
        ascii_manager->scale.x = 0.6f;
        ascii_manager->scale.y = 0.6f;
        position.y = Y + 6.0f;

        ascii_manager->printf(&position, "%.2d", this->spell_timer_hundredths);

        ascii_manager = ASCII_MANAGER_PTR;

        ascii_manager->scale.x = 1.0f;
        ascii_manager->scale.y = 1.0f;
        ascii_manager->color = PackD3DCOLOR(255, 255, 255, 255);
        ascii_manager->group = 0;
        ascii_manager->font_id = 0;
    }

    return UpdateFuncNext;
}

// 0x401860
dllexport gnu_noinline uint32_t get_hardware_xinput() asm_symbol_rel(0x401860);
dllexport gnu_noinline uint32_t get_hardware_xinput() {
    return INPUT_STATES[0].get_xinput(0);
}

// 0x401650
dllexport gnu_noinline uint32_t get_joypad_input(uint32_t buttons) asm_symbol_rel(0x401650);
dllexport gnu_noinline uint32_t get_joypad_input(uint32_t buttons) {
    return INPUT_STATES[0].get_joypad(buttons);
}

dllexport gnu_noinline uint32_t get_hardware_inputs() {
    uint32_t buttons = get_hardware_xinput();
    if (WINDOW_DATA.window_active) {
        buttons = INPUT_STATES[0].get_keyboard(buttons);
    }
    buttons = get_joypad_input(buttons);
    INPUT_STATES[0].hardware_inputs_previous = INPUT_STATES[0].hardware_inputs_current;
    INPUT_STATES[0].hardware_inputs_current = buttons;
    INPUT_STATES[0].__update_hardware_input();
    return buttons;
}

// 0x486140
dllexport gnu_noinline int32_t thiscall AnmManager::__sub_486140(AnmImage* image, uint32_t format_index, uint32_t entry_index, int32_t width, int32_t height, int32_t offset_x, int32_t offset_y) {
    image->__unknown_flag_A = false;
    LPDIRECT3DTEXTURE9 texture;
    if (D3DXCreateTextureFromFileInMemoryEx(
        SUPERVISOR.d3d_device,
        image->file,
        image->file_size,
        0, 0, 0, 0,
        D3DFORMAT_TABLE[format_index],
        D3DPOOL_MANAGED,
        D3DX_FILTER_NONE,
        D3DX_DEFAULT,
        0,
        NULL,
        NULL,
        &texture
    ) != D3D_OK) {
        return ZUN_ERROR;
    }
    LPDIRECT3DSURFACE9 surface;
    texture->GetSurfaceLevel(0, &surface);
    D3DSURFACE_DESC surface_desc;
    surface->GetDesc(&surface_desc);
    this->__screw_with_texture_bits(texture);
    float floatA = WINDOW_DATA.__game_scale;
    if (
        surface_desc.Width == width && surface_desc.Height == height &&
        (!image->entry->low_res_scale || !(floatA < 2.0f))
    ) {
        image->d3d_texture = texture;
        SAFE_RELEASE(surface);
    } else {
        uint32_t right = width;
        uint32_t bottom = height;
        if (width + offset_x > surface_desc.Width) {
            right = surface_desc.Width - offset_x;
        }
        if (height + offset_y > surface_desc.Height) {
            bottom = surface_desc.Height - offset_y;
        }
        if (image->entry->low_res_scale && floatA < 2.0f) {
            width = (float)width * floatA * 0.5f;
            height = (float)height * floatA * 0.5f;
        }
        D3DXCreateTexture(
            SUPERVISOR.d3d_device,
            width, height,
            0, 0,
            D3DFORMAT_TABLE[format_index], D3DPOOL_MANAGED,
            &image->d3d_texture
        );
        LPDIRECT3DSURFACE9 surface2;
        image->d3d_texture->GetSurfaceLevel(0, &surface2);
        RECT src_rect;
        src_rect.left = offset_x;
        src_rect.right = offset_x + right;
        src_rect.top = offset_y;
        src_rect.bottom = offset_y + bottom;
        DWORD filter = !image->entry->low_res_scale || !(WINDOW_DATA.__game_scale < 2.0f) ? D3DX_FILTER_NONE : D3DX_FILTER_TRIANGLE | D3DX_FILTER_MIRROR_U | D3DX_FILTER_MIRROR_V;
        D3DXLoadSurfaceFromSurface(
            surface2, NULL, NULL,
            surface, NULL, &src_rect, filter, 0
        );
        SAFE_RELEASE(surface);
        SAFE_RELEASE(surface2);
        SAFE_RELEASE(texture);
    }
    this->__screw_with_texture_bits(image->d3d_texture);
    uint32_t bytes_per_pixel = D3DFORMAT_SIZES_TABLE[format_index];
    image->bytes_per_pixel = bytes_per_pixel;
    return bytes_per_pixel * width * height;
}

// 0x486390
dllexport gnu_noinline int32_t stdcall __sub_486390(AnmImage* image, AnmTexture* texture, uint32_t format_index, uint32_t width, uint32_t height) asm_symbol_rel(0x486390);
dllexport gnu_noinline int32_t stdcall __sub_486390(AnmImage* image, AnmTexture* texture, uint32_t format_index, uint32_t width, uint32_t height) {
    image->__unknown_flag_A = false;
    AnmEntry* entry = image->entry;
    int32_t texture_width = texture->width;
    int32_t texture_height = texture->height;
    RECT rectA = {
        .left = 0,
        .top = 0,
        .right = texture_width,
        .bottom = texture_width
    };
    RECT rectB = {
        .left = 0,
        .top = 0,
        .right = texture_width,
        .bottom = texture_width
    };
    float floatA = WINDOW_DATA.__game_scale;
    if (entry->low_res_scale && floatA < 2.0f) {
        rectB.right = (float)texture_width * floatA * 0.5f;
    }
    // TODO
}

// 0x486560
dllexport gnu_noinline int32_t stdcall __create_render_target_texture(AnmImage* image, uint32_t width, uint32_t height) {
    SUPERVISOR.d3d_device->CreateTexture(
        width, height,
        1, D3DUSAGE_RENDERTARGET,
        D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT,
        &image->d3d_texture, NULL
    );
    image->bytes_per_pixel = (SUPERVISOR.present_parameters.BackBufferFormat == D3DFMT_A8R8G8B8) * 2 + 2;
    return 0;
}

static inline int32_t stdcall __create_normal_texture(AnmImage* image, uint32_t format_index, uint32_t width, uint32_t height) {
    image->__unknown_flag_A = false;
    D3DXCreateTexture(
        SUPERVISOR.d3d_device,
        width, height,
        1, 0,
        D3DFORMAT_TABLE[format_index], D3DPOOL_MANAGED,
        &image->d3d_texture
    );
    uint32_t bytes_per_pixel = D3DFORMAT_SIZES_TABLE[format_index];
    image->bytes_per_pixel = bytes_per_pixel;
    return bytes_per_pixel * width * height;
}

// 0x486BC0
dllexport gnu_noinline int32_t thiscall AnmManager::__sub_486BC0(AnmLoaded* anm_loaded, uint32_t entry_index, uint32_t sprite_count, uint32_t script_count, AnmEntry* entry) {
    if (!entry) {
        LOG_BUFFER.write_error(JpEnStr("", "Can't load animation. data is lost or corrupted\r\n"));
        return -1;
    }
    if (entry->version != 8) {
        LOG_BUFFER.write_error(JpEnStr("", "different version of animation\r\n"));
        return -1;
    }
    anm_loaded->images[entry_index].entry = entry;
    int32_t image_size;
    if (!entry->has_data) {
        const char* image_filename = based_pointer<const char>(entry, entry->image_path_offset);
        if (image_filename[0] == '@') {
            if (image_filename[1] == 'R') {
                entry->width = WINDOW_DATA.__scaled_width;
                entry->height = WINDOW_DATA.__scaled_height;
                __create_render_target_texture(&anm_loaded->images[entry_index], WINDOW_DATA.__scaled_width, WINDOW_DATA.__scaled_height);
                goto skip_adding_image_size;
            }
            image_size = __create_normal_texture(&anm_loaded->images[entry_index], entry->format, entry->width, entry->height);
        } else {
            image_size = this->__sub_486140(&anm_loaded->images[entry_index], entry->format, entry_index, entry->width, entry->height, entry->offset_x, entry->offset_y);
            if (image_size < 0) {
                LOG_BUFFER.write_error(JpEnStr("", "Unable to create texture %s. data is lost or corrupted\r\n"), image_filename);
                return -1;
            }
        }
    } else {
        image_size = __sub_486390(&anm_loaded->images[entry_index], based_pointer<AnmTexture>(entry, entry->texture_data_offset), entry->format, entry->width, entry->height);
        if (image_size < 0) {
            LOG_BUFFER.write_error(JpEnStr("", "Unable to create texture. data is lost or corrupted\r\n"));
            return -1;
        }
    }
    // TODO
skip_adding_image_size:
}

// 0x454B20
dllexport gnu_noinline void thiscall Supervisor::__initialize_cameras() {
    this->cameras[2].position.x = 0.0f;
    this->cameras[2].position.y = 0.0f;
    this->cameras[2].position.z = 0.0f;
    this->cameras[2].facing.x = 0.0f;
    this->cameras[2].facing.y = 0.0f;
    this->cameras[2].rotation.x = 0.0f;
    this->cameras[2].rotation.y = 1.0f;
    StageCamera* camera2 = &this->cameras[2];
    camera2->viewport.X = 0;
    camera2->viewport.Y = 0;
    camera2->fov = 0.5235988f;
    float dumb_local = 0.0f;
    camera2->facing.z = dumb_local;
    dumb_local = 0.0f;
    camera2->rotation.z = dumb_local;
    camera2->viewport.Width = WINDOW_DATA.__scaled_width;
    camera2->viewport.Height = WINDOW_DATA.__scaled_height;
    camera2->__shaking_float3_A.x = 0.0f;
    camera2->__shaking_float3_A.y = 0.0f;
    camera2->viewport.MinZ = 0.0f;
    camera2->viewport.MaxZ = 1.0f;
    camera2->camera_index = 2;
    dumb_local = 0.0f;
    camera2->__shaking_float3_A.z = dumb_local;
    camera2->__shaking_float3_B.x = 0.0f;
    camera2->__shaking_float3_B.y = 0.0f;
    dumb_local = 0.0f;
    camera2->__shaking_float3_B.z = dumb_local;
    camera2->window_resolution.x = WINDOW_DATA.__scaled_width;
    camera2->window_resolution.y = WINDOW_DATA.__scaled_height;
    camera2->__viewport_10C = camera2->viewport;
    camera2->__int2_104.x = 0;
    camera2->__int2_104.y = 0;
    camera2->__viewport_10C.X = 0;
    camera2->__viewport_10C.Y = 0;
    camera2->__viewport_10C.Width = WINDOW_DATA.__scaled_width;
    camera2->__viewport_10C.Height = WINDOW_DATA.__scaled_height;
    camera2->__viewport_124.X = WINDOW_DATA.__game_scale * 32.0f;
    camera2->__viewport_124.Y = WINDOW_DATA.__game_scale * 16.0f;
    camera2->__viewport_124.Width = WINDOW_DATA.__game_scale * 384.0f;
    camera2->__viewport_124.Height = WINDOW_DATA.__game_scale * 448.0f;
    this->__sub_454950(camera2);
    StageCamera* camera0 = &this->cameras[0];
    *camera0 = *camera2;
    camera0->camera_index = 0;
    camera0->viewport.X = WINDOW_DATA.__game_scale * 32.0f;
    camera0->viewport.Y = WINDOW_DATA.__game_scale * 16.0f;
    camera0->viewport.Width = WINDOW_DATA.__game_scale * 384.0f;
    camera0->viewport.Height = WINDOW_DATA.__game_scale * 448.0f;
    camera0->__int2_104.x = 0;
    camera0->__int2_104.y = 0;
    camera0->__viewport_10C = camera0->viewport;
    this->__sub_454950(camera0);
    StageCamera* camera1 = &this->cameras[1];
    *camera1 = *camera0;
    camera1->camera_index = 1;
    camera1->viewport.X = WINDOW_DATA.__game_scale * 128.0f;
    camera1->viewport.Y = WINDOW_DATA.__game_scale * 16.0f;
    camera1->viewport.Width = WINDOW_DATA.__game_scale * 384.0f;
    camera1->viewport.Height = WINDOW_DATA.__game_scale * 448.0f;
    camera1->__int2_104.x = 0;
    camera1->__int2_104.y = 0;
    camera1->__viewport_10C = camera1->viewport;
    this->__sub_454950(camera1);
    StageCamera* camera3 = &this->cameras[3];
    *camera3 = *camera0;
    camera3->camera_index = 3;
    camera3->viewport.X = ((float)WINDOW_DATA.__scaled_width - 408.0f) * 0.5f;
    camera3->viewport.Width = 408;
    camera3->viewport.Width = 472;
    camera3->__int2_104.x = 0;
    camera3->__int2_104.y = 0;
    camera3->viewport.Y = ((float)WINDOW_DATA.__scaled_height - 472.0f) * 0.5f;
    camera3->__viewport_10C = camera3->viewport;
    this->__sub_454950(camera3);
    WINDOW_DATA.__int_2084 = WINDOW_DATA.__scaled_width / 2;
    WINDOW_DATA.__int_2088 = WINDOW_DATA.__game_scale * 16.0f;
}

// 0x454F50
dllexport gnu_noinline void Supervisor::__camera2_sub_454F50() {
    int32_t intA = WINDOW_DATA.__scaled_width;
    int32_t intB = (float)(WINDOW_DATA.__backbuffer_width - intA) * 0.5f;
    float floatA = WINDOW_DATA.__game_scale;
    SUPERVISOR.cameras[2].__int2_104.x = intB;
    int32_t intC = WINDOW_DATA.__scaled_height;
    int32_t intD = (float)(WINDOW_DATA.__backbuffer_height - intC) * 0.5f;
    SUPERVISOR.cameras[2].__int2_104.y = intD;
    SUPERVISOR.cameras[2].__viewport_10C = SUPERVISOR.cameras[2].viewport;
    SUPERVISOR.cameras[2].__viewport_10C.X = intB;
    SUPERVISOR.cameras[2].__viewport_10C.Y = intD;
    SUPERVISOR.cameras[2].__viewport_10C.Width = intA;
    SUPERVISOR.cameras[2].__viewport_10C.Height = intC;
    SUPERVISOR.cameras[2].__viewport_124.X = floatA * -32.0f;
    SUPERVISOR.cameras[2].__viewport_124.Y = floatA * -16.0f;
    SUPERVISOR.cameras[2].__viewport_124.Width = floatA * 384.0f;
    SUPERVISOR.cameras[2].__viewport_124.Width = floatA * 448.0f;
}

// 0x462680
dllexport gnu_noinline ZUNResult thiscall ReplayManager::__load_from_path(const char* path) {
    char buffer[0x1000];
    void* replay_data;
    ReplayHeader* header;
    byteloop_strcpy(this->file_path, path);
    if (!GAME_MANAGER.__unknown_flag_C) {
        chdir(WINDOW_DATA.appdata_path);
        sprintf(buffer, "replay/%s", path);
        if (zun_file_exists(buffer)) {
            if (!__zun_open_file(buffer)) {
                header = (ReplayHeader*)__zun_read_file(sizeof(ReplayHeader));
                this->header = header;
                if (
                    header->magic.as_int == REPLAY_MAGIC &&
                    header->__version == REPLAY_VERSION_NUMBER
                ) {
                    replay_data = __zun_read_file(header->file_size);
                    __zun_close_file();
                    header = this->header;
                    goto valid_replay;
                }
            }
            __zun_close_file();
        }
        chdir(WINDOW_DATA.exe_path);
        return ZUN_ERROR;
    }
    else {
        void* file = read_file_to_buffer(path, (int32_t*)&replay_data, false);
        header = (ReplayHeader*)file;
        this->header = header;
        replay_data = based_pointer(file, sizeof(ReplayHeader));
    }
valid_replay:
    this->file_buffer = malloc(header->uncompressed_size);
    __decrypt_buffer(replay_data, this->header->compressed_size, 0x5C, 0xE1, 0x400, this->header->compressed_size);
    __decrypt_buffer(replay_data, this->header->compressed_size, 0x7D, 0x3A, 0x100, this->header->compressed_size);
    __decompress_buffer(replay_data, this->header->compressed_size, this->file_buffer, this->header->uncompressed_size);
    void* file = this->file_buffer;
    this->info = (ReplayInfo*)file;
    ReplayGamestate* gamestate_ptr = based_pointer<ReplayGamestate>(file, sizeof(ReplayInfo));
    for (int32_t i = 0; ; ++i) {
        int32_t stage_count = this->info->stage_count;
        stage_count = stage_count >= STAGE_COUNT ? 6 : stage_count;
        if (i >= stage_count) {
            break;
        }
        ReplayFrameInput* inputs = (ReplayFrameInput*)&gamestate_ptr->extra[0];
        this->stage_data[gamestate_ptr->stage_number].gamestate_start = gamestate_ptr;
        this->stage_data[gamestate_ptr->stage_number].input_start = inputs;
        this->stage_data[gamestate_ptr->stage_number].fps_counts_start = (uint8_t*)(gamestate_ptr->input_count * sizeof(ReplayFrameInput));
        gamestate_ptr = based_pointer(gamestate_ptr + 1, gamestate_ptr->extra_size);
    }
    if (
        !GAME_MANAGER.__unknown_flag_C &&
        replay_data
    ) {
        free(replay_data);
    }
    chdir(WINDOW_DATA.exe_path);
    return ZUN_SUCCESS;
}

// 0x461E90
dllexport gnu_noinline ZUNResult thiscall ReplayManager::__write_to_path(const char* filename, const char* name, bool arg3, bool arg4) {
    ReplayManager* self = REPLAY_MANAGER_PTR;

    int32_t stage_end = 0; // EBP-128
    int32_t stage_start = 0; // EBP-120

    byteloop_strcpy(self->info->name, name);
    for (
        int32_t i = strlen(name);
        i < countof(self->info->name) - 1;
        ++i
    ) {
        self->info->name[i] = ' ';
    }

    if (self->__unknown_flag_B && arg4) {
        ReplayChunk* cur_chunk = self->current_chunk_node->data;
        if (cur_chunk->write_input(REPLAY_INPUT_END)) {
            self->current_chunk_node = self->allocate_chunk(self->stage_number);
        }
    }

    char path[MAX_PATH];
    sprintf(path, "replay/%s", filename);

    size_t alloc_size = sizeof(ReplayInfo);
    size_t stage_count = 0;

    for (int32_t i = 0; i < STAGE_COUNT; ++i) {
        if (ReplayGamestate* game_state = self->game_states[i]) {
            stage_end = i;
            if (!stage_start) {
                stage_start = i; // This only works if 0 isn't a valid index, so why are the arrays 8...?
            }

            if (!self->__unknown_flag_B) {
                game_state->extra_size = 0;
            }
            alloc_size += sizeof(ReplayGamestate);
            self->chunk_lists[i].for_each([&](ReplayChunk* chunk) {
                size_t input_size = chunk->input_size();
                alloc_size += input_size;
                alloc_size += chunk->fps_size();
                if (!self->__unknown_flag_B) {
                    self->game_states[i]->extra_size += input_size + chunk->fps_size();
                    self->game_states[i]->input_count += chunk->input_count();
                }
            });
            ++stage_count;
        }
    }

    self->info->stage_count = stage_count;
    self->info->score = GAME_MANAGER.globals.score;
    self->info->slowdown_rate = FPS_COUNTER_PTR->calc_slowdown_rate();

    uint8_t* buffer = (uint8_t*)malloc(alloc_size);
    *(ReplayInfo*)buffer = *self->info;

    size_t offset = sizeof(ReplayInfo);
    for (int32_t i = 0; i < STAGE_COUNT; ++i) {
        if (ReplayGamestate* game_state = self->game_states[i]) {
            memcpy(&buffer[offset], game_state, sizeof(ReplayGamestate));
            offset += sizeof(ReplayGamestate);
            self->chunk_lists[i].for_each([&](ReplayChunk* chunk) {
                memcpy(&buffer[offset], chunk->inputs, chunk->input_size());
                offset += chunk->input_size();
            });
            self->chunk_lists[i].for_each([&](ReplayChunk* chunk) {
                memcpy(&buffer[offset], chunk->fps_counts, chunk->fps_size());
                offset += chunk->fps_size();
            });
        }
    }

    int32_t compressed_size;
    uint8_t* compressed_buffer = (uint8_t*)__compress_buffer(buffer, offset, &compressed_size);
    free(buffer);
    __crypt_buffer(compressed_buffer, compressed_size, 0x7D, 0x3A, 0x100, compressed_size);
    __crypt_buffer(compressed_buffer, compressed_size, 0x5C, 0xE1, 0x400, compressed_size);

    self->header->uncompressed_size = offset;
    self->header->compressed_size = compressed_size;
    self->header->file_size = compressed_size + sizeof(ReplayHeader);

    chdir(WINDOW_DATA.appdata_path);
    __zun_open_new_file(path);
    if (__zun_write_file(self->header, sizeof(ReplayHeader)) != ZUN_ERROR) {
        __zun_write_file(compressed_buffer, compressed_size);
    }

    if (compressed_buffer) {
        free(compressed_buffer);
    }

    // oh why zun
    char* user_data_buffer = (char*)malloc(UINT16_MAX);
    memset(user_data_buffer, 0, UINT16_MAX);

    ReplayUserData* user_data = (ReplayUserData*)user_data_buffer;

    user_data->magic.as_uint = REPLAY_USER_MAGIC;
    char* user_write = user_data->text;

    user_write += sprintf(user_write, 
        JpEnStr("", "%s replay file information\r\n"),
        JpEnStr("", "Oriental Rainbow Cave")
    );
    user_write += sprintf(user_write, "Version %s\r\n", "1.00a");
    user_write += sprintf(user_write, "Name %s\r\n", self->info->name);

    tm* time = localtime(&self->info->time);

    user_write += sprintf(user_write, "Date %.2d/%.2d/%.2d %.2d:%.2d\r\n", time->tm_year % 100, time->tm_mon + 1, time->tm_mday, time->tm_hour, time->tm_min);

    user_write += sprintf(user_write, "Chara %s\r\n", SIX_LETTER_SHOTTYPE_NAMES[self->info->shottype_index()]);

    user_write += sprintf(user_write, "Rank %s\r\n", SEVEN_LETTER_DIFFICULTY_NAMES[self->info->difficulty]);

    if (self->info->__end_stage > 7) {
        if (stage_start == 7) {
            user_write += sprintf(user_write, "Extra Stage Clear\r\n");
        }
        else {
            user_write += sprintf(user_write, "Stage All Clear\r\n");
        }
    }
    else {
        if (stage_start == stage_end) {
            if (stage_start == 7) {
                user_write += sprintf(user_write, "Extra Stage\r\n");
            }
            else {
                user_write += sprintf(user_write, "Stage %d\r\n", stage_start);
            }
        }
        else {
            user_write += sprintf(user_write, "Stage %d - %d\r\n", stage_start, stage_end);
        }
    }

    user_write += sprintf(user_write, "Score %d\r\n", self->info->score);

    user_write += sprintf(user_write, "Slow Rate %2.2f\r\n", self->info->slowdown_rate);

    ++user_write;

    int32_t user_size_align = (user_write - user_data_buffer) % 4;
    if (!user_size_align) {
        user_write += 4 - user_size_align;
    }
    int32_t user_size = user_write - user_data_buffer;
    user_data->size = user_size;

    __zun_write_file(user_data_buffer, user_size);

    memset(user_data_buffer, 0, UINT16_MAX);
    user_data->magic.as_uint = REPLAY_USER_MAGIC;
    user_data->__byte_8 = 1;

    user_write = user_data->text;

    user_write += sprintf(user_write,
        JpEnStr("", "can write comments")
    );

    ++user_write;

    user_size_align = (user_write - user_data_buffer) % 4;
    if (!user_size_align) {
        user_write += 4 - user_size_align;
    }
    user_size = user_write - user_data_buffer;
    user_data->size = user_size;

    __zun_write_file(user_data_buffer, user_size);

    free(user_data_buffer);

    __zun_close_file();

    chdir(WINDOW_DATA.exe_path);

    self->__unknown_flag_B = true;

    return ZUN_SUCCESS;
}

// 0x4543A0
dllexport gnu_noinline ZUNResult thiscall Supervisor::load_config_file(int) {
    SUPERVISOR.config.initialize();
    chdir(WINDOW_DATA.appdata_path);
    int32_t file_size;
    void* config_file = read_file_to_buffer("th18.cfg", &file_size, true);
    chdir(WINDOW_DATA.exe_path);
    if (!config_file) {
        LOG_BUFFER.write(JpEnStr("RtBOf[^\r\n", "I initialized because the configuration data was not found\r\n"));
        SUPERVISOR.config.initialize();
    }
    else {
        SUPERVISOR.config = *(Config*)config_file;
        free(config_file);
        if (
            SUPERVISOR.config.__ubyte_44 < 2 &&
            SUPERVISOR.config.__ubyte_45 < 3 &&
            SUPERVISOR.config.__ubyte_46 < 2 &&
            SUPERVISOR.config.__ubyte_47 < 10 &&
            SUPERVISOR.config.__ubyte_48 < 3 &&
            SUPERVISOR.config.__ubyte_49 < 3 &&
            SUPERVISOR.config.__dword_0 == 0x180002 &&
            file_size == 0x88
        ) {
            INPUT_STATES[0].xinput_mapping   = SUPERVISOR.config.xinput_mapping;
            INPUT_STATES[0].joypad_mapping   = SUPERVISOR.config.joypad_mapping;
            INPUT_STATES[0].keyboard_mapping = SUPERVISOR.config.keyboard_mapping;
        }
        else {
            LOG_BUFFER.write(JpEnStr("RtBOf[^\r\n", "The configuration data was abnormal, so it was reinitialized\r\n"));
            SUPERVISOR.config.initialize();
        }
    }
    this->disable_vsync = false;
    if (this->config.disable_fog) {
        LOG_BUFFER.write(JpEnStr("tHOgp}\r\n", "suppress the use of fog\r\n"));
    }
    if (this->present_parameters.Windowed) {
        LOG_BUFFER.write(JpEnStr("EBhE[hN\r\n", "start in windowed mode\r\n"));
    }
    if (this->config.reference_rasterizer) {
        LOG_BUFFER.write(JpEnStr("t@XX^CU\r\n", "force reference rasterizer\r\n"));
    }
    if (this->config.disable_direct_input) {
        LOG_BUFFER.write(JpEnStr("pbhAL[{[h DirectInput gp\r\n", "Does not use DirectInput for pad and keyboard input\r\n"));
    }
    if (this->config.preload_bgm) {
        LOG_BUFFER.write(JpEnStr("afl\r\n", "Load BGM into memory\r\n"));
    }
    if (this->config.disable_vsync) {
        LOG_BUFFER.write(JpEnStr("\r\n", "no vertical sync\r\n"));
        SUPERVISOR.disable_vsync = true;
    }
    if (this->config.__disable_locale_detection) {
        LOG_BUFFER.write(JpEnStr("`o\r\n", "Do not auto-detect character drawing environment\r\n"));
    }
    chdir(WINDOW_DATA.appdata_path);
    if (ZUN_FAILED(__zun_create_new_file_from_buffer("th18.cfg", &SUPERVISOR.config, sizeof(Config)))) {
        LOG_BUFFER.write_error(JpEnStr("t@Co %s\r\n", "Unable to write file %s\r\n"), "th18.cfg");
        LOG_BUFFER.write_error(JpEnStr("tH_~AfBXNH\r\n", "Is the folder write-protected or is the disk full?\r\n"));
        chdir(WINDOW_DATA.exe_path);
        return ZUN_ERROR;
    }
    else {
        chdir(WINDOW_DATA.exe_path);
        return ZUN_SUCCESS;
    }
}

// 0x473390
dllexport gnu_noinline double vectorcall get_runtime() asm_symbol_rel(0x473390);
dllexport gnu_noinline double vectorcall get_runtime() {
    CRITICAL_SECTION_MANAGER.enter_section(Menu_CS);
    double current_time;
    double prev_time;
    if (WINDOW_DATA.performance_counter_frequency.QuadPart) {
        LARGE_INTEGER current_qpc_value;
        QueryPerformanceCounter(&current_qpc_value);
        current_time = (double)(current_qpc_value.QuadPart - WINDOW_DATA.startup_qpc_value.QuadPart) / (double)WINDOW_DATA.performance_counter_frequency.QuadPart;
        prev_time = WINDOW_DATA.__double_20B0;
        if (current_time < prev_time) {
            WINDOW_DATA.__double_20B0 = prev_time = current_time;
        }
        CRITICAL_SECTION_MANAGER.leave_section(Menu_CS);
        return current_time - WINDOW_DATA.__double_20B0;
    } else {
        current_time = timeGetTime();
        prev_time = WINDOW_DATA.__double_20B0;
        if (current_time < prev_time) {
            WINDOW_DATA.__double_20B0 = prev_time = current_time;
        }
        current_time = (current_time - prev_time * 1000.0) / 1000.0;
        CRITICAL_SECTION_MANAGER.leave_section(Menu_CS);
        return current_time;
    }
}

// 0x454950
dllexport gnu_noinline int thiscall Supervisor::__sub_454950() {
    if (this->gamemode_current != this->gamemode_switch) {
        CRITICAL_SECTION_MANAGER.enter_section(Menu_CS);


        int32_t prev_gamemode = this->gamemode_current;
        int32_t new_gamemode = this->gamemode_switch;
        this->gamemode_previous = prev_gamemode;

        switch (new_gamemode) {
            case 0:
                this->gamemode_switch = 1;
                // TODO
        }


        CRITICAL_SECTION_MANAGER.leave_section(Menu_CS);
    }
    return 1;
}

extern "C" {
    // 0x4CF438
    externcg int32_t UNKNOWN_INT32_C cgasm("_UNKNOWN_INT32_C");
}

// 0x455040
dllexport gnu_noinline UpdateFuncRet thiscall Supervisor::__sub_455040() {
    if (this->gamemode_current != this->gamemode_switch) {
        CRITICAL_SECTION_MANAGER.enter_section(Menu_CS);
        {

            int32_t prev_gamemode = this->gamemode_current;
            int32_t new_gamemode = this->gamemode_switch;
            this->gamemode_previous = prev_gamemode;

            this->background_color = PackD3DCOLOR(255, 0, 0, 0);

            switch (new_gamemode) {
                case 0: {
                    this->gamemode_switch = 1;
                    LoadingThread* loading_thread = LoadingThread::allocate();
                    this->__loading_thread_B40 = loading_thread;
                    if (loading_thread) {
                        break;
                    }
                    this->gamemode_switch = 3;
                }
                case 3:
                    this->__sub_453C70();
                    CRITICAL_SECTION_MANAGER.leave_section(Menu_CS);
                    return UpdateFuncEnd0;
                case 4: {
                    AbilityManager* ability_manager = ABILITY_MANAGER_PTR;
                    ability_manager->__int_C5C = 0;
                    ability_manager->__sub_407DA0(TRUE);
                    switch (this->gamemode_current) {
                        default:
                            goto finalize_gamemode_switch;
                        case 7:
                            GAME_THREAD_PTR->cleanup();
                            break;
                        case 15:
                            //ENDING_PTR->cleanup();
                            break;
                        case 1: case 2:
                            break;
                    }
                    MainMenu::allocate();
                    break;
                }
                case 16: {
                    AbilityManager* ability_manager = ABILITY_MANAGER_PTR;
                    ability_manager->__int_C5C = 0;
                    ability_manager->__sub_407DA0(TRUE);
                    switch (this->gamemode_current) {
                        default:
                            goto finalize_gamemode_switch;
                        case 7:
                            GAME_THREAD_PTR->cleanup();
                            break;
                        case 15:
                            //ENDING_PTR->cleanup();
                            break;
                        case 2:
                            break;
                    }
                    this->gamemode_switch = 4;
                    UNKNOWN_INT32_C = 3;
                    MainMenu::allocate();
                    break;
                }
                case 7:
                    if (prev_gamemode == 4) {
                        //MAIN_MENU_PTR->cleanup();
                    }
                    this->__int_804 = 1;
                    GameThread::allocate(__replay_recording);
                    break;
                case 13:
                    if (prev_gamemode == 4) {
                        //MAIN_MENU_PTR->cleanup();
                    }
                    this->gamemode_switch = 7;
                    this->__int_804 = 1;
                    GameThread::allocate(__replay_playback);
                    break;
                case 12: {
                    ReplayMode replay_mode = GAME_THREAD_PTR->replay_mode;
                    this->__int_804 = 0;
                    if (prev_gamemode == 7) {
                        GAME_THREAD_PTR->cleanup();
                    }
                    this->gamemode_switch = 7;
                    GameThread::allocate(replay_mode);
                    break;
                }
                case 10: {
                    GAME_THREAD_PTR->cleanup();
                    this->__int_804 = 1;
                    this->__dword_808 = 0;
                    this->gamemode_switch = 7;
                    int32_t stage_number = GAME_MANAGER.globals.__stage_number_related_4;
                    GAME_MANAGER.globals.current_stage = stage_number;
                    STAGE_DATA_PTR = &STAGE_DATA[stage_number];
                    GameThread::allocate(__replay_recording);
                    break;
                }
                case 11: {
                    GAME_THREAD_PTR->cleanup();
                    this->__int_804 = 1;
                    this->__dword_808 = 0;
                    this->gamemode_switch = 7;
                    int32_t stage_number = GAME_MANAGER.globals.__stage_number_related_4;
                    GAME_MANAGER.globals.current_stage = stage_number;
                    STAGE_DATA_PTR = &STAGE_DATA[stage_number];
                    GameThread::allocate(__replay_playback);
                    break;
                }
                case 19: {
                    GAME_THREAD_PTR->cleanup();
                    this->__int_804 = 1;
                    this->__dword_808 = 1;
                    this->gamemode_switch = 7;
                    int32_t stage_number = GAME_MANAGER.globals.__stage_number_related_4;
                    GAME_MANAGER.globals.current_stage = stage_number;
                    STAGE_DATA_PTR = &STAGE_DATA[stage_number];
                    GameThread::allocate(__replay_recording);
                    break;
                }
                case 14:
                    GAME_THREAD_PTR->cleanup();
                    this->__int_804 = 1;
                    this->gamemode_switch = 7;
                    GameThread::allocate(__replay_recording);
                    break;
                case 15:
                    if (prev_gamemode == 7) {
                        GAME_THREAD_PTR->cleanup();
                    }
                    //Ending::allocate();
                    break;
                case 17:
                    this->__sub_453C70();
                    CRITICAL_SECTION_MANAGER.leave_section(Menu_CS);
                    return UpdateFuncEndN1;
            }
    finalize_gamemode_switch:
            this->gamemode_current = this->gamemode_switch;
        }
        CRITICAL_SECTION_MANAGER.leave_section(Menu_CS);
    }
    return UpdateFuncNext;
}

// 0x453C70
dllexport gnu_noinline void thiscall Supervisor::__sub_453C70() {
    if (!SUPERVISOR.__unknown_bitfield_A) {
        SUPERVISOR.__unknown_bitfield_A = 1;
    }

    delete KEY_CONFIG_MENU_PTR;
    delete OPTIONS_MENU_PTR;
    delete GAME_THREAD_PTR;
    //MAIN_MENU_PTR->cleanup();
    delete LOADING_THREAD_PTR;
    //delete ENDING_PTR;
    delete REPLAY_MANAGER_PTR;
    SAFE_DELETE(EFFECT_MANAGER_PTR);
    delete HELP_MENU_PTR;
    delete ABILITY_MANAGER_PTR;
    delete ABILITY_MENU_PTR;
    ABILITY_SHOP_PTR->cleanup();
    //delete TROPHY_MANAGER_A;
    //delete NOTICE_MANAGER;
}

// 0x453A70
dllexport gnu_noinline void thiscall Supervisor::__sub_453A70() {
    //while (SOUND_MANAGER.__sub_476D20());

    SUPERVISOR.__thread_AB0.stop_and_cleanup();
    SUPERVISOR.__thread_A94.stop_and_cleanup();

    SAFE_FREE(SUPERVISOR.ver_file_buffer);

    this->__sub_453C70();

    delete FPS_COUNTER_PTR;
    delete TICK_COUNTER_PTR;

    SAFE_RELEASE(ANM_MANAGER_PTR->__d3d_vertex_buffer_3120E18);

    // more sound manager
    // cleanup font handles

    if (auto keyboard_device = this->keyboard_device) {
        keyboard_device->Unacquire();
        SAFE_RELEASE(this->keyboard_device);
    }
    if (auto joypad_device = this->joypad_devices[0]) {
        joypad_device->Unacquire();
        SAFE_RELEASE(this->joypad_devices[0]);
    }

    SAFE_RELEASE(this->dinput);

    //THDAT_ARCFILE.~ArcFile();

    SAFE_DELETE(this->__arcade_vm_ptr_A);
    SAFE_DELETE(this->__arcade_vm_ptr_B);
    SAFE_DELETE(this->__arcade_vm_ptr_C);
    SAFE_DELETE(this->__arcade_vm_ptr_D);
}

// 0x443860
dllexport gnu_noinline UpdateFuncRet thiscall GameThread::on_tick() {
    if (SUPERVISOR.__unknown_bitfield_A != 0) {
        return UpdateFuncDeleteCurrentThenNext;
    }

    if (this->__unknown_flag_E) {
        if (this->__unknown_flag_I) {
            return UpdateFuncEnd1;
        }

        int A = ++this->__int_D4;

        ReplayMode replay_mode = this->replay_mode;
        if (replay_mode != __replay_recording) {
            if (A == 120) {
                // PAUSE_MENU_PTR->__sub_4588F0();
                replay_mode = this->replay_mode;
            }
        }
        if (replay_mode == __replay_recording) {
            if (this->__int_D4 == 180) {
                // ScreenEffect::create(5, 0xC8, 0, 0, 0, 0x59);
                replay_mode = this->replay_mode;
            }
        }
        if (replay_mode == __replay_recording) {
            if (this->__int_D4 > 380) {
                // ABILITY_MANAGER_PTR->__sub_4074C0();
                ABILITY_MANAGER_PTR->__sub_407DA0(true);

                int32_t mode;
                if (GAME_MANAGER.globals.difficulty != EXTRA) {
                    mode = (SUPERVISOR.__unknown_bitfield_A & 1) ? 2 : 15;
                } else {
                    mode = (SUPERVISOR.__unknown_bitfield_A & 1) ? 2 : 16;
                }
                SUPERVISOR.gamemode_switch = mode;
            }
        }
    }

    Gui* gui = GUI_PTR;
    if (
        !gui->__unknown_flag_A ||
        gui->__timer_198 >= 120
        ) {
        if (!this->__unknown_flag_I) {
            return UpdateFuncNext;
        }

        // These both allocate the "main" enemy
        switch (this->__timer_C.current) {
            case 0:
                if (ZUN_FAILED(this->__sub_443E60())) {
                    return UpdateFuncNext;
                }
                break;
            case 30:
                this->__sub_4443C0();
                break;
        }
    }

    Stage* stageB = STAGE_B_PTR;
    if (
        stageB != NULL &&
        stageB->__unknown_flag_A &&
        stageB != NULL
    ) {
        delete stageB;
    }

    WINDOW_DATA.__int_20D0 = this->__timer_C == 5 ? 2 : WINDOW_DATA.__int_20D0;

    if (this->skip_flag) {
        this->__unknown_flag_J = true;
        return UpdateFuncNext;
    }

    if (!GAME_MANAGER.__unknown_flag_E) {
        if (
            INPUT_STATES[0].check_hardware_inputs(BUTTON_SHOOT | BUTTON_BOMB | BUTTON_PAUSE | BUTTON_ENTER) ||
            (this->__unknown_flag_I | this->__unknown_flag_L | this->__unknown_flag_M)
        ) {
            SUPERVISOR.gamemode_switch = (SUPERVISOR.__unknown_bitfield_A & 1) ? 2 : 4;
        }

        switch (this->__timer_C.current) {
            case 3540:
                // ScreenEffect::create(5, 0x3C, 0, 0, 0, 0x5B);
                break;
            case 3600:
                SUPERVISOR.gamemode_switch = (SUPERVISOR.__unknown_bitfield_A & 1) ? 2 : 4;
                break;
        }
    }

#if INCLUDE_PATCH_CODE
    gui = GUI_PTR;
    uint64_t score = GAME_MANAGER.globals.score | (uint64_t)score_upper[0] << 32;
    uint64_t displayed_score = gui->__score | (uint64_t)score_upper[2] << 32;
    if (score != displayed_score) {
        uint64_t score_diff = score - displayed_score;
        uint64_t score_diff_B = score_diff / 32;

        uint32_t score_diff_C = __max(__min(score_diff_B, 578910), 1);

        if (gui->__int_15C < score_diff_C) {
            gui->__int_15C = score_diff_C;
        } else {
            score_diff_C = gui->__int_15C;
        }

        if (score_diff_C > score_diff) {
            gui->__int_15C = score_diff;
        } else {
            score_diff = score_diff_C;
        }
        displayed_score += score_diff;
        gui->__score = displayed_score;
        score_upper[2] = displayed_score >> 32;

        if (displayed_score >= score) {
            gui->__int_15C = 0;
        }
    }
    uint64_t high_score = GAME_MANAGER.__high_score | (uint64_t)score_upper[1] << 32;
    if (high_score < displayed_score) {
        int32_t continues_local = GAME_MANAGER.globals.continues;
        GAME_MANAGER.__unknown_flag_C = true;
        GAME_MANAGER.__high_score = displayed_score;
        score_upper[1] = displayed_score >> 32;
        GAME_MANAGER.__high_score_continues = continues_local;
    }
#else
    gui = GUI_PTR;
    uint32_t score = GAME_MANAGER.globals.score;
    uint32_t displayed_score = gui->__score;
    if (score != displayed_score) {
        uint32_t score_diff = score - displayed_score;
        uint32_t score_diff_B = score_diff / 32;

        int32_t score_diff_C = __max(__min(score_diff_B, 578910), 1);

        if (gui->__int_15C < score_diff_C) {
            gui->__int_15C = score_diff_C;
            score = GAME_MANAGER.globals.score;
        } else {
            score_diff_C = gui->__int_15C;
        }

        int32_t score_diff_D = score - displayed_score;

        if (score_diff_C > score_diff_D) {
            gui->__int_15C = score_diff_D;
            score_diff_C = score_diff_D;
        }
        displayed_score += score_diff_C;
        gui->__score = displayed_score;

        if (displayed_score >= (int32_t)GAME_MANAGER.globals.score) {
            gui->__int_15C = 0;
        }
    }
    if ((int32_t)GAME_MANAGER.__high_score < displayed_score) {
        int32_t continues = GAME_MANAGER.globals.continues;
        GAME_MANAGER.__unknown_flag_C = true;
        GAME_MANAGER.__high_score = displayed_score;
        GAME_MANAGER.__high_score_continues = continues;
    }
#endif
}

// All values are stored / 100

// 0x4B666C
static const int32_t MIN_POINT_ITEM_VALUES_TABLE[DIFFICULTY_COUNT] = {
    10000,
    10000,
    10000,
    10000,
    10000,
    100000
};
// 0x4B6654
static const int32_t MAX_POINT_ITEM_VALUES_TABLE[DIFFICULTY_COUNT] = {
    200000,
    500000,
    700000,
    1000000,
    500000,
    1000000
};

// 0x4B663C
static const int32_t CONTINUE_CREDITS_TABLE[DIFFICULTY_COUNT] = {
    5, 5, 5, 5,
    0, 0
};

// 0x4432C0
dllexport gnu_noinline GameThread::~GameThread() {
    SCOREFILE_MANAGER_PTR->save_files();
    GAME_MANAGER.__unknown_flag_A = false;
    GAME_MANAGER.__unknown_flag_B = false;
    GAME_SPEED.set(1.0f);
    UNKNOWN_FUNC_PTR_A = NULL;
    UNKNOWN_FUNC_PTR_B = NULL;
    
    switch (SUPERVISOR.gamemode_switch) {
        case 12:
            ASCII_MANAGER_PTR->__instantiate_vm_id_19268(480.0f, 392.0f);
            GAME_MANAGER.__unknown_flag_B = true;
            break;
        case 4: case 16:
            ASCII_MANAGER_PTR->__instantiate_vm_id_19268(480.0f, 392.0f);
            ABILITY_MANAGER_PTR->__cleanup_all_anms();
            break;
        case 14:
            ASCII_MANAGER_PTR->__instantiate_vm_id_19268(480.0f, 392.0f);
            if (GAME_MANAGER.globals.__stage_number_related_4 == GAME_MANAGER.globals.current_stage) {
                GAME_MANAGER.globals.add_continue();
                GAME_MANAGER.__unknown_flag_D = true;
            }
            else {
                GAME_MANAGER.__unknown_flag_A = true;
            }
            break;
        case 2:
            ABILITY_MANAGER_PTR->__cleanup_all_anms();
            break;
        case 10: case 11:
            ABILITY_MANAGER_PTR->__sub_4080E0();
            ASCII_MANAGER_PTR->__instantiate_vm_id_19268(480.0f, 392.0f);
            if (GAME_MANAGER.globals.__stage_number_related_4 == GAME_MANAGER.globals.current_stage) {
                GAME_MANAGER.__unknown_flag_A = true;
            }
            break;
    }

    if (!GAME_MANAGER.__unknown_flag_B) {
        switch (SUPERVISOR.gamemode_switch) {
            default:
                delete REPLAY_MANAGER_PTR;
            case 15: case 16:;
        }
        delete STAGE_PTR;
        delete STAGE_B_PTR;
        delete PAUSE_MENU_PTR;
        delete GUI_PTR;
        delete PLAYER_PTR;
        delete BULLET_MANAGER_PTR;
        delete ITEM_MANAGER_PTR;
        delete LASER_MANAGER_PTR;
        delete POPUP_MANAGER_PTR;
    }
    else {
        Gui* gui = GUI_PTR;
        SAFE_DELETE(gui->msg_vm);
        if (
            !GAME_MANAGER.__unknown_flag_A &&
            !GAME_MANAGER.__unknown_flag_D
        ) {
            ANM_MANAGER_PTR->unload_anm(6);
            gui->stage_logo_anm = NULL;
            SAFE_FREE(gui->msg_file);
        }
        delete STAGE_B_PTR;
        STAGE_B_PTR = STAGE_PTR;
        PAUSE_MENU_PTR->disable_funcs();
        BULLET_MANAGER_PTR->disable_funcs();
        REPLAY_MANAGER_PTR->disable_funcs();
        ITEM_MANAGER_PTR->destroy_all();
    }

    EnemyManager* enemy_manager = ENEMY_MANAGER_PTR;
    if (
        !GAME_MANAGER.__unknown_flag_A &&
        !GAME_MANAGER.__unknown_flag_D
    ) {
        delete enemy_manager;
    }
    else {
        enemy_manager->destroy_all();
    }

    AnmManager* anm_manager = ANM_MANAGER_PTR;
    anm_manager->mark_all_vms_from_loaded_slot_for_delete(8);
    anm_manager->mark_all_vms_from_loaded_slot_for_delete(7);

    SAFE_DELETE(BOMB_PTR);
    delete SPELLCARD_PTR;

    UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_tick_func);
    UPDATE_FUNC_REGISTRY_PTR->delete_func_locked(this->on_draw_func);

    GAME_THREAD_PTR = NULL;

    if (AbilityShop* ability_shop = ABILITY_SHOP_PTR) {
        ability_shop->cleanup();
    }

    if (
        (GAME_MANAGER.__unknown_field_A != 2 || !GAME_MANAGER.__unknown_flag_A) &&
        !GAME_MANAGER.__unknown_flag_B &&
        !GAME_MANAGER.__unknown_flag_E
    ) {
        // TODO something in sound manager
    }

    SOUND_MANAGER.__stop_all();

    UNKNOWN_INT_H = 1;

    SUPERVISOR.background_color = GAME_MANAGER.__unknown_flag_A ? PackD3DCOLOR(0, 0, 0, 0) : PackD3DCOLOR(255, 0, 0, 0);
}

inline unsigned GameThread::thread_start_impl() {
    GameThread* game_thread = GAME_THREAD_PTR;
    
    this->skip_flag = true;

    __asm FINIT

    while (ANM_MANAGER_PTR->__int_20 >= 0) {
        if (SUPERVISOR.__unknown_bitfield_A) {
            goto thread_start_important_label;
        }
        Sleep(1);
    }

    if (!SUPERVISOR.__int_804) {
        Sleep(60);
    }

    SUPERVISOR.__arcade_vm_ptr_A->interrupt_and_run(2);

    GAME_SPEED.value = 1.0f;
    GAME_THREAD_PTR->__unknown_flag_E = false;
    GAME_MANAGER.globals.__counter_C = 0;
    GAME_MANAGER.globals.__counter_10 = 0;
    GAME_MANAGER.globals.__counter_14 = 0;

    ABILITY_MANAGER_PTR->wait_for_ability_data_to_load();

    if (GAME_THREAD_PTR->replay_mode == __replay_recording) {
        SCOREFILE_MANAGER_PTR->primary_file.shottypes[GAME_MANAGER.globals.shottype_index()]
            .practice[GAME_MANAGER.globals.difficulty][GAME_MANAGER.globals.current_stage]
                .unlocked = true;
    }

    if (SUPERVISOR.__int_804) {
        int32_t difficulty = GAME_MANAGER.globals.difficulty;
        if (GAME_MANAGER.globals.current_stage == 7) {
            difficulty = __max(difficulty, LUNATIC);
            GAME_MANAGER.globals.difficulty = difficulty;
        }

        switch (GAME_MANAGER.__unknown_field_A) {
            case 2: {
                ScorefileSpellcard& spell = SCOREFILE_MANAGER_PTR->primary_file.shottypes[GAME_MANAGER.globals.shottype_index()]
                                                .spells[GAME_MANAGER.globals.__ecl_var_9907];
                GAME_MANAGER.__high_score = spell.spell_practice_score;
                GAME_MANAGER.__high_score_continues = 0;
                break;
            }
            case 1: {
                ScorefileStagePractice& practice = SCOREFILE_MANAGER_PTR->primary_file.shottypes[GAME_MANAGER.globals.shottype_index()]
                                                       .practice[GAME_MANAGER.globals.difficulty][GAME_MANAGER.globals.current_stage];
                GAME_MANAGER.__high_score = practice.score;
                GAME_MANAGER.__high_score_continues = 0;
                break;
            }
            default: {
                ScorefileRecord& record = SCOREFILE_MANAGER_PTR->primary_file.shottypes[GAME_MANAGER.globals.shottype_index()]
                                              .records[GAME_MANAGER.globals.difficulty][0];
                GAME_MANAGER.__high_score = record.score;
                GAME_MANAGER.__high_score_continues = record.continues;
                break;
            }
        }

        GAME_MANAGER.globals.graze_in_stage = 0;

        int32_t continues = GAME_MANAGER.globals.continues;
        continues = !GAME_MANAGER.__unknown_flag_D ? 0 : GAME_MANAGER.globals.continues;
        GAME_MANAGER.globals.continues = continues;

        GAME_MANAGER.globals.score = 0;

        int32_t starting_bombs = __min(GAME_MANAGER.globals.bomb_stock_max, 3);

        GAME_MANAGER.globals.money_collected_in_game = 0;
        GAME_MANAGER.globals.current_money = 0;
        GAME_MANAGER.globals.point_items_collected_in_game = 0;
        GAME_MANAGER.globals.current_power = 0;
        GAME_MANAGER.globals.power_per_level = 1;
        GAME_MANAGER.globals.bomb_stocks_for_new_life = 3;
        GAME_MANAGER.globals.bomb_stocks = starting_bombs;

        // inlined version of standalone __update_bomb_ui
        Gui* gui = GUI_PTR;
        if (gui) {
            gui->__update_bomb_ui(starting_bombs, GAME_MANAGER.globals.bomb_fragments, GAME_MANAGER.globals.bomb_stock_max);
        }

        GAME_MANAGER.globals.bomb_fragments = 0;
        GAME_MANAGER.globals.life_fragments = 0;
        GAME_MANAGER.globals.lives_added = 0;
        GAME_MANAGER.globals.miss_count_in_game = 0;
        GAME_MANAGER.globals.__dword_94 = 0;

        GAME_MANAGER.globals.__timer_C4.reset();
        GAME_MANAGER.globals.__timer_D8.reset();

        int32_t min_item_value = MIN_POINT_ITEM_VALUES_TABLE[difficulty] * 100;
        int32_t max_item_value = MAX_POINT_ITEM_VALUES_TABLE[difficulty] * 100;

        GAME_MANAGER.globals.min_point_item_value = min_item_value;
        GAME_MANAGER.globals.__dword_EC = 0;
        GAME_MANAGER.globals.__dword_F0 = 0;
        GAME_MANAGER.globals.__dword_F4 = 0;
        GAME_MANAGER.globals.max_point_item_value = max_item_value;

        // why are you like this ZUN
        int32_t item_value = min_item_value / 100.0f * 100.0f;

        if (item_value < max_item_value) {
            item_value = __min(item_value, GAME_MANAGER.globals.min_point_item_value);
        } else {
            item_value = max_item_value;
        }
        GAME_MANAGER.globals.point_item_value = item_value;

        GAME_MANAGER.continue_credits = CONTINUE_CREDITS_TABLE[difficulty];
        GAME_MANAGER.globals.life_stock_max = 7;

        switch (GAME_MANAGER.__unknown_field_A) {
            case 2:
                GAME_MANAGER.globals.bomb_stock_max = 7;
                GAME_MANAGER.globals.life_stocks = 0;
                GAME_MANAGER.globals.bomb_stocks = 0;
                if (gui) {
                    gui->__update_bomb_ui(0, 0, 7);
                }
                break;
            case 0:
                GAME_MANAGER.globals.bomb_stock_max = 7;
                GAME_MANAGER.globals.life_stocks = 2;
                GAME_MANAGER.globals.bomb_stocks = 3;
                if (gui) {
                    gui->__update_bomb_ui(3, 0, 7);
                }
                break;
            default: {
                int32_t life_override = GAME_MANAGER.__int_C;
                if (!life_override) {
                    GAME_MANAGER.globals.bomb_stock_max = 7;
                    GAME_MANAGER.globals.life_stocks = 7;
                } else {
                    GAME_MANAGER.globals.life_stocks = life_override - 1;
                }
            }
        }

        if (!Player::allocate()) {
            goto thread_start_important_label;
        }

        if (GAME_MANAGER.__unknown_field_A == 2) {
            clang_forceinline GAME_MANAGER.globals.set_power(GAME_MANAGER.globals.power_per_level * DEFAULT_MAX_POWER_LEVEL);
        }
        else {
            int32_t power;
            int32_t stage = GAME_MANAGER.globals.current_stage;
            if (stage <= 1) {
                power = GAME_MANAGER.globals.power_per_level;
            }
            else if (stage == 7) {
                power = GAME_MANAGER.globals.power_per_level;
            }
            else {
                power = GAME_MANAGER.globals.power_per_level * DEFAULT_MAX_POWER_LEVEL;
            }
            GAME_MANAGER.globals.set_power(power);
        }

        GAME_MANAGER.__unknown_flag_C = false;

        if (
            game_thread->replay_mode == __replay_recording &&
            ACHIEVEMENT_MODE_STATE < 0
        ) {
            SCOREFILE_MANAGER_PTR->primary_file.shottypes[GAME_MANAGER.globals.shottype_index()].__add_play_count();
        }

        if (
            GAME_MANAGER.globals.current_stage == 7 &&
            !ABILITY_MANAGER_PTR->card_equipped(MAGATAMA2_CARD)
        ) {
            ABILITY_MANAGER_PTR->allocate_new_card(MAGATAMA2_CARD, 0);
            //ABILITY_MANAGER_PTR->__sub_4094C0();
        }
        UNKNOWN_COUNTER_A = 0;
    }
    else {
        GAME_MANAGER.__high_score = __max(GAME_MANAGER.globals.score, GAME_MANAGER.__high_score);
    }

    UpdateFunc* update_func = new UpdateFunc(&on_tick, false, this);
    UpdateFuncRegistry::register_on_tick(update_func, 16);
    this->on_tick_func = update_func;
    update_func = new UpdateFunc(&on_draw, false, this);
    UpdateFuncRegistry::register_on_draw(update_func, 2);
    this->on_draw_func = update_func;

    this->config = SUPERVISOR.config;

    this->stage_number = STAGE_DATA_PTR->stage_number;

    if (!GAME_MANAGER.__unknown_flag_B) {
        if (!ReplayManager::allocate(UNKNOWN_TEXT_BUFFER_A)) {
            goto thread_start_important_label;
        }
        REPLAY_MANAGER_PTR->__sub_462D20();

        if (
            !Stage::allocate(STAGE_DATA_PTR->std_filename) ||
            !Gui::allocate() ||
            !BulletManager::allocate() ||
            !ItemManager::allocate() ||
            !LaserManager::allocate() ||
            !PopupManager::allocate()
        ) {
            goto thread_start_important_label;
        }
    }
    else {
        REPLAY_MANAGER_PTR->__inline_sub_A();
        REPLAY_MANAGER_PTR->__sub_462D20();
        GUI_PTR->__initialize();
        if (!Stage::allocate(STAGE_DATA_PTR->std_filename)) {
            goto thread_start_important_label;
        }
    }

    AbilityManager* ability_manager = ABILITY_MANAGER_PTR;
    ability_manager->__float_C58 = 1.0f;
    ability_manager->card_list.for_each([](CardBase* card) {
        card->__on_load_2();
    });
    ABILITY_MANAGER_PTR->card_list.for_each_safeB([](CardBase* card) {
        card->initializeA();
    });

    if (
        !GAME_MANAGER.__unknown_flag_A &&
        !GAME_MANAGER.__unknown_flag_D
    ) {
        if (!EnemyManager::allocate(STAGE_DATA_PTR->ecl_filename)) {
            goto thread_start_important_label;
        }
    }
    else {
        ENEMY_MANAGER_PTR->reset();
    }

    if (
        !BombBase::allocate() ||
        !Spellcard::allocate()
    ) {
        goto thread_start_important_label;
    }

    SCOREFILE_MANAGER_PTR->save_files();

    if (GAME_MANAGER.__unknown_field_A == 2) {
        //SOUND_MANAGER.__sub_4546F0();
    }

    //SOUND_MANAGER.__sub_454620(0, STAGE_DATA_PTR->__string_array_C[0]);
    //SOUND_MANAGER.__sub_454620(1, STAGE_DATA_PTR->__string_array_C[1]);

    FPS_COUNTER_PTR->reset();

    clang_noinline this->__timer_C.set(0);

    while (SOUND_MANAGER.__unknown_smd_array_2484[0].__dword_0) {
        Sleep(16);
    }

    EffectManager* effect_manager = EFFECT_MANAGER_PTR;
    while (!effect_manager->__done_loading) {
        Sleep(1);
    }

    PLAYER_PTR->data.__update_option_power_levels();

    this->__int_B8 = 60;

    if (SUPERVISOR.__int_AD0 == 1) {
        UNKNOWN_ANM_ID_A.interrupt_tree(2);
        UNKNOWN_ANM_ID_B.interrupt_tree(2);
        UNKNOWN_ANM_ID_C.interrupt_tree(2);
        UNKNOWN_ANM_ID_A = 0;
        UNKNOWN_ANM_ID_B = 0;
        UNKNOWN_ANM_ID_C = 0;
        SUPERVISOR.__int_AD0 = 0;
    }

    this->__unknown_flag_H = false;

    SUPERVISOR.__thread_A94.__bool_10 = false;
    SUPERVISOR.__thread_A94.__bool_C = true;

    UNKNOWN_INT_H = 0;
    UNKNOWN_FUNC_PTR_A = NULL;
    UNKNOWN_FUNC_PTR_B = NULL;

    SUPERVISOR.__arcade_vm_ptr_A->interrupt(2);
    SUPERVISOR.__arcade_vm_ptr_B->interrupt(2);
    SUPERVISOR.__arcade_vm_ptr_C->interrupt(2);
    SUPERVISOR.__arcade_vm_ptr_D->interrupt(2);

    if (GAME_THREAD_PTR->replay_mode == __replay_recording) {
        GAME_MANAGER.game_time_double = get_runtime();
    }

    this->enable_funcs();

    return ZUN_SUCCESS;

thread_start_important_label:

    this->__unknown_flag_H = true;

    if (SUPERVISOR.__int_AD0 == 1) {
        UNKNOWN_ANM_ID_A.interrupt_tree(2);
        UNKNOWN_ANM_ID_B.interrupt_tree(2);
        UNKNOWN_ANM_ID_C.interrupt_tree(2);
        UNKNOWN_ANM_ID_A = 0;
        UNKNOWN_ANM_ID_B = 0;
        UNKNOWN_ANM_ID_C = 0;
        SUPERVISOR.__int_AD0 = 2;
    }

    SUPERVISOR.__thread_A94.__bool_10 = false;
    SUPERVISOR.__thread_A94.__bool_C = true;

    this->enable_funcs();

    return ZUN_ERROR;
}

inline void WindowData::__restore_properties() {
    SystemParametersInfoA(SPI_GETSCREENSAVEACTIVE, 0, &this->screen_saver_active, SPIF_SENDCHANGE);
    SystemParametersInfoA(SPI_GETLOWPOWERACTIVE, 0, &this->screen_saver_low_power_active, SPIF_SENDCHANGE);
    SystemParametersInfoA(SPI_GETPOWEROFFACTIVE, 0, &this->screen_saver_power_off_active, SPIF_SENDCHANGE);
}

// 0x4726A0
dllexport gnu_noinline ZUNResult WindowData::__save_properties_and_configure_paths() {
    SystemParametersInfoA(SPI_GETSCREENSAVEACTIVE, 0, &WINDOW_DATA.screen_saver_active, 0);
    SystemParametersInfoA(SPI_GETLOWPOWERACTIVE, 0, &WINDOW_DATA.screen_saver_low_power_active, 0);
    SystemParametersInfoA(SPI_GETPOWEROFFACTIVE, 0, &WINDOW_DATA.screen_saver_power_off_active, 0);
    SystemParametersInfoA(SPI_SETSCREENSAVEACTIVE, FALSE, NULL, SPIF_SENDCHANGE);
    SystemParametersInfoA(SPI_SETLOWPOWERACTIVE, 0, NULL, SPIF_SENDCHANGE);
    SystemParametersInfoA(SPI_SETPOWEROFFACTIVE, 0, NULL, SPIF_SENDCHANGE);
    QueryPerformanceFrequency(&WINDOW_DATA.performance_counter_frequency);
    QueryPerformanceCounter(&WINDOW_DATA.startup_qpc_value);
    char* appdata_path = this->appdata_path;
    GetEnvironmentVariableA("APPDATA", appdata_path, sizeof(this->appdata_path));
    if (appdata_path[0] != '\0') {
        byteloop_strcat(appdata_path, "\\ShanghaiAlice");
        if (chdir(appdata_path)) {
            if (!mkdir(appdata_path)) return ZUN_ERROR;
            if (!chdir(appdata_path)) return ZUN_ERROR;
        }
        byteloop_strcat(appdata_path, "\\th18");
        if (chdir(appdata_path)) {
            if (!mkdir(appdata_path)) return ZUN_ERROR;
            if (!chdir(appdata_path)) return ZUN_ERROR;
        }
        byteloop_strcat(appdata_path, "\\");
        if (chdir("replay")) {
            if (!mkdir("replay")) return ZUN_ERROR;
        }
        if (chdir("snapshot")) {
            if (!mkdir("snapshot")) return ZUN_ERROR;
        }
        DebugLogger::__debug_log_stub_11("%d\n", appdata_path);
    }
    char* exe_path = this->exe_path;
    if (GetModuleFileNameA(NULL, exe_path, sizeof(this->exe_path)) != ERROR_SUCCESS) {
        if (char* final_slash = strrchr(exe_path, '\\')) {
            *final_slash = '\0';
        }
        DebugLogger::__debug_log_stub_11("%d\n", exe_path);
    }
    if (chdir(exe_path)) return ZUN_ERROR;
    return ZUN_SUCCESS;
}

template<typename L>
inline int32_t WindowData::update_window_common(const L& lambda) {
    ANM_MANAGER_PTR->flush_sprites();
    SUPERVISOR.set_camera_by_index(2);

    switch (UPDATE_FUNC_REGISTRY_PTR->run_all_on_tick()) {
        case 0:
            SUPERVISOR.__thread_A94.stop_and_cleanup();
            return 1;
        case -1:
            SUPERVISOR.__thread_A94.stop_and_cleanup();
            return 2;
    }

    ++this->__sbyte_1C;
    if (SUPERVISOR.config.__ubyte_48 < this->__sbyte_1C) {
        SUPERVISOR.d3d_device->BeginScene();
        ANM_MANAGER_PTR->reset_vertex_buffers();
        SUPERVISOR.fog_enabled = 0xFF;
        ANM_MANAGER_PTR->flush_sprites();
        SUPERVISOR.fog_enabled = FALSE;
        SUPERVISOR.d3d_device->SetRenderState(D3DRS_FOGENABLE, FALSE);
        UPDATE_FUNC_REGISTRY_PTR->run_all_on_draw();
        ANM_MANAGER_PTR->flush_sprites();
        SUPERVISOR.d3d_device->SetTexture(0, NULL);
        SUPERVISOR.d3d_device->EndScene();
        this->__sbyte_1C = 0;

        lambda();
    }
    SUPERVISOR.__double_B50 = get_runtime() - this->__double_2098;
    return 0;
}

// 0x4740D0
dllexport gnu_noinline void __set_default_d3d_states() asm_symbol_rel(0x4740D0);
dllexport gnu_noinline void __set_default_d3d_states() {
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_LIGHTING, FALSE);
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_SEPARATEALPHABLENDENABLE, TRUE);
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_ZFUNC, D3DCMP_ALWAYS);
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_SRCBLENDALPHA, D3DBLEND_ONE);
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_DESTBLENDALPHA, D3DBLEND_ZERO);
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_BLENDOPALPHA, D3DBLENDOP_ADD);
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_ALPHAREF, 0x01);
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATEREQUAL);
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_FOGENABLE, TRUE);
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_FOGDENSITY, bitcast<DWORD>(1.0f));
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_FOGTABLEMODE, D3DFOG_NONE);
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_FOGVERTEXMODE, D3DFOG_LINEAR);
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_FOGCOLOR, PackD3DCOLOR(255, 160, 160, 160));
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_FOGSTART, bitcast<DWORD>(1000.0f));
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_FOGEND, bitcast<DWORD>(5000.0f));
    SUPERVISOR.d3d_device->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);
    SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
    SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TFACTOR);
    SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
    SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_TFACTOR);
    SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2);
    SUPERVISOR.d3d_device->SetTextureStageState(0, D3DTSS_TEXCOORDINDEX, 0 | D3DTSS_TCI_PASSTHRU);
    SUPERVISOR.d3d_device->SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_NONE);
    SUPERVISOR.d3d_device->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
    SUPERVISOR.d3d_device->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
    SUPERVISOR.d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSW, D3DTADDRESS_CLAMP);
    SUPERVISOR.d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);
    SUPERVISOR.d3d_device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);
    if (AnmManager* anm_manager = ANM_MANAGER_PTR) {
        anm_manager->current_blend_mode = (AnmBlendMode)11;
        anm_manager->__byte_3120E09 = -1;
        anm_manager->__sbyte_3120E0A = -1;
        anm_manager->__index_3120E04 = -1;
        anm_manager->__byte_3120E0C = -1;
    }
}

// 0x472DD0
dllexport gnu_noinline int32_t thiscall WindowData::update_window__normal_version() {
    double A = get_runtime();
    double B = this->__double_20A0;
    this->__double_2098 = A;
    if (A < B) {
        this->__double_20A8 = A;
        B = A;
    } else {
        B = this->__double_20A8;
    }
    this->__double_20A0 = B;
    A -= B;
    A *= 1000.0;
    if (A >= 1.5) {
        Sleep(1);
    }

    if (this->__double_2098 > this->__double_20A8) {
        A = this->__double_2098;
        do {
            B = this->__double_20A8;
            B += 1.0 / 60.0;
            this->__double_20A8 = B;
        } while (A > B);

        return this->update_window_common([=]() {
            this->__sub_4731B0();
            if (FAILED(SUPERVISOR.d3d_device->Present(NULL, NULL, NULL, NULL))) {
                SUPERVISOR.__release_rendering_surfaces();
                ANM_MANAGER_PTR->__release_render_targets();
                SUPERVISOR.d3d_device->Reset(&SUPERVISOR.present_parameters);
                ANM_MANAGER_PTR->__create_render_targets();
                SUPERVISOR.__sub_455EC0();
                __set_default_d3d_states();
                SUPERVISOR.__int_818 = 2;
                // FPS_COUNTER_PTR->__sub_4728A0();
            }
        });
    }
    return 0;
}

// 0x472FD0
dllexport gnu_noinline int32_t thiscall WindowData::update_window__alt_version() {
    return this->update_window_common([=]() {

        double A = get_runtime();
        this->__double_2098 = A;

        if (SUPERVISOR.config.__byte_4D == 1) {
            double B = A;
            double C = this->__double_20B8;
            B -= C;
            if (
                B < 1.0 / 60.0 &&
                B > 0.0
            ) {
                C += 1.0 / 60.0;
                C -= A;
                C *= 1000.0;
                C -= 3.5;
                int32_t D = C;
                if (D > 0) {
                    Sleep(D);
                }
            }

            this->__double_20C0 = get_runtime();

            this->__sub_4731B0();
            if (FAILED(SUPERVISOR.d3d_device->Present(NULL, NULL, NULL, NULL))) {
                SUPERVISOR.__release_rendering_surfaces();
                ANM_MANAGER_PTR->__release_render_targets();
                SUPERVISOR.d3d_device->Reset(&SUPERVISOR.present_parameters);
                ANM_MANAGER_PTR->__create_render_targets();
                SUPERVISOR.__sub_455EC0();
                __set_default_d3d_states();
                SUPERVISOR.__int_818 = 2;
                this->__double_20B8 = get_runtime();
                // FPS_COUNTER_PTR->__sub_4728A0();
            }
        }
    });
}

inline int32_t thiscall WindowData::update_window__alt_version2() {
    double A = this->__double_2098;
    double B = this->__double_20A8;
    while (B < A) {
        B += 1.0 / 60.0;
    }
    this->__double_20A8 = B;

    return this->update_window_common([=]() {
        this->__sub_472B50();
    });
}

// 0x472B50
dllexport gnu_noinline void thiscall WindowData::__sub_472B50() {

}

// 0x4731B0
dllexport gnu_noinline void thiscall WindowData::__sub_4731B0() {

}

static inline void show_cursor() {
    while (ShowCursor(true) < 0);
}
static inline void hide_cursor() {
    while (ShowCursor(false) >= 0);
}

// 0x472280
dllexport gnu_noinline LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
        case WM_ACTIVATEAPP: // 0x1C
            if ((WINDOW_DATA.window_active = wParam)) {
                WINDOW_DATA.__dword_14 = 0;
                SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);
                return DefWindowProcA(hWnd, uMsg, wParam, lParam);
            }
            else {
                WINDOW_DATA.__dword_14 = 1;
                SetWindowPos(hWnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);
                return DefWindowProcA(hWnd, uMsg, wParam, lParam);
            }
            break;
        case WM_SIZE: // 0x5
            if (WINDOW_DATA.__unknown_flag_A && wParam == SIZE_MAXIMIZED) {
                WINDOW_DATA.__unknown_flag_B = true;
                switch (WINDOW_DATA.__unknown_bitfield_A) {
                    case 3:
                        WINDOW_DATA.__unknown_bitfield_A = 0;
                        return DefWindowProcA(hWnd, uMsg, wParam, lParam);
                    case 4:
                        WINDOW_DATA.__unknown_bitfield_A = 1;
                        return DefWindowProcA(hWnd, uMsg, wParam, lParam);
                    case 5: case 6:
                        WINDOW_DATA.__unknown_bitfield_A = 2;
                        return DefWindowProcA(hWnd, uMsg, wParam, lParam);
                }
            }
            break;
        case WM_CLOSE: // 0x10
            SUPERVISOR.__unknown_bitfield_A = 1;
            return TRUE; // Documentation says to return 0?
        case WM_SETCURSOR: // 0x20
            if (!SUPERVISOR.present_parameters.Windowed) {
                if (WINDOW_DATA.__dword_14) {
                    SetCursor(LoadCursorA(NULL, IDC_ARROW));
                    show_cursor();
                    return TRUE;
                }
                else {
                    hide_cursor();
                    SetCursor(NULL);
                    return TRUE;
                }
            }
            else {
                SetCursor(LoadCursorA(NULL, IDC_ARROW));
                ShowCursor(true);
                return TRUE;
            }
            break;
        case WM_SYSCOMMAND: // 0x112
            switch (wParam) {
                case SC_MOUSEMENU: // 0xF090
                case SC_KEYMENU: // 0xF100
                    return TRUE;
            }
            break;
        case WM_SYSKEYDOWN: // 0x104
            if (wParam == VK_RETURN) {
                WINDOW_DATA.__unknown_flag_B = true;
                switch (WINDOW_DATA.__unknown_bitfield_A) {
                    case 3:
                        WINDOW_DATA.__unknown_bitfield_A = 0;
                        return DefWindowProcA(hWnd, uMsg, wParam, lParam);
                    case 4:
                        WINDOW_DATA.__unknown_bitfield_A = 1;
                        return DefWindowProcA(hWnd, uMsg, wParam, lParam);
                    case 5: case 6: case 7:
                        WINDOW_DATA.__unknown_bitfield_A = 2;
                        return DefWindowProcA(hWnd, uMsg, wParam, lParam);
                    case 2:
                        switch (SUPERVISOR.config.__ubyte_4E) {
                            case 4:
                                WINDOW_DATA.__unknown_bitfield_A = 7;
                                return DefWindowProcA(hWnd, uMsg, wParam, lParam);
                            case 3:
                                WINDOW_DATA.__unknown_bitfield_A = 6;
                                return DefWindowProcA(hWnd, uMsg, wParam, lParam);
                            default:
                                WINDOW_DATA.__unknown_bitfield_A = 5;
                                return DefWindowProcA(hWnd, uMsg, wParam, lParam);
                        }
                    case 8: case 9:
                        switch (SUPERVISOR.config.__ubyte_4E) {
                            case 4:
                                WINDOW_DATA.__unknown_bitfield_A = 7;
                                return DefWindowProcA(hWnd, uMsg, wParam, lParam);
                            case 3:
                                WINDOW_DATA.__unknown_bitfield_A = 6;
                                return DefWindowProcA(hWnd, uMsg, wParam, lParam);
                            case 2: case 5:
                                WINDOW_DATA.__unknown_bitfield_A = 5;
                                return DefWindowProcA(hWnd, uMsg, wParam, lParam);
                            case 0:
                                WINDOW_DATA.__unknown_bitfield_A = 3;
                                return DefWindowProcA(hWnd, uMsg, wParam, lParam);
                            case 1:
                                WINDOW_DATA.__unknown_bitfield_A = 4;
                                return DefWindowProcA(hWnd, uMsg, wParam, lParam);
                        }
                        break;
                    case 0:
                        WINDOW_DATA.__unknown_bitfield_A = 3;
                        return DefWindowProcA(hWnd, uMsg, wParam, lParam);
                    case 1:
                        WINDOW_DATA.__unknown_bitfield_A = 4;
                        return DefWindowProcA(hWnd, uMsg, wParam, lParam);
                }
            }
            break;
        case WM_DISPLAYCHANGE: // 0x7E
            if (!SUPERVISOR.present_parameters.Windowed) {
                Sleep(3000);
            }
            WINDOW_DATA.__dword_18 = 300;
            break;
    }
    return DefWindowProcA(hWnd, uMsg, wParam, lParam);
}

// 0x4734E0
dllexport gnu_noinline void WindowData::__sub_4734E0(int arg1) {
    float floatA;
    int32_t height;
    int32_t width;
    switch (int32_t intA = WINDOW_DATA.__unknown_bitfield_A) {
        case 7:
            WINDOW_DATA.__game_scale = floatA = 2.0f;
            WINDOW_DATA.window_width = 2560;
            WINDOW_DATA.window_height = 1920;
            break;
        case 6:
            WINDOW_DATA.__game_scale = floatA = 2.0f;
            WINDOW_DATA.window_width = 1920;
            WINDOW_DATA.window_height = 1440;
            break;
        default:
            WINDOW_DATA.__game_scale = floatA = 1.0f;
            WINDOW_DATA.window_width = 640;
            WINDOW_DATA.window_height = 480;
            break;
        case 1: case 4:
            WINDOW_DATA.__game_scale = floatA = 1.5f;
            WINDOW_DATA.window_width = 960;
            WINDOW_DATA.window_height = 720;
            break;
        case 2: case 5:
            WINDOW_DATA.__game_scale = floatA = 2.0f;
            WINDOW_DATA.window_width = 1280;
            WINDOW_DATA.window_height = 960;
            break;
        case 8: case 9:
            if (arg1) {
                height = WINDOW_DATA.__display_height;
                width = WINDOW_DATA.__display_width;
                WINDOW_DATA.window_width = width;
                WINDOW_DATA.window_height = height;
                if (width >= 2560 && height >= 1920) {
                    WINDOW_DATA.__game_scale = floatA = 2.0f;
                    SUPERVISOR.config.__ubyte_4E = 4;
                }
                else if (width >= 1920 && height >= 1440) {
                    WINDOW_DATA.__game_scale = floatA = 2.0f;
                    SUPERVISOR.config.__ubyte_4E = 3;
                }
                else if (width >= 1280 && height >= 960) {
                    WINDOW_DATA.__game_scale = floatA = 2.0f;
                    SUPERVISOR.config.__ubyte_4E = 2;
                }
                else if (width >= 960 && height >= 720) {
                    WINDOW_DATA.__game_scale = floatA = 1.5f;
                    SUPERVISOR.config.__ubyte_4E = 1;
                }
                else {
                    floatA = 1.0f;
                    SUPERVISOR.config.__ubyte_4E = 0;
                    WINDOW_DATA.__game_scale = floatA;
                }
            } else {
                floatA = WINDOW_DATA.__game_scale;
            }
            // Screw this crap
    }
    height = floatA * LOGICAL_WINDOW_HEIGHT;
    width = floatA * LOGICAL_WINDOW_WIDTH;
    WINDOW_DATA.__scaled_height = height;
    WINDOW_DATA.__scaled_width = width;
    this->__int_2074 = (int32_t)(width - SCREEN_WIDTH) / 2;
    this->__int_2078 = (int32_t)(WINDOW_DATA.__scaled_height - SCREEN_HEIGHT) / 2;
}

// 0x473890
dllexport gnu_noinline BOOL WindowData::__create_window(HINSTANCE instance) {
    WNDCLASSA class_def;
    LCID user_locale = GetUserDefaultLCID();
    class_def.style = 0;
    class_def.hIcon = NULL;
    class_def.lpszMenuName = NULL;
    class_def.cbClsExtra = 0;
    class_def.cbWndExtra = 0;
    const char* window_title = user_locale == 0x411
        ? "@` Unconnected Marketeers ver 1.00a"
        : "TH18 - Unconnected Marketeers ver 1.00a";
    class_def.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
    class_def.hCursor = LoadCursorA(NULL, IDC_ARROW);
    class_def.hInstance = instance;
    class_def.lpfnWndProc = &WndProc;
    this->window_active = true;
    this->__dword_14 = 0;
    class_def.lpszClassName = "BASE";
    RegisterClassA(&class_def);
    this->__unknown_bitfield_A = SUPERVISOR.config.__ubyte_47;
    SUPERVISOR.present_parameters.Windowed = this->__unknown_bitfield_A >= 3;
    if (SUPERVISOR.config.__ubyte_48 && SUPERVISOR.config.__byte_4D == 2) {
        this->__unknown_flag_C = true;
    } else {
        this->__unknown_flag_C = false;
    }
    this->__dword_array_20D4[0] = 15;
    this->__dword_array_20D4[1] = 15;
    this->__dword_array_20D4[2] = 0;
    this->__dword_array_20D4[3] = 12;
    this->__dword_array_20D4[4] = 12;
    this->__dword_array_20D4[5] = 0;
    this->__dword_array_20D4[6] = 12;
    this->__dword_array_20D4[7] = 12;
    this->__dword_array_20D4[8] = 0;
    this->__dword_array_20D4[9] = 8;
    this->__dword_array_20D4[10] = 8;
    this->__dword_array_20D4[11] = 0;
    this->__int_20D0 = 0;
    this->__sub_4734E0(true);
    if (!SUPERVISOR.present_parameters.Windowed) {
        this->window = CreateWindowExA(
            0,
            "BASE",
            window_title,
            WS_VISIBLE | WS_POPUP,
            0,
            0,
            this->window_width,
            this->window_height,
            NULL,
            NULL,
            instance,
            NULL
        );
    }
    else if (WINDOW_DATA.__unknown_bitfield_A != 8 && WINDOW_DATA.__unknown_bitfield_A != 9) {
        RECT rect;
        rect.right = this->window_width;
        rect.bottom = this->window_height;
        rect.left = 0;
        rect.top = 0;
        AdjustWindowRectEx(
            &rect,
            WS_OVERLAPPED | WS_MAXIMIZEBOX | WS_MINIMIZEBOX | WS_SYSMENU | WS_CAPTION | WS_VISIBLE,
            FALSE,
            0
        );
        this->window = CreateWindowExA(
            0,
            "BASE",
            window_title,
            WS_OVERLAPPED | WS_MAXIMIZEBOX | WS_MINIMIZEBOX | WS_SYSMENU | WS_CAPTION | WS_VISIBLE,
            SUPERVISOR.config.window_x,
            SUPERVISOR.config.window_y,
            rect.right - rect.left,
            rect.bottom - rect.top,
            NULL,
            NULL,
            instance,
            NULL
        );
    }
    else {
        HWND window_handle = CreateWindowExA(
            WS_EX_APPWINDOW,
            "BASE",
            window_title,
            WS_OVERLAPPED | WS_VISIBLE,
            0,
            0,
            this->window_width,
            this->window_height,
            NULL,
            NULL,
            instance,
            NULL
        );
        this->window = window_handle;
        SetWindowLongA(
            window_handle,
            GWL_STYLE,
            WS_OVERLAPPED
        );
        ShowWindow(
            this->window,
            SW_SHOW
        );
    }
    GetWindowRect(
        this->window,
        &SUPERVISOR.window_rect
    );
    SUPERVISOR.main_window_handle = this->window;
    return this->window == NULL;
}

struct MutexData {
    HANDLE handle; // 0x0
};
extern "C" {
    // 0x570C98
    externcg MutexData MUTEX_DATA cgasm("_MUTEX_DATA");
}

#include <ShObjIdl.h>

// 0x474400
dllexport gnu_noinline ZUNResult __make_mutex_and_test_path() asm_symbol_rel(0x474400);
dllexport gnu_noinline ZUNResult __make_mutex_and_test_path() {
    MUTEX_DATA.handle = CreateMutexA(NULL, TRUE, "th18 App");
    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        LOG_BUFFER.write_error(JpEnStr("N\r\n", "Two cannot be started\r\n"));
        return ZUN_ERROR;
    }
    STARTUPINFOA startup_info = { sizeof(STARTUPINFOA) };
    char filename_buffer[MAX_PATH + 1];
    char path_buffer[MAX_PATH + 1];
    GetModuleFileNameA(NULL, filename_buffer, sizeof(filename_buffer));
    GetConsoleTitleA(path_buffer, sizeof(path_buffer));
    GetStartupInfoA(&startup_info);
    if (startup_info.lpTitle) {
        char* file_extension_str = strrchr(startup_info.lpTitle, '.');
        if (zun_file_exists(startup_info.lpTitle) && file_extension_str) {
            if (!stricmp(file_extension_str, ".lnk")) {
                do {
                    if (CoInitialize(NULL) != S_OK) {
                        LOG_BUFFER.write_error(JpEnStr("CoInitialize s\r\n", "CoInitialize initialization failure\r\n"));
                    }
                    IShellLinkA* shortcut_interface;
                    if (SUCCEEDED(CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLinkA, (LPVOID*)&shortcut_interface))) {
                        IPersistFile* persist_file_interface;
                        if (SUCCEEDED(shortcut_interface->QueryInterface(IID_IPersistFile, (LPVOID*)&persist_file_interface))) {
                            wchar_t* conversion_array = new wchar_t[MAX_PATH];
                            WIN32_FIND_DATAA find_data;
                            memset_force(&find_data, 0, sizeof(WIN32_FIND_DATAA));
                            MultiByteToWideChar(CP_ACP, 0, startup_info.lpTitle, -1, conversion_array, MAX_PATH);
                            if (SUCCEEDED(persist_file_interface->Load(conversion_array, 0))) {
                                shortcut_interface->GetPath(path_buffer, MAX_PATH, &find_data, 0);
                            }
                            delete[] conversion_array;
                            persist_file_interface->Release();
                        }
                        shortcut_interface->Release();
                    }
                    CoUninitialize();
                } while (!stricmp(strrchr(path_buffer, '.'), ".lnk"));
            }
            else {
                byteloop_strcpy(path_buffer, startup_info.lpTitle);
            }
            WINDOW_DATA.__bool_30 = strcmp_asm(path_buffer, filename_buffer) ? true : WINDOW_DATA.__bool_30;
        }
        SUPERVISOR.__unknown_flag_A = false;
    }
    else {
        SUPERVISOR.__unknown_flag_A = true;
    }
    return MUTEX_DATA.handle != NULL ? ZUN_SUCCESS : ZUN_ERROR;
}

extern "C" {
    // 0x5705F0
    externcg JOYCAPSA JOYCAPS_GLOBAL cgasm("_JOYCAPS");
}

// 0x4B4280
static const int ResolutionDialogButtonIDs[] = {
    0xD3,
    0xD2,
    0xD1,
    0xD8,
    0xD7,
    0xD6,
    0xD5,
    0xD4,
    0xCF,
    0xD0
};

// 0x4B7FF0
static const int ResolutionDialogButtonIDsB[] = {
    0xCF,
    0xD0,
    0xD1,
    0xD2,
    0xD3,
    0xD4,
    0xD5,
    0xD6,
    0xD7,
    0xD8
};

// 0x4B7FBC
static const uint8_t ResolutionConfigValues[] = {
    0, 0, 0, 0, 1, 0, 0, 0, 2, 0
};

// 0x4747D0
dllexport gnu_noinline void set_selected_resolution() asm_symbol_rel(0x4747D0);
dllexport gnu_noinline void set_selected_resolution() {
    if (IsDlgButtonChecked(WINDOW_DATA.resolution_dialogue, 0xCA) == BST_CHECKED) {
        SUPERVISOR.config.__unknown_flag_A = true;
    } else {
        SUPERVISOR.config.__unknown_flag_A = false;
    }
    for (int32_t i = 0; i < countof(ResolutionDialogButtonIDs); ++i) {
        if (IsDlgButtonChecked(WINDOW_DATA.resolution_dialogue, ResolutionDialogButtonIDs[i]) == BST_CHECKED) {
            SUPERVISOR.config.__ubyte_47 = i;
            SUPERVISOR.config.__ubyte_4E = ResolutionConfigValues[i];
            return;
        }
    }
}

// 0x4746C0
dllexport gnu_noinline INT_PTR CALLBACK ResolutionDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
        case WM_COMMAND: // 0x111
            if (LOWORD(wParam) == 0xCE) {
                return 0;
            }
            set_selected_resolution();
            DestroyWindow(WINDOW_DATA.resolution_dialogue);
            WINDOW_DATA.resolution_dialogue = NULL;
            break;
        case WM_INITDIALOG: // 0x110
            if (SUPERVISOR.config.__unknown_flag_A) {
                SendMessageA(GetDlgItem(hWnd, 0xCA), BM_SETCHECK, BST_CHECKED, 0);
            }
            SendMessageA(GetDlgItem(hWnd, ResolutionDialogButtonIDs[SUPERVISOR.config.__ubyte_47]), BM_SETCHECK, BST_CHECKED, 0);
            WINDOW_DATA.__unknown_bitfield_B = 2;
            break;
        case WM_CLOSE: // 0x10
            if (WINDOW_DATA.__unknown_bitfield_B == 2) {
                WINDOW_DATA.__unknown_bitfield_B = 1;
            }
            DestroyWindow(WINDOW_DATA.resolution_dialogue);
            WINDOW_DATA.resolution_dialogue = NULL;
            return TRUE;
    }
    return FALSE;
}

// 0x474850
dllexport gnu_noinline void process_resolution_dialog() asm_symbol_rel(0x474850);
dllexport gnu_noinline void process_resolution_dialog() {
    BOOL disabled_buttons[10] = {};
    if (!SUPERVISOR.config.__unknown_flag_A) {
        BYTE keyboard[256];
        GetKeyboardState(keyboard);
        if (keyboard[VK_SHIFT] & 0x80) {
            return;
        }
    }
    LCID user_locale = GetUserDefaultLCID();
    WINDOW_DATA.resolution_dialogue = CreateDialogParamA(WINDOW_DATA.current_instance, MAKEINTRESOURCEA(user_locale == 0x411 ? 0xCB : 0xCC), 0, &ResolutionDlgProc, 0);
    DEVMODEA dev_mode;
    // ZUN not following the documentation again by leaving dev_mode uninitialized...
    EnumDisplaySettingsA(NULL, ENUM_CURRENT_SETTINGS, &dev_mode);
    if (dev_mode.dmPelsWidth <= 2560 || dev_mode.dmPelsHeight <= 1920) {
        disabled_buttons[5] = true;
        EnableWindow(GetDlgItem(WINDOW_DATA.resolution_dialogue, 0xD4), FALSE);
    }
    if (dev_mode.dmPelsWidth <= 1920 && dev_mode.dmPelsHeight <= 1440) {
        disabled_buttons[6] = true;
        EnableWindow(GetDlgItem(WINDOW_DATA.resolution_dialogue, 0xD5), FALSE);
    }
    if (dev_mode.dmPelsWidth <= 1280 && dev_mode.dmPelsHeight <= 960) {
        disabled_buttons[7] = true;
        EnableWindow(GetDlgItem(WINDOW_DATA.resolution_dialogue, 0xD6), FALSE);
        disabled_buttons[2] = true;
        EnableWindow(GetDlgItem(WINDOW_DATA.resolution_dialogue, 0xD1), FALSE);
    }
    if (dev_mode.dmPelsWidth <= 960 && dev_mode.dmPelsHeight <= 720) {
        disabled_buttons[8] = true;
        EnableWindow(GetDlgItem(WINDOW_DATA.resolution_dialogue, 0xD7), FALSE);
        disabled_buttons[3] = true;
        EnableWindow(GetDlgItem(WINDOW_DATA.resolution_dialogue, 0xD2), FALSE);
    }
    int32_t button_index = 0;
    for (int32_t i = 0; i < countof(ResolutionDialogButtonIDsB); ++i) {
        if (IsDlgButtonChecked(WINDOW_DATA.resolution_dialogue, ResolutionDialogButtonIDsB[i]) == BST_CHECKED) {
            button_index = i;
            break;
        }
    }
    ShowWindow(WINDOW_DATA.resolution_dialogue, SW_SHOW);
    for (;;) {
        JOYINFOEX joy_info{};
        joy_info.dwSize = sizeof(JOYINFOEX);
        joy_info.dwFlags = JOY_RETURNALL;
        if (joyGetPosEx(JOYSTICKID1, &joy_info) == JOYERR_NOERROR) {
            // TODO: bother writing out the joystick code at 0x474AC0
        }
        MSG message;
        if (PeekMessageA(&message, NULL, WM_NULL, WM_NULL, PM_REMOVE)) {
            if (!IsDialogMessageA(WINDOW_DATA.resolution_dialogue, &message)) {
                continue;
            }
            TranslateMessage(&message);
            DispatchMessageA(&message);
        }
        if (INPUT_STATES[0].check_hardware_inputs_no_repeat(BUTTON_ENTER | BUTTON_SHOOT)) {
            break;
        }
        if (
            INPUT_STATES[0].check_hardware_inputs_repeating(BUTTON_DOWN) &&
            button_index < 9
        ) {
            while (disabled_buttons[++button_index]);
            CheckRadioButton(WINDOW_DATA.resolution_dialogue, 0xCF, 0xD8, ResolutionDialogButtonIDsB[button_index]);
        }
        if (
            INPUT_STATES[0].check_hardware_inputs_repeating(BUTTON_UP) &&
            button_index > 0
        ) {
            while (disabled_buttons[--button_index]);
            CheckRadioButton(WINDOW_DATA.resolution_dialogue, 0xCF, 0xD8, ResolutionDialogButtonIDsB[button_index]);
        }
        if (!WINDOW_DATA.resolution_dialogue) {
            return;
        }
        Sleep(6);
    }
    set_selected_resolution();
    WINDOW_DATA.__unknown_bitfield_B = 0;
}

/*
struct D3DPRESENT_PARAMETERS {
    UINT                BackBufferWidth; // 0x0 EBP-54
    UINT                BackBufferHeight; // 0x4 EBP-50
    D3DFORMAT           BackBufferFormat; // 0x8 EBP-4C
    UINT                BackBufferCount; // 0xC EBP-48
    D3DMULTISAMPLE_TYPE MultiSampleType; // 0x10 EBP-44
    DWORD               MultiSampleQuality; // 0x14 EBP-40
    D3DSWAPEFFECT       SwapEffect; // 0x18 EBP-3C
    HWND                hDeviceWindow; // 0x1C EBP-38
    BOOL                Windowed; // 0x20 EBP-34
    BOOL                EnableAutoDepthStencil; // 0x24 EBP-30
    D3DFORMAT           AutoDepthStencilFormat; // 0x28 EBP-2C
    DWORD               Flags; // 0x2C EBP-28
    UINT                FullScreen_RefreshRateInHz; // 0x30 EBP-24
    UINT                PresentationInterval; // 0x34 EBP-20
    // 0x38
};
*/

struct SimpleInt2 {
    int32_t x;
    int32_t y;
};

// 0x4B8020
static const SimpleInt2 RESOLUTIONS[] = {
    { .x = 640, .y = 480 },
    { .x = 960, .y = 720 },
    { .x = 1024, .y = 768 },
    { .x = 1152, .y = 864 },
    { .x = 1280, .y = 960 },
    { .x = 1280, .y = 1024 },
    { .x = 1600, .y = 1024 },
    { .x = 1600, .y = 1200 },
    { .x = 1920, .y = 1080 },
    { .x = 1920, .y = 1200 },
    { .x = 1920, .y = 1440 },
    { .x = 2048, .y = 1152 },
    { .x = 2048, .y = 1536 },
    { .x = 2560, .y = 1440 },
    { .x = 2560, .y = 1600 },
    { .x = 3840, .y = 2160 }
};

// 0x473B20
dllexport gnu_noinline ZUNResult fastcall __sub_473B20(BOOL arg1) asm_symbol_rel(0x473B20);
dllexport gnu_noinline ZUNResult fastcall __sub_473B20(BOOL arg1) {
    D3DPRESENT_PARAMETERS present_parameters = SUPERVISOR.present_parameters;
    BOOL is_second_iteration = false;
    if (SUPERVISOR.config.__byte_4D == 3) {
        WINDOW_DATA.__unknown_flag_C = false;
        present_parameters.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
    } else {
        present_parameters.PresentationInterval = D3DPRESENT_INTERVAL_ONE;
    }
    for (;;) {
        size_t i = 0;
        do {
            if (
                i == 0 &&
                (WINDOW_DATA.__unknown_bitfield_A == 8 || WINDOW_DATA.__unknown_bitfield_A == 9)
            ) {
                present_parameters.BackBufferWidth = WINDOW_DATA.__backbuffer_width;
                present_parameters.BackBufferHeight = WINDOW_DATA.__backbuffer_height;
            } else {
                int32_t width = RESOLUTIONS[i].x;
                if (width < WINDOW_DATA.__scaled_width) continue;
                int32_t height = RESOLUTIONS[i].y;
                if (height < WINDOW_DATA.__scaled_height) continue;
                present_parameters.BackBufferWidth = width;
                present_parameters.BackBufferHeight = height;
            }
            if (!arg1) {
                SUPERVISOR.__unknown_flag_D = false;
                if (!SUPERVISOR.config.reference_rasterizer) {
                    if (SUPERVISOR.d3d->CreateDevice(
                        D3DADAPTER_DEFAULT,
                        D3DDEVTYPE_HAL,
                        WINDOW_DATA.window,
                        D3DCREATE_HARDWARE_VERTEXPROCESSING,
                        &present_parameters,
                        &SUPERVISOR.d3d_device
                    ) == D3D_OK) {
                        break;
                    }
                    if (SUPERVISOR.d3d->CreateDevice(
                        D3DADAPTER_DEFAULT,
                        D3DDEVTYPE_HAL,
                        WINDOW_DATA.window,
                        D3DCREATE_SOFTWARE_VERTEXPROCESSING,
                        &present_parameters,
                        &SUPERVISOR.d3d_device
                    ) == D3D_OK) {
                        break;
                    }
                }
                if (SUPERVISOR.d3d->CreateDevice(
                    D3DADAPTER_DEFAULT,
                    D3DDEVTYPE_REF,
                    WINDOW_DATA.window,
                    D3DCREATE_SOFTWARE_VERTEXPROCESSING,
                    &present_parameters,
                    &SUPERVISOR.d3d_device
                ) == D3D_OK) {
                    break;
                }
                SAFE_RELEASE(SUPERVISOR.d3d_device);
            }
            else {
                if (SUPERVISOR.d3d_device->Reset(&present_parameters) == D3D_OK) {
                    goto reset_success;
                }
            }
        } while (++i < countof(RESOLUTIONS));
        SUPERVISOR.__unknown_flag_D = true;
reset_success:
        HDC hdc = GetDC(WINDOW_DATA.window);
        GetDeviceCaps(hdc, VREFRESH);
        ReleaseDC(WINDOW_DATA.window, hdc);
        if (i < countof(RESOLUTIONS)) {
            break;
        }
        if (is_second_iteration) {
            if (!arg1) {
                LOG_BUFFER.write_error(JpEnStr("Direct3D sAx\r\n", "Direct3D initialization failed, this resolution is not supported\r\n"));
                SAFE_RELEASE(SUPERVISOR.d3d);
            }
            return ZUN_ERROR;
        }
        is_second_iteration = true;
    }
    HDC hdc = GetDC(WINDOW_DATA.window);
    int32_t refresh_rate = GetDeviceCaps(hdc, VREFRESH);
    ReleaseDC(WINDOW_DATA.window, hdc);
    if (refresh_rate != 60) {
        WINDOW_DATA.__unknown_flag_C = false;
        present_parameters.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
    }
    SUPERVISOR.present_parameters = present_parameters;
    if (SUPERVISOR.d3d_device->Reset(&present_parameters) == D3D_OK) {
        LOG_BUFFER.write(
            JpEnStr("x %d %dN\r\n", "Booting at resolution %d %d\r\n")
            , present_parameters.BackBufferWidth, present_parameters.BackBufferHeight
        );
    }
    return ZUN_SUCCESS;
}

// 0x473DF0
dllexport gnu_noinline int32_t __initialize_d3d() asm_symbol_rel(0x473DF0);
dllexport gnu_noinline int32_t __initialize_d3d() {
    D3DPRESENT_PARAMETERS present_parameters;
    present_parameters.BackBufferWidth = 0;
    present_parameters.BackBufferHeight = 0;
    present_parameters.BackBufferFormat = D3DFMT_UNKNOWN;
    present_parameters.BackBufferCount = 0;
    present_parameters.MultiSampleType = D3DMULTISAMPLE_NONE;
    present_parameters.MultiSampleQuality = 0;
    present_parameters.hDeviceWindow = NULL;
    present_parameters.Windowed = false;
    present_parameters.FullScreen_RefreshRateInHz = 0;
    present_parameters.PresentationInterval = 0;
    D3DDISPLAYMODE display_mode;
    SUPERVISOR.d3d->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &display_mode);
    UINT refresh_rate = display_mode.RefreshRate;
    D3DFORMAT d3d_format = display_mode.Format == D3DFMT_X8R8G8B8 ? D3DFMT_A8R8G8B8 : display_mode.Format;
    display_mode.Format = d3d_format;
    SUPERVISOR.display_mode = display_mode;
    if (SUPERVISOR.present_parameters.Windowed && refresh_rate != 60) {
        WINDOW_DATA.__unknown_flag_C = false;
    }
    BOOL boolA = true;
    SUPERVISOR.disable_vsync = WINDOW_DATA.__bool_30 ? boolA : SUPERVISOR.disable_vsync;
    if (!SUPERVISOR.present_parameters.Windowed) {
        if (SUPERVISOR.config.__ubyte_44 == 255) {
            d3d_format = D3DFMT_A8R8G8B8;
            LOG_BUFFER.write(JpEnStr("NA 32Bits \r\n", "First boot, screen initialized with 32Bits\r\n"));
        } else {
            d3d_format = !SUPERVISOR.config.__ubyte_44 ? D3DFMT_R5G6B5 : D3DFMT_A8R8G8B8;
            present_parameters.BackBufferFormat = d3d_format;
        }
        if (!SUPERVISOR.disable_vsync) {
            // IDK how this might've originally looked, so comma jank
            if (
                WINDOW_DATA.__unknown_flag_C ||
                ((present_parameters.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE), SUPERVISOR.config.__byte_4D != 3)
            ) {
                present_parameters.PresentationInterval = D3DPRESENT_INTERVAL_ONE;
            }
            present_parameters.SwapEffect = D3DSWAPEFFECT_DISCARD;
        }
        else {
            present_parameters.FullScreen_RefreshRateInHz = 0;
            present_parameters.SwapEffect = D3DSWAPEFFECT_DISCARD;
            present_parameters.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
        }
    }
    else {
        present_parameters.SwapEffect = D3DSWAPEFFECT_DISCARD;
        d3d_format = d3d_format == D3DFMT_X8R8G8B8 ? D3DFMT_A8R8G8B8 : d3d_format;
        present_parameters.BackBufferFormat = d3d_format;
        if (SUPERVISOR.config.__byte_4D != 3 && refresh_rate == 60) {
            if (WINDOW_DATA.__unknown_flag_C) {
                present_parameters.PresentationInterval = D3DPRESENT_INTERVAL_ONE;
            }
        }
        else {
            WINDOW_DATA.__unknown_flag_C = false;
            present_parameters.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
        }
        present_parameters.Windowed = true;
    }
    SUPERVISOR.__unknown_flag_C = true;
    present_parameters.EnableAutoDepthStencil = true;
    present_parameters.AutoDepthStencilFormat = D3DFMT_D16;
    present_parameters.Flags = D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;
    SUPERVISOR.__dword_824 = 1;
    SUPERVISOR.present_parameters = present_parameters;
    if (ZUN_FAILED(__sub_473B20(false))) {
        return boolA;
    }
    SUPERVISOR.d3d_device->GetDeviceCaps(&SUPERVISOR.d3dcaps);
    if (!(SUPERVISOR.d3dcaps.TextureOpCaps & D3DTEXOPCAPS_ADD)) {
        LOG_BUFFER.write(JpEnStr("D3DTEXOPCAPS_ADD T|[gAFZG~[g[h\r\n", "Does not support D3DTEXOPCAPS_ADD, works in color addition emulation mode\r\n"));
    }
    if (SUPERVISOR.d3dcaps.MaxTextureWidth < 256) { // Is this a wrong number or a bad translation?
        LOG_BUFFER.write(JpEnStr("512 eNX`T|[gBwG{P\B\r\n", "Doesn't support larger than 512 textures. Most of the pictures are blurry.\r\n"));
    }
    if (SUPERVISOR.d3d->CheckDeviceFormat(
        D3DADAPTER_DEFAULT,
        D3DDEVTYPE_HAL,
        d3d_format,
        0,
        D3DRTYPE_TEXTURE,
        D3DFMT_A8R8G8B8
    ) == D3D_OK) {
        SUPERVISOR.__unknown_flag_E = true;
    }
    else {
        SUPERVISOR.__unknown_flag_E = false;
        SUPERVISOR.config.__unknown_flag_B = true;
        LOG_BUFFER.write(JpEnStr("", "Does not support D3DFMT_A8R8G8B8, works in reduced color mode\r\n"));
    }
    WINDOW_DATA.__dword_8 = 0;
    __set_default_d3d_states();
    SUPERVISOR.__dword_828 = 0;
    return 0;
}


template <typename T>
inline T* ole_strstr(T* lhs, const std::remove_const_t<T>* rhs) {
    if constexpr (std::is_same_v<std::remove_pointer_t<T>, char>) {
        return strstr(lhs, rhs);
    } else if constexpr (std::is_same_v<std::remove_pointer_t<T>, wchar_t>) {
        return wcsstr(lhs, rhs);
    }
}

template <typename T, typename ... FormatArgs>
inline int ole_sscanf(const T* buffer, const T* format, FormatArgs... args) {
    if constexpr (std::is_same_v<T, char>) {
        return sscanf(buffer, format, args...);
    } else if constexpr (std::is_same_v<T, wchar_t>) {
        return swscanf(buffer, format, args...);
    }
}

// 0x474CD0
dllexport gnu_noinline BOOL fastcall __joystick_enum_devices_callback(const GUID* joystick_guid) asm_symbol_rel(0x474CD0);
dllexport gnu_noinline BOOL fastcall __joystick_enum_devices_callback(const GUID* joystick_guid) {
    IWbemLocator* wbem_locator = NULL;
    IEnumWbemClassObject* wbem_enum = NULL;
    IWbemClassObject* wbem_objects[20] = {};
    IWbemServices* wbem_services = NULL;
    ULONG wbem_object_count = 0;
    bool com_was_initialized = SUCCEEDED(CoInitialize(NULL));
    BSTR bstrA, bstrB;
    BSTR bstrC = NULL;
    BOOL found_joystick;
    if (
        SUCCEEDED(CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID*)&wbem_locator)) &&
        wbem_locator != NULL &&
        (bstrA = SysAllocString(OLESTR("\\\\.\\root\\cimv2")))
    ) {
        if (
            (bstrB = SysAllocString(OLESTR("Win32_PNPEntity"))) &&
            (bstrC = SysAllocString(OLESTR("DeviceID"))) &&
            SUCCEEDED(wbem_locator->ConnectServer(bstrA, NULL, NULL, NULL, 0, NULL, NULL, &wbem_services)) &&
            wbem_services != NULL &&
            CoSetProxyBlanket(wbem_services, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE), SUCCEEDED(wbem_services->CreateInstanceEnum(bstrB, 0, NULL, &wbem_enum)) &&
            wbem_enum != NULL
        ) {
            while (SUCCEEDED(wbem_enum->Next(10000, countof(wbem_objects), wbem_objects, &wbem_object_count))) {
                if (!wbem_object_count) {
                    // ole_fail_D
                    found_joystick = false;
                    SysFreeString(bstrA);
                    SysFreeString(bstrC);
                    goto ole_break;
                }
                for (ULONG i = 0; i < wbem_object_count; ++i) {
                    VARIANT device_id;
                    if (
                        SUCCEEDED(wbem_objects[i]->Get(bstrC, 0, &device_id, NULL, NULL)) &&
                        V_VT(&device_id) == VT_BSTR &&
                        V_BSTR(&device_id) &&
                        ole_strstr(V_BSTR(&device_id), OLESTR("IG_"))
                    ) {
                        unsigned int product_id = 0;
                        unsigned int vendor_id = 0;
                        if (BSTR vid_str = ole_strstr(V_BSTR(&device_id), OLESTR("VID_"))) {
                            vendor_id = ole_sscanf(vid_str, OLESTR("VID_%4X"), &vendor_id) == 1 ? vendor_id : 0;
                        }
                        if (BSTR pid_str = ole_strstr(V_BSTR(&device_id), OLESTR("PID_"))) {
                            product_id = ole_sscanf(pid_str, OLESTR("PID_%4X"), &product_id) == 1 ? product_id : 0;
                        }
                        if (MAKELONG(vendor_id, product_id) == joystick_guid->Data1) {
                            found_joystick = true;
                            SysFreeString(bstrA);
                            SysFreeString(bstrC);
                            goto ole_break;
                        }
                    }
                    SAFE_RELEASE(wbem_objects[i]);
                }
            }
            // ole_fail_C
            found_joystick = false;
            SysFreeString(bstrA);
            SysFreeString(bstrC);
        } else {
            // ole_fail_B
            found_joystick = false;
            SysFreeString(bstrA);
            if (bstrC) {
                SysFreeString(bstrC);
            }
        }
ole_break:
        if (bstrB) {
            SysFreeString(bstrB);
        }
    }
    for (ULONG i = 0; i < wbem_object_count; ++i) {
        SAFE_RELEASE(wbem_objects[i]);
    }
    SAFE_RELEASE(wbem_enum);
    SAFE_RELEASE(wbem_locator);
    SAFE_RELEASE(wbem_services);
    if (com_was_initialized) {
        CoUninitialize();
    }
    return found_joystick;
}

// 0x475230
dllexport gnu_noinline BOOL PASCAL EnumDevicesCallback(LPCDIDEVICEINSTANCEA lpddi, LPVOID pvref) asm_symbol_rel(0x475230);
dllexport gnu_noinline BOOL PASCAL EnumDevicesCallback(LPCDIDEVICEINSTANCEA lpddi, LPVOID pvref) {
    if (!__joystick_enum_devices_callback(&lpddi->guidProduct)) {
        if (!SUPERVISOR.joypad_devices[0]) {
            SUPERVISOR.dinput->CreateDevice(
                lpddi->guidInstance,
                &SUPERVISOR.joypad_devices[0],
                NULL
            );
        }
        else {
            return DIENUM_STOP;
        }
    }
    return DIENUM_CONTINUE;
}

// 0x475280
dllexport gnu_noinline BOOL PASCAL EnumDeviceObjectsCallback(LPCDIDEVICEOBJECTINSTANCEA lpddoi, LPVOID pvRef) asm_symbol_rel(0x475280);
dllexport gnu_noinline BOOL PASCAL EnumDeviceObjectsCallback(LPCDIDEVICEOBJECTINSTANCEA lpddoi, LPVOID pvRef) {
    DWORD joypad_type = lpddoi->dwType;
    if (joypad_type & DIDFT_AXIS) {
        DIPROPRANGE range;
        range.diph.dwObj = joypad_type;
        range.diph.dwSize = sizeof(DIPROPRANGE);
        range.diph.dwHeaderSize = sizeof(DIPROPHEADER);
        range.diph.dwHow = DIPH_BYID;
        range.lMin = JOYPAD_MIN_RANGE;
        range.lMax = JOYPAD_MAX_RANGE;
        if (SUCCEEDED(SUPERVISOR.joypad_devices[JOYPAD_INDEX]->SetProperty(DIPROP_RANGE, (LPCDIPROPHEADER)&range))) {
            return DIENUM_STOP;
        }
    }
    return DIENUM_CONTINUE;
}

// 0x475050
dllexport gnu_noinline ZUNResult __initialize_dinput() asm_symbol_rel(0x475050);
dllexport gnu_noinline ZUNResult __initialize_dinput() {
    if (SUCCEEDED(DirectInput8Create(
        WINDOW_DATA.current_instance,
        DIRECTINPUT_VERSION, // 0x800
        IID_IDirectInput8A,
        (LPVOID*)&SUPERVISOR.dinput,
        NULL
    ))) {
        if (SUCCEEDED(SUPERVISOR.dinput->CreateDevice(
            GUID_SysKeyboard,
            &SUPERVISOR.keyboard_device,
            NULL
        ))) {
            goto dinput_init_success;
        }
        SAFE_RELEASE(SUPERVISOR.dinput);
    }
    SUPERVISOR.dinput = NULL;
    LOG_BUFFER.write(JpEnStr("DirectInput gp\r\n", "DirectInput not available\r\n"));
    return ZUN_ERROR;
dinput_init_success:
    if (FAILED(SUPERVISOR.keyboard_device->SetDataFormat(&c_dfDIKeyboard))) {
        SAFE_RELEASE(SUPERVISOR.keyboard_device);
        SAFE_RELEASE(SUPERVISOR.dinput);
        LOG_BUFFER.write(JpEnStr("DirectInput SetDataFormat gp\r\n", "DirectInput SetDataFormat not available\r\n"));
        return ZUN_ERROR;
    }
    if (FAILED(SUPERVISOR.keyboard_device->SetCooperativeLevel(WINDOW_DATA.window, DISCL_NOWINKEY))) {
        SAFE_RELEASE(SUPERVISOR.keyboard_device);
        SAFE_RELEASE(SUPERVISOR.dinput);
        LOG_BUFFER.write(JpEnStr("DirectInput SetCooperativeLevel gp\r\n", "DirectInput SetCooperativeLevel not available\r\n"));
        return ZUN_ERROR;
    }
    SUPERVISOR.keyboard_device->Acquire();
    LOG_BUFFER.write(JpEnStr("DirectInput \r\n", "DirectInput successfully initialized\r\n"));
    SUPERVISOR.dinput->EnumDevices(
        DI8DEVCLASS_GAMECTRL,
        &EnumDevicesCallback,
        NULL,
        DIEDFL_ATTACHEDONLY
    );
    if (LPDIRECTINPUTDEVICE8 joypad_device = SUPERVISOR.joypad_devices[0]) {
        joypad_device->SetDataFormat(&c_dfDIJoystick2);
        SUPERVISOR.joypad_devices[0]->SetCooperativeLevel(WINDOW_DATA.window, DISCL_NONEXCLUSIVE | DISCL_BACKGROUND);
        SUPERVISOR.__joypad_caps.dwSize = sizeof(DIDEVCAPS);
        SUPERVISOR.joypad_devices[0]->GetCapabilities(&SUPERVISOR.__joypad_caps);
        JOYPAD_INDEX = 0;
        SUPERVISOR.joypad_devices[0]->EnumObjects(
            &EnumDeviceObjectsCallback,
            NULL,
            DIDFT_ALL
        );
        LOG_BUFFER.write(JpEnStr("Lpbh\r\n", "found a valid pad\r\n"));
    }
    return ZUN_SUCCESS;
}

extern "C" {

// 0x471270
dllexport gnu_noinline int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR pCmdLine, int nCmdShow);
dllexport gnu_noinline int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR pCmdLine, int nCmdShow) asm_symbol_rel(0x471270) {
    HINSTANCE current_instance = hInstance;
    int local_dword_18 = 0;
    WINDOW_DATA.current_instance = hInstance;
    WINDOW_DATA.__dword_18 = 0;
    timeBeginPeriod(1);
    CRITICAL_SECTION_MANAGER.initialize();
    DEBUG_LOG_PTR = new DebugLogger();
    DEBUG_LOG_PTR->__dword_0 = 0;
    LOG_BUFFER.write(JpEnStr("L^ --------------------------------------------- \r\n", "Touhou Operation Record --------------------------------------------- \r\n"));
    if (__make_mutex_and_test_path() != ZUN_ERROR) {
        SUPERVISOR.current_instance = current_instance;
        if (ZUN_SUCCEEDED(WINDOW_DATA.__save_properties_and_configure_paths())) {
            goto winmain_load_config;
        }
        LOG_BUFFER.write_error(JpEnStr("Z[uf[^\r\n", "Save data cannot be saved\r\n"));
    }
winmain_important_label:
    SOUND_MANAGER.__dword_5724 = 2;
    SOUND_MANAGER.cleanup();
    SAFE_DELETE(ANM_MANAGER_PTR);
    SAFE_RELEASE(SUPERVISOR.__surface_1AC);
    SAFE_RELEASE(SUPERVISOR.__surface_1B0);
    SAFE_RELEASE(SUPERVISOR.back_buffer);
    SAFE_RELEASE(SUPERVISOR.d3d_device);
    SAFE_RELEASE(SUPERVISOR.d3d);
    if (HWND window_handle = WINDOW_DATA.window) {
        ShowWindow(window_handle, SW_HIDE);
        MoveWindow(WINDOW_DATA.window, 0, 0, 0, 0, FALSE);
        DestroyWindow(WINDOW_DATA.window);
        WINDOW_DATA.window = NULL;
    }
    show_cursor();
    if (local_dword_18 != 2) {
        goto winmain_weird_local_not_2;
    }
    LOG_BUFFER.buffer_write = LOG_BUFFER.buffer;
    LOG_BUFFER.buffer[0] = '\0';
    LOG_BUFFER.write(JpEnStr("NvIvVXN\r\n", "An option that requires a reboot has been changed and will be rebooted\r\n"));
    if (!SUPERVISOR.present_parameters.Windowed) {
        WINNLSEnableIME(NULL, true);
    }
    MSG message;
    uint32_t message_count = 60;
    do {
        if (PeekMessageA(&message, NULL, WM_NULL, WM_NULL, PM_REMOVE)) {
            TranslateMessage(&message);
            DispatchMessageA(&message);
        }
    } while (--message_count);
    SUPERVISOR.__unknown_bitfield_A = 0;
winmain_after_config_loaded:
    IDirect3D9* d3d_ptr = Direct3DCreate9(D3D_SDK_VERSION); // version 32
    SUPERVISOR.d3d = d3d_ptr;
    if (d3d_ptr) {
        goto winmain_d3d_create_success;
    }
    LOG_BUFFER.write_error(JpEnStr("Direct3D IuWFNgo\r\n", "Direct3D object could not be created for some reason\r\n"));
    goto winmain_important_label;

winmain_load_config:
    if (ZUN_FAILED(SUPERVISOR.load_config_file(UNUSED_DWORD))) {
        goto winmain_important_label;
    }
    JOYINFOEX joy_info;
    joy_info.dwSize = sizeof(JOYINFOEX);
    joy_info.dwFlags = JOY_RETURNALL;
    if (
        joyGetPosEx(JOYSTICKID1, &joy_info) == JOYERR_NOERROR &&
        joyGetPosEx(JOYSTICKID2, &joy_info) == JOYERR_NOERROR
    ) {
        SUPERVISOR.__unknown_flag_B = false;
    } else {
        joyGetDevCapsA(JOYSTICKID1, &JOYCAPS_GLOBAL, sizeof(JOYCAPSA));
        SUPERVISOR.__unknown_flag_B = true;
    }
    BYTE keyboard[256];
    GetKeyboardState(keyboard);
    for (int32_t i = 0; i < countof(keyboard); ++i) {
        keyboard[i] &= 0x7F;
    }
    SetKeyboardState(keyboard);
    process_resolution_dialog();
    if (WINDOW_DATA.__unknown_bitfield_B) {
        goto winmain_important_label;
    }
    WINDOW_DATA.__unknown_bitfield_A = SUPERVISOR.config.__ubyte_47;
#if FIX_REALLY_BAD_BUGS
    char module_name[MAX_PATH + 1];
#else
    char module_name[8];
#endif
    if (GetModuleFileNameA(NULL, module_name, MAX_PATH + 1)) { // But why is the size wrong...?
        int32_t exe_file_size;
        if (void* module_file_buffer = read_file_to_buffer(module_name, &exe_file_size, true)) {
            int32_t* module_file_read = (int32_t*)module_file_buffer;
            int32_t checksum_low = 0;
            int32_t checksum_high = 0;
            int32_t file_size_in_dwords = exe_file_size / 4;
            int32_t summed_dword_count = 0;
            if (file_size_in_dwords >= 2) {
                int32_t checksum_iters = (uint32_t)(file_size_in_dwords - 2) / 2 - 1;
                summed_dword_count = checksum_iters * 2;
                do {
                    checksum_low += module_file_read[0];
                    checksum_high += module_file_read[1];
                    module_file_read += 2;
                } while (--checksum_iters);
            }
            int32_t checksum = summed_dword_count < file_size_in_dwords ? *module_file_read : 0;
            free(module_file_buffer);
            SUPERVISOR.game_exe_checksum = checksum;
            SUPERVISOR.game_exe_file_size = exe_file_size;
        }
    }
    goto winmain_after_config_loaded;

winmain_d3d_create_success:
    DEVMODEA dev_mode;
    dev_mode.dmPelsWidth = 0;
    // ZUN not following the documentation again by leaving dev_mode uninitialized...
    EnumDisplaySettingsA(NULL, ENUM_CURRENT_SETTINGS, &dev_mode);
    DWORD window_width = dev_mode.dmPelsWidth;
    DWORD window_height = dev_mode.dmPelsHeight;
    WINDOW_DATA.__display_width = window_width;
    WINDOW_DATA.window_width = window_width;
    WINDOW_DATA.__display_height = window_height;
    WINDOW_DATA.window_height = window_height;
    if (WINDOW_DATA.__create_window(current_instance)) {
        goto winmain_important_label;
    }
    __initialize_dinput();
    UNKNOWN_THREAD_A.stop_and_cleanup();
    SOUND_MANAGER.zero_contents();
    SOUND_MANAGER.main_window_hwnd = WINDOW_DATA.window;
    SOUND_MANAGER.__thread_5718 = CreateThread(
        NULL,
        0,
        &SoundManager::sound_thread_func,
        &SOUND_MANAGER,
        0,
        &SOUND_MANAGER.__thread_id_5720
    );
    if (__initialize_d3d()) {
        goto winmain_important_label;
    }
    UPDATE_FUNC_REGISTRY_PTR = new UpdateFuncRegistry();
    ANM_MANAGER_PTR = new AnmManager();
    if (SUPERVISOR.present_parameters.Windowed) {
        WINNLSEnableIME(NULL, false);
        hide_cursor();
        SetCursor(NULL);
    }
    WINDOW_DATA.__double_20B0 = 0.0;
    double runtimeA = get_runtime();
    WINDOW_DATA.__double_20A8 = runtimeA;
    WINDOW_DATA.__double_2098 = runtimeA;
    WINDOW_DATA.__double_20A0 = runtimeA;
    runtimeA = get_runtime();
    WINDOW_DATA.__double_20B8 = runtimeA;
    WINDOW_DATA.__double_20C0 = runtimeA;
    SetForegroundWindow(WINDOW_DATA.window);
    ZUNResult result = SUPERVISOR.initialize();
    if (result == ZUN_SUCCESS) {
        WINDOW_DATA.__unknown_flag_A = true;
        local_dword_18 = 0;
        WINDOW_DATA.__sbyte_1C = -4;
        while (!WINDOW_DATA.__dword_8) {
            if (PeekMessageA(&message, NULL, WM_NULL, WM_NULL, PM_REMOVE)) {
                TranslateMessage(&message);
                DispatchMessageA(&message);
            }
            else {
                switch (SUPERVISOR.d3d_device->TestCooperativeLevel()) {
                    case D3D_OK:
                        if (!WINDOW_DATA.__unknown_flag_B) {
                            if (WINDOW_DATA.__unknown_flag_C) {
                                local_dword_18 = WINDOW_DATA.update_window__alt_version2();
                            }
                            else if (
                                SUPERVISOR.present_parameters.PresentationInterval == 1 &&
                                SUPERVISOR.config.__ubyte_48 == 0
                            ) {
                                local_dword_18 = WINDOW_DATA.update_window__alt_version();
                            }
                            else {
                                local_dword_18 = WINDOW_DATA.update_window__normal_version();
                            }
                            if (local_dword_18 != 0) {
                                goto loop_break;
                            }
                            SUPERVISOR.__unknown_flag_F = false;
                            break;
                        }
                    case D3DERR_DEVICENOTRESET:
                        WINDOW_DATA.__counter_2044 = 10;
                        if (!WINDOW_DATA.__unknown_flag_B) {
                            D3DFORMAT format;
                            if (WINDOW_DATA.__unknown_bitfield_A <= 2) {
                                GetWindowRect(WINDOW_DATA.window, &SUPERVISOR.window_rect);
                                SUPERVISOR.present_parameters.Windowed = FALSE;
                                format = SUPERVISOR.config.__ubyte_44 ? D3DFMT_R5G6B5 : D3DFMT_A8R8G8B8;
                            }
                            else {
                                format = SUPERVISOR.display_mode.Format;
                                SUPERVISOR.present_parameters.FullScreen_RefreshRateInHz = 0;
                                SUPERVISOR.present_parameters.Windowed = TRUE;
                            }
                            SUPERVISOR.present_parameters.BackBufferFormat = format;
                            WINDOW_DATA.__sub_4734E0(0);
                        }
                        SUPERVISOR.__release_rendering_surfaces();
                        ANM_MANAGER_PTR->__release_render_targets();
                        if (ZUN_FAILED(__sub_473B20(TRUE))) {
                            goto loop_break;
                        }
                        __set_default_d3d_states();
                        ANM_MANAGER_PTR->__create_render_targets();
                        SUPERVISOR.__unknown_flag_F = true;
                        SUPERVISOR.__int_818 = 3;
                        if (WINDOW_DATA.__unknown_flag_B) {
                            SUPERVISOR.__camera2_sub_454F50();
                            switch (WINDOW_DATA.__unknown_bitfield_A) {
                                default: {
                                    SetWindowLongA(WINDOW_DATA.window, GWL_STYLE, WS_OVERLAPPED | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_CAPTION | WS_SYSMENU | WS_VISIBLE);
                                    int32_t full_window_width = WINDOW_DATA.window_width + 2 * GetSystemMetrics(SM_CXFIXEDFRAME);
                                    int32_t full_window_height = WINDOW_DATA.window_height + GetSystemMetrics(SM_CYCAPTION) + 2 * GetSystemMetrics(SM_CYFIXEDFRAME);
                                    SetWindowPos(
                                        WINDOW_DATA.window, HWND_TOP,
                                        SUPERVISOR.window_rect.left, SUPERVISOR.window_rect.top,
                                        full_window_width, full_window_height,
                                        SWP_FRAMECHANGED | SWP_SHOWWINDOW
                                    );
                                    ShowWindow(WINDOW_DATA.window, SW_SHOWNORMAL);
                                    WINNLSEnableIME(NULL, true);
                                    show_cursor();
                                    break;
                                }
                                case 0: case 1: case 2: {
                                    int32_t width = WINDOW_DATA.__scaled_width;
                                    int32_t height = WINDOW_DATA.__scaled_height;
                                    SetWindowLongA(WINDOW_DATA.window, GWL_STYLE, WS_POPUP | WS_VISIBLE);
                                    SetWindowPos(
                                        WINDOW_DATA.window, HWND_TOP,
                                        0, 0,
                                        width, height,
                                        SWP_FRAMECHANGED
                                    );
                                    WINNLSEnableIME(NULL, false);
                                    hide_cursor();
                                    SetCursor(NULL);
                                    WINDOW_DATA.__dword_14 = 0;
                                    break;
                                }
                                case 8: case 9:
                                    SetWindowLongA(WINDOW_DATA.window, GWL_STYLE, WS_OVERLAPPED);
                                    ShowWindow(WINDOW_DATA.window, SW_SHOW);
                                    SetWindowPos(
                                        WINDOW_DATA.window, HWND_TOP,
                                        0, 0,
                                        960, 720,
                                        SWP_SHOWWINDOW
                                    );
                                    WINNLSEnableIME(NULL, true);
                                    show_cursor();
                                    break;
                            }
                            GetWindowRect(WINDOW_DATA.window, &SUPERVISOR.window_rect);
                            SUPERVISOR.__sub_455EC0();
                            WINDOW_DATA.__unknown_flag_B = false;
                        }
                }
            }
        }
loop_break:;
    }
    else if (result == ZUN_ERROR) {
        local_dword_18 = -1;
    }
    else {
        local_dword_18 = 2;
    }
    switch ((SUPERVISOR.config.__ubyte_47 = WINDOW_DATA.__unknown_bitfield_A)) {
        default:
            GetWindowRect(WINDOW_DATA.window, &SUPERVISOR.window_rect);
            SUPERVISOR.config.window_x = SUPERVISOR.window_rect.left;
            SUPERVISOR.config.window_y = SUPERVISOR.window_rect.top;
        case 0: case 1: case 2:
            break;
    }
    SUPERVISOR.__sub_453A70();

    delete UPDATE_FUNC_REGISTRY_PTR;
    goto winmain_important_label;

winmain_weird_local_not_2:
    char config_filename[0x1000];
    byteloop_strcpy(config_filename, WINDOW_DATA.appdata_path);
    byteloop_strcat(config_filename, "th18.cfg");
    __zun_create_new_file_from_buffer(config_filename, &SUPERVISOR.config, sizeof(Config));
    timeEndPeriod(1);
    char log_filename[0x1000];
    byteloop_strcpy(log_filename, WINDOW_DATA.appdata_path);
    byteloop_strcat(log_filename, "log.txt");
    if (LOG_BUFFER.buffer_write != LOG_BUFFER.buffer) {
        LOG_BUFFER.write("---------------------------------------------------------- \r\n");
        if (LOG_BUFFER.is_error) {
            MessageBoxA(NULL, LOG_BUFFER.buffer, "log", MB_ICONERROR);
        }
        __zun_create_new_file_from_buffer(log_filename, LOG_BUFFER.buffer, byteloop_strlen(LOG_BUFFER.buffer));
    }
    WINDOW_DATA.__restore_properties();
    WINNLSEnableIME(NULL, true);
    delete DEBUG_LOG_PTR;
    CRITICAL_SECTION_MANAGER.cleanup();
    return 0;
}

}


#ifdef CHEAT_THE_LOADER

//dllexport volatile char backing_memory[0x200000];

struct StaticCtorsDtors {

#define static_construct(global) new(&global) decltype(global)()

#define original_addr(addr) ((void*)((uintptr_t)original_game + ((uintptr_t)(addr) - 0x400000)))

    template<typename T>
    static inline void copy_from_original_game(T& value, HMODULE original_game) {
        __builtin_memcpy(&value, original_addr(&value), sizeof(value));
    }

    template<typename T, typename P>
    static inline void copy_from_original_game(T& value, P addr, HMODULE original_game) {
        __builtin_memcpy(&value, original_addr(addr), sizeof(value));
    }

    gnu_noinline StaticCtorsDtors() {
        _chdir("F:\\Touhou_Stuff_2\\disassembly_stuff\\18\\crack\\");
        HMODULE original_game = LoadLibraryExA("th18.exe.unvlv.exe", NULL, 0);

        copy_from_original_game(SOUND_DATA, 0x4C9B80, original_game);
        copy_from_original_game(BULLET_SPRITE_DATA, 0x4C5F90, original_game);
        copy_from_original_game(BULLET_IDK_DATA, 0x4B36F0, original_game);
        copy_from_original_game(FONT_DATA, 0x4C9AD0, original_game);
        copy_from_original_game(STAGE_DATA, 0x4C9410, original_game);
        copy_from_original_game(DEFAULT_JOYPAD_MAPPINGS, 0x4CABA8, original_game);
        copy_from_original_game(DEFAULT_XINPUT_MAPPINGS, 0x4CABBC, original_game);
        copy_from_original_game(DEFAULT_KEYBOARD_MAPPINGS, 0x4CABD0, original_game);

        FreeLibrary(original_game);

        /*
        FILE* card_dump = fopen("card_dump", "wb");
        auto* original_card_table = (CardData*)original_addr(0x4C53C0);
        for (size_t i = 0; i < countof(CARD_DATA_TABLE); ++i) {
            __builtin_dump_struct(&original_card_table[i], &fprintf, card_dump);
        }
        fclose(card_dump);
        */

        //static_construct(LOG_BUFFER);
        //static_construct(SOUND_MANAGER);
    }
    ~StaticCtorsDtors() {

    }
};

gnu_attr(init_priority(101)) StaticCtorsDtors fake_static_data;

#endif